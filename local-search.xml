<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode 387. 字符串中的第一个唯一字符</title>
    <link href="/2020/09/01/LeetCode-387-first-unique-character-in-a-string/"/>
    <url>/2020/09/01/LeetCode-387-first-unique-character-in-a-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">387. 字符串中的第一个唯一字符</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>记录每个字母出现的次数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-comment">// 记录每个字母出现的次数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        counts[c - <span class="hljs-string">'a'</span>]++;    &#125;    <span class="hljs-comment">// 寻找出现次数为 1 的字母位置</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;        <span class="hljs-keyword">if</span> (counts[chars[i] - <span class="hljs-string">'a'</span>] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>判断首次出现的位置和最后出现的位置是否相等。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;        <span class="hljs-keyword">if</span> (s.indexOf(chars[i]) == s.lastIndexOf(chars[i])) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2020/09/01/sorting-algorithms/"/>
    <url>/2020/09/01/sorting-algorithms/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h1><h2 id="1-直接插入排序"><a class="markdownIt-Anchor" href="#1-直接插入排序"></a> 1. 直接插入排序</h2><blockquote><p>将每个元素依次插入前面已经排序好的序列。需要反复把已排序元素向后移，为新元素提供插入空间。</p></blockquote><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：每趟操作都要比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。<ul><li>最好情况：元素已经有序，每个元素只需比较一次 - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>最坏情况：元素逆序 - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>平均：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>稳定性</strong>：<strong>稳定</strong> - 每次插入总是先比较再移动，不会出现相同元素的相对位置变化。</li><li><strong>适用性</strong>：适用于顺序存储和链式存储的线性表</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> cur, j;    <span class="hljs-comment">// 位置 0 作为第一个有序元素</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;        <span class="hljs-comment">// 当 cur &lt; 前一个元素，进行排序</span>        <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i - <span class="hljs-number">1</span>]) &#123;            cur = arr[i];            <span class="hljs-comment">// 后移直到 cur &gt;= arr[j]</span>            <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; cur; --j) &#123;                arr[j + <span class="hljs-number">1</span>] = arr[j];            &#125;            <span class="hljs-comment">// 插入当前元素</span>            arr[j + <span class="hljs-number">1</span>] = cur;        &#125;    &#125;&#125;</code></pre><h2 id="2-折半插入排序"><a class="markdownIt-Anchor" href="#2-折半插入排序"></a> 2. 折半插入排序</h2><blockquote><p>在查找有序表时使用折半查找实现。</p></blockquote><p>仅仅减少了比较次数，其他与直接插入相同。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> low, high;    <span class="hljs-keyword">int</span> cur;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;        cur = arr[i];        low = <span class="hljs-number">0</span>;        high = i - <span class="hljs-number">1</span>;        <span class="hljs-comment">// low = high + 1 时结束，即 low 为最终插入位置</span>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;            <span class="hljs-keyword">int</span> mid = (low + high) &gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (arr[mid] &gt; cur) &#123;                high = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                low = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-comment">// 移动 low 直到 i 位置</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= low; j--) &#123;            arr[j + <span class="hljs-number">1</span>] = arr[j];        &#125;        arr[low] = cur;    &#125;&#125;</code></pre><h2 id="3-希尔排序"><a class="markdownIt-Anchor" href="#3-希尔排序"></a> 3. 希尔排序</h2><blockquote><p>根据增量序列，对子序列进行排序。</p></blockquote><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：依赖于增量函数<ul><li><strong>最好</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>最坏</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>平均</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>稳定性</strong>：<strong>不稳定</strong> - 当相同元素被划分到不同的子序列时，相对位置可能改变。</li><li><strong>适用性</strong>：顺序存储的线性表</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = arr.length;    <span class="hljs-keyword">int</span> cur;    <span class="hljs-keyword">int</span> j;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> dk = n / <span class="hljs-number">2</span>; dk &gt;= <span class="hljs-number">1</span>; dk /= <span class="hljs-number">2</span>) &#123;        <span class="hljs-comment">// 对增量 dk 内的每个元素排序</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = dk + <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i - dk]) &#123;                cur = arr[i];                <span class="hljs-comment">// 寻找插入位置</span>                <span class="hljs-keyword">for</span> (j = i - dk; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; cur; j -= dk) &#123;                    arr[j + dk] = arr[j];                &#125;                arr[j + dk] = cur;            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="交换排序"><a class="markdownIt-Anchor" href="#交换排序"></a> 交换排序</h1><h2 id="1-冒泡排序"><a class="markdownIt-Anchor" href="#1-冒泡排序"></a> 1. 冒泡排序</h2><blockquote><p>两两比较相邻元素的值，若逆序则交换，一趟冒泡结束后，当前步骤的最大元素到达最终位置。</p></blockquote><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<ul><li><strong>最好</strong>：初始序列有序 - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>最坏</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>平均</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>稳定性</strong>：<strong>稳定</strong> - 元素相等时不进行交换</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">int</span> t = arr[j];                arr[j] = arr[j + <span class="hljs-number">1</span>];                arr[j + <span class="hljs-number">1</span>] = t;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="2-快速排序"><a class="markdownIt-Anchor" href="#2-快速排序"></a> 2. 快速排序</h2><blockquote><p>选取一个基准元素，将排序表分为两部分，该元素被放到最终位置，递归执行该过程。</p></blockquote><ul><li><strong>空间复杂度</strong>：与栈深度一致<ul><li>最好：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2(n+1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>最坏：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>平均：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>时间复杂度</strong>：与划分是否对称有关<ul><li><strong>最好</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>最坏</strong>：有序或逆序 - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>平均</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>稳定性</strong>：<strong>不稳定</strong> - 会进行左右区间的交换</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-comment">// pivot 的最终位置</span>        <span class="hljs-keyword">int</span> pivotPos = partition(arr, low, high);        <span class="hljs-comment">// 对左半部分递归排序</span>        quickSort(arr, low, pivotPos - <span class="hljs-number">1</span>);        <span class="hljs-comment">// 对右半部分递归排序</span>        quickSort(arr, pivotPos + <span class="hljs-number">1</span>, high);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> pivot = arr[low];    <span class="hljs-keyword">while</span> (low &lt; high) &#123;        <span class="hljs-comment">// 找到比 low 小的元素</span>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;            <span class="hljs-comment">// 向前查找</span>            high--;        &#125;        <span class="hljs-comment">// 小元素移到 low</span>        arr[low] = arr[high];        <span class="hljs-comment">// 找到比 pivot 大的元素</span>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;            <span class="hljs-comment">// 向后查找</span>            low++;        &#125;        <span class="hljs-comment">// 大元素移到 high</span>        arr[high] = arr[low];    &#125;    <span class="hljs-comment">// pivot 的最终位置</span>    arr[low] = pivot;    <span class="hljs-keyword">return</span> low;&#125;</code></pre><h1 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h1><h2 id="1-简单选择排序"><a class="markdownIt-Anchor" href="#1-简单选择排序"></a> 1. 简单选择排序</h2><blockquote><p>在未排序序列中找到最大（最小）值，存放到排序序列的末尾。一趟排序可以确定一个元素的最终位置。</p></blockquote><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>稳定性</strong>：<strong>不稳定</strong></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = arr.length;    <span class="hljs-comment">// 从 0 开始存放元素</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">int</span> min = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;            <span class="hljs-comment">// 找到最小的元素位置</span>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min]) &#123;                min = j;            &#125;        &#125;        <span class="hljs-comment">// 交换第 i 个元素和 min</span>        <span class="hljs-keyword">if</span> (min != i) &#123;            swap(arr, i, min);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> min)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = arr[i];    arr[i] = arr[min];    arr[min] = t;&#125;</code></pre><h2 id="2-堆排序"><a class="markdownIt-Anchor" href="#2-堆排序"></a> 2. 堆排序</h2><blockquote><p>使用大顶堆或小顶堆。</p></blockquote><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>稳定性</strong>：<strong>不稳定</strong></li></ul><h1 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h1><h2 id="1-二路归并排序"><a class="markdownIt-Anchor" href="#1-二路归并排序"></a> 1. 二路归并排序</h2><blockquote><p>将两个或两个以上的有序表组合成一个新的有序表。</p></blockquote><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 一趟归并 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span> 趟</li><li><strong>稳定性</strong>：<strong>稳定</strong></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;        mergeSort(arr, low, mid);        mergeSort(arr, mid + <span class="hljs-number">1</span>, high);        merge(arr, low, mid, high);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-comment">// 辅助数组</span>    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;        tmp[i] = arr[i];    &#125;    <span class="hljs-comment">// 合并 [low...mid] 和 [mid + 1...high]</span>    <span class="hljs-keyword">int</span> i, j, k;    <span class="hljs-keyword">for</span> (i = low, j = mid + <span class="hljs-number">1</span>, k = i; i &lt; mid &amp;&amp; j &lt; high; k++) &#123;        <span class="hljs-keyword">if</span> (tmp[i] &lt;= tmp[j]) &#123;            arr[k] = tmp[i++];        &#125; <span class="hljs-keyword">else</span> &#123;            arr[k] = tmp[j++];        &#125;    &#125;    <span class="hljs-comment">// 合并剩下那个表剩余的部分</span>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        arr[k++] = tmp[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= high) &#123;        arr[k++] = tmp[j++];    &#125;&#125;</code></pre><h1 id="非比较排序"><a class="markdownIt-Anchor" href="#非比较排序"></a> 非比较排序</h1><h2 id="1-基数排序"><a class="markdownIt-Anchor" href="#1-基数排序"></a> 1. 基数排序</h2><blockquote><p>对每个位置进行排序。</p></blockquote><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d(n + r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li><strong>稳定性</strong>：<strong>稳定</strong></li></ul><h2 id="2-计数排序"><a class="markdownIt-Anchor" href="#2-计数排序"></a> 2. 计数排序</h2><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<ul><li><strong>最好</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>最坏</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>平均</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>稳定性</strong>：<strong>不稳定</strong> -</li><li><strong>适用性</strong>：</li></ul><h2 id="3-桶排序"><a class="markdownIt-Anchor" href="#3-桶排序"></a> 3. 桶排序</h2><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<ul><li><strong>最好</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>最坏</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>平均</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>稳定性</strong>：<strong>不稳定</strong> -</li><li><strong>适用性</strong>：</li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>每一次排序之后都能确定至少一个元素位置的排序方法包括：</p><ol><li><p><strong>选择排序</strong>：每次将最大的数放到最后。所以最大的数排一次序后位置就确定了。</p></li><li><p><strong>冒泡排序</strong>：同选择排序。每一次排序最大的值位置确定。</p></li><li><p><strong>快排</strong>：每一次排序 <code>pivot</code> 的位置确定。</p></li><li><p><strong>堆排序</strong>：每一次排序时，都是将堆顶的元素和最后一个节点互换，然后调整堆，再将堆大小减1。所以每一次排序堆顶元素确定。</p></li></ol><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">最好</th><th style="text-align:center">平均</th><th style="text-align:center">最坏</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">直接插入</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><code>不稳定</code></td></tr><tr><td style="text-align:center">冒泡</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快排</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><code>不稳定</code></td></tr><tr><td style="text-align:center">简单选择</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><code>不稳定</code></td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><code>不稳定</code></td></tr><tr><td style="text-align:center">二路归并</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><mi>d</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d(d+r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><mi>d</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d(d+r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><mi>d</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d(d+r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 771. 宝石与石头</title>
    <link href="/2020/08/31/LeetCode-771-jewels-and-stones/"/>
    <url>/2020/08/31/LeetCode-771-jewels-and-stones/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">771. 宝石与石头</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numJewelsInStones</span><span class="hljs-params">(String J, String S)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">char</span>[] js = J.toCharArray();    <span class="hljs-keyword">char</span>[] ss = S.toCharArray();    Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : js) &#123;        set.add(c);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : ss) &#123;        <span class="hljs-keyword">if</span> (set.contains(c)) &#123;            count++;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 58. 最后一个单词的长度</title>
    <link href="/2020/08/31/LeetCode-58-length-of-last-word/"/>
    <url>/2020/08/31/LeetCode-58-length-of-last-word/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">58. 最后一个单词的长度</a></p><p>需要注意最后一个字符为空的情况。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> end = s.length() - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 找到末尾不为空的字符位置</span>    <span class="hljs-keyword">while</span> (end &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(end) == <span class="hljs-string">' '</span>) &#123;        end--;    &#125;    <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 从后往前找第一个空的位置</span>    <span class="hljs-keyword">int</span> start = end;    <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(start) != <span class="hljs-string">' '</span>) &#123;        start--;    &#125;    <span class="hljs-keyword">return</span> end - start;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 709. 转换成小写字母</title>
    <link href="/2020/08/31/LeetCode-709-to-lower-case/"/>
    <url>/2020/08/31/LeetCode-709-to-lower-case/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/to-lower-case/" target="_blank" rel="noopener">709. 转换成小写字母</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLowerCase</span><span class="hljs-params">(String str)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = str.toCharArray();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;        <span class="hljs-keyword">if</span> (chars[i] &gt;= <span class="hljs-string">'A'</span> &amp;&amp; chars[i] &lt;= <span class="hljs-string">'Z'</span>) &#123;            chars[i] = (<span class="hljs-keyword">char</span>) (chars[i] + <span class="hljs-number">32</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> String.valueOf(chars);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 146. LRU 缓存机制</title>
    <link href="/2020/08/30/LeetCode-146-lru-cache/"/>
    <url>/2020/08/30/LeetCode-146-lru-cache/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 结点类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">int</span> key;    <span class="hljs-keyword">int</span> value;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.value = value;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Cache 对应的链表，用于增删结点 O(1)</span><span class="hljs-comment">     * Node&lt;k1, v1&gt; -&gt; Node&lt;k2, v2&gt; -&gt; ...</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> LinkedList&lt;Node&gt; cache;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * key 到 Node 的映射，用于查询 O(1)</span><span class="hljs-comment">     * key -&gt; Node</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Map&lt;Integer, Node&gt; map;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 最大容量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;        cache = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">this</span>.capacity = capacity;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 若 key 存在，返回，且要把对应结点移到前面</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            <span class="hljs-keyword">int</span> value = map.get(key).value;            <span class="hljs-comment">// 使用 put 方法移动已存在结点到前面</span>            put(key, value);            <span class="hljs-keyword">return</span> value;        &#125;        <span class="hljs-comment">// 结点不存在</span>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 若 key 存在，删除旧结点，添加新结点，并把对应结点移到前面</span><span class="hljs-comment">     * 否则插入新结点</span><span class="hljs-comment">     * 若容量达到上限，删除最久未使用的结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        Node node = <span class="hljs-keyword">new</span> Node(key, value);        <span class="hljs-comment">// 该结点已存在</span>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            <span class="hljs-comment">// 删除旧结点</span>            cache.remove(map.get(key));            map.remove(key);        &#125;        <span class="hljs-comment">// 该结点不存在，则要判断是否有空位置用来新增结点</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// cache 容量达到上限，删除最后一个结点</span>            <span class="hljs-keyword">if</span> (cache.size() == capacity) &#123;                Node last = cache.getLast();                cache.removeLast();                map.remove(last.key);            &#125;        &#125;        <span class="hljs-comment">// 添加新结点</span>        cache.addFirst(node);        map.put(key, node);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2020/08/29/bloom-filter/"/>
    <url>/2020/08/29/bloom-filter/</url>
    
    <content type="html"><![CDATA[<h1 id="bloom-filter-概念"><a class="markdownIt-Anchor" href="#bloom-filter-概念"></a> <code>Bloom Filter</code> 概念</h1><p>布隆过滤器（<code>Bloom Filter</code>）是1970年由一个叫布隆的小伙子提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p><em><strong>面试关联：一般都会在回答缓存穿透，或者海量数据去重这个时候引出来，加分项哟</strong></em></p><h1 id="bloom-filter-原理"><a class="markdownIt-Anchor" href="#bloom-filter-原理"></a> <code>Bloom Filter</code> 原理</h1><p>布隆过滤器的原理是，当一个元素被加入集合时，通过 <code>K</code> 个散列函数将这个元素映射成一个位数组中的 <code>K</code> 个点，把它们置为 <code>1</code>。检索时，我们只要看看这些点是不是都是 <code>1</code> 就（大约）知道集合中有没有它了：</p><ul><li>如果这些点有任何一个 <code>0</code>，则被检元素一定不在；</li><li>如果都是 <code>1</code>，则被检元素很可能在。这就是布隆过滤器的基本思想。</li></ul><p><code>Bloom Filter</code> 跟单哈希函数 <code>Bit-Map</code> 不同之处在于：<code>Bloom Filter</code> 使用了 <code>k</code> 个哈希函数，每个字符串跟 <code>k</code> 个 <code>bit</code> 对应。从而降低了冲突的概率。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200829182232.jpeg" srcset="/img/loading.gif" alt="" /></p><p>简单的说一下就是我们先把我们数据库的数据都加载到我们的过滤器中，比如数据库的 <code>id</code> 现在有：<code>1</code>、<code>2</code>、<code>3</code></p><p>那就用 <code>id = 1</code> 为例子他在上图中经过三次 <code>hash</code> 之后，把三次原本值 <code>0</code> 的地方改为 <code>1</code>。</p><p>下次我进来查询如果 <code>id</code>也是 <code>1</code> 那我就把 <code>1</code> 拿去三次 <code>hash</code> 发现跟上面的三个位置完全一样，那就能证明过滤器中有 <code>1</code> 的。</p><p>反之如果不一样就说明不存在了</p><p>那应用的场景在哪里呢？一般我们都会用来<strong>防止缓存击穿</strong>。</p><p>简单来说就是你数据库的id都是1开始然后自增的，那我知道你接口是通过 <code>id</code> 查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我又去数据库查也没有，一个请求这样，100 个，1000 个，10000 个呢？你的 DB 基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接 return 一个数据为空不就好了嘛。</p><p>这玩意这么好使那有啥缺点么？有的，我们接着往下看</p><h1 id="bloom-filter-的缺点"><a class="markdownIt-Anchor" href="#bloom-filter-的缺点"></a> Bloom Filter 的缺点</h1><p><code>Bloom Filter</code> 之所以能做到在时间和空间上的效率比较高，是因为牺牲了判断的准确率、删除的便利性</p><ul><li><p><strong>存在误判</strong>。可能要查到的元素并没有在容器中，但是 <code>hash</code> 之后得到的 <code>k</code> 个位置上值都是 <code>1</code>。如果 <code>bloom filter</code> 中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</p></li><li><p><strong>删除困难</strong>。一个放入容器的元素映射到 <code>bit</code> 数组的 <code>k</code> 个位置上是 <code>1</code>，删除的时候不能简单的直接置为 <code>0</code>，可能会影响其他元素的判断。可以采用 <a href="http://wiki.corp.qunar.com/confluence/download/attachments/199003276/US9740797.pdf?version=1&amp;modificationDate=1526538500000&amp;api=v2" target="_blank" rel="noopener">Counting Bloom Filter</a></p></li></ul><h1 id="bloom-filter-实现"><a class="markdownIt-Anchor" href="#bloom-filter-实现"></a> <code>Bloom Filter</code> 实现</h1><p>布隆过滤器有许多实现与优化，Guava中就提供了一种 <code>Bloom Filter</code> 的实现。</p><ul><li><p>在使用 <code>bloom filter</code> 时，绕不过的两点是预估数据量 <code>n</code> 以及期望的误判率 <code>fpp</code>，</p></li><li><p>在实现 <code>bloom filter</code> 时，绕不过的两点就是 <code>hash</code> 函数的选取以及 <code>bit</code> 数组的大小。</p></li></ul><p>对于一个确定的场景，我们预估要存的数据量为 <code>n</code>，期望的误判率为 <code>fpp</code>，然后需要计算我们需要的 <code>Bit</code> 数组的大小 <code>m</code>，以及 <code>hash</code> 函数的个数 <code>k</code>，并选择 <code>hash</code> 函数</p><h2 id="1-bit-数组大小选择"><a class="markdownIt-Anchor" href="#1-bit-数组大小选择"></a> (1) <code>Bit</code> 数组大小选择</h2><p>根据预估数据量 <code>n</code> 以及误判率 <code>fpp</code>，<code>bit</code> 数组大小的 <code>m</code> 的计算方式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mo>−</mo><mfrac><mrow><mi>n</mi><mi>l</mi><mi>n</mi><mi>f</mi><mi>p</mi><mi>p</mi></mrow><mrow><mo stretchy="false">(</mo><mi>l</mi><mi>n</mi><mn>2</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">m = -\frac{nlnfpp}{(ln2)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3074399999999997em;vertical-align:-0.936em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h2 id="2-哈希函数选择"><a class="markdownIt-Anchor" href="#2-哈希函数选择"></a> (2) 哈希函数选择</h2><p>由预估数据量 <code>n</code> 以及 <code>bit</code> 数组长度 <code>m</code>，可以得到一个 <code>hash</code> 函数的个数 <code>k</code>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mi>l</mi><mi>n</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k = \frac{m}{n}ln2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord">2</span></span></span></span></span></p><p>哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个<code>Bit</code>。选择 <code>k</code> 个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入 <code>k</code> 个不同的参数。</p><p>哈希函数个数 <code>k</code>、位数组大小 <code>m</code>、加入的字符串数量 <code>n</code> 的关系可以参考 <a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html" target="_blank" rel="noopener">Bloom Filters - the math</a>，<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">Bloom_filter-wikipedia</a></p><h1 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h1><h2 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h2><p>要使用 <code>BloomFilter</code>，需要引入 <code>guava</code>包：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>23.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>测试分两步：<br />1、往过滤器中放一百万个数，然后去验证这一百万个数是否能通过过滤器<br />2、另外找一万个数，去检验漏网之鱼的数量</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 测试布隆过滤器</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBloomFilter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> total = <span class="hljs-number">100_0000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total);<span class="hljs-comment">//    private static BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total, 0.001);</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 初始化 1000000 条数据到过滤器中</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++) &#123;            bf.put(i);        &#125;        <span class="hljs-comment">// 匹配已在过滤器中的值，是否有匹配不上的</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++) &#123;            <span class="hljs-keyword">if</span> (!bf.mightContain(i)) &#123;                System.out.println(<span class="hljs-string">"有坏人逃脱了~~~"</span>);            &#125;        &#125;        <span class="hljs-comment">// 匹配不在过滤器中的 10000 个值，有多少匹配出来</span>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = total; i &lt; total + <span class="hljs-number">10000</span>; i++) &#123;            <span class="hljs-keyword">if</span> (bf.mightContain(i)) &#123;                count++;            &#125;        &#125;        System.out.println(<span class="hljs-string">"误伤的数量："</span> + count);    &#125;&#125;</code></pre><h2 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BloomFilter&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(Funnel&lt;? <span class="hljs-keyword">super</span> T&gt; funnel, <span class="hljs-keyword">int</span> expectedInsertions)</span> </span>&#123;        <span class="hljs-keyword">return</span> create(funnel, (<span class="hljs-keyword">long</span>) expectedInsertions);    &#125;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BloomFilter&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(Funnel&lt;? <span class="hljs-keyword">super</span> T&gt; funnel, <span class="hljs-keyword">long</span> expectedInsertions)</span> </span>&#123;        <span class="hljs-keyword">return</span> create(funnel, expectedInsertions, <span class="hljs-number">0.03</span>); <span class="hljs-comment">// FYI, for 3%, we always get 5 hash functions</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BloomFilter&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">          Funnel&lt;? <span class="hljs-keyword">super</span> T&gt; funnel, <span class="hljs-keyword">long</span> expectedInsertions, <span class="hljs-keyword">double</span> fpp)</span> </span>&#123;        <span class="hljs-keyword">return</span> create(funnel, expectedInsertions, fpp, BloomFilterStrategies.MURMUR128_MITZ_64);    &#125;    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BloomFilter&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      Funnel&lt;? <span class="hljs-keyword">super</span> T&gt; funnel, <span class="hljs-keyword">long</span> expectedInsertions, <span class="hljs-keyword">double</span> fpp, Strategy strategy)</span> </span>&#123;     ......    &#125;</code></pre><p><code>BloomFilter</code> 一共四个 <code>create</code> 方法，不过最终都是走向第四个。看一下每个参数的含义：</p><ol><li><p><code>funnel</code>：数据类型(一般是调用 <code>Funnels</code> 工具类中的)</p></li><li><p><code>expectedInsertions</code>：期望插入的值的个数</p></li><li><p><code>fpp</code> 错误率(默认值为 <code>0.03</code>)</p></li><li><p><code>strategy</code> 哈希算法</p></li></ol><p>使用第三个 <code>create</code> 方法，我们设置下错误率：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total, <span class="hljs-number">0.0003</span>);</code></pre><p><strong>错误率越大，所需空间和时间越小，错误率越小，所需空间和时间越大。</strong></p><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h2><ul><li><p><code>cerberus</code> 在收集监控数据的时候, 有的系统的监控项量会很大, 需要检查一个监控项的名字是否已经被记录到 db 过了, 如果没有的话就需要写入 db.</p></li><li><p>爬虫过滤已抓到的 url 就不再抓，可用 bloom filter 过滤</p></li><li><p>垃圾邮件过滤。如果用哈希表，每存储一亿个 email 地址，就需要 1.6GB 的内存（用哈希表实现的具体办法是将每一个 email 地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB 的内存。而 Bloom Filter 只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 52. N皇后 II</title>
    <link href="/2020/08/29/LeetCode-52-n-queens-ii/"/>
    <url>/2020/08/29/LeetCode-52-n-queens-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">52. N皇后 II</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">totalNQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">this</span>.n = n;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-keyword">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : board) &#123;            Arrays.fill(line, <span class="hljs-string">'.'</span>);        &#125;        backtrack(<span class="hljs-number">0</span>, board);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">if</span> (row == n) &#123;            res++;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;            <span class="hljs-keyword">if</span> (!isValid(row, col, board)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            board[row][col] = <span class="hljs-string">'Q'</span>;            backtrack(row + <span class="hljs-number">1</span>, board);            board[row][col] = <span class="hljs-string">'.'</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : board) &#123;            <span class="hljs-keyword">if</span> (line[col] == <span class="hljs-string">'Q'</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--)&#123;            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'Q'</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'Q'</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 7. 整数反转</title>
    <link href="/2020/08/29/LeetCode-7-reverse-integer/"/>
    <url>/2020/08/29/LeetCode-7-reverse-integer/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. 整数反转</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 个位数</span>        <span class="hljs-keyword">int</span> pop = x % <span class="hljs-number">10</span>;        <span class="hljs-comment">// 去除个位数</span>        x = x / <span class="hljs-number">10</span>;        <span class="hljs-keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="hljs-number">10</span>                <span class="hljs-comment">// 最后一位溢出</span>                || (res == Integer.MAX_VALUE / <span class="hljs-number">10</span> &amp;&amp; pop &gt; <span class="hljs-number">7</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="hljs-number">10</span>                <span class="hljs-comment">// 最后一位溢出</span>                || (res == Integer.MIN_VALUE / <span class="hljs-number">10</span> &amp;&amp; pop &lt; -<span class="hljs-number">8</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// 翻转后的数</span>        res = res * <span class="hljs-number">10</span> + pop;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 338. 比特位计数</title>
    <link href="/2020/08/28/LeetCode-338-counting-bits/"/>
    <url>/2020/08/28/LeetCode-338-counting-bits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>每个数依次计数</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= num; i++) &#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = i;        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;            n = n &amp; (n - <span class="hljs-number">1</span>);            count++;        &#125;        res[i] = count;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>用奇偶数判断妙的很啊！！！</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= num; i++) &#123;        <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 奇数比前面的偶数多一个 1</span>            res[i] = res[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-comment">// 偶数的最低位是 0，所以 i 中 1 的个数和去除低位 0 后的那个数一样多</span>             res[i] = res[i &gt;&gt; <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><p>其实也是奇偶数的思路。<br /><code>i</code> 和 <code>i &gt;&gt; 1</code> 中 <code>1</code> 的个数是最低有效位上的差别。</p><pre><code class="hljs java">i = (<span class="hljs-number">100101</span>)i &gt;&gt; <span class="hljs-number">1</span> = (<span class="hljs-number">10010</span>)</code></pre><p>状态：<code>dp[i]</code> - 数字 <code>i</code> 中 <code>1</code> 的个数。<br />状态转移方程：<code>dp[i] = dp[i &gt;&gt; 1] + 最低有效位</code>。</p><hr /><p><code>i</code> 和 <code>i &amp; (i - 1)</code> 中 <code>1</code> 的个数总是相差 <code>1</code>，因为 <code>i</code> 中的最后一位 <code>1</code> 已经变为 <code>0</code>。<br />状态转移方程：<code>dp[i] = dp[i &amp; (i - 1)] + 1</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;        <span class="hljs-comment">// 使用最低有效位计算</span>        <span class="hljs-comment">// dp[i] = dp[i &gt;&gt; 1] + (i &amp; 1);</span>        <span class="hljs-comment">// 抹除最低位的 1</span>        dp[i] = dp[i &amp; (i - <span class="hljs-number">1</span>)] + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> dp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 190. 颠倒二进制位</title>
    <link href="/2020/08/28/LeetCode-190-reverse-bits/"/>
    <url>/2020/08/28/LeetCode-190-reverse-bits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>逐位移动，<code>n</code> 从<strong>右往左取</strong>，取出的每一位放到 <code>res</code> 中，<code>res</code> 从<strong>左往右放</strong>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">31</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;        <span class="hljs-comment">// 先左移空出最右边一位，再加上 n 的最后一位</span>        res = (res &lt;&lt; <span class="hljs-number">1</span>) + (n &amp; <span class="hljs-number">1</span>);        <span class="hljs-comment">// 删除最后一位</span>        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二：</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// 取最后一位移到左边</span>        res += (n &amp; <span class="hljs-number">1</span>) &lt;&lt; i;        <span class="hljs-comment">// 删除最后一位</span>        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 50. Pow(x, n)</title>
    <link href="/2020/08/28/LeetCode-50-powx-n/"/>
    <url>/2020/08/28/LeetCode-50-powx-n/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></p><h1 id="快速幂-递归"><a class="markdownIt-Anchor" href="#快速幂-递归"></a> 快速幂 + 递归</h1><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>77</mn></msup><mo>←</mo><msup><mi>x</mi><mn>38</mn></msup><mo>⋅</mo><mi>x</mi><mo>←</mo><msup><mi>x</mi><mn>19</mn></msup><mo>←</mo><msup><mi>x</mi><mn>9</mn></msup><mo>⋅</mo><mi>x</mi><mo>←</mo><msup><mi>x</mi><mn>4</mn></msup><mo>⋅</mo><mi>x</mi><mo>←</mo><msup><mi>x</mi><mn>2</mn></msup><mo>←</mo><mi>x</mi><mo>←</mo><msup><mi>x</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">x^{77} \leftarrow x^{38} \cdot x \leftarrow x^{19} \leftarrow x^9 \cdot x \leftarrow x^4 \cdot x \leftarrow x^2 \leftarrow x \leftarrow x^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">9</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></p><p>若 <code>n</code> 为偶数，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><msup><mi>x</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">x^n = x^{\frac{n}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.89708em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.89708em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>若 <code>n</code> 为奇数，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><msup><mi>x</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup><mo>⋅</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x^n = x^{\frac{n}{2}} \cdot x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.89708em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.89708em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></span></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">long</span> N = n;    <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? getPow(x, N) : <span class="hljs-number">1.0</span> / getPow(x, N);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;    &#125;    <span class="hljs-keyword">double</span> y = getPow(x, n / <span class="hljs-number">2</span>);    <span class="hljs-keyword">return</span> (n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> ? y * y * x : y * y;&#125;</code></pre><h1 id="快速幂-迭代"><a class="markdownIt-Anchor" href="#快速幂-迭代"></a> 快速幂 + 迭代</h1><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mi>m</mi></msub><msub><mo>⋯</mo><mn>3</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub></mrow></msup><mo>=</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>×</mo><mn>1</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mn>2</mn></msub><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mn>3</mn></msub><mo>×</mo><msup><mn>2</mn><mn>2</mn></msup></mrow></msup><mo separator="true">⋅</mo><mo>…</mo><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></msup><mo separator="true">⋅</mo></mrow><annotation encoding="application/x-tex">x^n = x^{b_m\dotsb_3b_2b_1} = x^{b_1\times1}·x^{b_2\times2^1}·x^{b_3\times2^2}·\dots·x^{b_m\times2^{m-1}}·</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.899108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.899108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="minner mtight"><span class="minner mtight">⋯</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0369199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.899108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>9</mn></msup><mo>=</mo><msup><mi>x</mi><mn>1001</mn></msup><mo>=</mo><msup><mi>x</mi><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><mn>0</mn><mo>×</mo><mn>2</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><mn>0</mn><mo>×</mo><mn>4</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><mn>1</mn><mo>×</mo><mn>8</mn></mrow></msup></mrow><annotation encoding="application/x-tex">x^9 = x^{1001} = x^{1\times1}·x^{0\times2}·x^{0\times4}·x^{1\times8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">×</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">×</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">×</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>所以当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 0 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></msup></mrow><annotation encoding="application/x-tex">x^{b_m\times2^{m-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869199999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> = 1，此时该项不用计算，每一项的规则如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></msup><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>x</mi><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></msup><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">x^{b_m\times2^{m-1}} = \begin{cases}1, &amp; b_m = 0 \\x^{2^{m-1}}, &amp; b_m = 1\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0369199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>最终的计算规则：</p><ul><li>先获取二进制位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><msub><mo>⋯</mo><mn>3</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_m\dotsb_3b_2b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner">⋯</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的值<ul><li><code>n &amp; 1</code>: 获取最后一位</li><li><code>n &gt;&gt; 1</code>: 删除最后一位，获取下一位</li></ul></li><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> == 1，则更新结果：<code>res *= x</code></li><li>计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>1</mn></msup><mo separator="true">,</mo><msup><mi>x</mi><mn>2</mn></msup><mo separator="true">,</mo><msup><mi>x</mi><mn>4</mn></msup><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msup><mi>x</mi><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></msup></mrow><annotation encoding="application/x-tex">x^1, x^2, x^4, \dots, x^{2^{m-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.18136em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 的值：循环操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x = x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">long</span> N = n;    <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? getPow(x, N) : <span class="hljs-number">1.0</span> / getPow(x, -N);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span> </span>&#123;    <span class="hljs-keyword">double</span> res = <span class="hljs-number">1.0</span>;    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 最后一位为 1，表示此时 x^n 有效</span>        <span class="hljs-comment">// 若为 0，增益为 0，结果不变</span>        <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;            res *= x;        &#125;        <span class="hljs-comment">// 保存当前位的 x^i</span>        x *= x;        <span class="hljs-comment">// 删除最后一位，进行下一位计算</span>        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 231. 2的幂</title>
    <link href="/2020/08/27/LeetCode-231-power-of-two/"/>
    <url>/2020/08/27/LeetCode-231-power-of-two/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">231. 2的幂</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><blockquote><p>二进制下，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 只有一位是 <code>1</code>。</p></blockquote><p>若 <code>x &amp; (x - 1) == 0</code>，表示 <code>x</code> 只有 <code>1</code> 个 <code>1</code>，即为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>。</p><table><thead><tr><th style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></th><th style="text-align:center">n</th><th style="text-align:center">n-1</th><th style="text-align:center">n &amp; (n - 1)</th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">1</td><td style="text-align:center">0000</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">10</td><td style="text-align:center">0001</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">100</td><td style="text-align:center">0011</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">1000</td><td style="text-align:center">0111</td><td style="text-align:center">0</td></tr></tbody></table><p>证明：<br />若 <code>n</code> 为 <code>2</code> 的幂，则 <code>n</code> 的二进制位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><msub><mi>n</mi><mn>2</mn></msub><msub><mi>n</mi><mn>3</mn></msub><msub><mi>n</mi><mn>4</mn></msub><mo>…</mo></mrow><annotation encoding="application/x-tex">n_1 n_2 n_3n_4\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span> 有且只有一位为 <code>1</code>，且为最高位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则 <code>n - 1</code> 的二进制位除了最高位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n_1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 外其余位都为 <code>1</code>。<br />在这种情况下，<code>n &amp; (n - 1) == 0</code>，因此可用来判断 <code>n</code> 是不是 <code>2</code> 的幂。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 除 1 之外的奇数</span>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 2 的幂最后商是 1</span>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 是奇数</span>        <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 191. 位1的个数</title>
    <link href="/2020/08/27/LeetCode-191-number-of-1-bits/"/>
    <url>/2020/08/27/LeetCode-191-number-of-1-bits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>任何数字 <code>&amp; 1</code> 都会获得这个数字的最低位，因此只要 <code>mask</code> 左移就能获取每个数字的最低位。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 32 位整数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;        <span class="hljs-keyword">if</span> ((n &amp; mask) != <span class="hljs-number">0</span>) &#123;            count++;        &#125;        mask &lt;&lt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;        count += n &amp; <span class="hljs-number">1</span>;        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p><code>n &amp; n - 1</code> 可以把最低位的 <code>1</code> 变为 <code>0</code>，因此只要循环操作，直到 <code>n == 0</code>，操作的次数就是 <code>1</code> 的个数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;        n = n &amp; (n - <span class="hljs-number">1</span>);        count++;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 773. 滑动谜题</title>
    <link href="/2020/08/27/LeetCode-773-sliding-puzzle/"/>
    <url>/2020/08/27/LeetCode-773-sliding-puzzle/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sliding-puzzle/" target="_blank" rel="noopener">773. 滑动谜题</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>需要注意棋盘的深拷贝。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">slidingPuzzle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">int</span> rows = board.length;        <span class="hljs-keyword">int</span> cols = board[<span class="hljs-number">0</span>].length;        Node start = <span class="hljs-keyword">null</span>;        String startBoardStr = <span class="hljs-string">""</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-number">0</span>) &#123;                    startBoardStr = Arrays.deepToString(board);                    start = <span class="hljs-keyword">new</span> Node(i, j, board.clone(), startBoardStr);                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> (start == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;        String target = Arrays.deepToString(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>&#125;&#125;);        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        Set&lt;String&gt; used = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        queue.add(start);        used.add(startBoardStr);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            count++;            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                Node curNode = queue.poll();                String curBoardStr = curNode.boardStr;                System.out.println(curBoardStr);                <span class="hljs-keyword">if</span> (target.equals(curBoardStr)) &#123;                    <span class="hljs-keyword">return</span> count - <span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                    <span class="hljs-keyword">int</span> newX = curNode.zeroX + dir[<span class="hljs-number">0</span>];                    <span class="hljs-keyword">int</span> newY = curNode.zeroY + dir[<span class="hljs-number">1</span>];                    <span class="hljs-comment">// 越界</span>                    <span class="hljs-keyword">if</span> (!inArea(newX, newY, rows, cols)) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-keyword">int</span>[][] newBoard = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][cols];                    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] line : curNode.board) &#123;                        newBoard[i++] = line.clone();                    &#125;                    <span class="hljs-comment">// 交换数字</span>                    newBoard[curNode.zeroX][curNode.zeroY] = newBoard[newX][newY];                    newBoard[newX][newY] = <span class="hljs-number">0</span>;                    String newBoardStr = Arrays.deepToString(newBoard);                    <span class="hljs-comment">// 已被使用</span>                    <span class="hljs-keyword">if</span> (used.contains(newBoardStr)) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-comment">// 加入队列并标记</span>                    queue.add(<span class="hljs-keyword">new</span> Node(newX, newY, newBoard, newBoardStr));                    used.add(newBoardStr);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">int</span> zeroX;    <span class="hljs-keyword">int</span> zeroY;    <span class="hljs-keyword">int</span>[][] board;    String boardStr;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> zeroX, <span class="hljs-keyword">int</span> zeroY, <span class="hljs-keyword">int</span>[][] board, String boardStr)</span> </span>&#123;        <span class="hljs-keyword">this</span>.zeroX = zeroX;        <span class="hljs-keyword">this</span>.zeroY = zeroY;        <span class="hljs-keyword">this</span>.board = board;        <span class="hljs-keyword">this</span>.boardStr = boardStr;    &#125;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>把二维数组映射为字符串，每次移动一个数字就相当于交换字符，省去了很多边界判断。</p><pre><code class="hljs java">String TARGET = <span class="hljs-string">"123450"</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">slidingPuzzle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;&#125;;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] row : board) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : row) &#123;            sb.append(num);        &#125;    &#125;    String start = sb.toString();    <span class="hljs-keyword">if</span> (TARGET.equals(start)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    Set&lt;String&gt; used = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    queue.add(start);    used.add(start);    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        count++;        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            String cur = queue.poll();            <span class="hljs-keyword">if</span> (TARGET.equals(cur)) &#123;                <span class="hljs-keyword">return</span> count - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">char</span>[] arr = cur.toCharArray();            <span class="hljs-comment">// 一定会找到 0，不用特判</span>            <span class="hljs-keyword">int</span> zeroIdx = cur.indexOf(<span class="hljs-string">'0'</span>);            <span class="hljs-keyword">int</span>[] moves = dirs[zeroIdx];            <span class="hljs-comment">// 尝试交换每个位置</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> next : moves) &#123;                <span class="hljs-comment">// 交换 0</span>                arr[zeroIdx] = arr[next];                arr[next] = <span class="hljs-string">'0'</span>;                <span class="hljs-comment">// 若未出现过，则加入队列</span>                String candidate = String.valueOf(arr);                <span class="hljs-keyword">if</span> (!used.contains(candidate)) &#123;                    queue.add(candidate);                    used.add(candidate);                &#125;                <span class="hljs-comment">// 还原</span>                arr[next] = arr[zeroIdx];                arr[zeroIdx] = <span class="hljs-string">'0'</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1091. 二进制矩阵中的最短路径</title>
    <link href="/2020/08/27/LeetCode-1091-shortest-path-in-binary-matrix/"/>
    <url>/2020/08/27/LeetCode-1091-shortest-path-in-binary-matrix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">1091. 二进制矩阵中的最短路径</a></p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><p>需要注意起点和终点都要 <code>== 0</code>，提交了好多次都在判断边界。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = grid.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 一开始就走不通</span>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 只有一个元素</span>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len][len];        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(<span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            count++;            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                Node curNode = queue.poll();                <span class="hljs-comment">// System.out.println(count + ": " + curNode.x + ", " + curNode.y);</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                    <span class="hljs-keyword">int</span> newX = curNode.x + dir[<span class="hljs-number">0</span>];                    <span class="hljs-keyword">int</span> newY = curNode.y + dir[<span class="hljs-number">1</span>];                    <span class="hljs-comment">// System.out.println(newX + ", " + newY + ", len = " + len);</span>                    <span class="hljs-keyword">if</span> (!inArea(newX, newY, len) || visited[newX][newY] || grid[newX][newY] == <span class="hljs-number">1</span>) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-comment">// grid[i][j] == 0 时才有效</span>                    <span class="hljs-keyword">if</span> (newX == (len - <span class="hljs-number">1</span>) &amp;&amp; newY == (len - <span class="hljs-number">1</span>)) &#123;                        <span class="hljs-keyword">return</span> count + <span class="hljs-number">1</span>;                    &#125;                    queue.add(<span class="hljs-keyword">new</span> Node(newX, newY));                    visited[newX][newY] = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; len &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; len;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">int</span> y;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 37. 解数独</title>
    <link href="/2020/08/26/LeetCode-37-sudoku-solver/"/>
    <url>/2020/08/26/LeetCode-37-sudoku-solver/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></p><p>如果采用与 <a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独</a> 类似的解法，使用下面这种方式来判断重复也很有效。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">return</span> rows[row][num] + cols[col][num] + boxes[(row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + col / <span class="hljs-number">3</span>][num] == <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        backtrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, board);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-comment">// 最后一行，结束</span>        <span class="hljs-keyword">if</span> (row == <span class="hljs-number">9</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 到最后一列，进入下一行</span>        <span class="hljs-keyword">if</span> (col == <span class="hljs-number">9</span>) &#123;            <span class="hljs-keyword">return</span> backtrack(row + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, board);        &#125;        <span class="hljs-comment">// 当前位置已经是数字，进入下一个位置</span>        <span class="hljs-keyword">if</span> (board[row][col] != <span class="hljs-string">'.'</span>) &#123;            <span class="hljs-keyword">return</span> backtrack(row, col + <span class="hljs-number">1</span>, board);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;            <span class="hljs-keyword">if</span> (!isValid((<span class="hljs-keyword">char</span>) (i + <span class="hljs-string">'0'</span>), row, col, board)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            board[row][col] = (<span class="hljs-keyword">char</span>) (i + <span class="hljs-string">'0'</span>);            <span class="hljs-comment">// 当前位置可以放置，进入下一个位置</span>            <span class="hljs-comment">// 若返回 true，表示所有位置都已正确放置，结束递归</span>            <span class="hljs-keyword">if</span> (backtrack(row, col + <span class="hljs-number">1</span>, board)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            board[row][col] = <span class="hljs-string">'.'</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            <span class="hljs-comment">// 判断行是否重复</span>            <span class="hljs-keyword">if</span> (board[row][i] == ch) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 判断列是否重复</span>            <span class="hljs-keyword">if</span> (board[i][col] == ch) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 判断九宫格是否重复</span>            <span class="hljs-keyword">int</span> x = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + i / <span class="hljs-number">3</span>;            <span class="hljs-keyword">int</span> y = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + i % <span class="hljs-number">3</span>;            <span class="hljs-keyword">if</span> (board[x][y] == ch) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 36. 有效的数独</title>
    <link href="/2020/08/26/LeetCode-36-valid-sudoku/"/>
    <url>/2020/08/26/LeetCode-36-valid-sudoku/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p><code>board[i][j]</code> 是字符型，判断九宫格重复时不要忘了转为数字。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span>[][] boxes;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 9 个格子，每个格子 9 个数</span>        <span class="hljs-comment">// 一行代表一个格子，若格子中某个位置为 1，表示该位置对应的数已经出现过</span>        boxes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, board);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-comment">// 所有行遍历完成，则结束</span>        <span class="hljs-keyword">if</span> (row == rows) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 对当前行的每一个位置判断</span>        <span class="hljs-keyword">char</span>[] curLine = board[row];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; curLine.length; col++) &#123;            <span class="hljs-keyword">if</span> (board[row][col] == <span class="hljs-string">'.'</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (!isValid(row, col, board)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 进入下一行</span>        <span class="hljs-keyword">return</span> dfs(row + <span class="hljs-number">1</span>, board);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-comment">// 判断列是否重复</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">if</span> (i != row &amp;&amp; board[i][col] == board[row][col]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 判断行是否重复</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (j != col &amp;&amp; board[row][j] == board[row][col]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 判断九宫格是否重复</span>        <span class="hljs-keyword">int</span> boxNum = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + col / <span class="hljs-number">3</span>;        <span class="hljs-keyword">int</span> num = board[row][col] - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">if</span> (boxes[boxNum][num] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 未出现过则设置为 1，用于下一个数字判断</span>        boxes[boxNum][num] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>把行列，九宫格的数字都映射到数组里，加快判断效率。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-comment">// 每行记录 board 的每行数字是否出现</span>    <span class="hljs-comment">// 下标代表对应元素</span>    <span class="hljs-comment">// 1: 出现 0: 未出现</span>    <span class="hljs-keyword">int</span>[][] rows = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];    <span class="hljs-comment">// 每行记录 board 的每列数字是否出现</span>    <span class="hljs-keyword">int</span>[][] cols = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];    <span class="hljs-comment">// 每行记录 board 每个九宫格是否出现</span>    <span class="hljs-keyword">int</span>[][] boxes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'.'</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">int</span> num = board[i][j] - <span class="hljs-string">'0'</span>;            <span class="hljs-keyword">if</span> (rows[i][num] == <span class="hljs-number">1</span> || cols[j][num] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-keyword">int</span> box = (i / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;            <span class="hljs-keyword">if</span> (boxes[box][num] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 标记对应元素</span>            rows[i][num] = <span class="hljs-number">1</span>;            cols[j][num] = <span class="hljs-number">1</span>;            boxes[box][num] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 130. 被围绕的区域</title>
    <link href="/2020/08/25/LeetCode-130-surrounded-regions/"/>
    <url>/2020/08/25/LeetCode-130-surrounded-regions/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><p>先标记边界以及和边界连通的 <code>O</code>，剩下的就是需要填充的格子，最后还原之前标记的格子。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-comment">// 左</span>            <span class="hljs-keyword">if</span> (board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">'O'</span>) &#123;                dfs(i, <span class="hljs-number">0</span>, board);            &#125;            <span class="hljs-comment">// 右</span>            <span class="hljs-keyword">if</span> (board[i][cols - <span class="hljs-number">1</span>] == <span class="hljs-string">'O'</span>) &#123;                dfs(i, cols - <span class="hljs-number">1</span>, board);            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;            <span class="hljs-comment">// 上</span>            <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>][i] == <span class="hljs-string">'O'</span>) &#123;                dfs(<span class="hljs-number">0</span>, i, board);            &#125;            <span class="hljs-comment">// 下</span>            <span class="hljs-keyword">if</span> (board[rows - <span class="hljs-number">1</span>][i] == <span class="hljs-string">'O'</span>) &#123;                dfs(rows - <span class="hljs-number">1</span>, i, board);            &#125;        &#125;        <span class="hljs-comment">// 填充 O 为 X</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'O'</span>) &#123;                    board[i][j] = <span class="hljs-string">'X'</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 还原 O</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'#'</span>) &#123;                    board[i][j] = <span class="hljs-string">'O'</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        board[x][y] = <span class="hljs-string">'#'</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = x + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = y + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (inArea(newX, newY) &amp;&amp; board[newX][newY] == <span class="hljs-string">'O'</span>) &#123;                dfs(newX, newY, board);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;&#125;</code></pre><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><ul><li>将边界的 <code>O</code> 与 <code>dummy</code> 连接</li><li>将内部的 <code>O</code> 互相连接，剩下的未与 <code>dummy</code> 连接的 <code>O</code> 即为需要填充的部分</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span> dummy;    UnionFind uf;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 所有未被围绕的 O 都与 dummy 连接</span>        dummy = rows * cols;        uf = <span class="hljs-keyword">new</span> UnionFind(dummy + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 连接左右边界</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-comment">// 左</span>            <span class="hljs-keyword">if</span> (board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">'O'</span>) &#123;                uf.union(dummy, getIndex(i, <span class="hljs-number">0</span>));            &#125;            <span class="hljs-comment">// 右</span>            <span class="hljs-keyword">if</span> (board[i][cols - <span class="hljs-number">1</span>] == <span class="hljs-string">'O'</span>) &#123;                uf.union(dummy, getIndex(i, cols - <span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-comment">// 连接上下边界</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;            <span class="hljs-comment">// 上</span>            <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>][i] == <span class="hljs-string">'O'</span>) &#123;                uf.union(dummy, getIndex(<span class="hljs-number">0</span>, i));            &#125;            <span class="hljs-comment">// 下</span>            <span class="hljs-keyword">if</span> (board[rows - <span class="hljs-number">1</span>][i] == <span class="hljs-string">'O'</span>) &#123;                uf.union(dummy, getIndex(rows - <span class="hljs-number">1</span>, i));            &#125;        &#125;        <span class="hljs-comment">// 遍历中间的 O，并将它们互相连接</span>        <span class="hljs-comment">// 则未与 dummy 连接的 O 即为需要填充的</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; cols - <span class="hljs-number">1</span>; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'O'</span>) &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                        <span class="hljs-keyword">int</span> newX = i + dir[<span class="hljs-number">0</span>];                        <span class="hljs-keyword">int</span> newY = j + dir[<span class="hljs-number">1</span>];                        <span class="hljs-keyword">if</span> (board[newX][newY] == <span class="hljs-string">'O'</span>) &#123;                            uf.union(getIndex(i, j), getIndex(newX, newY));                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 未与 dummy 连接的 O 填充为 X</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (!uf.connected(dummy, i * cols + j)) &#123;                    board[i][j] = <span class="hljs-string">'O'</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x * cols + y;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 547. 朋友圈</title>
    <link href="/2020/08/25/LeetCode-547-friend-circles/"/>
    <url>/2020/08/25/LeetCode-547-friend-circles/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">547. 朋友圈</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-keyword">boolean</span>[] visited;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] M)</span> </span>&#123;    n = M.length;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];    <span class="hljs-comment">// i 表示第 i 个人</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">if</span> (!visited[i]) &#123;            count++;            dfs(i, M);        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>[][] m)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;        <span class="hljs-comment">// i 和 j 为朋友，则从 j 开始递归查找</span>        <span class="hljs-comment">// 直到 j 的朋友为空</span>        <span class="hljs-keyword">if</span> (m[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j]) &#123;            visited[j] = <span class="hljs-keyword">true</span>;            dfs(j, m);        &#125;    &#125;&#125;</code></pre><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><p>并查集的连通分量数就是朋友圈的数量。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] M)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = M.length;    UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; M[<span class="hljs-number">0</span>].length; j++) &#123;            <span class="hljs-keyword">if</span> (M[i][j] == <span class="hljs-number">1</span>) &#123;                uf.union(i, j);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> uf.getCount();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2020/08/25/data-structure-union-find/"/>
    <url>/2020/08/25/data-structure-union-find/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 连通分量个数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 并查集对应的树</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每棵树的子结点数量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">this</span>.count = n;        <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.count];        <span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.count];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.count; i++) &#123;            <span class="hljs-comment">// 初始根节点为自己</span>            parent[i] = i;            <span class="hljs-comment">// 初始子结点只有自己</span>            size[i] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取连通分量个数</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 连接 p, q 结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> q</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;        <span class="hljs-keyword">int</span> rootP = findRoot(p);        <span class="hljs-keyword">int</span> rootQ = findRoot(q);        <span class="hljs-comment">// p, q 已经连接</span>        <span class="hljs-keyword">if</span> (rootP == rootQ) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 把 小树 挂到 大树 下，使得整棵树更平衡</span>        <span class="hljs-keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;            parent[rootQ] = rootP;            size[rootP] += size[rootQ];        &#125; <span class="hljs-keyword">else</span> &#123;            parent[rootP] = rootQ;            size[rootQ] += size[rootP];        &#125;        <span class="hljs-keyword">this</span>.count--;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断 p, q 结点是否属于同一个集合</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> q</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;        <span class="hljs-keyword">int</span> rootP = findRoot(p);        <span class="hljs-keyword">int</span> rootQ = findRoot(q);        <span class="hljs-comment">// 若根结点相同 则属于同一个集合</span>        <span class="hljs-keyword">return</span> rootP == rootQ;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 找到 x 的根节点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRoot</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-comment">// parent[x] == x 表示 到达根结点</span>        <span class="hljs-keyword">while</span> (parent[x] != x) &#123;            <span class="hljs-comment">// 路径压缩，把 x 挂到 x 的 爷爷上</span>            <span class="hljs-comment">// 压缩树的高度</span>            parent[x] = parent[parent[x]];            x = parent[x];        &#125;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 212. 单词搜索 II</title>
    <link href="/2020/08/24/LeetCode-212-word-search-ii/"/>
    <url>/2020/08/24/LeetCode-212-word-search-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">212. 单词搜索 II</a><br />坑：查找前缀时，若找到 <code>word</code>，不能 <code>return</code>，否则递归结束会导致与 <code>word</code> 同前缀的单词丢失，如 <code>aaba</code> 和 <code>aaab</code>，只能找到 <code>aaba</code>。</p><p>还是对前缀树理解不够，找了好久才发现。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">boolean</span>[][] used;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findWords</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String[] words)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span> || words.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];        Trie trie = <span class="hljs-keyword">new</span> Trie();        <span class="hljs-keyword">for</span> (String word : words) &#123;            trie.insert(word);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                backtrack(i, j, board, trie.root);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">char</span>[][] board, TrieNode node)</span> </span>&#123;        node = node.links[board[i][j] - <span class="hljs-string">'a'</span>];        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (node.word != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (!res.contains(node.word)) &#123;                res.add(node.word);                <span class="hljs-comment">// 一定不能 return，否则会丢失前缀</span>                <span class="hljs-comment">// return;</span>            &#125;        &#125;        used[i][j] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = i + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = j + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (inArea(newX, newY) &amp;&amp; !used[newX][newY]) &#123;                backtrack(newX, newY, board, node);            &#125;        &#125;        used[i][j] = <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;    TrieNode[] links;    String word;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> R = <span class="hljs-number">26</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.links = <span class="hljs-keyword">new</span> TrieNode[R];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>] != <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TrieNode <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key, TrieNode node)</span> </span>&#123;        <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>] = node;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;    TrieNode root;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;        root = <span class="hljs-keyword">new</span> TrieNode();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;        TrieNode node = root;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">char</span> key = word.charAt(i);            <span class="hljs-keyword">if</span> (!node.containsKey(key)) &#123;                node.put(key, <span class="hljs-keyword">new</span> TrieNode());            &#125;            node = node.get(key);        &#125;        node.word = word;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 79. 单词搜索</title>
    <link href="/2020/08/24/LeetCode-79-word-search/"/>
    <url>/2020/08/24/LeetCode-79-word-search/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></p><p>还是类似岛屿数量的回溯思想，整体不难，注意细节。<br />一开始方向的坐标写重复了一个，还忘了状态重置，一直无法通过，调了很久才发现。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span> || word.length() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">boolean</span>[][] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-comment">// 假设 (i, j) 都是起点进行搜索</span>                <span class="hljs-keyword">if</span> (backtrack(i, j, <span class="hljs-number">0</span>, used, board, word)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">boolean</span>[][] used, <span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;        <span class="hljs-comment">// 可避免只有一个元素的情况</span>        <span class="hljs-keyword">if</span> (pos == word.length() - <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> board[x][y] == word.charAt(pos);        &#125;        <span class="hljs-comment">// 当前位置匹配时，获取下一个位置</span>        <span class="hljs-keyword">if</span> (board[x][y] == word.charAt(pos)) &#123;            used[x][y] = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                <span class="hljs-keyword">int</span> newX = x + dir[<span class="hljs-number">0</span>];                <span class="hljs-keyword">int</span> newY = y + dir[<span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span> (inArea(newX, newY) &amp;&amp; !used[newX][newY]) &#123;                    <span class="hljs-keyword">if</span> (backtrack(newX, newY, pos + <span class="hljs-number">1</span>, used, board, word)) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                    &#125;                &#125;            &#125;            <span class="hljs-comment">// !!! 状态还原</span>            used[x][y] = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 208. 实现 Trie (前缀树)</title>
    <link href="/2020/08/24/LeetCode-208-implement-trie-prefix-tree/"/>
    <url>/2020/08/24/LeetCode-208-implement-trie-prefix-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></p><p>字典树 结点定义：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 字典树 结点</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每个结点相当于一个数组</span><span class="hljs-comment">     * 若数组的某个位置不为空，则指向下一个结点</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> TrieNode[] links;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 数组的长度</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> R = <span class="hljs-number">26</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 是否到达叶子结点</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnd;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.links = <span class="hljs-keyword">new</span> TrieNode[R];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断 key 位置上是否为空</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 用于计算 key 所在位置</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>] != <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取 key 位置上的下一个结点</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TrieNode <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 设置 key 位置上的下一个结点为 node</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key, TrieNode node)</span> </span>&#123;        <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>] = node;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断是否到达叶子结点</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isEnd;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 设置叶子结点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.isEnd = <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><p>字典树：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;    <span class="hljs-keyword">private</span> TrieNode root;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;        root = <span class="hljs-keyword">new</span> TrieNode();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Inserts a word into the trie.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;        TrieNode node = root;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">char</span> key = word.charAt(i);            <span class="hljs-keyword">if</span> (!node.containsKey(key)) &#123;                node.put(key, <span class="hljs-keyword">new</span> TrieNode());            &#125;            node = node.get(key);        &#125;        node.setEnd();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> TrieNode <span class="hljs-title">searchPrefix</span><span class="hljs-params">(String word)</span> </span>&#123;        TrieNode node = root;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">char</span> key = word.charAt(i);            <span class="hljs-keyword">if</span> (!node.containsKey(key)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            node = node.get(key);        &#125;        <span class="hljs-keyword">return</span> node;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns if the word is in the trie.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;        TrieNode node = searchPrefix(word);        <span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span> &amp;&amp; node.isEnd();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns if there is any word in the trie that starts with the given prefix.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 309. 最佳买卖股票时机含冷冻期</title>
    <link href="/2020/08/23/LeetCode-309-best-time-to-buy-and-sell-stock-with-cooldown/"/>
    <url>/2020/08/23/LeetCode-309-best-time-to-buy-and-sell-stock-with-cooldown/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">    0 rest</span><span class="hljs-comment">    1 买入</span><span class="hljs-comment">    2 卖出</span><span class="hljs-comment">    3 卖出后的冷冻期</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">4</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = Integer.MIN_VALUE;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] - prices[i]));        dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);    &#125;    <span class="hljs-keyword">return</span> Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]));&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 714. 买卖股票的最佳时机含手续费</title>
    <link href="/2020/08/22/LeetCode-309-best-time-to-buy-and-sell-stock-with-transaction-fee/"/>
    <url>/2020/08/22/LeetCode-309-best-time-to-buy-and-sell-stock-with-transaction-fee/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></p><p>此题加了手续费，但解法还是和第二题类似。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -(prices[<span class="hljs-number">0</span>] + fee);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i] - fee);    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre><p>可进行状态压缩</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = prices.length;        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> dp0 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> dp1 = -(prices[<span class="hljs-number">0</span>] + fee);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            <span class="hljs-comment">// 保存前一天持有现金时的最大收益</span>            <span class="hljs-keyword">int</span> pre = dp0;            dp0 = Math.max(dp0, dp1 + prices[i]);            dp1 = Math.max(dp1, pre - prices[i] - fee);        &#125;        <span class="hljs-keyword">return</span> dp0;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 188.  买卖股票的最佳时机 IV</title>
    <link href="/2020/08/22/LeetCode-188-best-time-to-buy-and-sell-stock-iv/"/>
    <url>/2020/08/22/LeetCode-188-best-time-to-buy-and-sell-stock-iv/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></p><blockquote><p>一次交易至少需要 2 天，一天买，一天卖。因此如果 <code>k</code> 很大，大到大于等于 <code>len / 2</code>，就相当于股票系列的第 2 题，使用贪心算法去做就可以了。这是一个特判。</p></blockquote><p>可进行状态压缩，省去第一维空间。加上无限交易次数的贪心版本，可加快速度。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 若 交易次数 &gt; 天数 / 2，则无法达成有效的交易，此时等价于无限次交易次数</span>    <span class="hljs-keyword">if</span> (k &gt; len / <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> maxProfit(prices);    &#125;    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];    <span class="hljs-comment">// 初始化第一次状态</span>    <span class="hljs-comment">// 1 次买入</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; k + <span class="hljs-number">1</span>; i++) &#123;        dp[<span class="hljs-number">0</span>][i][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = k; j &gt; <span class="hljs-number">0</span>; j--) &#123;            dp[i][j][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + prices[i]);            dp[i][j][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 123. 买卖股票的最佳时机 III</title>
    <link href="/2020/08/22/LeetCode-123-best-time-to-buy-and-sell-stock-iii/"/>
    <url>/2020/08/22/LeetCode-123-best-time-to-buy-and-sell-stock-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];    <span class="hljs-comment">// 初始化第一天状态，只需要考虑持有股票的情况</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 1 次交易买入</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 2 次交易买入</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 第一次交易</span>        dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        <span class="hljs-comment">// 可能买入 dp[i - 1][0][0] - prices[i]</span>        dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - prices[i]);        <span class="hljs-comment">// 第二次交易</span>        dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] + prices[i]);        <span class="hljs-comment">// 可能买入 dp[i - 1][1][0] - prices[i]</span>        dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>];&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">    dp[i][0] 没有交易 rest</span><span class="hljs-comment">    dp[i][1] 第一次买入</span><span class="hljs-comment">    dp[i][2] 第一次卖出</span><span class="hljs-comment">    dp[i][3] 第二次买入</span><span class="hljs-comment">    dp[i][4] 第二次卖出</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">5</span>];    <span class="hljs-comment">// 第一次买入</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 第二次买入卖出都还没发生</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = Integer.MIN_VALUE;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>] = Integer.MIN_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);        dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);        dp[i][<span class="hljs-number">4</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);    &#125;    <span class="hljs-comment">// 没有交易 第一次卖出 第二次卖出 中可能存在最大值</span>    <span class="hljs-keyword">return</span> Math.max(Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]), dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>]);&#125;</code></pre><p>可进行状态压缩，省去第一维空间。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 121. 买卖股票的最佳时机</title>
    <link href="/2020/08/22/LeetCode-121-best-time-to-buy-and-sell-stock/"/>
    <url>/2020/08/22/LeetCode-121-best-time-to-buy-and-sell-stock/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>状态：<br /><code>dp[i][j][s]</code>: 第 <code>i</code> 天最多进行了 <code>j</code> 次交易后，持有股票状态为 <code>s</code> 的最大利润。</p><ul><li><code>i</code>: 第 <code>i</code> 天</li><li><code>j</code>: 到今天进行的最大交易次数</li><li><code>s</code>: 今天是否持有股票</li></ul><p>状态转移方程：</p><ul><li><code>dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])</code><ul><li>昨天就没有持有，然后今天选择 <code>rest</code>，所以我今天还是没有持有；</li><li>昨天持有股票，但是今天我 <code>sell</code> 了，所以我今天没有持有股票了。</li></ul></li><li><code>dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])</code><ul><li>昨天就持有着股票，然后今天选择 <code>rest</code>，所以我今天还持有着股票；</li><li>昨天本没有持有，但今天我选择 <code>buy</code>，所以今天我就持有股票了。</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span>;    <span class="hljs-comment">// dp[i][j][1]: 第 i 天，持有股票，至今已经进行了 j 次交易</span>    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][k][<span class="hljs-number">2</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; k; j++) &#123;            dp[i][j][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + prices[i]);            dp[i][j][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][k - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>状态：</p><ul><li><code>dp[i][0]</code> - 持有现金 表示第 <code>i</code> 天<strong>卖出股票后的最大利润</strong></li><li><code>dp[i][1]</code> - 持有股票 表示第 <code>i</code> 天持有股票的最大利润</li></ul><p>状态转移方程：</p><ul><li><code>dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</code><ul><li>昨天持有现金，今天 <code>rest</code>，今天仍持有现金</li><li>昨天持有股票，今天 <code>sell</code>，今天变为持有现金</li></ul></li><li><code>dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);</code><ul><li>昨天持有股票，今天 <code>rest</code>，今天仍持有股票</li><li>昨天持有现金，今天 <code>buy</code>，今天变为持有股票，由于只能进行一次交易，只能买入一次股票，不能加上昨天卖出股票后的最大利润</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = prices.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// dp[i][0] - 持有现金 表示第 i 天卖出股票后的最大利润</span>        <span class="hljs-comment">// dp[i][1] - 持有股票 表示第 i 天买入股票的最大利润</span>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);            <span class="hljs-comment">// 只能进行一次交易，意味着只能卖出一次股票，dp[i][1] 不可以从 dp[i][0] 转移而来</span>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);        &#125;        <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    &#125;</code></pre><h1 id="解法三"><a class="markdownIt-Anchor" href="#解法三"></a> 解法三</h1><p>使用差分数组，求数组的最大子序和就是最大盈利。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = prices.length;        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len - <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            diff[i - <span class="hljs-number">1</span>] = prices[i] - prices[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len - <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>] + diff[i], diff[i]);        &#125;                <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;            max = Math.max(max, dp[i]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 337. 打家劫舍 III</title>
    <link href="/2020/08/21/LeetCode-337-house-robber-iii/"/>
    <url>/2020/08/21/LeetCode-337-house-robber-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></p><h1 id="解法一记忆化递归"><a class="markdownIt-Anchor" href="#解法一记忆化递归"></a> 解法一：记忆化递归</h1><pre><code class="hljs java">Map&lt;TreeNode, Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> (memo.containsKey(root)) &#123;            <span class="hljs-keyword">return</span> memo.get(root);        &#125;        <span class="hljs-comment">// 打劫根结点</span>        <span class="hljs-keyword">int</span> doRob = root.val;        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;            doRob += rob(root.left.left) + rob(root.left.right);        &#125;        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;            doRob += rob(root.right.left) + rob(root.right.right);        &#125;        <span class="hljs-comment">// 不打劫根结点</span>        <span class="hljs-keyword">int</span> notRob = rob(root.left) + rob(root.right);        <span class="hljs-keyword">int</span> res = Math.max(doRob, notRob);        memo.put(root, res);        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>状态：</p><ul><li><code>dp[root][0]</code> - 不打劫 <code>root</code> 结点</li><li><code>dp[root][1]</code> - 打劫 <code>root</code> 结点</li></ul><p>转移方程：</p><ul><li><code>dp[root][0]</code>：左右子结点可选择偷或不偷，取他们的最大值</li><li><code>dp[root][1]</code>：左右子结点不偷</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] res = robber(root);    <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] robber(TreeNode root) &#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;    &#125;    <span class="hljs-comment">// 后序遍历，自底向上，先计算左右结点，再计算 root</span>    <span class="hljs-keyword">int</span>[] left = robber(root.left);    <span class="hljs-keyword">int</span>[] right = robber(root.right);    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];    <span class="hljs-comment">// 打劫 root</span>    dp[<span class="hljs-number">1</span>] = root.val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 不打劫 root</span>    dp[<span class="hljs-number">0</span>] = Math.max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + Math.max(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">return</span> dp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 213. 打家劫舍 II</title>
    <link href="/2020/08/21/LeetCode-213-house-robber-ii/"/>
    <url>/2020/08/21/LeetCode-213-house-robber-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></p><p>题目说明：首尾不能同时 rob，那么可以去除第一个元素或去除最后一个元素进行 rob，还是使用 <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a> 的解法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">return</span> Math.max(robRange(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">2</span>), robRange(nums, <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">robRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">int</span> i_2 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> i_1 = nums[start];    <span class="hljs-keyword">int</span> cur = nums[start];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>; i &lt;= end; i++) &#123;        cur = Math.max(i_1, i_2 + nums[i]);        i_2 = i_1;        i_1 = cur;    &#125;    <span class="hljs-keyword">return</span> cur;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 198. 打家劫舍</title>
    <link href="/2020/08/21/LeetCode-198-house-robber/"/>
    <url>/2020/08/21/LeetCode-198-house-robber/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></p><p>状态：<code>dp[i]</code> 第 <code>i</code> 个数结尾的最大子序列和<br />转移：</p><ul><li>不偷 <code>nums[i]</code>, <code>dp[i] = dp[i - 1]</code></li><li>偷 <code>nums[i - 2]</code>, <code>dp[i] = dp[i - 2] + nums[i - 1]</code></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= len; i++) &#123;        dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">return</span> dp[len];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 152. 乘积最大子数组</title>
    <link href="/2020/08/21/LeetCode-152-maximum-product-subarray/"/>
    <url>/2020/08/21/LeetCode-152-maximum-product-subarray/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></p><p>状态：</p><ul><li><code>dp[i][0]</code>: 以 <code>nums[i]</code> 结尾的子数组最小值</li><li><code>dp[i][1]</code>: 以 <code>nums[i]</code> 结尾的子数组最大值</li></ul><p>状态转移：</p><ul><li><code>nums[i] &gt; 0</code><ul><li><code>最大值 * nums[i]</code> 还是最大值</li><li><code>最小值 * nums[i]</code> 还是最小值</li></ul></li><li><code>nums[i] &gt; 0</code><ul><li><code>最大值 * nums[i]</code> = 最小值</li><li><code>最小值 * nums[i]</code> = 最大值</li></ul></li></ul><p>和 <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a> 类似，只要计算当前数字 <code>nums[i]</code> 对 <code>min</code> 或 <code>max</code> 的增益，若有利于他们的最值，则进行更新，否则从 <code>nums[i]</code> 开始重新计算最值。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">/*</span><span class="hljs-comment">         nums[i] &gt; 0:</span><span class="hljs-comment">            max * nums[i] -&gt; max</span><span class="hljs-comment">                dp[i - 1][1] &gt; 0, max = nums[i] * dp[i - 1][1] else nums[i]</span><span class="hljs-comment">            min * nums[i] -&gt; min</span><span class="hljs-comment">                dp[i - 1][0] &lt; 0, min = nums[i] * dp[i - 1][0] else nums[i]</span><span class="hljs-comment"></span><span class="hljs-comment">         num[i] &lt; 0:</span><span class="hljs-comment">            max * nums[i] -&gt; min</span><span class="hljs-comment">                dp[i - 1][1] &gt; 0, min = nums[i] * dp[i - 1][1] else nums[i]</span><span class="hljs-comment">            min * nums[i] -&gt; max</span><span class="hljs-comment">                dp[i - 1][0] &lt; 0, max = nums[i] * dp[i - 1][0] else nums[i]</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> max = dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;                dp[i][<span class="hljs-number">0</span>] = Math.min(nums[i], nums[i] * dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);                dp[i][<span class="hljs-number">1</span>] = Math.max(nums[i], nums[i] * dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);            &#125; <span class="hljs-keyword">else</span> &#123;                dp[i][<span class="hljs-number">0</span>] = Math.min(nums[i], nums[i] * dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);                dp[i][<span class="hljs-number">1</span>] = Math.max(nums[i], nums[i] * dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);            &#125;            max = Math.max(max, dp[i][<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre><p>空间优化：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> imax = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> imin = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> max = imax;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 交换 imax 和 imin，省去后面的二次判断</span>        <span class="hljs-comment">// 否则会出现 imax 和 imin 互相依赖的情况</span>        <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> t = imin;            imin = imax;            imax = t;        &#125;        imin = Math.min(nums[i], nums[i] * imin);        imax = Math.max(nums[i], nums[i] * imax);        max = Math.max(max, imax);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 53. 最大子序和</title>
    <link href="/2020/08/20/LeetCode-53-maximum-subarray/"/>
    <url>/2020/08/20/LeetCode-53-maximum-subarray/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p><p>状态转移：如果前一个子序列和 <code>nums[i - 1]</code> 无法为 <code>nums[i]</code> 带来正增益，则 <code>nums[i]</code> 为 <code>dp[i]</code> 的最大值。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 状态：dp[i] 以 nums[i] 结尾的子数组最大和</span><span class="hljs-comment"> * 转移方程：</span><span class="hljs-comment"> * dp[i] = 前一个子序列 + nums[i] if 前一个子序列 + nums[i] &gt; nums[i] else nums[i]</span><span class="hljs-comment"> * dp[i] = nums[i] 表示重新开始计算新的子序列和</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;        dp[i] = Math.max(nums[i], dp[i - <span class="hljs-number">1</span>] + nums[i]);        max = Math.max(dp[i], max);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><p>空间优化：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> dp = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> max = dp;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            dp = Math.max(nums[i], dp + nums[i]);            max = Math.max(dp, max);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 120. 三角形最小路径和</title>
    <link href="/2020/08/20/LeetCode-120-triangle/"/>
    <url>/2020/08/20/LeetCode-120-triangle/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></p><p>最开始用回溯，最后一个测试用例未通过，原因是输出太长了。<br />然后用动态规划：<br />状态转移方程：<br /><code>dp[i][j] = triangle[i][j] + min(dp[i + 1][j], dp[i + 1][j + 1])</code></p><h1 id="自顶向下"><a class="markdownIt-Anchor" href="#自顶向下"></a> 自顶向下</h1><p>判断很多，最后还要排序，虽然也过了，后来题解发现可以采用自底向上可以方便很多。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = triangle.size();    <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> lastRowNum = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][rows];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] line : dp) &#123;        Arrays.fill(line, Integer.MAX_VALUE);    &#125;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows; i++) &#123;        List&lt;Integer&gt; level = triangle.get(i);        dp[i][<span class="hljs-number">0</span>] = level.get(<span class="hljs-number">0</span>) + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; level.size(); j++) &#123;            <span class="hljs-keyword">int</span> offset = j - <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (offset &gt;= <span class="hljs-number">0</span> &amp;&amp; offset &lt; lastRowNum) &#123;                dp[i][j] = level.get(j) + Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][offset]);            &#125;        &#125;        lastRowNum = level.size();    &#125;    Arrays.sort(dp[rows - <span class="hljs-number">1</span>]);    <span class="hljs-keyword">return</span> dp[rows - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre><h1 id="自底向上"><a class="markdownIt-Anchor" href="#自底向上"></a> 自底向上</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = triangle.size();    <span class="hljs-comment">// 多分配一行，不用判断边界</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// 每行元素的个数就是该行 行号</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;            <span class="hljs-comment">// 因为上面的行数总是 &lt; 下面的行数，不用担心越界</span>            dp[i][j] = triangle.get(i).get(j) + Math.min(dp[i + <span class="hljs-number">1</span>][j], dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];&#125;</code></pre><p>空间优化：<br />计算 <code>dp[i][j]dp[i][j]</code> 时，只用到了下一行的 <code>dp[i + 1][j]dp[i+1][j]</code> 和 <code>dp[i + 1][j + 1]dp[i+1][j+1]</code>，因此只用一行就可以了。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = triangle.size();    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;            dp[j] = triangle.get(i).get(j) + Math.min(dp[j], dp[j + <span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1143. 最长公共子序列</title>
    <link href="/2020/08/20/LeetCode-1143-longest-common-subsequence/"/>
    <url>/2020/08/20/LeetCode-1143-longest-common-subsequence/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200820153633.png" srcset="/img/loading.gif" alt="" /></p><p>base: 两个字符串中有一个为空，则 <code>dp[0][j] = 0</code> 或 <code>dp[i][0] = 0</code><br />状态：<code>dp[i][j]</code> -&gt; <code>str1[:i]</code> 和 <code>str[:j]</code> 的最长序列<br />转移：</p><ul><li>比较位置：<code>str[:i], str[:j]</code> || <code>str1[:i-1]</code>, <code>str2[:j]</code> || <code>str1[:i]</code>, <code>str2[:j-1]</code></li><li>若 <code>i</code>, <code>j</code> 位置相等，直接 + 1</li><li>若不等：取 <code>str1[:i-1]</code>, <code>str2[:j]</code> 和 <code>str1[:i]</code>, <code>str2[:j-1]</code> 中的最大值</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[text1.length() + <span class="hljs-number">1</span>][text2.length() + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= text1.length(); i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= text2.length(); j++) &#123;                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[text1.length()][text2.length()];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 322. 零钱兑换</title>
    <link href="/2020/08/19/LeetCode-322-coin-change/"/>
    <url>/2020/08/19/LeetCode-322-coin-change/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] mem = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];    <span class="hljs-keyword">return</span> dp(amount, coins, mem);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span>[] mem)</span> </span>&#123;    <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 若命中缓存，直接返回</span>    <span class="hljs-keyword">if</span> (mem[amount] != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> mem[amount];    &#125;    <span class="hljs-keyword">int</span> count = Integer.MAX_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;        <span class="hljs-comment">// 计算减去 coin 后最小的硬币数量</span>        <span class="hljs-keyword">int</span> prev = amount - coin;        <span class="hljs-keyword">int</span> prevCount = dp(prev, coins, mem);        <span class="hljs-comment">// 若能找到 prev 的最小数目，计算本次 count 的最小值</span>        <span class="hljs-keyword">if</span> (prevCount != -<span class="hljs-number">1</span>) &#123;            count = Math.min(prevCount + <span class="hljs-number">1</span>, count);        &#125;    &#125;    <span class="hljs-comment">// 更新缓存</span>    mem[amount] = count == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : count;    <span class="hljs-keyword">return</span> mem[amount];&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;    <span class="hljs-comment">// 1, 2, 5 =&gt; 11</span>    <span class="hljs-comment">// 10: dp[10] + 1</span>    <span class="hljs-comment">// 9: dp[9] + 1</span>    <span class="hljs-comment">// 6: dp[6] + 1</span>    <span class="hljs-comment">// base: 0, 1, 1</span>    <span class="hljs-comment">// 状态: dp[i] 表示第 i 个值需要的最小硬币数</span>    <span class="hljs-comment">// 选择：每一种硬币</span>    <span class="hljs-comment">// dp[i] = min(dp[i - coin])</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];    Arrays.fill(dp, Integer.MAX_VALUE);    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; amount; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;            <span class="hljs-comment">// 前一个值有效 &amp;&amp; 前一个值能够取得最小硬币数</span>            <span class="hljs-keyword">if</span> (i - coin &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i - coin] != Integer.MAX_VALUE) &#123;                dp[i] = Math.min(dp[i - coin] + <span class="hljs-number">1</span>, dp[i]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : dp[amount];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 复制</title>
    <link href="/2020/08/19/MySQL-replication/"/>
    <url>/2020/08/19/MySQL-replication/</url>
    
    <content type="html"><![CDATA[<h1 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h1><ol><li>主服务器把数据更改记录到二进制日志中。</li><li>从服务器把主服务器的二进制日志复制到自己的中继日志中。</li><li>从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。</li></ol><p>需要注意的是：复制不是完全实时地进行同步，而是<strong>异步实时</strong>。这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819125023.png" srcset="/img/loading.gif" alt="" /></p><h1 id="快照-复制的备份架构"><a class="markdownIt-Anchor" href="#快照-复制的备份架构"></a> 快照 + 复制的备份架构</h1><p>复制的主要功能：</p><ul><li><strong>数据分布</strong><br />可以在不同的数据中心实现数据的复制。</li><li><strong>读取的负载平衡</strong><br />通过建立多个从服务器，可将读取平均地分布到这些从服务器中，并且减少了主服务器的压力</li><li><strong>数据库备份</strong><br />复制对备份很有帮助，但是从服务器不是备份，不能完全代替备份。</li><li><strong>高可用性和故障转移</strong><br />从服务器有助于故障转移，减少故障的停机时间和恢复时间</li></ul><p>通过对从服务器上的数据库所在分区做快照，可避免误操作对复制造成影响。当发生主服务器上的误操作时，只需要将从服务器上的快照进行恢复，然后再根据二进制日志进行 <code>point-in-time</code> 的恢复。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819131452.png" srcset="/img/loading.gif" alt="" /></p><h1 id="复制的原理"><a class="markdownIt-Anchor" href="#复制的原理"></a> 复制的原理</h1><p>默认情况下使用基于语句的复制模式，如果发现语句无法被正确地复制，就切换到基于行的复制模式。</p><h2 id="基于语句的复制"><a class="markdownIt-Anchor" href="#基于语句的复制"></a> 基于语句的复制</h2><p>在基于语句的复制模式下，主库会记录那些造成数据更改的查询，当备库读取并重放这些事件时，实际上只是把主库上执行的 <code>SQL</code> 语句再执行一遍。</p><p><code>mysqlbinlog</code> 工具是使用基于语句的日志的最佳工具。</p><p>好处：</p><ol><li>实现简单。只要记录和执行 <code>SQL</code> 语句。</li><li>二进制日志里的事件更加紧凑，不会使用太多带宽。</li></ol><p>缺点：</p><ol><li>使用存储过程和触发器的语句复制时可能存在问题（时间戳、用户）。</li><li>更新必须是串行的，需要更多的锁。</li></ol><h2 id="基于行的复制"><a class="markdownIt-Anchor" href="#基于行的复制"></a> 基于行的复制</h2><p>基于行的复制会将实际数据记录在二进制日志中。</p><p>好处：</p><ol><li>几乎没有基于行的复制模式无法处理的场景。</li><li>可能减少锁的使用。</li><li>会记录数据变更。</li></ol><p>缺点：</p><ol><li>由于语句并没有在日志里记录，无法判断执行了哪些 <code>SQL</code>。</li><li>使用一种完全不同的方式在备库进行数据变更，无法知道服务器在做什么。</li></ol><h1 id="复制拓扑"><a class="markdownIt-Anchor" href="#复制拓扑"></a> 复制拓扑</h1><p>基本原则：</p><ol><li>一个 <code>MySQL</code> 备库实例只能有一个主库。</li><li>一个主库可以有多个备库。</li><li>每个备库必须有一个唯一的服务器 <code>ID</code>。</li><li>如果打开了 <code>log_slave_updates</code> 选项，一个备库可以把其主库上的数据变化传播到其他备库。</li></ol><h2 id="一主库多备库"><a class="markdownIt-Anchor" href="#一主库多备库"></a> 一主库多备库</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819135637.png" srcset="/img/loading.gif" alt="" /></p><p>用途：</p><ol><li>为不同的角色使用不同的备库。</li><li>把一台备库当作待用的主库，除了复制没有其他数据传输。</li><li>将一台备库放到远程数据中心，用作灾难恢复。</li><li>将一台备库作为备份、培训、开发、测试服务器。</li></ol><h2 id="主动-主动模式下的主-主复制"><a class="markdownIt-Anchor" href="#主动-主动模式下的主-主复制"></a> 主动-主动模式下的主-主复制</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819135956.png" srcset="/img/loading.gif" alt="" /></p><ul><li>主-主复制包含两台服务器，每一个都被配置成对方的主库和备库，它们是一对主库。</li><li>该模式的使用场景是两个处于不同地理位置的办公室，并且都需要一份可写的数据拷贝。</li></ul><h2 id="主动-被动模式下的主-主复制"><a class="markdownIt-Anchor" href="#主动-被动模式下的主-主复制"></a> 主动-被动模式下的主-主复制</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819140316.png" srcset="/img/loading.gif" alt="" /></p><ul><li>这是主-主结构的变体，主要区别在于其中的一台服务器是只读的被动服务器。</li><li>这种方式使得反复切换主动和被动服务器非常方便，因为服务器是对称的。</li><li>该结构类似于创建一个热备份，用来提高性能。</li></ul><h2 id="拥有备库的主-主结构"><a class="markdownIt-Anchor" href="#拥有备库的主-主结构"></a> 拥有备库的主-主结构</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819140659.png" srcset="/img/loading.gif" alt="" /></p><p>为每个主库增加一个备库，增加了冗余，对于不同地理位置的复制拓扑，能够消除单点失效的问题。当主库失效时，用备库来代替主库是可行的。</p><h2 id="环形复制"><a class="markdownIt-Anchor" href="#环形复制"></a> 环形复制</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819141026.png" srcset="/img/loading.gif" alt="" /></p><ul><li><p>环形结构可以拥有三个或更多的主库。每个服务器都是在它之前的服务器的备库，是在它之后服务器的主库。</p></li><li><p>环形结构完全依赖于环上的每一个结点，这大大增加了系统失效的几率。如果从环中移除一个节点，这个节点发起的事件就会陷入无限循环：它们将永远绕着服务器链循环。</p></li></ul><h2 id="主库-分发主库以及备库"><a class="markdownIt-Anchor" href="#主库-分发主库以及备库"></a> 主库、分发主库以及备库</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819141525.png" srcset="/img/loading.gif" alt="" /></p><p>分发主库事实上也是一个备库，它的唯一目的就是提取和提供主库的二进制日志。多个备库连接到分发主库，这使原来的主库摆脱了负担。</p><h2 id="树或金字塔形"><a class="markdownIt-Anchor" href="#树或金字塔形"></a> 树或金字塔形</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819142034.png" srcset="/img/loading.gif" alt="" /></p><p>和分发主库一样，减轻了主库的负担。<br />它的缺点是中间层出现的任何错误都会影响到多个服务器，中间层次越多，处理故障会更困难、更复杂。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 63. 不同路径 II</title>
    <link href="/2020/08/18/LeetCode-63-unique-paths-ii/"/>
    <url>/2020/08/18/LeetCode-63-unique-paths-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></p><p>一开始判断第一行或第一列的障碍时没有及时 <code>break</code>，导致若只有一行或一列的情况下出错。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * base: 若左边或上边存在障碍，则不能继续往下走</span><span class="hljs-comment">         * 状态：dp[i][j]</span><span class="hljs-comment">         * 选择：左，上</span><span class="hljs-comment">         * dp[i][[j] = dp[i - 1][j] + dp[i][j - 1]</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span> rows = obstacleGrid.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> cols = obstacleGrid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][cols];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-comment">// 如果有一个位置有障碍，那么该列剩下的位置都走不过去了</span>            <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;            <span class="hljs-comment">// 如果有一个位置有障碍，那么该行剩下的位置都走不过去了</span>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">0</span>) &#123;                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[rows - <span class="hljs-number">1</span>][cols - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 62. 不同路径</title>
    <link href="/2020/08/18/LeetCode-62-unique-paths/"/>
    <url>/2020/08/18/LeetCode-62-unique-paths/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></p><p>边界条件：第一行 <code>dp[0][i]</code> 和第一列 <code>dp[i][0]</code> 值为 <code>1</code>：只有一条路径可到达该位置。<br />状态转移方程：每个位置的路径 = 左边路径数 + 上边路径数。</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><code>2</code></td><td style="text-align:center"><code>3</code></td><td style="text-align:center"><code>4</code></td><td style="text-align:center"><code>5</code></td><td style="text-align:center"><code>6</code></td><td style="text-align:center"><code>7</code></td></tr><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><code>3</code></td><td style="text-align:center"><code>6</code></td><td style="text-align:center"><code>10</code></td><td style="text-align:center"><code>15</code></td><td style="text-align:center"><code>21</code></td><td style="text-align:center"><code>28</code></td></tr></tbody></table><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * base: 第一行和第一列为 1</span><span class="hljs-comment">     * 状态：dp[i][j] 每个位置路径数 = 左 + 上</span><span class="hljs-comment">     * 选择：左，上</span><span class="hljs-comment">     * dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];&#125;</code></pre><p>优化：</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th></tr></thead><tbody></tbody></table><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center"><code>2</code></th><th style="text-align:center"><code>3</code></th><th style="text-align:center"><code>4</code></th><th style="text-align:center"><code>5</code></th><th style="text-align:center"><code>6</code></th><th style="text-align:center"><code>7</code></th></tr></thead><tbody></tbody></table><p>省去列上的空间：<code>dp[j] = dp[j] + dp[j - 1]</code><br /><code>dp[j]</code> 在更新前相当于上边的值<br /><code>dp[j - 1]</code> 在更新 <code>dp[j]</code> 时，已经更新了 <code>dp[j - 1]</code> ，所以它相当于左边的值。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;     <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];     Arrays.fill(dp, <span class="hljs-number">1</span>);     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;             dp[j] += dp[j - <span class="hljs-number">1</span>];         &#125;     &#125;     <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>]; &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 备份与恢复</title>
    <link href="/2020/08/18/MySQL-backup-recovery/"/>
    <url>/2020/08/18/MySQL-backup-recovery/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>根据备份方法：</p><ul><li><strong>热备</strong>（<code>Hot Backup</code>）：运行的数据库中备份，对数据库操作没有影响</li><li><strong>冷备</strong>（<code>Cold Backup</code>）：数据库停止的情况下，复制物理文件</li><li><strong>温备</strong>（<code>Warm Backup</code>）：运行的数据库，但对数据库操作有影响，如加一个全局读锁保证数据一致性。</li></ul><p>根据备份后文件的内容：</p><ul><li><strong>逻辑备份</strong>：内容一般是一条条 <code>SQL</code> 语句，恢复时间长</li><li><strong>裸文件备份</strong>：复制数据库的物理文件，恢复时间短</li></ul><p>根据备份数据库的内容：</p><ul><li><strong>完全备份</strong>：对数据库进行一个完整的备份。</li><li><strong>增量备份</strong>：在上次完全备份的基础上，对于更改的数据进行备份。</li><li><strong>日志备份</strong>：对二进制日志的备份，通过对二进制日志的重做完成恢复。</li></ul><h1 id="冷备"><a class="markdownIt-Anchor" href="#冷备"></a> 冷备</h1><p>只需要备份 <code>MySQL</code> 数据库的 <code>frm</code> 文件，共享表空间文件，独立表空间（<code>*.ibd</code>）文件，重做日志文件。</p><p>优点：</p><ul><li>备份简单，只要复制相关文件即可</li><li>备份文件易于在不同操作系统，不同 <code>MySQL</code> 版本上恢复</li><li>恢复简单，只要把文件恢复到指定位置即可</li><li>恢复速度快，不需要执行任何 <code>SQL</code> 语句，也不需要重建索引</li></ul><p>缺点：</p><ul><li>冷备的文件通常比逻辑文件大很多，因为表空间中存放着很多其他的数据，如 <code>undo</code> 段，插入缓冲等信息。</li><li>冷备不总是可以轻易地跨平台。操作系统、<code>MySQL</code> 的版本、文件大小写敏感和浮点数格式都会成为问题。</li></ul><h1 id="热备"><a class="markdownIt-Anchor" href="#热备"></a> 热备</h1><h2 id="ibbackup"><a class="markdownIt-Anchor" href="#ibbackup"></a> <code>ibbackup</code></h2><p><code>ibbackup</code> 可以同时备份 <code>MyISAM</code> 和 <code>InnoDB</code> 存储引擎表。工作原理如下：</p><ol><li>记录备份开始时，重做日志文件检查点的 <code>LSN</code>。</li><li>复制共享表空间文件及独立表空间文件。</li><li>记录复制完表空间文件后，重做日志文件检查点的 <code>LSN</code>。</li><li>复制在备份时产生的重做日志。</li></ol><p>优点：</p><ul><li>在线备份，不阻塞任何的 <code>SQL</code> 语句。</li><li>备份性能好，<strong>备份的实质是复制数据库文件和重做日志文件</strong>。</li><li>支持压缩备份，通过选项，可以支持不同级别的压缩。</li><li>跨平台支持。</li></ul><p>恢复步骤：</p><ul><li>恢复表空间文件。</li><li>应用重做日志文件。</li></ul><h2 id="xtrabackup"><a class="markdownIt-Anchor" href="#xtrabackup"></a> <code>XtraBackup</code></h2><p><code>XtraBackup</code> 是一款开源免费的热备工具，它实现了 <code>ibbackup</code> 的所有功能，并且支持了真正的增量备份功能，是热备的更好选择。</p><p>工作原理：</p><ol><li>首先完成一个全备，并记录下此时检查点的 <code>LSN</code>。</li><li>在进行增量备份时，比较表空间中每个页的 <code>LSN</code> 是否大于上次备份时的 <code>LSN</code>，如果是，则备份该页，同时记录当前检查点的 <code>LSN</code>。</li></ol><h1 id="逻辑备份"><a class="markdownIt-Anchor" href="#逻辑备份"></a> 逻辑备份</h1><h2 id="备份方式"><a class="markdownIt-Anchor" href="#备份方式"></a> 备份方式</h2><h3 id="mysqldump"><a class="markdownIt-Anchor" href="#mysqldump"></a> <code>mysqldump</code></h3><p><code>mysqldump</code> 通常用来完成转存（<code>dump</code>）数据库的备份及不同数据库之间的移植。</p><h3 id="selectinto-outfile"><a class="markdownIt-Anchor" href="#selectinto-outfile"></a> <code>SELECT...INTO OUTFILE</code></h3><p><code>SELECT...INTO OUTFILE</code> 可以导出一张表中的数据。</p><h2 id="逻辑备份的恢复"><a class="markdownIt-Anchor" href="#逻辑备份的恢复"></a> 逻辑备份的恢复</h2><h3 id="mysqldump-2"><a class="markdownIt-Anchor" href="#mysqldump-2"></a> <code>mysqldump</code></h3><p><code>mysqldump</code> 的恢复操作比较简单，因为备份的文件就是导出的 <code>SQL</code> 语句，一般只需要执行这个文件就可以了。</p><p><code>mysqldump</code> <strong>不能导出视图</strong>，因此若数据库中使用了视图，还需要导出视图的定义，或者备份视图定义的 <code>frm</code> 文件，并在恢复时进行导入。</p><h3 id="load-data-infile"><a class="markdownIt-Anchor" href="#load-data-infile"></a> <code>LOAD DATA INFILE</code></h3><p>若通过 <code>mysqldump-tab</code>，或者通过 <code>SELECT...INTO OUTFILE</code> 导出的数据需要恢复，可以通过命令 <code>LOAD DATA INFILE</code> 来进行导入。</p><h3 id="mysqlimport"><a class="markdownIt-Anchor" href="#mysqlimport"></a> <code>mysqlimport</code></h3><p><code>mysqlimport</code> 是 <code>LOAD DATA INFILE</code> 的命令接口，而且大多数选项都和 <code>LOAD DATA INFILE</code> 语法相同。</p><p>和 <code>LOAD DATA INFILE</code> 不同的是，<code>mysqlimport</code> 可以用来导入<strong>多张表</strong>，或者<strong>并发地导入多个文件</strong>。</p><h1 id="二进制日志备份与恢复"><a class="markdownIt-Anchor" href="#二进制日志备份与恢复"></a> 二进制日志备份与恢复</h1><p>在默认情况下并不启用二进制日志，启用它需在配置文件中设置：</p><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><span class="hljs-attr">log-bin</span>=mysql-bin</code></pre><p>通过 <code>mysqlbinlog</code> 可恢复二进制日志。<br />如果需要恢复多个二进制文件，也可以先通过 <code>mysqlbinlog</code> 命令导出到一个文件，然后再通过 <code>SOURCE</code> 命令来导入。</p><h1 id="快照备份"><a class="markdownIt-Anchor" href="#快照备份"></a> 快照备份</h1><p><code>MySQL</code> 数据库本身并不支持快照功能，因此快照备份是指通过文件系统支持的快照功能对数据库进行备份。</p><ul><li>备份的前提是将所有数据库文件放在同一文件分区中，然后对该分区进行快照操作。</li><li>支持快照功能的文件系统和设备包括 <code>FreeBSD</code> 的 <code>UFS</code>，<code>Solaris</code> 的 <code>ZFS</code>，<code>GNU/Linux</code> 的逻辑管理器（<code>Logical Volume Manager, LVM</code>）等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 事务</title>
    <link href="/2020/08/17/MySQL-transaction/"/>
    <url>/2020/08/17/MySQL-transaction/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><blockquote><p>事务是访问并更新数据库中各种数据项的一个程序执行单元。<br />在事务中的操作，要么都不做，要么都做修改，这就是事务的目的，也是事务模型区别于文件系统的重要特征之一。</p></blockquote><ul><li>事务就是一组原子性的 <code>SQL</code> 语句。具体来说，事务指的是满足 <code>ACID</code> 特性的一组操作。</li><li>通过 <code>COMMIT</code> 提交一个事务，也可以使用 <code>ROLLBACK</code> 进行回滚。</li><li>事务内的 <code>SQL</code> 语句，要么全执行成功，要么全执行失败。</li><li>通过加锁的方式，可以实现不同的事务隔离机制。</li></ul><h2 id="acid-特性"><a class="markdownIt-Anchor" href="#acid-特性"></a> <code>ACID</code> 特性</h2><ul><li><p><strong>原子性 (<code>Atomicity</code>)</strong>：原子性是指整个数据库事务是不可分割的工作单位。<br />事务的所有操作够执行成功，整个事务才算成功。<br />事务的任何一个 <code>SQL</code> 语句执行失败，数据库状态应该退回到执行事务前的状态。</p></li><li><p><strong>一致性 (<code>Consistency</code>)</strong>：一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和结束之后，数据库的完整性约束没有被破坏。</p></li><li><p><strong>隔离性 (<code>Isolation</code>)</strong>：每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，通常使用锁来实现。</p></li><li><p><strong>持久性 (<code>Durability</code>)</strong>：事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。</p></li></ul><h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2><h3 id="扁平事务"><a class="markdownIt-Anchor" href="#扁平事务"></a> 扁平事务</h3><p>扁平事务中，所有操作都处于同一层次，由 <code>BEGIN WORK</code> 开始，由 <code>COMMIT WORK</code> 或 <code>ROLLBACK WORK</code> 结束，其间的操作是原子的。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200817194044.png" srcset="/img/loading.gif" alt="" /></p><p>扁平事务的主要限制是<strong>不能提交或者回滚事务的某一部分</strong>。</p><p><strong>带有保存点的扁平事务</strong>：<br />允许在事务执行过程中回滚到同一事务中较早的一个状态。<br />保存点（<code>Savepoint</code>）用来通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。</p><h3 id="链事务"><a class="markdownIt-Anchor" href="#链事务"></a> 链事务</h3><p>可视为保存点模式的一种变种。带有保存点的扁平事务，当发生系统崩溃时，所有的保存点都将消失，因为其保存点是易失的（<code>volatile</code>），而非持久的（<code>persistent</code>）。当恢复时，事务要从开始处重新执行，而不能从最近的一个保存点继续执行。</p><p>链事务：当提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传递给下一个要开始的事务。</p><ul><li>链事务只能恢复到<strong>最近</strong>的一个保存点，而带有保存点的扁平事务能回滚到<strong>任意正确的时间点</strong>。</li><li>链事务在执行 <code>COMMIT</code> 后即释放了当前事务所持有的锁，而带有保存点的扁平事务不影响所持有的锁。</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200817195151.png" srcset="/img/loading.gif" alt="" /></p><h3 id="嵌套事务"><a class="markdownIt-Anchor" href="#嵌套事务"></a> 嵌套事务</h3><p>嵌套事务是一个层次结构框架。由一个顶层事务控制着各个层次的事务。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200817195457.png" srcset="/img/loading.gif" alt="" /></p><h3 id="分布式事务"><a class="markdownIt-Anchor" href="#分布式事务"></a> 分布式事务</h3><p>分布式事务通常是一个在分布式环境下运行的扁平事务，需要根据数据所在位置访问网络中的不同节点，它也需要满足 <code>ACID</code> 特性。</p><h1 id="acid-实现"><a class="markdownIt-Anchor" href="#acid-实现"></a> <code>ACID</code> 实现</h1><ul><li>事务的隔离性通过锁实现。</li><li>原子性、一致性、持久性通过 <code>redo log</code> 和 <code>undo log</code> 来完成。<ul><li><code>redo log</code> 用来保证原子性和持久性；</li><li><code>undo log</code> 用来保证一致性。</li></ul></li></ul><p><code>redo</code> 和 <code>undo</code> 的区别：</p><ul><li><code>redo</code> 恢复提交事务修改的页操作，是<strong>物理日志</strong>，记录的是<strong>页的物理修改</strong>操作。</li><li><code>undo</code> 回滚行记录到某个特定版本，是<strong>逻辑日志</strong>，根据<strong>每行记录</strong>进行记录。</li></ul><h2 id="redo"><a class="markdownIt-Anchor" href="#redo"></a> <code>redo</code></h2><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><p>重做日志由两部分组成：</p><ol><li>重做日志缓冲（<code>redo log buffer</code>），其是易失的</li><li>重做日志文件（<code>redo log file</code>），其是持久的</li></ol><p>当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的 <code>COMMIT</code> 操作完成才算完成。<br />为了确保每次日志都写入重做日志文件，在每次将重做日志缓冲写入重做日志文件后，<code>InnoDB</code> 都需要调用一次 <code>fsync</code> 操作。</p><h3 id="log-block"><a class="markdownIt-Anchor" href="#log-block"></a> <code>log block</code></h3><p>重做日志都是以 <code>512</code> 字节进行存储的，这意味着重做日志缓存、重做日志文件都是以块（<code>block</code>）的方式保存的，称之为重做日志块（<code>redo log block</code>）。</p><p>由于重做日志块的大小和磁盘扇区大小一样，因此重做日志的写入可以保证原子性，不需要 <code>doublewrite</code> 技术。</p><h3 id="log-group"><a class="markdownIt-Anchor" href="#log-group"></a> <code>log group</code></h3><p><code>log group</code> 为重做日志组，其中有多个重做日志文件，<code>InnoDB</code> 实际只有一个 <code>log group</code>。<br /><code>log group</code> 是一个逻辑上的概念，并没有一个实际的物理文件来表示 <code>log group</code> 信息。</p><h2 id="undo"><a class="markdownIt-Anchor" href="#undo"></a> <code>undo</code></h2><h3 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h3><ul><li><code>undo</code> 是逻辑日志，只是通过<strong>回滚</strong>操作将数据库逻辑地恢复到原来的样子，数据结构和页本身在回滚之后可能大不相同，这是因为在并发系统中，不能将页回滚到事务开始时的样子，否则会影响其他事务正在进行的工作。</li><li><code>undo</code> 的另一个作用是 <strong><code>MVCC</code></strong>，<code>MVCC</code> 的实现是通过 <code>undo</code> 来完成。当用户读取一行时，若该行已被其他事务占用，当前事务可以通过 <code>undo</code> 读取之前的行版本信息，实现非锁定读取。</li><li><code>undo log</code> 会产生 <code>redo log</code>，这是因为 <code>undo log</code> 也需要持久性的保护。</li></ul><h3 id="undo-log-格式"><a class="markdownIt-Anchor" href="#undo-log-格式"></a> <code>undo log</code> 格式</h3><p><code>undo log</code> 分为：</p><ol><li><code>insert undo log</code></li><li><code>update undo log</code></li></ol><ul><li><p><code>insert undo log</code> 是指在 <code>insert</code> 操作中产生的 <code>undo log</code>，因为 insert 操作的记录，只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后删除。</p></li><li><p><code>update undo log</code> 记录的是对 <code>delete</code> 和 <code>update</code> 操作产生的 <code>undo log</code>，该 <code>undo log</code> 可能需要提供 <code>MVCC</code> 机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge</code> 线程进行最后的删除。</p></li></ul><h1 id="事务控制语句"><a class="markdownIt-Anchor" href="#事务控制语句"></a> 事务控制语句</h1><ul><li><code>START TRANSACTION | BEGIN</code>: 显式地开启一个事务。</li><li><code>COMMIT</code>: 提交事务。</li><li><code>ROLLBACK</code>: 结束用户的事务，撤销正在进行的所有未提交的事务。</li><li><code>SAVEPOINT identifier</code>: 创建一个保存点。</li><li><code>RELEASE SAVEPOINT identifier</code>: 删除一个事务的保存点。</li><li><code>ROLLBACK TO [SAVEPOINT] identifier</code>: 把事务回滚到标记点，而不回滚在此标记点之前的任何工作。</li><li><code>SET TRANSACTION</code>: 设置隔离级别。</li></ul><h1 id="隐式提交"><a class="markdownIt-Anchor" href="#隐式提交"></a> 隐式提交</h1><p><code>MySQL</code> 默认采用<strong>隐式提交策略</strong>（<code>autocommit</code>）。每执行一条语句就把这条语句当成一个事务然后进行提交。</p><ul><li>当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；</li><li>当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</li></ul><p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对<strong>每个连接</strong>而不是针对服务器的。</p><h1 id="隔离级别"><a class="markdownIt-Anchor" href="#隔离级别"></a> 隔离级别</h1><h2 id="读未提交-脏读"><a class="markdownIt-Anchor" href="#读未提交-脏读"></a> 读未提交 - 脏读</h2><p><strong>脏读</strong>（<code>Dirty Read</code>）：事务可以读取未提交的数据。</p><p><code>T1</code> 修改一个数据，<code>T2</code> 随后读取这个数据。如果 <code>T1</code> 撤销了这次修改，那么 <code>T2</code> 读取的数据是脏数据。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200818130050.png" srcset="/img/loading.gif" alt="" /></p><h2 id="读已提交-不可重复读"><a class="markdownIt-Anchor" href="#读已提交-不可重复读"></a> 读已提交 - 不可重复读</h2><p>读已提交解决了脏读的问题：每次读取数据前都生成一个 <code>ReadView</code>，每次都可判断事务是否提交。</p><p><strong>不可重复读</strong>：执行两次相同的查询，得到的结果可能不一致。<br /><code>T2</code> 读取一个数据，<code>T1</code> 对该数据做了修改。如果 <code>T2</code> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200818131135.png" srcset="/img/loading.gif" alt="" /></p><h2 id="可重复读-幻读"><a class="markdownIt-Anchor" href="#可重复读-幻读"></a> 可重复读 - 幻读</h2><p>解决了不可重复读的问题：在第一次读取数据时生成一个 <code>ReadView</code>，每次访问时都读取最初的版本。</p><p><strong>幻读</strong>：当某个事务读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务又再次读取该范围的记录时，得到结果与第一次不一致。</p><p><code>T1</code> 读取某个范围的数据，<code>T2</code> 在这个范围内插入新的数据，<code>T1</code> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><blockquote><p>InnoDB 使用 <code>Next-Key Lock</code>，避免了幻读。</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200818131209.png" srcset="/img/loading.gif" alt="" /></p><h2 id="串行化"><a class="markdownIt-Anchor" href="#串行化"></a> 串行化</h2><p>强制事务串行执行，则避免了所有的并发问题。</p><p>串行化策略会在读取的每一行数据上都加锁，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。</p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><ul><li><code>READ UNCOMMITTED</code> - 事务中的修改，即使没有提交，对其它事务也是可见的。</li><li><code>READ COMMITTED</code> - 一个事务只能读取已经提交的事务所做的修改，避免<strong>脏读</strong>。</li><li><code>REPEATABLE READ</code> - 默认隔离级别，解决了不可重复读的问题，使用 <code>Next-Key Lock</code>，避免<strong>幻读</strong>。</li><li><code>SERIALIZABLE</code> - 对每个读取操作加共享锁，强制事务串行执行，不支持一致性的非锁定读。</li></ul><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">读未提交（<code>READ UNCOMMITTED</code>）</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">读已提交（<code>READ COMMITTED</code>）</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">可重复读（<code>REPREATABLE READ</code>）</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">❌ (<code>InnoDB</code> - ✔️)</td></tr><tr><td style="text-align:center">串行化（<code>SERIALIZABLE</code>）</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 35. 搜索插入位置</title>
    <link href="/2020/08/17/LeetCode-35-search-insert-position/"/>
    <url>/2020/08/17/LeetCode-35-search-insert-position/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></p><p>标准的二分</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (target == nums[mid]) &#123;                <span class="hljs-keyword">return</span> mid;            &#125;            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;                right = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 154. 寻找旋转排序数组中的最小值 II</title>
    <link href="/2020/08/17/LeetCode-154-find-minimum-in-rotated-sorted-array-ii/"/>
    <url>/2020/08/17/LeetCode-154-find-minimum-in-rotated-sorted-array-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[right] &lt; nums[mid]) &#123;                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[right] &gt; nums[mid]) &#123;                right = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 若 右 == 中，因为最小值一定靠近左边，丢弃右边的重复值，缩小右边界</span>                right--;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left];    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 153. 寻找旋转排序数组中的最小值</title>
    <link href="/2020/08/17/LeetCode-153-find-minimum-in-rotated-sorted-array/"/>
    <url>/2020/08/17/LeetCode-153-find-minimum-in-rotated-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></p><p>第一次通过的代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[left] &gt; nums[mid]) &#123;            <span class="hljs-comment">// 左 &gt; 中，min 在 中 后面的部分</span>            min = Math.min(nums[mid], min);            <span class="hljs-comment">// 到左边查找</span>            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 中 &gt;= 左，min 在最左边</span>            min = Math.min(nums[left], min);            <span class="hljs-comment">// 到右边查找</span>            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> Math.min(min, nums[left]);&#125;</code></pre><p>评论区：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * [3,4,5,1,2]</span><span class="hljs-comment">     * [4,5,6,7,0,1,2]</span><span class="hljs-comment">     * [0,1,2,3,4]</span><span class="hljs-comment">     * [2,1]</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[right] &lt; nums[mid]) &#123;            <span class="hljs-comment">// 右 &lt; 中，一定在右边，则到右边查找</span>            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 右 &gt;= 中，一定在左边</span>            right = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> nums[left];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 81. 搜索旋转排序数组 II</title>
    <link href="/2020/08/17/LeetCode-81-search-in-rotated-sorted-array-ii/"/>
    <url>/2020/08/17/LeetCode-81-search-in-rotated-sorted-array-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></p><p>本题加入重复数字，所以在判断哪一部分有序时，若 <code>nums[left] == nums[mid]</code> 可能出现判断不出来的情况，一开始一直卡着，后来发现只要丢弃一个重复数字，则下一次就可成功判断。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (target == nums[mid]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">if</span> (nums[left] &lt; nums[mid]) &#123;                <span class="hljs-comment">// 左半部分有序</span>                <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid]) &#123;                    right = mid;                &#125; <span class="hljs-keyword">else</span> &#123;                    left = mid + <span class="hljs-number">1</span>;                &#125;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] &gt; nums[mid]) &#123;                <span class="hljs-comment">// 右半部分有序</span>                <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;                    left = mid + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    right = mid;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// nums[left] == nums[mid] 时无法判断哪部分有序，则丢弃一个重复数字</span>                <span class="hljs-comment">// [1,3,1,1,1]</span>                <span class="hljs-comment">// [1,3,1,1]</span>                left++;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left] == target;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 74. 搜索二维矩阵</title>
    <link href="/2020/08/17/LeetCode-74-search-a-2d-matrix/"/>
    <url>/2020/08/17/LeetCode-74-search-a-2d-matrix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a><br />一开始用 <code>i = mid / rows</code> 计算行数，导致位置计算不正确。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> rows = matrix.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = rows * cols - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-comment">// 行数是对每行大小进行整除，</span>            <span class="hljs-comment">// 列数是对每行大小进行取余</span>            <span class="hljs-keyword">int</span> i = mid / cols;            <span class="hljs-keyword">int</span> j = mid % cols;            <span class="hljs-keyword">if</span> (matrix[i][j] == target) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target) &#123;                <span class="hljs-comment">// 不使用 left = mid</span>                <span class="hljs-comment">// 原因在于向上取整时 matrix 可能会越界，所以采用向下取整</span>                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                right = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> matrix[left / cols][left % cols] == target;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 33. 搜索旋转排序数组</title>
    <link href="/2020/08/17/LeetCode-33-search-in-rotated-sorted-array/"/>
    <url>/2020/08/17/LeetCode-33-search-in-rotated-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;                <span class="hljs-keyword">return</span> mid;            &#125;            <span class="hljs-keyword">if</span> (nums[left] &lt; nums[mid]) &#123;                <span class="hljs-comment">// 1. 左半部分 [left, mid] 有序</span>                <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;                    <span class="hljs-comment">// 1.1 target in [left, mid]</span>                    <span class="hljs-comment">// left &lt;= target &lt; mid.....right</span>                    <span class="hljs-comment">// [left, mid - 1]</span>                    right = mid - <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 1.2 target in [mid + 1, right]</span>                    <span class="hljs-comment">// [mid, right]</span>                    left = mid;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 2. 右半部分 [mid, right] 有序</span>                <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;                    <span class="hljs-comment">// 2.1 target in [mid, right]</span>                    <span class="hljs-comment">// left.....mid &lt; target &lt;= right</span>                    <span class="hljs-comment">// [mid, right]</span>                    left = mid;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 2.2 target in [left, mid - 1]</span>                    <span class="hljs-comment">// [left, mid - 1]</span>                    right = mid - <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 367. 有效的完全平方数</title>
    <link href="/2020/08/16/LeetCode-367.%20valid-perfect-square/"/>
    <url>/2020/08/16/LeetCode-367.%20valid-perfect-square/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-perfect-square/" target="_blank" rel="noopener">367. 有效的完全平方数</a></p><p>两种解法都击败 <code>100%</code></p><h1 id="二分法"><a class="markdownIt-Anchor" href="#二分法"></a> 二分法</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">long</span> left = <span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> right = num / <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">long</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">long</span> prod = mid * mid;        <span class="hljs-keyword">if</span> (prod == num) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prod &gt; num) &#123;            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> left * left == num;&#125;</code></pre><h1 id="牛顿迭代法"><a class="markdownIt-Anchor" href="#牛顿迭代法"></a> 牛顿迭代法</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">long</span> x = num / <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (x * x &gt; num) &#123;        x = (x + num / x) / <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> x * x == num;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 69. x 的平方根</title>
    <link href="/2020/08/15/LeetCode-69-sqrtx/"/>
    <url>/2020/08/15/LeetCode-69-sqrtx/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></p><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><blockquote><p><code>sqrt(x) &lt;= x / 2</code><br />一个数的平方根 <code>&lt;=</code> 这个数的一半，所以右边界最大 <code>= x / 2</code></p></blockquote><ul><li>先写分支逻辑，再决定中间数是否上取整；</li><li>只要看到 <code>left = mid</code> ，它对应的取中位数的取法一定是 <code>mid = left + (right - left + 1) / 2;</code>。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">long</span> left = <span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> right = x / <span class="hljs-number">2</span>;    <span class="hljs-comment">// 排除元素，使用 &lt;，每次都使用 [left, right] 查找</span>    <span class="hljs-comment">// 查找元素，使用 &lt;=</span>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-comment">// +1 向上取整，避免死循环</span>        <span class="hljs-comment">// 不使用 (left + right) / 2 是为了避免 long 溢出</span>        <span class="hljs-keyword">long</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (mid * mid &gt; x) &#123;            <span class="hljs-comment">// [left, mid - 1]</span>            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// [mid, right]</span>            left = mid;        &#125;    &#125;    <span class="hljs-comment">// 退出循环时 left == right</span>    <span class="hljs-comment">// 还剩一个元素没有查找，</span>    <span class="hljs-comment">// 因为答案一定存在，即一定在搜索区间，剩下的元素就是问题答案</span>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)left;&#125;</code></pre><h1 id="牛顿迭代法"><a class="markdownIt-Anchor" href="#牛顿迭代法"></a> 牛顿迭代法</h1><p>要使用 <code>double</code> 类型，一开始使用 <code>float</code> 精度不够，有三个测试用例无法通过。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mspace linebreak="newline"></mspace><mo>=</mo><mo>&gt;</mo><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>x</mi><mo>=</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mspace linebreak="newline"></mspace><mi>x</mi><mo>=</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><mfrac><mrow><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup><mo>−</mo><mi>a</mi></mrow><mrow><mn>2</mn><msub><mi>x</mi><mi>n</mi></msub></mrow></mfrac><mspace linebreak="newline"></mspace><mi>x</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>+</mo><mfrac><mi>a</mi><msub><mi>x</mi><mi>n</mi></msub></mfrac><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">f(x) = x^2 - a \\=&gt; y = f(x_n) + f&#x27;(x_n)(x - x_n) \\x = x_n - \frac{f(x_n)}{f&#x27;(x_n)}\\x = x_n - \frac{x_n^2 - a}{2x_n}\\x = \frac{1}{2}(x_n + \frac{a}{x_n})\\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6778919999999999em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.327108em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.9435600000000002em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span></span></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">double</span> cur = <span class="hljs-number">1.0</span>;    <span class="hljs-keyword">double</span> pre = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (Math.abs(cur - pre) &gt; <span class="hljs-number">1e-6</span>) &#123;        pre = cur;        cur = (cur + x / cur) / <span class="hljs-number">2</span>;    &#125;    System.out.println(cur);    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)cur;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 45. 跳跃游戏 II</title>
    <link href="/2020/08/14/LeetCode-45-jump-game-ii/"/>
    <url>/2020/08/14/LeetCode-45-jump-game-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></p><p>本题在 <a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a> 基础上加了个最小次数，其实也是计算每个位置能跳到的最远距离，关键在于要保存上一次的最远边界，用来判断跳跃的次数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (pos &lt; nums.length - <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 本次能跳到的最远位置</span>            <span class="hljs-keyword">int</span> max = pos;            <span class="hljs-comment">// 每次都在 [begin, end] 区间里找到能跳到的最远位置</span>            <span class="hljs-comment">// 一个区间表示一次跳跃的所有可能起点，选取能跳到的最远位置</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin; i &lt;= end; i++) &#123;                max = Math.max(max, i + nums[i]);            &#125;            <span class="hljs-comment">// 更新下一次跳的区间</span>            begin = end + <span class="hljs-number">1</span>;            end = max;            <span class="hljs-comment">// 更新最远位置</span>            pos = max;            count++;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre><p>优化：计算从每个位置能跳到的最远距离。每次最远，最终最远，则跳跃次数最少。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">// 一次跳跃可到达的最远位置</span>        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-comment">// 若上一次已到达终点，则结束</span>            <span class="hljs-keyword">if</span> (end == nums.length - <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> count;            &#125;            <span class="hljs-comment">// 计算从第 i 个位置起跳的最远位置</span>            max = Math.max(max, i + nums[i]);            <span class="hljs-comment">// 一次跳跃到达终点，更新跳跃次数和下一次的跳跃边界</span>            <span class="hljs-keyword">if</span> (end == i) &#123;                count++;                end = max;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 55. 跳跃游戏</title>
    <link href="/2020/08/14/LeetCode-55-jump-game/"/>
    <url>/2020/08/14/LeetCode-55-jump-game/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></p><p>(🙃一开始还用的回溯。。。)<br />关键在于：若能跳到第 <code>i</code> 个位置，则在这之前的所有位置都能到达，所以只要计算从第 <code>i</code> 个位置起跳能跳到的最远位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> maxPos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-comment">// 若能跳到的最远位置 &lt; 当前位置</span>            <span class="hljs-comment">// 说明连当前位置都跳不到，也就跳不到终点了</span>            <span class="hljs-keyword">if</span> (maxPos &lt; i) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 能跳到第 i 个位置的情况下，</span>            <span class="hljs-comment">// 计算从第 i 个位置起跳，能跳到的最远位置</span>            <span class="hljs-comment">// 最远 = max(本次起跳，上次最远位置)</span>            maxPos = Math.max(i + nums[i], maxPos);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 锁</title>
    <link href="/2020/08/14/InnoDB-Lock/"/>
    <url>/2020/08/14/InnoDB-Lock/</url>
    
    <content type="html"><![CDATA[<h1 id="innodb-中的锁"><a class="markdownIt-Anchor" href="#innodb-中的锁"></a> <code>InnoDB</code> 中的锁</h1><h2 id="表级锁和行级锁"><a class="markdownIt-Anchor" href="#表级锁和行级锁"></a> 表级锁和行级锁</h2><table><thead><tr><th style="text-align:center">锁类型</th><th style="text-align:center">开销</th><th style="text-align:center">加锁速度</th><th style="text-align:center">死锁</th><th style="text-align:center">粒度</th><th style="text-align:center">锁冲突</th><th style="text-align:center">并发性</th></tr></thead><tbody><tr><td style="text-align:center">表级锁（<code>table lock</code>）</td><td style="text-align:center">小</td><td style="text-align:center">快</td><td style="text-align:center">无</td><td style="text-align:center">大</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">行级锁（<code>row lock</code>）</td><td style="text-align:center">大</td><td style="text-align:center">慢</td><td style="text-align:center">有</td><td style="text-align:center">小</td><td style="text-align:center">小</td><td style="text-align:center">高</td></tr></tbody></table><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，锁竞争的发生频率就越小，系统的并发程度就越高。但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此锁粒度越小，系统开销就越大。</p><p>不同的存储引擎支持的锁粒度是不一样的：</p><ul><li><code>InnoDB</code> 行锁和表锁都支持。</li><li><code>MyISAM</code> 只支持表锁。</li></ul><p>在 <code>InnoDB</code> 中，行锁是通过给索引上的索引项加锁来实现的。如果没有索引，<code>InnoDB</code> 将会通过隐藏的聚簇索引来对记录加锁。</p><h2 id="行级锁的类型"><a class="markdownIt-Anchor" href="#行级锁的类型"></a> 行级锁的类型</h2><p><code>InnoDB</code> 实现了如下两种标准的行级锁：</p><ol><li>共享锁（读锁、<code>S</code> 锁）：允许事务读一行数据。</li><li>排他锁(写锁、<code>X</code> 锁)：允许事务删除或更新一行数据。</li></ol><p><code>InnoDB</code> 支持在不同粒度上进行加锁操作，称为意向锁，即为<strong>表级别的锁</strong>，对程序员透明。若对细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。<br />两种意向锁：</p><ol><li>意向共享锁：事务想要获得一张表中某几行的共享锁。</li><li>意向排他锁：事务想要获得一张表中某几行的排他锁。</li></ol><h2 id="一致性非锁定读"><a class="markdownIt-Anchor" href="#一致性非锁定读"></a> 一致性非锁定读</h2><p>指的是 <code>InnoDB</code> 通过行多版本控制的方式来读取当前执行时间数据库中行的数据。<br />如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会等待行锁的释放，而是去读取行的一个快照数据。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200814141414.png" srcset="/img/loading.gif" alt="" /></p><p>默认配置下，事务的隔离级别为 <code>REPREATABLE READ</code>。</p><ul><li>在 <code>READ COMMITTED</code> 事务隔离级别下，非一致性读总是读取被锁定行的<strong>最新一份</strong>快照数据。</li><li>在 <code>REPREATABLE READ</code> 事务隔离级别下，非一致性读总是读取<strong>事务开始时</strong>的行数据版本。</li></ul><h2 id="一致性锁定读"><a class="markdownIt-Anchor" href="#一致性锁定读"></a> 一致性锁定读</h2><p><code>InnoDB</code> 对于 <code>SELECT</code> 语句支持两种一致性的锁定读操作：</p><ol><li><code>SELECT ··· FOR UPDATE</code>: 对读取的行加一个 <code>X</code> 锁，其他事务不能对已锁定的行加任何锁。</li><li><code>SELECT ··· LOCK IN SHARE MODE</code>: 对读取的行加一个 <code>S</code> 锁，其他事务可以向被锁定的行加 <code>S</code> 锁，如果加 <code>X</code> 锁，则会被阻塞。</li></ol><p>在使用上述两句 <code>SELECT</code> 语句时，务必加上 <code>BEGIN, START TRANSACTION</code> 或者 <code>SET AUTOCOMMIT = 0</code>，因为他们必须在一个事务中，当事务提交了，锁也就释放了。</p><h2 id="自增长与锁"><a class="markdownIt-Anchor" href="#自增长与锁"></a> 自增长与锁</h2><p>每个含有自增长值的表都有一个自增长计数器（<code>auto-increment counter</code>），当表进行插入操作时，这个计数器会被初始化，插入操作会根据这个自增长的计数器加 <code>1</code> 赋予自增长列。<br />这个实现方式称作 <code>AUTO-INC Locking</code>。这种锁其实是采用一种特殊的表锁机制，为了提高插入的性能，<strong>锁不是在一个事务完成后释放，而是在完成对自增长值插入的 <code>SQL</code> 语句后释放</strong>。</p><p>在 <code>InnoDB</code> 中，自增长值的列必须是索引，同时必须是索引的第一个列。如果不是第一个列，会抛出异常，而 <code>MyISAM</code> 没有这个问题。</p><h1 id="行锁的三种算法"><a class="markdownIt-Anchor" href="#行锁的三种算法"></a> 行锁的三种算法</h1><ul><li><code>Record Lock</code>: 单个行记录上的锁。</li><li><code>Gap Lock</code>: 间隙锁，锁定一个范围，但不包含记录本身。</li><li><code>Next-Key Lock</code>: <code>Gap Lock + Record Lock</code>，锁定一个范围，并且锁定记录本身。</li></ul><p>加锁规则：</p><p>在 <code>READ COMMITTED</code> 事务隔离级别下，采用 <code>Record Lock</code>。<br />在 <code>REPREATABLE READ</code> 事务隔离级别下，采用 <code>Next-Key Lock</code>。</p><ul><li><p>当查询的索引含有唯一属性时，<code>Next-Key Lock</code> 会降级为 <code>Record Lock</code>，即仅锁住索引本身，而不是范围。</p></li><li><p>而对于辅助索引，会加上 <code>Next-Key Lock</code>，还会对辅助索引的下一个键值加上 <code>Gap Lock</code>。</p></li></ul><h1 id="事务隔离级别与锁问题"><a class="markdownIt-Anchor" href="#事务隔离级别与锁问题"></a> 事务隔离级别与锁问题</h1><h2 id="隔离级别"><a class="markdownIt-Anchor" href="#隔离级别"></a> 隔离级别</h2><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">读未提交（<code>READ UNCOMMITTED</code>）</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">读已提交（<code>READ COMMITTED</code>）</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">可重复读（<code>REPREATABLE READ</code>）</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">❌ (<code>InnoDB</code> - ✔️)</td></tr><tr><td style="text-align:center">串行化（<code>SERIALIZABLE</code>）</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td></tr></tbody></table><h2 id="脏读"><a class="markdownIt-Anchor" href="#脏读"></a> 脏读</h2><blockquote><p>针对未提交数据</p></blockquote><p>脏读指的是在<strong>不同的事务</strong>下，当前事务可以读到另外事务<strong>未提交</strong>的数据。</p><p>脏读发生的条件是需要事务的隔离级别为 <code>READ UNCOMMITTED</code>，而目前绝大部分的数据库都至少设置成 <code>READ COMMITTED</code>。</p><h2 id="不可重复读"><a class="markdownIt-Anchor" href="#不可重复读"></a> 不可重复读</h2><blockquote><p>针对其他事务提交前后，读取<strong>数据本身</strong>的对比<br />重点在于同一条数据被修改了</p></blockquote><p>不可重复读是指在<strong>同一事务</strong>下，在两次读同一个数据之间，由于第二个事务的修改，导致两次读到的数据不一样。</p><p><code>InnoDB</code> 在 <code>REPREATABLE READ</code> 事务隔离级别下，采用 <code>Next-Key Lock</code> 解决不可重复读的问题。</p><h2 id="幻读"><a class="markdownIt-Anchor" href="#幻读"></a> 幻读</h2><blockquote><p>针对其他事务提交前后，读取<strong>数据条数</strong>的对比<br />重点在于表中数据的<strong>新增</strong>或者<strong>删除</strong></p></blockquote><p>幻读是指在<strong>同一事务</strong>下，<strong>连续执行两次同样的 <code>SQL</code> 语句可能导致不同的结果</strong>，第二次的 <code>SQL</code> 语句可能会返回之前不存在的行。</p><p><code>InnoDB</code> 在 <code>REPREATABLE READ</code> 事务隔离级别下，采用 <code>Next-Key Lock</code> 已经能避免幻读的产生。<br />而其他数据库，如 <code>ORACLE</code> 可能需要在 <code>SERIALIZABLE</code> 下才能解决幻读。</p><h2 id="版本链"><a class="markdownIt-Anchor" href="#版本链"></a> 版本链</h2><p>每次对某条聚簇索引记录进行改动时，都会生成一个版本，都会记录一条 <code>undo</code> 日志，每条 <code>undo</code> 日志也都有一个 <code>roll_pointer</code> 属性。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200814164939.png" srcset="/img/loading.gif" alt="" /></p><p>对该记录每次更新后，都会将旧值放到一条 <code>undo</code> 日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 <code>roll_pointer</code> 属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务 <code>id</code>。</p><h2 id="readview"><a class="markdownIt-Anchor" href="#readview"></a> <code>ReadView</code></h2><ul><li>对于使用 <code>READ UNCOMMITTED</code> 隔离级别的事务来说，直接读取记录的最新版本就好了。</li><li>对于使用 <code>SERIALIZABLE</code> 隔离级别的事务来说，使用加锁的方式来访问记录。</li><li>对于使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务来说，就需要用到版本链了，核心问题就是：<strong>需要判断一下版本链中的哪个版本是当前事务可见的</strong>。</li></ul><p><code>ReadView</code> 中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务 <code>id</code> 放到一个列表中。这样在访问某条记录时，就可判断记录的某个版本是否可见。</p><ul><li><p><code>READ COMMITTED</code>：每次读取数据前都生成一个 <code>ReadView</code>，每次都可判断事务是否提交。</p></li><li><p><code>REPEATABLE READ</code>：在第一次读取数据时生成一个 <code>ReadView</code>，每次访问时都读取最初的版本。</p></li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://juejin.im/post/6844903808376504327" target="_blank" rel="noopener">MySQL事务隔离级别和MVCC</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 874. 模拟行走机器人</title>
    <link href="/2020/08/13/LeetCode-874-walking-robot-simulation/"/>
    <url>/2020/08/13/LeetCode-874-walking-robot-simulation/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/walking-robot-simulation/" target="_blank" rel="noopener">874. 模拟行走机器人</a></p><p>一开始用的 <code>findObstacle()</code>，每走一步都要遍历 <code>obstacles</code>，效率很慢，官方题解采取<strong>将障碍编码</strong>的方式，这样只要 <code>O(1)</code> 就可以完成判断。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">robotSim</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] commands, <span class="hljs-keyword">int</span>[][] obstacles)</span> </span>&#123;        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[][] dirs = &#123;                <span class="hljs-comment">// 北：0</span>                &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,                <span class="hljs-comment">// 东：1</span>                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,                <span class="hljs-comment">// 南：2</span>                &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,                <span class="hljs-comment">// 西：3</span>                &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        &#125;;        <span class="hljs-keyword">int</span> dir = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 将障碍编码，加快判断效率</span>        Set&lt;Long&gt; obstacleSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] ob : obstacles) &#123;            <span class="hljs-keyword">long</span> ox = ob[<span class="hljs-number">0</span>] + <span class="hljs-number">30000</span>;            <span class="hljs-keyword">long</span> oy = ob[<span class="hljs-number">1</span>] + <span class="hljs-number">30000</span>;            obstacleSet.add((ox &lt;&lt; <span class="hljs-number">16</span>) + oy);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step : commands) &#123;            <span class="hljs-keyword">if</span> (step == -<span class="hljs-number">1</span>) &#123;                <span class="hljs-comment">// 右转</span>                dir = (dir + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (step == -<span class="hljs-number">2</span>) &#123;                <span class="hljs-comment">// 左转</span>                dir = (dir + <span class="hljs-number">3</span>) % <span class="hljs-number">4</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 向前走 step 步，直到遇上障碍物</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; step; i++) &#123;                    <span class="hljs-keyword">long</span> nx = x + dirs[dir][<span class="hljs-number">0</span>] + <span class="hljs-number">30000</span>;                    <span class="hljs-keyword">long</span> ny = y + dirs[dir][<span class="hljs-number">1</span>] + <span class="hljs-number">30000</span>;                    <span class="hljs-keyword">if</span> (!obstacleSet.contains((nx &lt;&lt; <span class="hljs-number">16</span>) + ny)) &#123;                        x = x + dirs[dir][<span class="hljs-number">0</span>];                        y = y + dirs[dir][<span class="hljs-number">1</span>];                        max = Math.max(max, x * x + y * y);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;<span class="hljs-comment">//////////////////////// obsolete ////////////////////////////////</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findObstacle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span>[][] obstacles)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] ob : obstacles) &#123;            <span class="hljs-keyword">if</span> (ob[<span class="hljs-number">0</span>] == x &amp;&amp; ob[<span class="hljs-number">1</span>] == y) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 455. 分发饼干</title>
    <link href="/2020/08/13/LeetCode-455-assign-cookies/"/>
    <url>/2020/08/13/LeetCode-455-assign-cookies/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></p><p>优先用小饼干满足胃口小的孩子</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] g, <span class="hljs-keyword">int</span>[] s)</span> </span>&#123;        Arrays.sort(g);        Arrays.sort(s);        <span class="hljs-keyword">int</span> child = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> cookie = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (child &lt; g.length &amp;&amp; cookie &lt; s.length) &#123;            <span class="hljs-comment">// 满足要求，换下一个小孩</span>            <span class="hljs-keyword">if</span> (s[cookie] &gt;= g[child]) &#123;                count++;                child++;            &#125;            <span class="hljs-comment">// 下一个饼干</span>            cookie++;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 122. 买卖股票的最佳时机 II</title>
    <link href="/2020/08/12/LeetCode-122-best-time-to-buy-and-sell-stock-ii/"/>
    <url>/2020/08/12/LeetCode-122-best-time-to-buy-and-sell-stock-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></p><h1 id="贪心"><a class="markdownIt-Anchor" href="#贪心"></a> 贪心</h1><blockquote><p>贪心的思想在于每一步作出的决策在现在看来总是最好的，它不关心过去或者未来的状态。</p></blockquote><p>只要今天的价格高于明天就计算收益：相当于在今天判断：是否买入昨天，卖出今天。这样每一天都有收益，最终的收益就是最大的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> profit = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;            <span class="hljs-keyword">int</span> cur = prices[i] - prices[i - <span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (cur &gt; <span class="hljs-number">0</span>)&#123;                profit += cur;            &#125;        &#125;        <span class="hljs-keyword">return</span> profit;    &#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><p><strong>1. 状态 <code>dp[i][j]</code></strong>:</p><p>第 <code>i</code> 天所能获得的最大利润，<code>j = 0</code>: 第 <code>i</code> 天持有现金，<code>j = 1</code>: 第 <code>i</code> 天持有股票。</p><p><strong>2. 状态转移方程：</strong></p><p>每一天可能持有股票或现金。</p><ul><li>若第 <code>i</code> 天持有股票 (<code>dp[i][0]</code>)：<ul><li>第 <code>i - 1</code> 天持有股票，则第 <code>i</code> 天无操作。</li><li>第 <code>i - 1</code> 天持有现金，则第 <code>i</code> 天买入新股票  (<code>+prices[i]</code>)。</li></ul></li><li>若第 <code>i</code> 天持有现金 (<code>dp[i][1]</code>)：<ul><li>第 <code>i - 1</code> 天持有股票，则第 <code>i</code> 天卖出 (<code>-prices[i]</code>)。</li><li>第 <code>i - 1</code> 天持有现金，则第 <code>i</code> 天无操作。</li></ul></li></ul><p><strong>3. 结束</strong></p><p>输出最后一天持有现金 (<code>dp[len - 1][0]</code>)，持有现金的情况下才会把之前的股票卖出，若最后一天持有股票，金额还会更少 <code>dp[len - 1][0] &gt; dp[len - 1][1]</code>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[prices.length][<span class="hljs-number">2</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;            <span class="hljs-comment">// 第 i 天持有现金</span>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);            <span class="hljs-comment">// 第 i 天持有股票</span>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">return</span> dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    &#125;</code></pre><p><strong>状态压缩</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-comment">// 今天持有现金</span>        <span class="hljs-keyword">int</span> cash = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 今天持有股票</span>        <span class="hljs-keyword">int</span> hold = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 昨天持有现金</span>        <span class="hljs-keyword">int</span> preCash = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 昨天持有股票</span>        <span class="hljs-keyword">int</span> preHold = -prices[<span class="hljs-number">0</span>];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> price : prices) &#123;            cash = Math.max(preCash, preHold + price);            hold = Math.max(preHold, preCash - price);                        preCash = cash;            preHold = hold;        &#125;        <span class="hljs-keyword">return</span> cash;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 860. 柠檬水找零</title>
    <link href="/2020/08/11/LeetCode-860-lemonade-change/"/>
    <url>/2020/08/11/LeetCode-860-lemonade-change/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lemonade-change/" target="_blank" rel="noopener">860. 柠檬水找零</a></p><blockquote><p>不带零钱你买什么柠檬水！！！</p></blockquote><p>虽然有点贪心的思想，我感觉这题在搞笑。。。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] bills)</span> </span>&#123;        <span class="hljs-keyword">if</span> (bills.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> money : bills) &#123;            <span class="hljs-keyword">switch</span> (money) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                    five++;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:                    five--;                    ten++;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>:                    <span class="hljs-keyword">if</span> (ten &gt; <span class="hljs-number">0</span>) &#123;                        five--;                        ten--;                    &#125; <span class="hljs-keyword">else</span> &#123;                        five -= <span class="hljs-number">3</span>;                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span> (five &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 529. 扫雷游戏</title>
    <link href="/2020/08/11/LeetCode-529-minesweeper/"/>
    <url>/2020/08/11/LeetCode-529-minesweeper/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">529. 扫雷游戏</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><blockquote><p>找周围的雷和进入下一层递归都是在 <strong>八个方向</strong> 游走。</p></blockquote><p>典型的 <code>DFS</code>。</p><p>若 <code>click</code> 位置为 <code>M</code>，标记返回，否则进入递归。</p><p>需要注意的是新的位置不能越界，且未被标记过。</p><ol><li>若周围有雷，遍历周围的八个位置，找到雷的数量，标记后返回</li><li>若周围没有雷，标记为 <code>B</code>，遍历周围八个位置，进入递归。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dirs = &#123;            <span class="hljs-comment">// 上：(x - 1, y)</span>            &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,            <span class="hljs-comment">// 下：(x + 1, y)</span>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,            <span class="hljs-comment">// 左：(x, y - 1)</span>            &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 右：(x, y + 1)</span>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 左上：(x - 1, y - 1)</span>            &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 右上，(x - 1, y + 1)</span>            &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 左下：(x + 1, y - 1)</span>            &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 右下：(x + 1, y + 1)</span>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;    &#125;;    <span class="hljs-keyword">boolean</span>[][] used;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[][] updateBoard(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span>[] click) &#123;        <span class="hljs-keyword">if</span> (notInArea(click[<span class="hljs-number">0</span>], click[<span class="hljs-number">1</span>], board)) &#123;            <span class="hljs-keyword">return</span> board;        &#125;        <span class="hljs-keyword">if</span> (board[click[<span class="hljs-number">0</span>]][click[<span class="hljs-number">1</span>]] == <span class="hljs-string">'M'</span>) &#123;            board[click[<span class="hljs-number">0</span>]][click[<span class="hljs-number">1</span>]] = <span class="hljs-string">'X'</span>;            <span class="hljs-keyword">return</span> board;        &#125; <span class="hljs-keyword">else</span> &#123;            used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[board.length][board[<span class="hljs-number">0</span>].length];            dfs(click[<span class="hljs-number">0</span>], click[<span class="hljs-number">1</span>], board);        &#125;        <span class="hljs-keyword">return</span> board;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        used[x][y] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> mineCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = x + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = y + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (notInArea(newX, newY, board)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (board[newX][newY] == <span class="hljs-string">'M'</span>) &#123;                mineCount++;            &#125;        &#125;        <span class="hljs-comment">// 找到地雷返回上一层</span>        <span class="hljs-keyword">if</span> (mineCount &gt; <span class="hljs-number">0</span>) &#123;            board[x][y] = (<span class="hljs-keyword">char</span>) (mineCount + <span class="hljs-string">'0'</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 未找到雷，进行标记，进入下一个位置</span>        board[x][y] = <span class="hljs-string">'B'</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = x + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = y + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (notInArea(newX, newY, board) || used[newX][newY]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            dfs(newX, newY, board);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">notInArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> || x &gt;= board.length                || y &lt; <span class="hljs-number">0</span> || y &gt;= board[<span class="hljs-number">0</span>].length;    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dirs = &#123;        <span class="hljs-comment">// 上：(x - 1, y)</span>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 下：(x + 1, y)</span>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 左：(x, y - 1)</span>        &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 右：(x, y + 1)</span>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 左上：(x - 1, y - 1)</span>        &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 右上，(x - 1, y + 1)</span>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 左下：(x + 1, y - 1)</span>        &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 右下：(x + 1, y + 1)</span>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-keyword">boolean</span>[][] used;<span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[][] updateBoard(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span>[] click) &#123;    <span class="hljs-keyword">if</span> (notInArea(click[<span class="hljs-number">0</span>], click[<span class="hljs-number">1</span>], board)) &#123;        <span class="hljs-keyword">return</span> board;    &#125;    <span class="hljs-keyword">if</span> (board[click[<span class="hljs-number">0</span>]][click[<span class="hljs-number">1</span>]] == <span class="hljs-string">'M'</span>) &#123;        board[click[<span class="hljs-number">0</span>]][click[<span class="hljs-number">1</span>]] = <span class="hljs-string">'X'</span>;        <span class="hljs-keyword">return</span> board;    &#125;    used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[board.length][board[<span class="hljs-number">0</span>].length];    Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(click);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-keyword">int</span>[] cur = queue.poll();        used[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> mineCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = cur[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = cur[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (notInArea(newX, newY, board)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (board[newX][newY] == <span class="hljs-string">'M'</span>) &#123;                mineCount++;            &#125;        &#125;        <span class="hljs-keyword">if</span> (mineCount &gt; <span class="hljs-number">0</span>) &#123;            board[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] = (<span class="hljs-keyword">char</span>) (mineCount + <span class="hljs-string">'0'</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            board[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] = <span class="hljs-string">'B'</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                <span class="hljs-keyword">int</span> newX = cur[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];                <span class="hljs-keyword">int</span> newY = cur[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span> (notInArea(newX, newY, board) || used[newX][newY]) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;newX, newY&#125;);                <span class="hljs-comment">// 避免超时</span>                used[newX][newY] = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> board;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">notInArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> || x &gt;= board.length            || y &lt; <span class="hljs-number">0</span> || y &gt;= board[<span class="hljs-number">0</span>].length;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 200. 岛屿数量</title>
    <link href="/2020/08/10/LeetCode-200-number-of-islands/"/>
    <url>/2020/08/10/LeetCode-200-number-of-islands/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 已被访问的数组</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">boolean</span>[][] visited;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 移动方向</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] dir = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;            <span class="hljs-comment">// 上: (x - 1, y)</span>            &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,            <span class="hljs-comment">// 右: (x, y + 1)</span>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 下: (x + 1, y)</span>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,            <span class="hljs-comment">// 左: (x, y - 1)</span>            &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;    &#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;        rows = grid.length;        <span class="hljs-keyword">if</span> (rows &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        cols = grid[<span class="hljs-number">0</span>].length;        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-comment">// 当前位置未访问过 &amp;&amp; 是陆地</span>                <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-string">'1'</span>) &#123;                    <span class="hljs-comment">// 只要未访问过且为 1 肯定存在一个岛屿</span>                    <span class="hljs-comment">// 需要做的就是找到这个岛屿连通的所有位置</span>                    count++;                    dfs(grid, i, j);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        visited[x][y] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dir.length; i++) &#123;            <span class="hljs-keyword">int</span> nextX = x + dir[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> nextY = y + dir[i][<span class="hljs-number">1</span>];            <span class="hljs-comment">// 新位置 未越界 &amp;&amp; 未访问过 &amp;&amp; 是陆地</span>            <span class="hljs-keyword">if</span> (inArea(nextX, nextY) &amp;&amp; !visited[nextX][nextY] &amp;&amp; grid[nextX][nextY] == <span class="hljs-string">'1'</span>) &#123;                dfs(grid, nextX, nextY);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span> rows;<span class="hljs-keyword">int</span> cols;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 已被访问的数组</span><span class="hljs-comment"> */</span><span class="hljs-keyword">boolean</span>[][] visited;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 移动方向</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span>[][] dir = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;        <span class="hljs-comment">// 上: (x - 1, y)</span>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 右: (x, y + 1)</span>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 下: (x + 1, y)</span>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 左: (x, y - 1)</span>        &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">int</span> y;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;    rows = grid.length;    <span class="hljs-keyword">if</span> (rows &lt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    cols = grid[<span class="hljs-number">0</span>].length;    visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-comment">// 当前位置未访问过 &amp;&amp; 是陆地</span>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-string">'1'</span>) &#123;                <span class="hljs-comment">// 只要未访问过且为 1 肯定存在一个岛屿</span>                <span class="hljs-comment">// 需要做的就是找到这个岛屿连通的所有位置</span>                count++;                Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();                visited[i][j] = <span class="hljs-keyword">true</span>;                queue.offer(<span class="hljs-keyword">new</span> Node(i, j));                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;                    Node cur = queue.poll();                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; dir.length; k++) &#123;                        <span class="hljs-keyword">int</span> nextX = cur.x + dir[k][<span class="hljs-number">0</span>];                        <span class="hljs-keyword">int</span> nextY = cur.y + dir[k][<span class="hljs-number">1</span>];                        <span class="hljs-comment">// 新位置 未越界 &amp;&amp; 未访问过 &amp;&amp; 是陆地</span>                        <span class="hljs-keyword">if</span> (inArea(nextX, nextY) &amp;&amp; !visited[nextX][nextY] &amp;&amp; grid[nextX][nextY] == <span class="hljs-string">'1'</span>) &#123;                            queue.offer(<span class="hljs-keyword">new</span> Node(nextX, nextY));                            <span class="hljs-comment">// 及时标记，避免超时</span>                            visited[nextX][nextY] = <span class="hljs-keyword">true</span>;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;&#125;</code></pre><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><p>把所有的水连接到水域结点，若是陆地尝试与周围结点链接。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;        rows = grid.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        cols = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> len = rows * cols;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(len + <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-comment">// 如果是 水，连接到 dummy 结点</span>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">'0'</span>) &#123;                    uf.union(len, getIndex(i, j));                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 如果是 陆地，尝试连接到周围的陆地</span>                    <span class="hljs-comment">// 这里 dirs 只要 右和下两个方向就能遍历到周围的结点</span>                    <span class="hljs-comment">// 因为在上一次遍历时已经访问过左和上方的结点</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                        <span class="hljs-keyword">int</span> newX = i + dir[<span class="hljs-number">0</span>];                        <span class="hljs-keyword">int</span> newY = j + dir[<span class="hljs-number">1</span>];                        <span class="hljs-keyword">if</span> (inArea(newX, newY) &amp;&amp; grid[newX][newY] == <span class="hljs-string">'1'</span>) &#123;                            uf.union(getIndex(i, j), getIndex(newX, newY));                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 减去水域的结点才是所有的陆地结点</span>        <span class="hljs-keyword">return</span> uf.getCount() - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">return</span> i * cols + j;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &lt; rows &amp;&amp; y &lt; cols;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 126. 单词接龙 II</title>
    <link href="/2020/08/09/LeetCode-126-word-ladder-ii/"/>
    <url>/2020/08/09/LeetCode-126-word-ladder-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. 单词接龙 II</a></p><ul><li>找的是最短路径，且可能有多个</li><li>一开始用的 <code>List</code> 存放每层元素，结果 回溯的时候难以访问下一层，最好用 <code>Map</code> 存放</li><li>！！最短路径要及时剪枝</li><li>！！不能用 <code>used</code> 数组标记访问过的元素，而是标记当前层和以上层已经访问过的数组，因为若存在多个最短路径，元素可能重复使用，<code>used</code> 数组标记后会把下层的元素也标记，会导致漏解。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (!wordList.contains(endWord)) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-comment">// boolean[] used = new boolean[wordList.size()];</span>        Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(beginWord);        <span class="hljs-comment">// int start = wordList.indexOf(beginWord);</span>        <span class="hljs-comment">// if (start != -1) &#123;</span>        <span class="hljs-comment">//     used[start] = true;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// key: 当前层每一个单词 value: 每个单词对应的下一层所有单词</span>        Map&lt;String, HashSet&lt;String&gt;&gt; successors = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        Set&lt;String&gt; level = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                String word = queue.poll();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordList.size(); i++) &#123;                    String candidate = wordList.get(i);                    <span class="hljs-comment">// 下一层 candidate 未被使用 &amp;&amp; 可以接龙</span>                    <span class="hljs-keyword">if</span> (!visited.contains(candidate) &amp;&amp; canLadder(word, candidate)) &#123;                        <span class="hljs-comment">// System.out.println(word + " -&gt; " + candidate);</span>                        <span class="hljs-keyword">if</span> (endWord.equals(candidate)) &#123;                            found = <span class="hljs-keyword">true</span>;                        &#125;                        <span class="hljs-keyword">if</span> (!level.contains(candidate))&#123;                            <span class="hljs-comment">// used[i] = true;</span>                            queue.offer(candidate);                            level.add(candidate);                        &#125;                        successors.computeIfAbsent(word, e -&gt; <span class="hljs-keyword">new</span> HashSet&lt;&gt;());                        successors.get(word).add(candidate);                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 若 found 为 true，说明已找到 end 的路径</span>            <span class="hljs-comment">// 可保证为最短路径</span>            <span class="hljs-comment">// ! 第一次提交没 AC 的原因：忘了找最短路径，把所有路径都找出来了</span>            <span class="hljs-keyword">if</span> (found) &#123;                <span class="hljs-keyword">break</span>;            &#125;            System.out.println(level.toString());            visited.addAll(level);            level.clear();        &#125;        System.out.println(successors.toString());        <span class="hljs-comment">// 未找到，返回空集</span>        <span class="hljs-keyword">if</span> (!found) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        path.add(beginWord);        dfs(beginWord, endWord, path, successors, res);        System.out.println(res);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; path, Map&lt;String, HashSet&lt;String&gt;&gt; successors, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;        <span class="hljs-keyword">if</span> (endWord.equals(beginWord)) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// ！及时剪枝，否则 NPE</span>        <span class="hljs-keyword">if</span> (!successors.containsKey(beginWord)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 选择队列：是当前 单词 的下一层，</span>        <span class="hljs-comment">// 所以如果用 List 来保存每一层的话，获取下一层就会比较麻烦</span>        HashSet&lt;String&gt; successor = successors.get(beginWord);        <span class="hljs-keyword">for</span> (String word : successor) &#123;            <span class="hljs-keyword">if</span> (path.contains(word)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            path.add(word);            dfs(word, endWord, path, successors, res);            path.remove(word);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canLadder</span><span class="hljs-params">(String word, String candidate)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">if</span> (word.charAt(i) != candidate.charAt(i)) &#123;                <span class="hljs-keyword">if</span> (++count &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 127. 单词接龙</title>
    <link href="/2020/08/08/LeetCode-127-word-ladder/"/>
    <url>/2020/08/08/LeetCode-127-word-ladder/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. 单词接龙</a></p><p>和 433.最小基因那题很像，不过本题变异的字母是不确定的，不再是 <code>ACGT</code>，若用回溯会超时。</p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;        <span class="hljs-comment">// ! endWord 不在 wordList 中直接返回</span>        <span class="hljs-keyword">if</span> (!wordList.contains(endWord)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[wordList.size()];        LinkedList&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-comment">// 将 beginWord 加入队列，标记访问数组</span>        queue.offer(beginWord);        <span class="hljs-keyword">int</span> start = wordList.indexOf(beginWord);        <span class="hljs-keyword">if</span> (start != -<span class="hljs-number">1</span>) &#123;            used[start] = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            step++;            <span class="hljs-comment">// 此时队列中的所有元素相当于上一个 word 可向下接龙的所有选择</span>            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                String word = queue.poll();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordList.size(); i++) &#123;                    String candidate = wordList.get(i);                    <span class="hljs-comment">// 若已经访问过 || word 无法接龙到 candidate，则跳过 </span>                    <span class="hljs-keyword">if</span> (used[i] || !canLadder(word, candidate)) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-comment">// candidate 到达 end，返回</span>                    <span class="hljs-keyword">if</span> (endWord.equals(candidate)) &#123;                        <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// 标记访问数组，将 candidate 加入队列</span>                        used[i] = <span class="hljs-keyword">true</span>;                        queue.offer(candidate);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// ！！！返回 0，不是 step</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canLadder</span><span class="hljs-params">(String word, String candidate)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate.length(); i++) &#123;            <span class="hljs-keyword">if</span> (word.charAt(i) != candidate.charAt(i)) &#123;                <span class="hljs-keyword">if</span> (++count &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><h1 id="双向-bfs"><a class="markdownIt-Anchor" href="#双向-bfs"></a> 双向 BFS</h1><p>采用左右两个扩散集合，当集合重复即表示扩散结束。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;        <span class="hljs-comment">// 不用 set 竟然超时了！</span>        Set&lt;String&gt; wordSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordList);        <span class="hljs-keyword">if</span> (!wordSet.contains(endWord)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// 标记已访问过的元素</span>        Set&lt;String&gt; used = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-comment">// 左边扩散集合，每次都假设该集合元素最少，则扩散速度更快</span>        Set&lt;String&gt; beginSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        beginSet.add(beginWord);        <span class="hljs-comment">// 右边扩散集合</span>        Set&lt;String&gt; endSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        endSet.add(endWord);        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!beginSet.isEmpty() &amp;&amp; !endSet.isEmpty()) &#123;            step++;            <span class="hljs-comment">// 使 beginSet 的元素最少</span>            <span class="hljs-keyword">if</span> (beginSet.size() &gt; endSet.size()) &#123;                Set&lt;String&gt; tmp = beginSet;                beginSet = endSet;                endSet = tmp;            &#125;            <span class="hljs-comment">// 下一层扩散的集合</span>            Set&lt;String&gt; nextLevel = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();            <span class="hljs-keyword">for</span> (String word : beginSet) &#123;                <span class="hljs-keyword">char</span>[] words = word.toCharArray();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;                    <span class="hljs-keyword">char</span> old = words[i];                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c = <span class="hljs-string">'a'</span>; c &lt;= <span class="hljs-string">'z'</span>; c++) &#123;                        <span class="hljs-keyword">if</span> (old == c) &#123;                            <span class="hljs-keyword">continue</span>;                        &#125;                        words[i] = c;                        String nextWord = String.valueOf(words);                        <span class="hljs-comment">// 新元素必须存在于提供的 list 中</span>                        <span class="hljs-keyword">if</span> (wordSet.contains(nextWord)) &#123;                            <span class="hljs-comment">// 右边集合包含该元素，说明扩散重复，直接返回</span>                            <span class="hljs-keyword">if</span> (endSet.contains(nextWord)) &#123;                                <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span>;                            &#125;                            <span class="hljs-comment">// 加入下一层扩散集合</span>                            <span class="hljs-keyword">if</span> (!used.contains(nextWord)) &#123;                                nextLevel.add(nextWord);                                <span class="hljs-comment">// 标记已访问</span>                                used.add(nextWord);                            &#125;                        &#125;                    &#125;                    words[i] = old;                &#125;            &#125;            <span class="hljs-comment">// 设置下一层的扩散集合</span>            beginSet = nextLevel;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 515. 在每个树行中找最大值</title>
    <link href="/2020/08/07/LeetCode-515-find-largest-value-in-each-tree-row/"/>
    <url>/2020/08/07/LeetCode-515-find-largest-value-in-each-tree-row/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">515. 在每个树行中找最大值</a></p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><p>层次遍历</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(root);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                TreeNode p = queue.poll();                max = Math.max(p.val, max);                <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) &#123;                    queue.offer(p.left);                &#125;                <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) &#123;                    queue.offer(p.right);                &#125;            &#125;            res.add(max);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><p>判断是否到了新的一层：<code>res</code> 中保存的是每一层的最大值，所以 <code>res.size()</code> 等于遍历过的层数，若 <code>res.size() &lt; level</code> 表示到了新层。</p><pre><code class="hljs java">List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;            dfs(root, <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> level)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 遍历到了下一层，添加新元素</span>        <span class="hljs-keyword">if</span> (res.size() &lt; level) &#123;            res.add(root.val);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 计算当前层的最大值</span>            <span class="hljs-keyword">int</span> levelMax = Math.max(root.val, res.get(level - <span class="hljs-number">1</span>));            res.set(level - <span class="hljs-number">1</span>, levelMax);        &#125;        dfs(root.left, level + <span class="hljs-number">1</span>);        dfs(root.right, level + <span class="hljs-number">1</span>);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 22. 括号生成</title>
    <link href="/2020/08/07/LeetCode-22-generate-parentheses/"/>
    <url>/2020/08/07/LeetCode-22-generate-parentheses/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/generate-parentheses/submissions/" target="_blank" rel="noopener">22. 括号生成</a></p><h1 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h1><pre><code class="hljs java">List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        backtrack(n, n, <span class="hljs-string">""</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 路径：生成的括号字符串</span><span class="hljs-comment">     * 选择列表：路径中可放置的左右括号数量</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> left  左括号剩余数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> right 右括号剩余数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path  路径</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, String path)</span> </span>&#123;        <span class="hljs-comment">// 左括号剩余 &gt; 右括号剩余：剪枝</span>        <span class="hljs-comment">// e.g. )</span>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;            res.add(path);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 左边可放置左括号</span>        <span class="hljs-comment">// e.g. ()</span>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;            backtrack(left - <span class="hljs-number">1</span>, right, path + <span class="hljs-string">"("</span>);        &#125;        <span class="hljs-comment">// 左括号剩余 &lt; 右括号剩余：右边可放置右括号</span>        <span class="hljs-comment">// e.g. ((, (</span>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;            backtrack(left, right - <span class="hljs-number">1</span>, path + <span class="hljs-string">")"</span>);        &#125;    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    String path;    <span class="hljs-keyword">int</span> left;    <span class="hljs-keyword">int</span> right;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path  当前结点产生的路径</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> left  左边剩余括号</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> right 右边剩余括号</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String path, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">this</span>.path = path;        <span class="hljs-keyword">this</span>.left = left;        <span class="hljs-keyword">this</span>.right = right;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(<span class="hljs-keyword">new</span> Node(<span class="hljs-string">""</span>, n, n));        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            Node q = queue.poll();            <span class="hljs-comment">// 左右括号均已用完</span>            <span class="hljs-keyword">if</span> (q.left == <span class="hljs-number">0</span> &amp;&amp; q.right == <span class="hljs-number">0</span>) &#123;                res.add(q.path);            &#125;            <span class="hljs-comment">// 左括号剩余</span>            <span class="hljs-keyword">if</span> (q.left &gt; <span class="hljs-number">0</span>) &#123;                queue.offer(<span class="hljs-keyword">new</span> Node(q.path + <span class="hljs-string">"("</span>, q.left - <span class="hljs-number">1</span>, q.right));            &#125;            <span class="hljs-comment">// 右括号剩余</span>            <span class="hljs-keyword">if</span> (q.right &gt; <span class="hljs-number">0</span> &amp;&amp; q.right &gt; q.left) &#123;                queue.offer(<span class="hljs-keyword">new</span> Node(q.path + <span class="hljs-string">")"</span>, q.left, q.right - <span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 索引</title>
    <link href="/2020/08/07/InnoDB-index/"/>
    <url>/2020/08/07/InnoDB-index/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><h2 id="b-树"><a class="markdownIt-Anchor" href="#b-树"></a> <code>B+</code> 树</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200807153046.png" srcset="/img/loading.gif" alt="" /></p><blockquote><p>🙃又是考研内容。</p></blockquote><p>一棵 <code>m</code> 阶 <code>B+</code> 树需满足下列条件：</p><ul><li>每个分支结点最多有 <code>m</code> 棵子树（子结点）。</li><li>非叶根结点至少有两棵子树，其他每个分支结点至少有 <code>⌈m / 2⌉</code> 棵子树。</li><li><strong>结点的子树个数与关键字个数相等</strong>。</li><li>所有叶子结点包含<strong>全部关键字</strong>及指向相应记录的<strong>指针</strong>，叶子结点中关键字按大小排序，相邻叶结点按大小顺序<strong>相互链接</strong>起来。</li><li>所有分支结点中仅包含它的各个子结点中<strong>关键字的最大值</strong>及指向其子结点的<strong>指针</strong>。</li></ul><p><code>m</code> 阶 <code>B+</code> 树与 <code>m</code> 阶 <code>B</code> 树的区别：</p><ol><li><strong>子树和结点的关系：</strong><br /><code>B+</code> 树 <code>n</code> 个关键字的结点只含有 <code>n</code> 棵子树，<strong>即每个关键字对应一棵子树</strong>；<br /><code>B</code> 树 <code>n</code> 个关键字的结点含有 <code>n + 1</code> 棵子树。</li><li><strong>结点关键字个数</strong><br /><code>B+</code> 树非根结点关键字个数：<code>⌈m / 2⌉ &lt;= n &lt;= m</code>，根结点：<code>1 &lt;= n &lt;= m</code>；<br /><code>B</code> 树非根结点关键字个数：<code>⌈m / 2⌉ - 1 &lt;= n &lt;= m - 1</code>，根结点：<code>1 &lt;= n &lt;= m - 1</code></li><li><strong>叶子结点和非叶结点</strong><br /><code>B+</code> 树叶结点包含信息，所有<strong>非叶结点仅起到索引作用</strong>，非叶结点中的每个索引项值含有子树最大关键字和指向子树的指针，<strong>不含该关键字的存储地址</strong>。</li><li><strong>关键字重复性</strong><br /><code>B+</code> 树中叶结点包含全部关键字，<strong>即关键字会和非叶结点重复</strong>；<br /><code>B</code> 树中叶结点包含的关键字和其他结点包含的关键字是<strong>不重复</strong>的。</li><li><strong>查找过程</strong><br /><code>B+</code> 树查找过程中，如果非叶结点上的关键字等于给定值时并不终止，而是继续向下查找直到叶结点为止。每次查找都是一条从根节点到叶结点的路径。</li></ol><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><p><code>B+</code> 树索引按照顺序存储，可以用来做 <code>ORDER BY</code> 和 <code>GROUP</code> 操作。<br />因为索引中存储了实际的列值，覆盖索引只需要适用索引就能完成查询。</p><ul><li>索引大大减少了服务器需要扫描的数据量。</li><li>索引可以帮助服务器避免排序和临时表。</li><li>索引可以将随机 <code>IO</code> 变为顺序 <code>IO</code>。</li></ul><h2 id="不使用索引的情况"><a class="markdownIt-Anchor" href="#不使用索引的情况"></a> 不使用索引的情况</h2><p>在范围查找、<code>JOIN</code> 链接操作等情况下，优化器直接进行全表的扫描来得到数据。<br />当用户要选取的数据是整行信息，而索引不能覆盖到要查询的信息，在通过索引查到指定数据后，还要一次书签访问来查找整行的信息。</p><p>可使用关键字 <code>FORCE INDEX</code> 来强制使用某个索引。</p><ul><li>表记录太少</li><li>经常增删改的表</li><li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li><li><strong>频繁更新</strong>的字段不适合创建索引（会加重 <code>IO</code> 负担）</li><li><code>where</code> 条件里用不到的字段不创建索引</li></ul><h2 id="需要创建索引的情况"><a class="markdownIt-Anchor" href="#需要创建索引的情况"></a> 需要创建索引的情况</h2><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li><li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li><li>查询中统计或分组字段</li></ul><h1 id="索引类型"><a class="markdownIt-Anchor" href="#索引类型"></a> 索引类型</h1><blockquote><p><code>InnoDB</code> 的索引是自适应哈希索引，使用 <code>B+</code> 树索引。<br /><code>B+</code> 树索引并不能找到一个给定键值的具体行，它只能找到被查找数据行所在的页，然后通过把页读入内存，在内存中查找想要的数据。</p></blockquote><h2 id="1-b-树索引"><a class="markdownIt-Anchor" href="#1-b-树索引"></a> 1. <code>B+</code> 树索引</h2><p><code>B+</code> 树索引能够加快访问数据的速度，因为存储引擎<strong>不再需要进行全表扫描</strong>来获取数据，而是从索引的根节点开始进行搜索。</p><ul><li>根节点存放了<strong>指向子节点的指针</strong>，存储引擎根据这些指针向下层查找，通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点。</li><li>叶子节点指向的是<strong>被索引的数据</strong>，而不是其他的节点页。</li></ul><p>索引列是按<strong>顺序组织</strong>存储的，所以很适合查找范围数据，多个值进行排序的依据是 <code>CREATE TABLE</code> 语句中定义索引时列的顺序。</p><h3 id="限制"><a class="markdownIt-Anchor" href="#限制"></a> 限制</h3><ul><li><strong>如果不是按照索引的最左列开始查找，则无法使用索引</strong>。如 <code>key(last_name,first_name, dob)</code> 无法用于查找特定的 <code>first_name</code> 和 <code>dob</code>。</li><li><strong>不能跳过索引中的列</strong>。如不能查找 <code>last_name</code> 和 <code>dob</code> 为特定值的记录。如果不指定 <code>first_name</code>，则只能使用索引的第一列。</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li></ul><h3 id="聚集索引"><a class="markdownIt-Anchor" href="#聚集索引"></a> 聚集索引</h3><p>聚集索引按照每张表的主键构造一棵 <code>B+</code> 树，叶子结点中存放的为整张表的行记录数据，叶子结点也称为数据页。<strong>一张表只能有一个聚集索引。</strong> 它对于主键的排序查找和范围查找非常快。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200811143800.png" srcset="/img/loading.gif" alt="" /><br />聚集索引的存储并不是物理上连续的（维护成本高），而是<strong>逻辑上连续</strong>的。</p><ul><li>页通过双向链表链接，页按照主键的顺序排序。<br />如果没有定义主键，<code>InnoDB</code> 会选择一个唯一的非空索引代替。<br />如果没有这样的主键，<code>InnoDB</code> 会隐式定义一个主键来作为聚集索引。</li><li>页中的记录通过双向链表链接，物理存储上也可以不按照主键存储。</li></ul><p>优点：</p><ul><li>可以把相关数据保存在一起，减少磁盘 <code>IO</code>。</li><li>数据访问更快。索引和数据都在同一个 <code>B+</code> 树中。</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li></ul><p>缺点：</p><ul><li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 <code>InnoDB</code> 表中速度最快的方式。</li><li>更新聚集索引列的代价很高，因为会强制 <code>InnoDB</code> 将每个被更新的行移动到新的位置。</li><li>可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li><li>二级索引（非聚集索引）可能很大，因为二级索引的叶子结点包含了引用行的主键列。</li><li>二级索引需要两次索引查找，而不是一次。</li></ul><h3 id="辅助索引非聚集索引"><a class="markdownIt-Anchor" href="#辅助索引非聚集索引"></a> 辅助索引（非聚集索引）</h3><p>辅助索引中，叶子结点并不包含行记录的全部数据。叶子结点除了包含键值以外，每个叶子结点中的索引行还包含了一个书签，该书签用来告诉 <code>InnoDB</code> 哪里可以找到与索引相对应的行数据。</p><p>辅助索引的存在并不影响数据在聚集索引中的组织，因此<strong>一张表可以有多个辅助索引。</strong></p><h3 id="覆盖索引"><a class="markdownIt-Anchor" href="#覆盖索引"></a> 覆盖索引</h3><blockquote><p>查询只要访问索引，而无须访问数据行。</p></blockquote><p>覆盖索引从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量 <code>IO</code>。</p><p>不是所有类型的索引都可以成为覆盖索引。<strong>覆盖索引必须要存储索引列的值</strong>，而哈希索引和全文索引等都不存储索引列的值，所以 <code>MySQL</code> 只能使用 <code>B+</code> 树索引做覆盖索引。</p><h3 id="联合索引"><a class="markdownIt-Anchor" href="#联合索引"></a> 联合索引</h3><p>联合索引是指对表上的多个列进行索引。其键值的数量不是 <code>1</code>，而是大于等于 <code>2</code>。</p><h2 id="2-哈希索引"><a class="markdownIt-Anchor" href="#2-哈希索引"></a> 2. 哈希索引</h2><blockquote><p>在 <code>MySQL</code> 中，只有 <code>Memory</code> 引擎显式支持哈希索引，它还支持非唯一哈希索引，如果多个列的哈希值相同，使用链表存放记录指针。</p></blockquote><p>哈希索引（<code>hash index</code>）基于哈希表实现，只有<strong>精确匹配</strong>索引所有列的查询才有效。</p><p>对于每一行数据，存储引擎会对<strong>所有的索引列</strong>计算一个哈希码（<code>hash code</code>），哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p><h3 id="限制-2"><a class="markdownIt-Anchor" href="#限制-2"></a> 限制</h3><ul><li>只包含<strong>哈希值</strong>和<strong>指针</strong>，不存储字段值，所以不能使用索引中的值来避免读取行。</li><li><strong>不支持顺序和范围查询</strong>。</li><li>哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序。</li><li>不支持部分索引列匹配查找，因为哈希索引始终使用索引列的全部内容来计算哈希值。</li><li>出现哈希冲突，必须遍历链表中所有指针。</li><li>如果哈希冲突很多，索引维护操作的代价很高。</li></ul><h3 id="自适应哈希索引"><a class="markdownIt-Anchor" href="#自适应哈希索引"></a> 自适应哈希索引</h3><p>当 <code>InnoDB</code> 注意到某些索引值被使用得很频繁时，它会自动在内存中基于 <code>B+</code> 树索引之上再创建一个哈希索引，这样就让 <code>B+</code> 树索引也具有哈希索引的一些优点，如快速哈希查找。</p><h2 id="3-全文索引"><a class="markdownIt-Anchor" href="#3-全文索引"></a> 3. 全文索引</h2><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文索引类似于搜索引擎，适用于 <code>MATCH AGAINST</code> 而不是简单的 <code>WHERE</code> 条件匹配。</p><h1 id="高性能的索引策略"><a class="markdownIt-Anchor" href="#高性能的索引策略"></a> 高性能的索引策略</h1><h2 id="独立的列"><a class="markdownIt-Anchor" href="#独立的列"></a> 独立的列</h2><blockquote><p>如果查询的列不是独立的，<code>MySQL</code> 就不会使用索引。</p></blockquote><p>独立的列：索引列不能是表达式的一部分，也不能是函数的参数。</p><h2 id="前缀索引和索引选择性"><a class="markdownIt-Anchor" href="#前缀索引和索引选择性"></a> 前缀索引和索引选择性</h2><blockquote><p>索引选择性 = 不重复的索引值 / 记录总数( <code>#T</code>)，范围从 <code>1 / #T</code> 到 <code>1</code> 之间，选择性越高则查询效率越高，因为选择性高的索引可以在查找时过滤更多的行。</p></blockquote><p>选择某个列选择性高的前缀进行查询。但前缀索引无法进行 <code>ORDER BY</code> 和 <code>GROUP</code> 操作。</p><h2 id="选择合适的索引列"><a class="markdownIt-Anchor" href="#选择合适的索引列"></a> 选择合适的索引列</h2><p>经验法则：将选择性高的索引刚到索引最前列。（并不适用所有情况，也要考虑 <code>WHERE</code> 子句中的排序，分组和范围条件等其他因素）</p><h2 id="聚集索引和覆盖索引"><a class="markdownIt-Anchor" href="#聚集索引和覆盖索引"></a> 聚集索引和覆盖索引</h2><h2 id="使用索引扫描来做排序"><a class="markdownIt-Anchor" href="#使用索引扫描来做排序"></a> 使用索引扫描来做排序</h2><p><code>MySQL</code> 可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务。<br />只有当索引的列顺序和 <code>ORDER BY</code> 子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，<code>MySQL</code> 才能使用索引来对结果做排序。</p><h2 id="冗余和重复索引"><a class="markdownIt-Anchor" href="#冗余和重复索引"></a> 冗余和重复索引</h2><ul><li>重复索引是指在相同的列上按照相同的顺序创建相同类型的索引。应该避免创建重复索引。</li><li>如果创建了索引 <code>(A, B)</code>，再创建索引 <code>(A)</code> 就是冗余索引，因为这只是前一个索引的前缀索引。<br />但是如果创建 <code>(B, A), (B)</code>，则不是冗余索引，因为它们不是 <code>(A, B)</code> 的最左前缀列。<br />其他不同类型的索引（哈希索引、全文索引）也不是 <code>B+</code> 树索引的冗余索引，无论它们覆盖的索引列是什么。</li></ul><h2 id="未使用的索引列"><a class="markdownIt-Anchor" href="#未使用的索引列"></a> 未使用的索引列</h2><p>建议删除未使用的索引列。</p><h2 id="索引和锁"><a class="markdownIt-Anchor" href="#索引和锁"></a> 索引和锁</h2><ul><li><strong>索引可以让查询锁定更少的行</strong>。如果查询从不访问那些不需要的行，那么会锁定更少的行。</li><li><code>InnoDB</code> 只有在访问行的时候才会对其加锁，而索引能减少访问行的次数，从而<strong>减少锁的数量</strong>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 433. 最小基因变化</title>
    <link href="/2020/08/06/LeetCode-433-minimum-genetic-mutation/"/>
    <url>/2020/08/06/LeetCode-433-minimum-genetic-mutation/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener">433. 最小基因变化</a></p><h1 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h1><p>第一次解法击败 <code>100%</code> 用户。</p><p>每一次的变异都可在基因库中找到，因此从基因库中构建决策树，与当前基因相差一个碱基且在之前的选择路径中未出现的基因即为下一步变异的基因。</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> minStep = Integer.MAX_VALUE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(String start, String end, String[] bank)</span> </span>&#123;        dfs(start, end, <span class="hljs-number">0</span>, bank);        <span class="hljs-keyword">return</span> minStep == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : minStep;    &#125;    List&lt;String&gt; selectedList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 选择队列：bank 中在决策树中未选择的元素</span><span class="hljs-comment">     * 路径：selectedList</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start 当前变异到的基因</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end   最终的基因</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> count 需要变为最终基因的次数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bank  选择队列</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String start, String end, <span class="hljs-keyword">int</span> count, String[] bank)</span> </span>&#123;        <span class="hljs-comment">// 当前步数 &gt; 最小步数：剪枝</span>        <span class="hljs-keyword">if</span> (count &gt; minStep) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 若 当前基因 可以变为 最终基因</span>        <span class="hljs-comment">// 则计算最小步数，结束递归</span>        <span class="hljs-keyword">if</span> (start.equals(end)) &#123;            minStep = Math.min(minStep, count);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (String candidate : bank) &#123;            <span class="hljs-comment">// 若 candidate 不在决策树中 &amp;&amp; start 可变异为 candidate</span>            <span class="hljs-comment">// 则进入决策</span>            <span class="hljs-keyword">if</span> (notSelected(candidate) &amp;&amp; canMutate(start, candidate)) &#123;                selectedList.add(candidate);                dfs(candidate, end, count + <span class="hljs-number">1</span>, bank);                selectedList.remove(candidate);            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断 start 基因是否可以变为 candidate 基因</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidate</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canMutate</span><span class="hljs-params">(String start, String candidate)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; start.length(); i++) &#123;            <span class="hljs-keyword">if</span> (start.charAt(i) != candidate.charAt(i)) &#123;                <span class="hljs-keyword">if</span> (++count &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断在之前的路径中是否未选择 candidate</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidate</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">notSelected</span><span class="hljs-params">(String candidate)</span> </span>&#123;        <span class="hljs-keyword">return</span> !selectedList.contains(candidate);    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><p>每次变异一个碱基，队列中保存的即为当前可变异的所有基因，且这些基因都在基因库中未被变异过。<br />相当于构建一棵树，进行树的层次遍历。<br />需要注意的是变异完后的碱基需要恢复原样，否则在下一次获取新基因时可能导致多个碱基都发生了变异。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(String start, String end, String[] bank)</span> </span>&#123;        Set&lt;String&gt; unSelectedSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(bank));        <span class="hljs-keyword">if</span> (!unSelectedSet.contains(end)) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">char</span>[] mutGenes = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'T'</span>&#125;;        LinkedList&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(start);        unSelectedSet.remove(start);        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            step++;            <span class="hljs-comment">// 队列中保存的是一个基因一次变异可以产生的新基因序列</span>            <span class="hljs-comment">// 队列为空则表示这次的序列变异结束，进入下一次遍历</span>            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 基因</span>                <span class="hljs-keyword">char</span>[] genes = queue.poll().toCharArray();                <span class="hljs-comment">// 1. 对每个基因位变异</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; genes.length; i++) &#123;                    <span class="hljs-comment">// 保存旧的碱基</span>                    <span class="hljs-keyword">char</span> oldGene = genes[i];                    <span class="hljs-comment">// 2. 基因的每一位依次进行 ACGT 变异</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> mutGene : mutGenes) &#123;                        genes[i] = mutGene;                        <span class="hljs-comment">// 3. 获取碱基变异后的新基因</span>                        String newGene = String.valueOf(genes);                        <span class="hljs-comment">// 4. 变到 end，直接返回</span>                        <span class="hljs-keyword">if</span> (end.equals(newGene)) &#123;                            <span class="hljs-keyword">return</span> step;                            <span class="hljs-comment">// 5. 在未变异的基因库中找到新基因</span>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unSelectedSet.contains(newGene)) &#123;                            unSelectedSet.remove(newGene);                            queue.offer(newGene);                        &#125;                    &#125;                    <span class="hljs-comment">// 变异的基因位要恢复原来的碱基</span>                    <span class="hljs-comment">// 否则在 3 中获取的新基因会变成 TTTT*，进而影响 4, 5</span>                    genes[i] = oldGene;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre><h1 id="双向-bfs"><a class="markdownIt-Anchor" href="#双向-bfs"></a> 双向 BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(String start, String end, String[] bank)</span> </span>&#123;        <span class="hljs-keyword">if</span> (start.length() == <span class="hljs-number">0</span> || end.length() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        Set&lt;String&gt; list = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(bank));        <span class="hljs-keyword">if</span> (!list.contains(end)) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">char</span>[] muteList = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'T'</span>&#125;;        Set&lt;String&gt; beginSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        beginSet.add(start);        Set&lt;String&gt; endSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        endSet.add(end);        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!beginSet.isEmpty() &amp;&amp; !endSet.isEmpty()) &#123;            count++;            <span class="hljs-comment">// 每次都假设从数目小的集合遍历</span>            <span class="hljs-keyword">if</span> (beginSet.size() &gt; endSet.size()) &#123;                Set&lt;String&gt; tmp = beginSet;                beginSet = endSet;                endSet = tmp;            &#125;            <span class="hljs-comment">// 下一次变异的列表</span>            Set&lt;String&gt; nextLevel = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();            <span class="hljs-keyword">for</span> (String word : beginSet) &#123;                <span class="hljs-keyword">char</span>[] words = word.toCharArray();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;                    <span class="hljs-keyword">char</span> old = words[i];                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : muteList) &#123;                        <span class="hljs-keyword">if</span> (old == c) &#123;                            <span class="hljs-keyword">continue</span>;                        &#125;                        words[i] = c;                        String candidate = String.valueOf(words);                        <span class="hljs-keyword">if</span> (endSet.contains(candidate)) &#123;                            <span class="hljs-keyword">return</span> count;                        &#125;                        <span class="hljs-comment">// 这里一定注意只能变异到 bank 中的单词</span>                        <span class="hljs-comment">// 如果使用 used 判断，会加入不在 bank 中的单词，导致出错</span>                        <span class="hljs-keyword">if</span> (list.contains(candidate)) &#123;                            nextLevel.add(candidate);                            list.remove(candidate);                        &#125;                    &#125;                    words[i] = old;                &#125;            &#125;            beginSet = nextLevel;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 102. 二叉树的层序遍历</title>
    <link href="/2020/08/06/LeetCode-102-binary-tree-level-order-traversal/"/>
    <url>/2020/08/06/LeetCode-102-binary-tree-level-order-traversal/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></p><p>主要在于判断每一层有哪些结点：遍历之前先保存每层结点数，然后按层处理结点。</p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(root);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-comment">// 保存当前层的结点数</span>            <span class="hljs-keyword">int</span> n = queue.size();            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-comment">// 遍历当前层的结点</span>            <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 对头出队，并将左右结点入队</span>                <span class="hljs-comment">// 当本轮循环结束后，队列里都是同一层的结点</span>                TreeNode p = queue.poll();                level.add(p.val);                <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) &#123;                    queue.add(p.left);                &#125;                <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) &#123;                    queue.add(p.right);                &#125;            &#125;            <span class="hljs-comment">// 将当前层加入结果</span>            res.add(level);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        dfs(root, <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> level)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (res.size() &lt; level) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(root.val)));        &#125; <span class="hljs-keyword">else</span> &#123;            res.get(level - <span class="hljs-number">1</span>).add(root.val);        &#125;        dfs(root.left, level + <span class="hljs-number">1</span>);        dfs(root.right, level + <span class="hljs-number">1</span>);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 表</title>
    <link href="/2020/08/06/InnoDB-table/"/>
    <url>/2020/08/06/InnoDB-table/</url>
    
    <content type="html"><![CDATA[<h1 id="索引组织表"><a class="markdownIt-Anchor" href="#索引组织表"></a> 索引组织表</h1><p>在 <code>InnoDB</code> 中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（<code>index organized table</code>）。如果在创建表时没有显式地定义主键，则会按以下方式选择或创建主键：</p><ul><li>首先判断表中是否有<strong>非空的唯一索引</strong>（<code>Unique NOT NULL</code>），如果有，则该列为主键；</li><li>否则，自动创建一个 <code>6</code> 字节大小的指针。</li></ul><p>当表中有多个非空唯一索引时，<code>InnoDB</code> 存储引擎将选择建表时第一个定义的非空唯一索引（<strong>索引的顺序</strong>）为主键。</p><h1 id="innodb-逻辑存储结构"><a class="markdownIt-Anchor" href="#innodb-逻辑存储结构"></a> <code>InnoDB</code> 逻辑存储结构</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805154705.png" srcset="/img/loading.gif" alt="" /></p><p>所有数据都存放在表空间，表空间由段（<code>segment</code>）、区（<code>extent</code>）、页（<code>page</code>）组成。</p><h2 id="段"><a class="markdownIt-Anchor" href="#段"></a> 段</h2><ul><li>数据段：<code>B+</code> 树的叶子节点（<code>Leaf node segment</code>）</li><li>索引段：<code>B+</code> 树的非叶子节点（<code>Non-Leaf node segment</code>）</li><li>回滚段：<code>Rollback segment</code></li></ul><h2 id="区"><a class="markdownIt-Anchor" href="#区"></a> 区</h2><p>区是由连续页组成的空间，<strong>在任何情况下每个区的大小都为 <code>1MB</code>。</strong> 为了保证区中页的连续性，<code>InnoDB</code> 一次从磁盘申请 <code>4 ~ 5</code> 个区，在默认情况下，页的大小为 <code>16KB</code>，即一个区中一共有 <code>64</code> 个连续的页。</p><h2 id="页"><a class="markdownIt-Anchor" href="#页"></a> 页</h2><p>页是 <code>InnoDB</code> 磁盘管理的最小单位。可通过 <code>innodb_page_size</code> 将页的大小设置为 <code>4K</code>、<code>8K</code>、<code>16K</code>。</p><h2 id="行"><a class="markdownIt-Anchor" href="#行"></a> 行</h2><p>数据按行存放，每页最多存放 <code>16KB / 2 - 200 = 7992</code> 行的记录。</p><h1 id="innodb-行记录格式"><a class="markdownIt-Anchor" href="#innodb-行记录格式"></a> <code>InnoDB</code> 行记录格式</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805164415.png" srcset="/img/loading.gif" alt="" /></p><h2 id="compact-行记录格式"><a class="markdownIt-Anchor" href="#compact-行记录格式"></a> <code>Compact</code> 行记录格式</h2><p>其目的是高效地存储数据，一个页中存放的数据越多，其性能就越高。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805162732.png" srcset="/img/loading.gif" alt="" /></p><h2 id="redundant-行记录格式"><a class="markdownIt-Anchor" href="#redundant-行记录格式"></a> <code>Redundant</code> 行记录格式</h2><p><code>Redundant</code> 是 <code>MySQL 5.0</code> 之前的行记录存储方式，它是为了兼容之前版本的页格式。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805162855.png" srcset="/img/loading.gif" alt="" /></p><h2 id="行溢出数据"><a class="markdownIt-Anchor" href="#行溢出数据"></a> 行溢出数据</h2><p>如果页中只能存放下一条记录，那么 <code>InnoDB</code> 会自动将行数据存放到溢出页中。</p><h2 id="compressed-和-dynamic-行记录格式"><a class="markdownIt-Anchor" href="#compressed-和-dynamic-行记录格式"></a> <code>Compressed</code> 和 <code>Dynamic</code> 行记录格式</h2><p>这两种记录格式对于存放在 <code>BLOB</code> 中的数据采用了完全的行溢出的方式。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805163825.png" srcset="/img/loading.gif" alt="" /><br />数据页中只存放 <code>20</code> 个字节的指针，实际数据都存放在 <code>Off Page</code> 中。</p><h1 id="约束"><a class="markdownIt-Anchor" href="#约束"></a> 约束</h1><h2 id="数据完整性"><a class="markdownIt-Anchor" href="#数据完整性"></a> 数据完整性</h2><ul><li><strong>实体完整性</strong>：保证表中有一个主键。</li><li><strong>域完整性</strong>：保证数据<strong>每列的值</strong>满足特定的条件。<ul><li>选择合适的数据类型确保一个数据值满足特定条件</li><li>外键约束</li><li>触发器</li><li><code>DEFAULT</code> 约束</li></ul></li><li><strong>参照完整性</strong>：保证<strong>两张表</strong>之间的关系。<ul><li><code>Primary Key</code></li><li><code>Unique Key</code></li><li><code>Foreigh Key</code></li><li><code>Default</code></li><li><code>NOT NULL</code></li></ul></li></ul><h2 id="约束的创建"><a class="markdownIt-Anchor" href="#约束的创建"></a> 约束的创建</h2><ol><li>表建立时进行约束定义</li><li>利用 <code>ALTER TABLE</code> 命令进行创建约束</li></ol><h2 id="约束和索引的区别"><a class="markdownIt-Anchor" href="#约束和索引的区别"></a> 约束和索引的区别</h2><ul><li>约束是一个<strong>逻辑概念</strong>，用来保证数据的完整性；</li><li>索引是一个数据结构，既有<strong>逻辑概念</strong>，在数据库中还代表着<strong>物理存储</strong>的方式。</li></ul><h1 id="视图"><a class="markdownIt-Anchor" href="#视图"></a> 视图</h1><blockquote><p>视图是一个命名的虚表，由一个 <code>SQL</code> 查询定义，视图中的数据没有实际的物理存储。</p></blockquote><p>视图的主要用途是被用做一个抽象装置，程序本身不需要关心基表（<code>base table</code>）的结构，只需要按照视图定义来<strong>获取数据或更新数据</strong>。</p><ul><li>通过定义视图 <code>WITH CHECK OPTION</code> 可对基本表进行更新。</li><li><code>SHOW TABLES</code> 命令也会把视图作为表显示出来。</li></ul><h1 id="分区表"><a class="markdownIt-Anchor" href="#分区表"></a> 分区表</h1><blockquote><p>分区的过程是将一个表或索引分解为多个更小、更可管理的部分。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。<br />从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。</p></blockquote><ul><li><code>MySQL</code> 支持<strong>水平分区</strong>，并不支持垂直分区；</li><li><code>MySQL</code> 的分区是<strong>局部分区索引</strong>，一个分区中既存放了数据又存放了索引。</li></ul><h2 id="分区类型"><a class="markdownIt-Anchor" href="#分区类型"></a> 分区类型</h2><ul><li><code>RANGE</code> 分区：行数据基于属于一个给定连续区间的列值被放入分区。</li><li><code>LIST</code> 分区：和 <code>RANGE</code> 分区类似，只是 <code>LIST</code> 分区面向的是离散的值。</li><li><code>HASH</code> 分区：根据用户自定义的表达式的返回值来进行分区。</li><li><code>KEY</code> 分区：根据 <code>MySQL</code> 提供的哈希函数来进行分区。</li><li><code>COLUMNS</code> 分区：不同于以上四种，该分区可以直接使用非整形的数据进行分区，分区根据类型比较而得，不需要转化为整形。</li></ul><h2 id="子分区"><a class="markdownIt-Anchor" href="#子分区"></a> 子分区</h2><p>子分区是在分区的基础上再进行分区。<code>MySQL</code> 允许在 <code>RANGE</code> 和 <code>LIST</code> 的分区上再进行 <code>HASH</code> 或 <code>KEY</code> 的子分区。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 51. N皇后</title>
    <link href="/2020/08/05/LeetCode-51-n-queens/"/>
    <url>/2020/08/05/LeetCode-51-n-queens/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></p><p>棋盘每一行相当于决策树的每一层，每行的任意一列都可放置皇后。因此，从 <strong>每一行</strong> 开始，选择该行的 <strong>每一列</strong> 作为选择列表进行递归，该行以上的所有行此时都正确放置了皇后，当行数达到棋盘深度时结束递归，返回本次递归的结果。</p><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] row : board) &#123;            Arrays.fill(row, <span class="hljs-string">'.'</span>);        &#125;        backtrack(board, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> board 棋盘</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> row   行号</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> row)</span> </span>&#123;        <span class="hljs-comment">// 行数达到棋盘最后一行结束</span>        <span class="hljs-comment">// 此时棋盘已正确放置皇后，返回本轮结果</span>        <span class="hljs-keyword">if</span> (row == board.length) &#123;            res.add(genBoard(board));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 路径：row 行上面的那些行都成功放置了 Q</span>        <span class="hljs-keyword">char</span>[] line = board[row];        <span class="hljs-comment">// 选择列表：第 row 行的每一列都是 Q 的可选位置</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; line.length; col++) &#123;            <span class="hljs-comment">// 排除不合法选择</span>            <span class="hljs-comment">// 若当前 (row, col) 位置不满足，则进入该行的下一列</span>            <span class="hljs-keyword">if</span> (!isValid(board, row, col)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 做选择</span>            board[row][col] = <span class="hljs-string">'Q'</span>;            <span class="hljs-comment">// 进入下一行决策</span>            backtrack(board, row + <span class="hljs-number">1</span>);            <span class="hljs-comment">// 撤销选择</span>            board[row][col] = <span class="hljs-string">'.'</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 因为其它位置还处于初始状态</span><span class="hljs-comment">     * 只需要验证每一列，左上和右上位置是否有皇后</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> board 棋盘</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> row   当前行</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> col   当前列</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前位置是否可以放置 皇后</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;        <span class="hljs-comment">// 验证 col 所在列是否有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : board) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-string">'Q'</span> == line[col]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 验证当前位置左上角是否有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>;             i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>;             i--, j--) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-string">'Q'</span> == board[i][j]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 验证当前位置右上角是否有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>;             i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; board.length;             i--, j++) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-string">'Q'</span> == board[i][j]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title">genBoard</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        List&lt;String&gt; bd = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : board) &#123;            bd.add(String.valueOf(line));        &#125;        <span class="hljs-keyword">return</span> bd;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 文件</title>
    <link href="/2020/08/05/InnoDB-file/"/>
    <url>/2020/08/05/InnoDB-file/</url>
    
    <content type="html"><![CDATA[<h1 id="参数文件"><a class="markdownIt-Anchor" href="#参数文件"></a> 参数文件</h1><blockquote><p>告诉 <code>MySQL</code> 实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置。</p></blockquote><p><code>MySQL</code> 实例可以不需要参数文件，这时所有的参数值取决于编译 <code>MySQL</code> 时指定的默认值和源代码中指定参数的默认值。</p><p>参数类型：</p><ul><li><strong>动态参数</strong> - 可以在 <code>MySQL</code> 实例运行中进行更改</li><li><strong>静态参数</strong> - 在整个实例生命周期内都不得进行修改</li></ul><h1 id="日志文件"><a class="markdownIt-Anchor" href="#日志文件"></a> 日志文件</h1><blockquote><p>日志文件记录了影响 <code>MySQL</code> 数据库的各种类型活动。</p></blockquote><ul><li><p><strong>错误日志（<code>error log</code>）</strong><br />记录 MySQL 的启动、运行、关闭过程。不仅记录所有错误信息，也记录一些警告或正确的信息。<br />可通过命令 <code>SHOW VARIABLES LIKE 'log_error'</code> 来定位该文件</p></li><li><p><strong>慢查询日志（<code>slow log</code>）</strong><br />定位可能存在问题的 <code>SQL</code> 语句，从而进行 <code>SQL</code> 语句层面的优化。<br />可通过设置参数 <code>long_query_time</code> 来设置阈值（默认为 <code>10</code>），将运行时间超过该值的所有 <code>SQL</code> 语句都记录到该慢查询日志文件中。</p></li><li><p><strong>查询日志（<code>log</code>）</strong><br />记录所有对 <code>MySQL</code> 数据库请求的信息，无论这些请求是否得到了正确的执行。<br />默认文件名为：<code>主机名.log</code></p></li><li><p><strong>二进制日志（<code>binlog</code>）</strong><br />记录对 <code>MySQL</code> 数据库执行更改的所有操作，但是不包括 <code>SELECT</code> 和 <code>SHOW</code> 这类操作。<br />作用：</p><ul><li>恢复（<code>recovery</code>）：数据恢复</li><li>复制（<code>replication</code>）：主从同步</li><li>审计（<code>audit</code>）：判断是否有对数据库进行注入攻击</li></ul></li></ul><h1 id="套接字文件"><a class="markdownIt-Anchor" href="#套接字文件"></a> 套接字文件</h1><p>在 <code>UNIX</code> 系统下本地连接 <code>MySQL</code> 可以采用 <code>UNIX</code> 域套接字方式，通过套接字（<code>socket</code>）文件连接。</p><h1 id="pid-文件"><a class="markdownIt-Anchor" href="#pid-文件"></a> <code>pid</code> 文件</h1><p>当 <code>MySQL</code> 实例启动时，会将自己的进程 <code>ID</code> 写入一个 <code>pid</code> 文件中。<br />默认位于数据库目录下，文件名为：<code>主机名.pid</code>。</p><h1 id="表结构定义文件"><a class="markdownIt-Anchor" href="#表结构定义文件"></a> 表结构定义文件</h1><p><code>MySQL</code> 的数据存储是根据表进行的，每个表/视图都有一个以 <code>frm</code> 为后缀名的文件，该文件记录了该表的表结构定义。</p><h1 id="innodb-存储引擎文件"><a class="markdownIt-Anchor" href="#innodb-存储引擎文件"></a> <code>InnoDB</code> 存储引擎文件</h1><p>以上文件都是 <code>MySQL</code> 数据库本身的文件，而 <code>InnoDB</code> 存储引擎还有其自己独有的文件。</p><h2 id="表空间文件"><a class="markdownIt-Anchor" href="#表空间文件"></a> 表空间文件</h2><p><code>InnoDB</code> 采用将存储的表空间（<code>tablespace</code>）进行存放的设计，默认配置下初始大小为 <code>10MB</code>，文件名为 <code>ibdata1</code>。<br />表空间分为共享表空间与独立表空间，用户可以将每个基于 <code>InnoDB</code> 存储引擎的表产生一个独立表空间，单独的表空间文件仅存储该表的数据、索引和插入缓冲 <code>BITMAP</code> 等信息，其余信息还是存放在默认的表空间中。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805144502.png" srcset="/img/loading.gif" alt="" /></p><h2 id="重做日志文件"><a class="markdownIt-Anchor" href="#重做日志文件"></a> 重做日志文件</h2><p>当实例或介质失败（<code>media failure</code>）时，<code>InnoDB</code> 存储引擎会使用重做日志恢复到实例正常的时刻，以此来保证数据的完整性。</p><p>每个 <code>InnoDB</code> 存储引擎至少有 <code>1</code> 个重做日志文件组，每个文件组下至少有 <code>2</code> 个重做日志文件。</p><p>重做日志文件的大小对存储引擎的性能有非常大的影响。</p><ul><li>如果太大，在恢复时可能需要很长的时间；</li><li>如果太小，可能导致一个事务的日志需要多次切换重做日志文件，还会呆滞频繁地发生 <code>async checkpoint</code>，导致性能的抖动。</li></ul><p><strong>与二进制日志的区别</strong>：</p><ul><li>二进制日志记录与 <code>MySQL</code> 数据库有关的日志记录，包括<strong>所有存储引擎</strong>的日志。<br /><code>InnoDB</code> 的重做日志只记录<strong>该存储引擎本身</strong>的事务日志。</li><li>二进制日志记录关于一个事务的<strong>具体操作内容</strong>。<br />重做日志记录的是每个页的<strong>物理更改</strong>情况。</li><li>二进制日志仅在事务提交前进行提交，<strong>只写磁盘一次</strong>。<br />而事务进行的过程中，不断有重做日志条目被写入到重做日志文件中。</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805150220.png" srcset="/img/loading.gif" alt="" /><br /><strong>写入流程</strong>：先写入一个重做日志缓冲（<code>redo log buffer</code>）中，然后按照一定的条件顺序地写入日志文件。<br /><strong>写入条件</strong>：</p><ul><li>主线程每秒写入重做日志文件，不论事务是否已经提交。</li><li>在提交（<code>commit</code>）操作时，设置 <code>innodb_flush_log_at_trx_commit = 1</code>，在 <code>commit</code> 提交时将重做日志缓冲同步写到磁盘。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 17. 电话号码的字母组合</title>
    <link href="/2020/08/04/LeetCode-17-letter-combinations-of-a-phone-number/"/>
    <url>/2020/08/04/LeetCode-17-letter-combinations-of-a-phone-number/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></p><h1 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h1><p>选择列表：每个 <code>digit</code> 对应的字母列表<br />路径：已选字母组合 + 选择列表的字母<br />终止条件：递归深度达到 <code>digits</code> 的长度</p><pre><code class="hljs java"><span class="hljs-comment">// 2 ~ 9 每个位置所对应的选择列表</span>String[] map = &#123;<span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>, <span class="hljs-string">"ghi"</span>, <span class="hljs-string">"jkl"</span>, <span class="hljs-string">"mno"</span>, <span class="hljs-string">"pqrs"</span>, <span class="hljs-string">"tuv"</span>, <span class="hljs-string">"wxyz"</span>&#125;;List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;    <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    combine(digits, <span class="hljs-string">""</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> digits</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> path   当前已选择的组合路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> len    当前递归到的 digits 位置</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">combine</span><span class="hljs-params">(String digits, String path, <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-comment">// 递归深度为 digits 的长度</span>    <span class="hljs-keyword">if</span> (len == digits.length()) &#123;        res.add(path);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 找到当前 digit 所对应的字母组合</span>    <span class="hljs-keyword">char</span> c = digits.charAt(len);    <span class="hljs-keyword">int</span> pos = c - <span class="hljs-string">'0'</span>;    <span class="hljs-comment">// 所需要的选择列表</span>    String candidateString = map[pos];    <span class="hljs-comment">// 枚举每个字母组合</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; candidateString.length(); i++) &#123;        <span class="hljs-comment">// 路径为：上一轮的路径 + 选择列表中的每个字母</span>        <span class="hljs-comment">// 递归深度/路径长度 + 1</span>        combine(digits, path + candidateString.charAt(i), len + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><p><code>8.16</code> 按照模板的回溯解法：添加 <code>add</code>，<code>remove</code> 操作。<br />一开始 <code>path</code> 使用的是 <code>List</code>，总是无法通过，后来发现若是 <code>digits</code> 由同一个数字组成的情况下，路径中的元素可能是重复的，此时使用 <code>list.remove()</code> 操作会删除错误位置的元素，使用栈的思想可解决这个问题。</p><pre><code class="hljs java">List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();String[] num2Str = &#123;<span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>, <span class="hljs-string">"ghi"</span>, <span class="hljs-string">"jkl"</span>, <span class="hljs-string">"mno"</span>, <span class="hljs-string">"pqrs"</span>, <span class="hljs-string">"tuv"</span>, <span class="hljs-string">"wxyz"</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;    <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">// 使用 StringBuilder</span>    <span class="hljs-comment">// 如果使用 List，当例子为 "999" 等相同数字时，在回溯时 remove 会出错</span>    StringBuilder path = <span class="hljs-keyword">new</span> StringBuilder();    backtrack(<span class="hljs-number">0</span>, path, digits);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len, StringBuilder path, String digits)</span> </span>&#123;    <span class="hljs-keyword">if</span> (len == digits.length()) &#123;        res.add(path.toString());        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> pos = digits.charAt(len) - <span class="hljs-string">'0'</span>;    String str = num2Str[pos];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; str.length(); j++) &#123;        String candidate = String.valueOf(str.charAt(j));        <span class="hljs-comment">// 末尾添加</span>        path.append(candidate);        backtrack(len + <span class="hljs-number">1</span>, path, digits);        <span class="hljs-comment">// 末尾删除</span>        path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h1 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h1><blockquote><p>‘’<br />a, b, c<br />b, c, ad, ae, af<br />…</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">// 2 ~ 9 每个位置所对应的选择列表</span>    String[] map = &#123;<span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>, <span class="hljs-string">"ghi"</span>, <span class="hljs-string">"jkl"</span>, <span class="hljs-string">"mno"</span>, <span class="hljs-string">"pqrs"</span>, <span class="hljs-string">"tuv"</span>, <span class="hljs-string">"wxyz"</span>&#125;;    <span class="hljs-comment">// 添加空元素，初始化时使第一个位置的字母入队</span>    res.add(<span class="hljs-string">""</span>);    <span class="hljs-comment">// 1. 遍历 digits e.g. "23"</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; digits.length(); i++) &#123;        <span class="hljs-keyword">int</span> pos = digits.charAt(i) - <span class="hljs-string">'0'</span>;        <span class="hljs-comment">// 选择列表 e.g. "def"</span>        String candidateStr = map[pos];        <span class="hljs-comment">// 2. 遍历队列，组合字母 res: a, b, c</span>        <span class="hljs-comment">// !! 先缓存当前的队列长度，否则动态 add path 时，队列长度在变化</span>        <span class="hljs-keyword">int</span> size = res.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++) &#123;            <span class="hljs-comment">// 队头出队 e.g. a</span>            String path = res.remove(<span class="hljs-number">0</span>);            <span class="hljs-comment">// 3. 组合队头和选择列表</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; candidateStr.length(); k++) &#123;                <span class="hljs-comment">// b, c, ad, ae, af</span>                res.add(path + candidateStr.charAt(k));            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 存储引擎</title>
    <link href="/2020/08/04/InnoDB-engine/"/>
    <url>/2020/08/04/InnoDB-engine/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql-体系结构"><a class="markdownIt-Anchor" href="#mysql-体系结构"></a> MySQL 体系结构</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200804132116.png" srcset="/img/loading.gif" alt="" /></p><ul><li>连接池组件</li><li>管理服务和工具类</li><li><code>SQL</code> 接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲组件</li><li>插件式存储引擎</li><li>物理文件</li></ul><blockquote><p>存储引擎是基于表的，而不是数据库。</p></blockquote><h1 id="innodb-体系架构"><a class="markdownIt-Anchor" href="#innodb-体系架构"></a> <code>InnoDB</code> 体系架构</h1><p><code>InnoDB</code> 存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池：负责以下工作：</p><ul><li>维护所有进程、线程需要访问的多个内部数据结构</li><li>缓存磁盘数据</li><li>重做日志缓冲</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200804133649.png" srcset="/img/loading.gif" alt="" /></p><p>后台线程的主要作用是<strong>负责刷新内存池中的数据</strong>，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下 <code>InnoDB</code> 能恢复到正常运行状态。</p><h2 id="后台线程"><a class="markdownIt-Anchor" href="#后台线程"></a> 后台线程</h2><ul><li><p><code>Master Thread</code><br /><code>Master Thread</code> 是一个非常核心的后台线程，主要负责将缓冲池中的<strong>数据异步刷新</strong>到磁盘，保证数据的一致性。包括脏页的刷新、合并插入缓冲、<code>UNDO</code> 页的回收等。</p></li><li><p><code>IO Thread</code><br /><code>InnoDB</code> 存储引擎中大量使用了 <code>AIO</code> 来处理写请求，<code>IO Thread</code> 的工作主要是负责这些 <strong><code>IO</code> 请求的回调处理</strong>。</p></li><li><p><code>Purge Thread</code><br />事务被提交后，其所使用的 <code>undolog</code> 可能不再需要，因此需要使用 <code>Purge Thread</code> 来<strong>回收</strong>已经使用并分配的 <code>undo</code> 页。</p></li><li><p><code>Page Cleaner Thread</code><br />其作用是将<strong>脏页的刷新操作</strong>都放入到单独的线程中来完成，其目的是为了减轻 <code>Master Thread</code> 的工作及对于用户查询线程的阻塞，进一步提高 <code>InnoDB</code> 的性能。</p></li></ul><h2 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200804135715.png" srcset="/img/loading.gif" alt="" /></p><h3 id="缓冲池"><a class="markdownIt-Anchor" href="#缓冲池"></a> 缓冲池</h3><p><code>InnoDB</code> 存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。<br />对于数据库中页的修改操作，首先修改在缓冲池中的页，然后再通过 <code>Checkpoint</code> 机制刷新到磁盘上。</p><h3 id="lru-list-free-list-flush-list"><a class="markdownIt-Anchor" href="#lru-list-free-list-flush-list"></a> <code>LRU List</code>, <code>Free List</code>, <code>Flush List</code></h3><p><code>InnoDB</code> 存储引擎中，<code>LRU List</code> 中还加入了 <code>midpoint</code> 位置，<code>midpoint</code> 之后的列表称为 <code>old</code> 列表， 之前的列表称为 <code>new</code> 列表，<code>new</code> 列表中的页都是最为活跃的热点数据。新读取到的页，并不是直接放入 <code>LRU</code> 列表的首部，而是放入 <code>LRU</code> 列表的 <code>midpoint</code> 位置。在默认配置下，这个位置在 <code>LRU</code> 列表长度的 <code>5/8</code> 处。</p><blockquote><p>那为什么不采用朴素的 <code>LRU</code> 算法，直接将读取的页放入到 <code>LRU List</code> 的首部呢？<br />若直接将读取到的页放人到 <code>LRU</code> 的首部，那么某些 <code>SQL</code> 操作可能会使缓冲池中的热点数据被刷新，而在下一次需要读取该页时，需要再次访问磁盘。<br />常见的这类操作为<strong>索引</strong>或<strong>数据的扫描</strong>操作。这类操作需要访问表中的许多页，甚至是全部的页，而这些页通常来说又仅在这次查询操作中需要，并不是活跃的热点数据。</p></blockquote><p><code>LRU List</code> 用来管理已经读取的页，但当数据库刚启动时，<code>LRU List</code> 是空的，即没有任何的页。这时页都存放在 <code>Free List</code> 中。当需要从缓冲池中分页时，首先从 <code>Free List</code> 中查找是否有可用的空闲页</p><ul><li>若有则将该页从 <code>Free List</code> 中删除，放入到 <code>LRU List</code> 中。</li><li>否则，根据 <code>LRU</code> 算法，淘汰 <code>LRU List</code> 末尾的页，将该内存空间分配给新的页。</li></ul><ul><li><code>page made young</code>: 页从 <code>LRU List</code> 的 <code>old</code> 部分加入到 <code>new</code> 部分。</li><li><code>page not made young</code>: 因为 <code>innodb-old_blocks-time</code> 的设置而导致页没有从 <code>old</code> 部分移动到 <code>new</code> 部分。</li></ul><p>当 <code>LRU List</code> 中的页被修改后，称该页为脏页（<code>dirty page</code>），即缓冲池中的页和磁盘上的页数据产生了不一致。这时候数据库会通过 <code>checkpoint</code> 机制将脏页刷新回磁盘，而 <code>Flush List</code> 中的页即为脏页列表。注意脏页也存在于 <code>LRU List</code> 中。</p><h3 id="重做日志缓冲"><a class="markdownIt-Anchor" href="#重做日志缓冲"></a> 重做日志缓冲</h3><p><code>InnoDB</code> 引擎首先将重做日志信息先放到重做日志缓冲区(<code>redo log buffer</code>)，然后按一定频率刷新到重做日志文件。重做日志缓冲不需要设置很大，一般每一秒都会刷新 <code>redo log buffer</code>，配置的大小只需要保证每秒产生的事务在这个缓冲区大小之内即可。通过参数 <code>innodb_log_buffer_size</code> 设置。<br />在下列情况下会将重做日志缓冲中的内容刷新到磁盘重做日志文件中：</p><ul><li><code>Master Thread</code> 每一秒中刷新一次；</li><li>每个事务提交时会刷新；</li><li>当重做日志缓冲区空间小于 <code>1/2</code> 时会刷新。</li></ul><h3 id="额外的内存池"><a class="markdownIt-Anchor" href="#额外的内存池"></a> 额外的内存池</h3><p>额外的内存池用来对一些数据结构本身的内存进行分配，例如缓冲控制对象(<code>buffer control block</code>)记录的 <code>LRU</code>，锁，等待等信息。额外的内存池不够时会从缓冲池中进行申请。因此，在申请了很大的 <code>InnoDB</code> 缓冲池时，额外的内存池也要适当的调大。通过参数 <code>innodb_additional_mem_pool_size</code> 来设置大小。</p><h1 id="checkpoint-技术"><a class="markdownIt-Anchor" href="#checkpoint-技术"></a> <code>Checkpoint</code> 技术</h1><p>作用：将脏页刷新到磁盘。<br />目的：</p><ul><li>缩短数据库的恢复时间</li><li>缓冲池不够用时，将脏页刷新到磁盘</li><li>重做日志不可用时，刷新脏页</li></ul><p>类型：</p><ul><li><code>Sharp Checkpoint</code> - 数据库关闭时将所有的脏页都刷新回磁盘。</li><li><code>Fuzzy Checkpoint</code>:<ul><li><code>Master THread Checkpoint</code> - 每秒或每十秒刷新</li><li><code>FLUSH_LRU_LIST Checkpoint</code> - 脏页来自于 <code>LRU List</code></li><li><code>Async/Sync Flush Checkpoint</code> - 重做日志不可用，强制刷新脏页</li><li><code>Dirty Page too mush Checkpoint</code> - 脏页太多强制刷新</li></ul></li></ul><h1 id="master-thread-工作方式"><a class="markdownIt-Anchor" href="#master-thread-工作方式"></a> <code>Master Thread</code> 工作方式</h1><p><code>Master Thread</code> 具有<strong>最高的线程优先级别</strong>，其内部由多个循环组成</p><ul><li>主循环（<code>loop</code>）</li><li>后台循环（<code>background loop</code>）</li><li>刷新循环（<code>lush loop</code>）</li><li>暂停循环（<code>suspend loop</code>）</li></ul><h2 id="主循环"><a class="markdownIt-Anchor" href="#主循环"></a> 主循环</h2><p>大多数的操作都是在<strong>主循环</strong>中，其中包括每秒的操作和每 <code>10</code> 秒的操作。</p><p>每秒的操作：</p><ul><li>日志缓冲刷新到磁盘，即使这个事务还没提交（总是）</li><li>合并插入缓冲（前一秒 <code>IO</code> 小于 <code>5</code> 次）</li><li>至多刷新 <code>100</code> 个 脏页到磁盘（脏页比例超过阈值）</li><li>如果没有用户活动，切换到后台循环</li></ul><p>每 <code>10</code> 秒的操作：</p><ul><li>刷新 <code>100</code> 个脏页到磁盘（过去 <code>10</code> 秒 <code>IO</code> 小于 <code>200</code> 次）</li><li>合并至多 <code>5</code> 个插入缓冲（总是）</li><li>将日志缓冲刷新到磁盘 （总是）</li><li>删除无用的 <code>undo</code> 页（总是）</li><li>刷新 <code>100</code> 个或者 <code>10</code> 个脏页到磁盘（总是）</li></ul><h2 id="后台循环"><a class="markdownIt-Anchor" href="#后台循环"></a> 后台循环</h2><blockquote><p>当前没有用户活动（数据库空闲时）或数据库关闭时，切换到后台循环。<br />操作：</p></blockquote><ul><li>删除无用的 <code>undo</code> 页（总是）</li><li>合并 <code>20</code> 个插入缓冲（总是）</li><li>调回到主循环（总是）</li><li>不断刷新 <code>100</code> 个页直到符合条件（可能，跳转到 <code>flush loop</code> 中完成）</li></ul><h1 id="innodb-关键特性"><a class="markdownIt-Anchor" href="#innodb-关键特性"></a> <code>InnoDB</code> 关键特性</h1><h2 id="插入缓冲"><a class="markdownIt-Anchor" href="#插入缓冲"></a> 插入缓冲</h2><h3 id="insert-buffer"><a class="markdownIt-Anchor" href="#insert-buffer"></a> <code>Insert Buffer</code></h3><p>对于<strong>非聚集索引</strong>的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入；若不在，则先放入到一个 <code>Insert Buffr</code> 对象中。<br />然后再以一定频率和情况进行插入缓冲的合并操作，将多个插入合并到一个操作中。</p><p>使用条件：</p><ol><li>索引是辅助索引</li><li>索引不是唯一的</li></ol><h3 id="change-buffer"><a class="markdownIt-Anchor" href="#change-buffer"></a> <code>Change Buffer</code></h3><p><code>Change Buffer</code> 可视为 <code>Insert Buffer</code> 的升级，可以对 <code>DML</code> 操作：<code>INSERT</code>, <code>DELETE</code>, <code>UPDATE</code> 都进行缓冲，分别是：<code>Insert Buffer</code>, <code>Delete Buffer</code>, <code>Purge Buffer</code>。</p><p>适用对象依然是<strong>非唯一的辅助索引</strong>。<br /><code>Insert/Change Buffer</code> 是一棵 <code>B+</code> 树。</p><p>操作过程：</p><ol><li>将记录标记为已删除（<code>Delete Buffer</code>）；</li><li>真正将记录删除（<code>Purge Buffer</code>）。</li></ol><h3 id="merge-insert-buffer"><a class="markdownIt-Anchor" href="#merge-insert-buffer"></a> <code>Merge Insert Buffer</code></h3><p><code>Merge Insert Buffer</code> 的操作可能发生在以下几种情况下：</p><ul><li>辅助索引页被读取到缓冲池时；</li><li><code>Insert Buffer Bitmap</code> 页追踪到该辅助索引页已无可用空间时；</li><li><code>Master Thread</code>：每秒或每 <code>10</code> 秒。</li></ul><h2 id="两次写"><a class="markdownIt-Anchor" href="#两次写"></a> 两次写</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200804162449.png" srcset="/img/loading.gif" alt="" /></p><ol><li>当刷新缓冲池脏页时，并不直接写到数据文件中，而是先拷贝至内存中的两次写缓冲区；</li><li>接着从两次写缓冲区分两次写入磁盘共享表空间中，每次写入 <code>1MB</code>；</li><li>待第2步完成后，再将两次写缓冲区写入数据文件。</li></ol><p>这样就可以解决<strong>部分写失效</strong>的问题，因为在磁盘共享表空间中已有数据页副本拷贝，如果数据库在页写入数据文件的过程中宕机，在实例恢复时，可以从共享表空间中找到该页副本，将其拷贝覆盖原有的数据页，再应用重做日志即可。</p><h2 id="自适应哈希索引"><a class="markdownIt-Anchor" href="#自适应哈希索引"></a> 自适应哈希索引</h2><blockquote><p><code>InnoDB</code> 会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。它是通过缓冲池中的 <code>B+</code> 树构造而来，且不需要对整个表建立哈希索引，因此它的速度非常快。</p></blockquote><p><code>InnoDB</code> 采用自适应哈希索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引。</p><h2 id="异步-io"><a class="markdownIt-Anchor" href="#异步-io"></a> 异步 IO</h2><ul><li><code>AIO</code> 可以使用户在发出一个 <code>IO</code> 请求后立即再发出另一个 <code>IO</code> 请求，当全部请求发送完毕后，等待所有 <code>IO</code> 操作的完成。</li><li>可以进行 <code>IO Merge</code> 操作，将多个 <code>IO</code> 合并为 <code>1</code> 个 <code>IO</code>。</li></ul><h2 id="刷新邻接页"><a class="markdownIt-Anchor" href="#刷新邻接页"></a> 刷新邻接页</h2><p>当刷新一个脏页时，<code>InnoDB</code> 会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。<br />好处是通过 <code>AIO</code> 将多个 <code>IO</code> 写入操作合并成一个 <code>IO</code> 操作，在传统机械硬盘下有着显著优势。而对于固态硬盘建议关闭此特性。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 169. 多数元素</title>
    <link href="/2020/08/03/LeetCode-169-majority-element/"/>
    <url>/2020/08/03/LeetCode-169-majority-element/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></p><h1 id="解法一hashmap"><a class="markdownIt-Anchor" href="#解法一hashmap"></a> 解法一：<code>HashMap</code></h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = nums.length;    <span class="hljs-keyword">int</span> maj = n / <span class="hljs-number">2</span>;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(n);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">if</span> (map.get(num) != <span class="hljs-keyword">null</span>) &#123;            map.put(num, map.get(num) + <span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            map.put(num, <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;        <span class="hljs-keyword">if</span> (entry.getValue() &gt; maj) &#123;            <span class="hljs-keyword">return</span> entry.getKey();        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h1 id="解法二排序"><a class="markdownIt-Anchor" href="#解法二排序"></a> 解法二：排序</h1><blockquote><p>给定的数组总是存在多数元素。</p></blockquote><p>排序后中间位置的元素一定是众数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        Arrays.sort(nums);        <span class="hljs-keyword">return</span> nums[nums.length / <span class="hljs-number">2</span>];&#125;</code></pre><ul><li>时间复杂度：<code>O(nlogn)</code></li><li>空间复杂度：<code>O(logn)</code></li></ul><h1 id="解法三随机化"><a class="markdownIt-Anchor" href="#解法三随机化"></a> 解法三：随机化</h1><p>因为超过 <code>n/2</code> 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;       <span class="hljs-keyword">int</span> maj = nums.length / <span class="hljs-number">2</span>;       Random random = <span class="hljs-keyword">new</span> Random();       <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;           <span class="hljs-keyword">int</span> candidate = nums[getRandIdx(random, <span class="hljs-number">0</span>, nums.length)];           <span class="hljs-keyword">if</span> (count(nums, candidate) &gt; maj) &#123;               <span class="hljs-keyword">return</span> candidate;           &#125;       &#125;   &#125;   <span class="hljs-comment">// 1. 获取随机位置</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRandIdx</span><span class="hljs-params">(Random random, <span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> max)</span> </span>&#123;       <span class="hljs-keyword">return</span> random.nextInt(max - min) + min;   &#125;   <span class="hljs-comment">// 2. 计算 candidate 出现次数</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> candidate)</span> </span>&#123;       <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;           <span class="hljs-keyword">if</span> (nums[i] == candidate) &#123;               count++;           &#125;       &#125;       <span class="hljs-keyword">return</span> count;   &#125;</code></pre><ul><li>时间复杂度：理论上最坏情况下的时间复杂度为 <code>O(∞)</code>，平均时间复杂度为 <code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h1 id="方法四分治"><a class="markdownIt-Anchor" href="#方法四分治"></a> 方法四：分治</h1><p>将数组分成左右两部分，直到所有的子问题都是长度为 <code>1</code> 的数组，分别求出左半部分的众数 <code>leftEle</code> 以及右半部分的众数 <code>rightEle</code>，随后在 <code>leftEle</code> 和 <code>rightEle</code> 中选出正确的众数。</p><ul><li>如果回溯后某区间的长度为 <code>1</code>，则子数组中唯一的数显然是众数，直接返回即可。</li><li>如果回溯后某区间的长度大于 <code>1</code>，我们必须将左右子区间的值合并。<ul><li>如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。</li><li>如果它们的众数不同，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">return</span> majEle(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majEle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-comment">// 1. 数组区间中只有一个元素，则直接返回</span>    <span class="hljs-keyword">if</span> (low == high) &#123;        <span class="hljs-keyword">return</span> nums[low];    &#125;    <span class="hljs-comment">// 2. 区间中存在多个元素，计算左右部分的众数</span>    <span class="hljs-keyword">int</span> mid = (high - low) / <span class="hljs-number">2</span> + low;    <span class="hljs-keyword">int</span> leftEle = majEle(nums, low, mid);    <span class="hljs-keyword">int</span> rightEle = majEle(nums, mid + <span class="hljs-number">1</span>, high);    <span class="hljs-comment">//  2.1 左右部分的众数相等</span>    <span class="hljs-keyword">if</span> (leftEle == rightEle) &#123;        <span class="hljs-keyword">return</span> leftEle;    &#125;    <span class="hljs-comment">// 2.2 左右部分众数不等，则计算他们在整个区间的出现次数</span>    <span class="hljs-keyword">int</span> lCount = count(nums, leftEle, low, high);    <span class="hljs-keyword">int</span> rCount = count(nums, rightEle, low, high);    <span class="hljs-keyword">return</span> lCount &gt; rCount ? leftEle : rightEle;&#125;<span class="hljs-comment">// 计算 candidate 出现次数</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> candidate, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt;= high; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] == candidate) &#123;            count++;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><ul><li>时间复杂度：<code>O(nlogn)</code>。</li><li>空间复杂度：<code>O(logn)</code>。尽管分治算法没有直接分配额外的数组空间，但在递归的过程中使用了额外的栈空间。算法每次将数组从中间分成两部分，所以数组长度变为 <code>1</code> 之前需要进行 <code>O(logn)</code> 次递归，即空间复杂度为 <code>O(logn)</code>。</li></ul><h1 id="方法五boyer-moore-投票算法"><a class="markdownIt-Anchor" href="#方法五boyer-moore-投票算法"></a> 方法五：<code>Boyer-Moore</code> 投票算法</h1><ul><li><p>我们维护一个候选众数 <code>candidate</code> 和它出现的次数 <code>count</code>。初始时 <code>candidate</code> 可以为任意值，<code>count</code> 为 0；</p></li><li><p>我们遍历数组 <code>nums</code> 中的所有元素，对于每个元素 <code>x</code>，在判断 <code>x</code> 之前，如果 <code>count</code> 的值为 0，我们先将 <code>x</code> 的值赋予 <code>candidate</code>，随后我们判断 x：</p><ul><li><p>如果 <code>x</code> 与 <code>candidate</code> 相等，那么计数器 <code>count + 1</code>；</p></li><li><p>如果 <code>x</code> 与 <code>candidate</code> 不等，那么计数器 <code>count - 1</code>。</p></li></ul></li><li><p>在遍历完成后，<code>candidate</code> 即为整个数组的众数。</p></li></ul><p>举个例子，我们的输入数组为 <code>[1, 1, 0, 0, 0, 1, 0]</code>，那么 <code>0</code> 就是多数元素。<br />首先，<code>candidate</code> 被设置为第一个元素 <code>1</code>，<code>count</code> 也变成 <code>1</code>，由于 <code>1</code> 不是多数元素，所以当扫描到数组某个位置时，<code>count</code> 一定会减为 <code>0</code> 。在我们的例子中，当扫描到第四个位置时，<code>count</code> 变成 <code>0</code>.</p><p><code>count</code> 值变化过程：<br /><code>[1, 2, 1, 0 ……]</code></p><p>当 <code>count</code> 变成 <code>0</code> 时，对于每一个出现的 <code>1</code>，我们都用一个 <code>0</code> 与其进行抵消，所以我们消耗掉了与其一样多的<code>0</code>，而 <code>0</code> 是多数元素，这意味着当扫描到第四个位置时，我们已经最大程度的消耗掉了多数元素。然而，对于数组从第五个位置开始的剩余部分，<code>0</code> 依然是其中的多数元素(注意，多数元素出现次数大于 <code>⌊ n/2 ⌋</code>，而我们扫描过的部分中多数元素只占一半，那剩余部分中多数元素还有一半)。如果之前用于抵消的元素中存在非多数元素，那么数组剩余部分包含的多数元素就更多了。</p><blockquote><p>数组中从 <code>candidate</code> 被赋值到 <code>count</code> 减到 <code>0</code> 的那一段可以被去除，余下部分的多数元素依然是原数组的多数元素。我们可以不断重复这个过程，直到扫描到数组尾部，那么 <code>count</code> 必然会大于 <code>0</code>，而且这个 <code>count</code> 对应的 <code>candinate</code> 就是原数组的多数元素。</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> candidate = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;            candidate = num;        &#125;        count += (candidate == num) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> candidate;&#125;</code></pre><ul><li><p>时间复杂度：<code>O(n)</code>。</p></li><li><p>空间复杂度：<code>O(1)</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VIM 指令记录</title>
    <link href="/2020/08/01/vim-command/"/>
    <url>/2020/08/01/vim-command/</url>
    
    <content type="html"><![CDATA[<p><code>vim</code> 常用指令记录</p><h1 id="命令模式"><a class="markdownIt-Anchor" href="#命令模式"></a> 命令模式</h1><h2 id="光标移动"><a class="markdownIt-Anchor" href="#光标移动"></a> 光标移动</h2><table><thead><tr><th style="text-align:center">cmd</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>h</code></td><td style="text-align:center">左移一个字符</td></tr><tr><td style="text-align:center"><code>l</code></td><td style="text-align:center">右移</td></tr><tr><td style="text-align:center"><code>k</code></td><td style="text-align:center">上移</td></tr><tr><td style="text-align:center"><code>j</code></td><td style="text-align:center">下移</td></tr><tr><td style="text-align:center"><code>{n}{op}</code></td><td style="text-align:center"><code>10j</code> 表示下移 <code>10</code> 行</td></tr><tr><td style="text-align:center"><code>{n}&lt;Space&gt;</code></td><td style="text-align:center">向后移动 <code>n</code> 个字符</td></tr><tr><td style="text-align:center"><code>{n}&lt;Enter&gt;</code></td><td style="text-align:center"><strong>向下移动 <code>n</code> 行</strong></td></tr><tr><td style="text-align:center"><code>$</code></td><td style="text-align:center"><strong>移动到行首</strong></td></tr><tr><td style="text-align:center"><code>0</code></td><td style="text-align:center"><strong>移动到行尾</strong></td></tr><tr><td style="text-align:center"><code>ctrl + f</code></td><td style="text-align:center"><strong>Page Down</strong></td></tr><tr><td style="text-align:center"><code>ctrl + b</code></td><td style="text-align:center"><strong>Page Up</strong></td></tr><tr><td style="text-align:center"><code>ctrl + d</code></td><td style="text-align:center">下移半页</td></tr><tr><td style="text-align:center"><code>ctrl + u</code></td><td style="text-align:center">上移半页</td></tr><tr><td style="text-align:center"><code>H</code></td><td style="text-align:center">移动到这个屏幕的第一行的第一个字符</td></tr><tr><td style="text-align:center"><code>M</code></td><td style="text-align:center">移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td style="text-align:center"><code>L</code></td><td style="text-align:center">移动到这个屏幕的最后一行的第一个字符</td></tr><tr><td style="text-align:center"><code>gg</code></td><td style="text-align:center"><strong>移动到文件第一行</strong></td></tr><tr><td style="text-align:center"><code>G</code></td><td style="text-align:center"><strong>移动到文件最后一行</strong></td></tr><tr><td style="text-align:center"><code>{n}G</code></td><td style="text-align:center">移动到第 <code>n</code> 行</td></tr></tbody></table><h2 id="剪切删除"><a class="markdownIt-Anchor" href="#剪切删除"></a> 剪切/删除</h2><table><thead><tr><th style="text-align:center">cmd</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>x</code>, <code>X</code></td><td style="text-align:center">delete, backspace</td></tr><tr><td style="text-align:center"><code>{n}x</code></td><td style="text-align:center">向后删除 <code>n</code> 个字符</td></tr><tr><td style="text-align:center"><code>dd</code></td><td style="text-align:center"><strong>删除一行</strong></td></tr><tr><td style="text-align:center"><code>{n}dd</code></td><td style="text-align:center"><strong>删除 <code>n</code> 行</strong></td></tr><tr><td style="text-align:center"><code>d1G</code></td><td style="text-align:center">删除第一行到光标所在行</td></tr><tr><td style="text-align:center"><code>dG</code></td><td style="text-align:center">删除光标所在行到最后一行</td></tr><tr><td style="text-align:center"><code>d0</code></td><td style="text-align:center"><strong>删除光标到该行首部</strong></td></tr><tr><td style="text-align:center"><code>d$</code></td><td style="text-align:center"><strong>删除光标所在处，到该行尾部(包括光标选中的字符)</strong></td></tr></tbody></table><h2 id="复制"><a class="markdownIt-Anchor" href="#复制"></a> 复制</h2><table><thead><tr><th style="text-align:center">cmd</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>y</code></td><td style="text-align:center"><code>v</code> 选中</td></tr><tr><td style="text-align:center"><code>yy</code></td><td style="text-align:center"><strong>复制一行</strong></td></tr><tr><td style="text-align:center"><code>{n}yy</code></td><td style="text-align:center"><strong>复制 <code>n</code> 行</strong></td></tr><tr><td style="text-align:center"><code>y1G</code></td><td style="text-align:center">复制第一行到光标所在行</td></tr><tr><td style="text-align:center"><code>yG</code></td><td style="text-align:center">复制光标所在行到最后一行</td></tr><tr><td style="text-align:center"><code>y0</code></td><td style="text-align:center"><strong>复制光标到该行首部</strong></td></tr><tr><td style="text-align:center"><code>y$</code></td><td style="text-align:center"><strong>复制光标所在处，到该行尾部(包括光标选中的字符)</strong></td></tr></tbody></table><h2 id="粘贴"><a class="markdownIt-Anchor" href="#粘贴"></a> 粘贴</h2><table><thead><tr><th style="text-align:center">cmd</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>p</code>, <code>P</code></td><td style="text-align:center">粘贴在上/下一行</td></tr><tr><td style="text-align:center"><code>J</code></td><td style="text-align:center">合并光标所在行和下一行</td></tr></tbody></table><h2 id="撤销-重做-重复"><a class="markdownIt-Anchor" href="#撤销-重做-重复"></a> 撤销、重做、重复</h2><table><thead><tr><th style="text-align:center">cmd</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>u</code></td><td style="text-align:center"><strong>撤销</strong></td></tr><tr><td style="text-align:center"><code>ctrl + r</code></td><td style="text-align:center"><strong>重做</strong></td></tr><tr><td style="text-align:center"><code>.</code></td><td style="text-align:center"><strong>重复上一个动作</strong></td></tr></tbody></table><h1 id="末行模式"><a class="markdownIt-Anchor" href="#末行模式"></a> 末行模式</h1><p>只记录不熟悉的</p><table><thead><tr><th style="text-align:center">cmd</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>ZZ</code></td><td style="text-align:center">相当于 <code>wq</code></td></tr><tr><td style="text-align:center"><code>ZQ</code></td><td style="text-align:center">相当于 <code>q!</code></td></tr><tr><td style="text-align:center"><code>:w {filename}</code></td><td style="text-align:center">save as</td></tr><tr><td style="text-align:center"><code>:r {filename}</code></td><td style="text-align:center">将 <code>filename</code> 文件追加到光标后</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 内存模型</title>
    <link href="/2020/07/29/java-memory-model/"/>
    <url>/2020/07/29/java-memory-model/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Java</code> 内存模型（<code>Java Memory Model</code>），简称 <code>JMM</code>。</p><p><code>JVM</code> 中试图定义一种 <code>JMM</code> 来屏蔽各种硬件和操作系统的内存访问差异，以实现让 <code>Java</code> 程序在各种平台下都能达到一致的内存访问效果。</p></blockquote><h1 id="物理内存模型"><a class="markdownIt-Anchor" href="#物理内存模型"></a> 物理内存模型</h1><p>物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</p><h2 id="硬件处理效率"><a class="markdownIt-Anchor" href="#硬件处理效率"></a> 硬件处理效率</h2><p>物理内存的第一个问题是：硬件处理效率。</p><ul><li><p>绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少需要与<strong>内存交互</strong>，如读取运算数据、存储运算结果，这个 <code>I/O</code> 操作是很难消除的（无法仅靠寄存器完成所有运算任务）。</p></li><li><p><strong>由于计算机的存储设备与处理器的运算速度有几个数量级的差距</strong> ，这种速度上的矛盾，会降低硬件的处理效率。所以，现代计算机都不得不 <strong>加入高速缓存（Cache）</strong> 来作为内存和处理器之间的缓冲。将需要用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步会内存中，这样处理器就无需等待缓慢的内存读写了。</p></li></ul><h2 id="缓存一致性"><a class="markdownIt-Anchor" href="#缓存一致性"></a> 缓存一致性</h2><p>高速缓存解决了 硬件效率问题，但是引入了一个新的问题：缓存一致性（<code>Cache Coherence</code>）。</p><p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。</p><p>为了解决缓存一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200729160602.png" srcset="/img/loading.gif" alt="" /></p><h2 id="代码乱序执行优化"><a class="markdownIt-Anchor" href="#代码乱序执行优化"></a> 代码乱序执行优化</h2><p>除了高速缓存以外，为了使得处理器内部的运算单元尽量被充分利用，处理器可能会对输入代码进行乱序执行（<code>Out-Of-Order Execution</code>）优化。处理器会在计算之后将乱序执行的结果重组，<strong>保证该结果与顺序执行的结果是一致的</strong>，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200729160655.png" srcset="/img/loading.gif" alt="" /></p><p>乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化。</p><ul><li><p>单核环境下，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此。</p></li><li><p>多核环境下， 如果存在一个核的计算任务依赖另一个核的计算任务的中间结果，而且对相关数据读写没做任何防护措施，那么其顺序性并不能靠代码的先后顺序来保证。</p></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200729160753.png" srcset="/img/loading.gif" alt="" /></p><h1 id="java-内存模型"><a class="markdownIt-Anchor" href="#java-内存模型"></a> Java 内存模型</h1><p><strong>内存模型</strong> 这个概念。我们可以理解为：在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理计算机可以有不一样的内存模型，<code>JVM</code> 也有自己的内存模型。</p><p><code>JVM</code> 中试图定义一种 <code>Java</code> 内存模型（<code>Java Memory Model</code>, <code>JMM</code>）来<strong>屏蔽各种硬件和操作系统的内存访问差异</strong>，以实现让 <code>Java</code> 程序 <strong>在各种平台下都能达到一致的内存访问效果</strong>。<code>JMM</code> 决定一个线程对共享变量的写入何时对另一个线程可见。</p><h2 id="jvm-内存结构-vs-java-内存模型"><a class="markdownIt-Anchor" href="#jvm-内存结构-vs-java-内存模型"></a> JVM 内存结构 vs Java 内存模型</h2><ul><li><p><code>JVM</code> 内存结构，由 <code>Java</code> 虚拟机规范定义。描述的是 <code>Java</code> 程序执行过程中，由 <code>JVM</code> 管理的不同数据区域。各个区域有其特定的功能。</p></li><li><p><code>Java</code> 的多线程之间是通过<strong>共享内存</strong>进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、有序性等问题，而 <code>JMM</code> 就是围绕着<strong>多线程通信</strong>以及与其相关的一系列特性而建立的模型。</p></li><li><p><code>JMM</code> 并不像 <code>JVM</code> 内存结构一样是真实存在的，它只是一个抽象的概念。</p></li></ul><h2 id="主内存和工作内存"><a class="markdownIt-Anchor" href="#主内存和工作内存"></a> 主内存和工作内存</h2><p><code>JMM</code> 规定了所有的变量都存储在主内存（<code>Main Memory</code>）中。</p><p>每条线程还有自己的<strong>工作内存</strong>（<code>Working Memory</code>），工作内存中保留了该线程使用到的变量的<strong>主内存的副本</strong>。工作内存是 <code>JMM</code> 的一个抽象概念，并不真实存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200729161040.png" srcset="/img/loading.gif" alt="" /></p><p>线程对变量的<strong>所有操作都必须在工作内存中进行</strong>，而不能直接读写主内存中的变量。不同的线程间也无法直接访问对方工作内存中的变量，<strong>线程间变量值的传递均需要通过主内存来完成</strong>。</p><h2 id="jmm-内存操作的问题"><a class="markdownIt-Anchor" href="#jmm-内存操作的问题"></a> JMM 内存操作的问题</h2><ul><li><strong>工作内存数据一致性</strong> - 各个线程操作数据时会保存使用到的主内存中的共享变量副本，当多个线程的运算任务都涉及同一个共享变量时，将导致各自的的共享变量副本不一致。如果真的发生这种情况，数据同步回主内存以谁的副本数据为准？ <code>Java</code> 内存模型主要通过一系列的数据同步协议、规则来保证数据的一致性。</li><li><strong>指令重排序优化</strong> - <code>Java</code> 中重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：<strong>编译期重排序</strong>和<strong>运行期重排序</strong>，分别对应编译时和运行时环境。 同样的，指令重排序不是随意重排序，它需要满足以下两个条件：<ul><li>在单线程环境下不能改变程序运行的结果。即时编译器（和处理器）需要保证程序能够遵守 <code>as-if-serial</code> 属性。通俗地说，就是在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。</li><li>存在数据依赖关系的不允许重排序。</li><li>多线程环境下，如果线程处理逻辑之间存在依赖关系，有可能因为指令重排序导致运行结果与预期不同。</li></ul></li></ul><h1 id="java-内存模型规则"><a class="markdownIt-Anchor" href="#java-内存模型规则"></a> Java 内存模型规则</h1><h2 id="内存交互操作的三大特性"><a class="markdownIt-Anchor" href="#内存交互操作的三大特性"></a> 内存交互操作的三大特性</h2><p>Java 内存三大特性：原子性、可见性、有序性。</p><p>而这三大特性，归根结底，是为了实现多线程的 <strong>数据一致性</strong>，使得程序在多线程并发，指令重排序优化的环境中能如预期运行。</p><h3 id="原子性"><a class="markdownIt-Anchor" href="#原子性"></a> 原子性</h3><blockquote><p>原子性即一个操作或者多个操作，要么全部执行（执行的过程不会被任何因素打断），要么就都不执行。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。</p></blockquote><p>在 <code>Java</code> 中，为了保证原子性，提供了两个高级的字节码指令 <code>monitorenter</code> 和 <code>monitorexit</code>。这两个字节码，在 <code>Java</code> 中对应的关键字就是 <code>synchronized</code>。</p><p>因此，在 <code>Java</code> 中可以使用 <code>synchronized</code> 来保证方法和代码块内的操作是原子性的。</p><h3 id="可见性"><a class="markdownIt-Anchor" href="#可见性"></a> 可见性</h3><blockquote><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></blockquote><p>JMM 是通过 “<strong>变量修改后将新值同步回主内存， 变量读取前从主内存刷新变量值</strong>” 这种依赖主内存作为传递媒介的方式来实现的。</p><p><code>Java</code> 实现多线程可见性的方式有：</p><ul><li><p><code>volatile</code></p></li><li><p><code>synchronized</code></p></li><li><p><code>final</code></p></li></ul><h3 id="有序性"><a class="markdownIt-Anchor" href="#有序性"></a> 有序性</h3><p>有序性规则表现在以下两种场景: 线程内和线程间</p><ul><li><p><strong>线程内</strong> - 从某个线程的角度看方法的执行，指令会按照一种叫“串行”（<code>as-if-serial</code>）的方式执行，此种方式已经应用于顺序编程语言。</p></li><li><p><strong>线程间</strong> - 这个线程“观察”到其他线程并发地执行非同步的代码时，由于指令重排序优化，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块（<code>synchronized</code> 关键字修饰）以及 <code>volatile</code> 字段的操作仍维持相对有序。</p></li></ul><p>在 Java 中，可以使用 <code>synchronized</code> 和 <code>volatile</code> 来保证多线程之间操作的有序性。实现方式有所区别：</p><ul><li><p><code>volatile</code> 关键字会禁止指令重排序。</p></li><li><p><code>synchronized</code> 关键字通过互斥保证同一时刻只允许一条线程操作。</p></li></ul><h2 id="happens-before-原则"><a class="markdownIt-Anchor" href="#happens-before-原则"></a> Happens-Before 原则</h2><blockquote><p>在 <code>JMM</code> 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 <code>happens-before</code> 关系。</p></blockquote><ul><li><p><strong>程序次序规则</strong> - 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。</p></li><li><p><strong>管程锁定规则</strong> - 一个 <code>unLock</code> 操作先行发生于后面对同一个锁的 <code>lock</code> 操作。</p></li><li><p><strong><code>volatile</code> 变量规则</strong> - 对一个 <code>volatile</code> 变量的写操作先行发生于后面对这个变量的读操作。</p></li><li><p><strong>线程启动规则</strong> - <code>Thread</code> 对象的 <code>start()</code> 方法先行发生于此线程的每个一个动作。</p></li><li><p><strong>线程终止规则</strong> - 线程中所有的操作都先行发生于线程的终止检测，我们可以通过 <code>Thread.join()</code> 方法结束、<code>Thread.isAlive()</code> 的返回值手段检测到线程已经终止执行。</p></li><li><p><strong>线程中断规则</strong> - 对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 <code>Thread.interrupted()</code>方法检测到是否有中断发生。</p></li><li><p><strong>对象终结规则</strong> - 一个对象的初始化完成先行发生于它的 <code>finalize()</code> 方法的开始。</p></li><li><p><strong>传递性</strong> - 如果操作 <code>A</code> 先行发生于 操作 <code>B</code>，而操作 <code>B</code> 又 先行发生于 操作 <code>C</code>，则可以得出操作 <code>A</code> 先行发生于 操作 <code>C</code>。</p></li></ul><h2 id="内存屏障"><a class="markdownIt-Anchor" href="#内存屏障"></a> 内存屏障</h2><p><code>Java</code> 中如何保证底层操作的<strong>有序性</strong>和<strong>可见性</strong>？可以通过内存屏障。</p><p>内存屏障是被插入两个 <code>CPU</code> 指令之间的一种指令，<strong>用来禁止处理器指令发生重排序</strong>（像屏障一样），从而保障有序性的。另外，为了达到屏障的效果，它也会<strong>使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列</strong>，从而保障可见性。</p><p>举个例子：</p><pre><code class="hljs bash">Store1;Store2;Load1;StoreLoad;  // 内存屏障Store3;Load2;Load3;</code></pre><p>对于上面的一组 <code>CPU</code> 指令，<code>StoreLoad</code> 屏障之前的 <code>Store</code> 指令无法与 <code>StoreLoad</code> 屏障之后的 <code>Load</code> 指令进行交换位置，即<strong>重排序</strong>。但是 <code>StoreLoad</code> 屏障之前和之后的指令是可以互换位置的，即 <code>Store1</code> 可以和 <code>Store2</code> 互换，<code>Load2</code> 可以和 <code>Load3</code> 互换。</p><p>常见有 4 种屏障</p><ul><li><p><strong><code>LoadLoad</code> 屏障</strong> - 对于这样的语句 <code>Load1; LoadLoad; Load2</code>，在 <code>Load2</code> 及后续读取操作要读取的数据被访问前，保证 <code>Load1</code> 要读取的数据被读取完毕。</p></li><li><p><strong><code>StoreStore</code> 屏障</strong> - 对于这样的语句 <code>Store1; StoreStore; Store2</code>，在 <code>Store2</code> 及后续写入操作执行前，保证 <code>Store1</code> 的写入操作对其它处理器可见。</p></li><li><p><strong><code>LoadStore</code> 屏障</strong> - 对于这样的语句 <code>Load1; LoadStore; Store2</code>，在 <code>Store2</code> 及后续写入操作被执行前，保证 <code>Load1</code> 要读取的数据被读取完毕。</p></li><li><p><strong><code>StoreLoad</code> 屏障</strong> - 对于这样的语句 <code>Store1; StoreLoad; Load2</code>，在 <code>Load2</code> 及后续所有读取操作执行前，保证 <code>Store1</code> 的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p></li></ul><p><code>Java</code> 中对内存屏障的使用在一般的代码中不太容易见到，常见的有 <code>volatile</code> 和 <code>synchronized</code> 关键字修饰的代码块，还可以通过 <code>Unsafe</code> 这个类来使用内存屏障。</p><h2 id="volatile-变量的特殊规则"><a class="markdownIt-Anchor" href="#volatile-变量的特殊规则"></a> volatile 变量的特殊规则</h2><p><code>volatile</code> 是 <code>JVM</code> 提供的 <strong>最轻量级的同步机制</strong>。</p><p>特性：</p><ul><li>保证变量对所有线程的可见性。</li><li>禁止进行指令重排序</li></ul><h3 id="保证变量对所有线程的可见性"><a class="markdownIt-Anchor" href="#保证变量对所有线程的可见性"></a> 保证变量对所有线程的可见性</h3><p>这里的可见性是指当一条线程修改了 <code>volatile</code> 变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。</p><p>线程写 <code>volatile</code> 变量的过程：</p><ol><li>改变线程工作内存中 <code>volatile</code> 变量副本的值</li><li>将改变后的副本的值从工作内存刷新到主内存</li></ol><p>线程读 <code>volatile</code> 变量的过程：</p><ul><li>从主内存中读取 <code>volatile</code> 变量的最新值到线程的工作内存中</li><li>从工作内存中读取 <code>volatile</code> 变量的副本</li></ul><p>但是如果多个线程同时把更新后的变量值同时刷新回主内存，可能导致得到的值不是预期结果：</p><h3 id="禁止进行指令重排序"><a class="markdownIt-Anchor" href="#禁止进行指令重排序"></a> 禁止进行指令重排序</h3><ul><li><p>当程序执行到 <code>volatile</code> 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p></li><li><p>在进行指令优化时，不能将在对 <code>volatile</code> 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。</p></li></ul><h3 id="volatile-的原理"><a class="markdownIt-Anchor" href="#volatile-的原理"></a> volatile 的原理</h3><p>具体实现方式是在编译期生成字节码时，会<strong>在指令序列中增加内存屏障</strong>来保证，下面是基于保守策略的 <code>JMM</code> 内存屏障插入策略：</p><ul><li><p>在每个 <code>volatile</code> 写操作的前面插入一个 <code>StoreStore</code> 屏障。 该屏障除了保证了屏障之前的写操作和该屏障之后的写操作不能重排序，还会保证了 <code>volatile</code> 写操作之前，任何的读写操作都会先于 <code>volatile</code> 被提交。</p></li><li><p>在每个 <code>volatile</code> 写操作的后面插入一个 <code>StoreLoad</code> 屏障。 该屏障除了使 <code>volatile</code> 写操作不会与之后的读操作重排序外，还会刷新处理器缓存，使 <code>volatile</code> 变量的写更新对其他线程可见。</p></li><li><p>在每个 <code>volatile</code> 读操作的前面插入一个 <code>LoadLoad</code> 屏障。 该屏障除了使 <code>volatile</code> 读操作不会与之前的写操作发生重排序外，还会刷新处理器缓存，使 <code>volatile</code> 变量读取的为最新值。</p></li><li><p>在每个 <code>volatile</code> 读操作的后面插入一个 <code>LoadStore</code> 屏障。 该屏障除了禁止了 <code>volatile</code> 读操作与其之后的任何写操作进行重排序，还会刷新处理器缓存，使其他线程 <code>volatile</code> 变量的写更新对 <code>volatile</code> 读操作的线程可见。</p></li></ul><h3 id="volatile-的使用场景"><a class="markdownIt-Anchor" href="#volatile-的使用场景"></a> volatile 的使用场景</h3><p>总结起来，就是“一次写入，到处读取”，某一线程负责更新变量，其他线程只读取变量(不更新变量)，并根据变量的新值执行相应逻辑。例如状态标志位更新，观察者模型变量值发布。</p><h2 id="long-和-double-变量的特殊规则"><a class="markdownIt-Anchor" href="#long-和-double-变量的特殊规则"></a> long 和 double 变量的特殊规则</h2><p><code>JMM</code> 要求 <code>lock</code>、<code>unlock</code>、<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>、<code>write</code> 这 8 种操作都具有原子性，但是对于 64 位的数据类型（<code>long</code> 和 <code>double</code>），在模型中特别定义相对宽松的规定：允许虚拟机将没有被 <code>volatile</code> 修饰的 64 位数据的读写操作分为 2 次 32 位的操作来进行，即允许虚拟机可选择不保证 64 位数据类型的 <code>load</code>、<code>store</code>、<code>read</code> 和 <code>write</code> 这 4 个操作的原子性。由于这种非原子性，有可能导致其他线程读到同步未完成的“32 位的半个变量”的值。</p><p>不过实际开发中，<code>Java</code> 内存模型强烈建议虚拟机把 64 位数据的读写实现为具有原子性，目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的 <code>long</code> 和 <code>double</code> 变量专门声明为 <code>volatile</code>。</p><h2 id="final-型变量的特殊规则"><a class="markdownIt-Anchor" href="#final-型变量的特殊规则"></a> final 型变量的特殊规则</h2><p>我们知道，<code>final</code> 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。 <code>fina</code> 关键字的可见性是指：被 <code>final</code> 修饰的字段在声明时或者构造器中，一旦初始化完成，那么在其他线程无须同步就能正确看见 <code>final</code> 字段的值。这是因为一旦初始化完成，<code>final</code> 变量的值立刻回写到主内存。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发-工具类</title>
    <link href="/2020/07/28/concurrent-utils/"/>
    <url>/2020/07/28/concurrent-utils/</url>
    
    <content type="html"><![CDATA[<h1 id="countdownlatch"><a class="markdownIt-Anchor" href="#countdownlatch"></a> CountDownLatch</h1><blockquote><p><code>CountDownLatch</code> 维护一个计数器 <code>count</code>，表示需要等待的事件数量。<code>countDown()</code> 方法递减计数器，表示有一个事件已经发生。调用 <code>await()</code> 方法的线程会一直阻塞直到<strong>计数器为零</strong>，或者等待中的<strong>线程中断</strong>，或者<strong>等待超时</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200728155654.png" srcset="/img/loading.gif" alt="" /></p><p><code>CountDownLatch</code> 是基于 <code>AQS</code> 实现的。</p><p><code>CountDownLatch</code> 唯一的构造方法：</p><pre><code class="hljs java"><span class="hljs-comment">// count 计数器</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CountDownLatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"count &lt; 0"</span>);        <span class="hljs-keyword">this</span>.sync = <span class="hljs-keyword">new</span> Sync(count);&#125;</code></pre><p><code>CountDownLatch</code> 的重要方法：</p><pre><code class="hljs java"><span class="hljs-comment">// 等待直到 count 值为 0  才继续执行或当前线程被中断</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123; &#125;;<span class="hljs-comment">// 和 await() 类似，只不过等待一定的时间后 count 值还没变为 0 的话就会继续执行</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123; &#125;;<span class="hljs-comment">// 将统计值 count 减 1</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countDown</span><span class="hljs-params">()</span> </span>&#123; &#125;;</code></pre><h1 id="cyclicbarrier"><a class="markdownIt-Anchor" href="#cyclicbarrier"></a> CyclicBarrier</h1><blockquote><p>字面意思是 循环栅栏。<code>CyclicBarrier</code> 可以让<strong>一组线程</strong>等待至某个状态（遵循字面意思，不妨称这个状态为栅栏）之后再全部同时执行。之所以叫循环栅栏是因为：当所有等待线程都被释放以后，<code>CyclicBarrier</code> 可以被重用。</p><p><code>CyclicBarrier</code> 维护一个计数器 <code>count</code>。每次执行 <code>await</code> 方法之后，<code>count</code> 加 1，直到计数器的值和设置的值相等，等待的所有线程才会继续执行。</p></blockquote><ul><li><p><code>CyclicBarrier</code> 是基于 <code>ReentrantLock</code> 和 <code>Condition</code> 实现的。</p></li><li><p><code>CyclicBarrier</code> 应用场景：<code>CyclicBarrier</code> 在并行迭代算法中非常有用。</p></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200728160917.png" srcset="/img/loading.gif" alt="" /></p><p><code>CyclicBarrier</code> 提供了 2 个构造方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;&#125;</code></pre><ul><li><p><code>parties</code> - <code>parties</code> 数相当于一个阈值，当有 <code>parties</code> 数量的线程在等待时， <code>CyclicBarrier</code> 处于栅栏状态。</p></li><li><p><code>barrierAction</code> - 当 <code>CyclicBarrier</code> 处于栅栏状态时执行的动作。</p></li></ul><p>重要方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException,</span><span class="hljs-function">               BrokenBarrierException,</span><span class="hljs-function">               TimeoutException </span>&#123;&#125;<span class="hljs-comment">// 将屏障重置为初始状态</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;&#125;</code></pre><ul><li><p><code>await()</code> - 等待调用 <code>await()</code> 的线程数达到屏障数。如果当前线程是最后一个到达的线程，并且在构造函数中提供了非空屏障操作，则当前线程在允许其他线程继续之前运行该操作。如果在屏障动作期间发生异常，那么该异常将在当前线程中传播并且屏障被置于断开状态。</p></li><li><p><code>await(long timeout, TimeUnit unit)</code> - 相比于 <code>await()</code> 方法，这个方法让这些线程等待至一定的时间，如果还有线程没有到达栅栏状态就直接让到达栅栏状态的线程执行后续任务。</p></li><li><p><code>reset()</code> - 将屏障重置为初始状态。</p></li></ul><h1 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore"></a> Semaphore</h1><blockquote><p>字面意思为 <strong>信号量</strong>。<code>Semaphore</code> 用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。</p></blockquote><p><code>Semaphore</code> 管理着一组虚拟的许可（<code>permit</code>），<code>permit</code> 的初始数量可通过构造方法来指定。每次执行 <code>acquire</code> 方法可以获取一个 <code>permit</code>，如果没有就等待；而 <code>release</code> 方法可以释放一个 <code>permit</code>。</p><p><code>Semaphore</code> 应用场景：</p><ul><li><p><code>Semaphore</code> 可以用于实现资源池，如数据库连接池。</p></li><li><p><code>Semaphore</code> 可以用于将任何一种容器变成有界阻塞容器。</p></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200728162824.png" srcset="/img/loading.gif" alt="" /></p><p><code>Semaphore</code> 提供了 2 个构造方法：</p><pre><code class="hljs java"><span class="hljs-comment">// 初始化固定数量的 permit，并且默认为非公平模式。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Semaphore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits)</span> </span>&#123;&#125;<span class="hljs-comment">// 设置是否为公平模式。所谓公平，是指等待久的优先获取 permit。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Semaphore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;&#125;</code></pre><p>重要方法：</p><pre><code class="hljs java"><span class="hljs-comment">// 获取 1 个许可</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;&#125;<span class="hljs-comment">//获取 permits 个许可</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;&#125;<span class="hljs-comment">// 释放 1 个许可</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">//释放 permits 个许可</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits)</span> </span>&#123;&#125;</code></pre><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li><p><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 都能够实现线程之间的等待，只不过它们侧重点不同：</p><ul><li><p><code>CountDownLatch</code> 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；</p></li><li><p><code>CyclicBarrier</code> 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p></li><li><p>另外，<code>CountDownLatch</code> 是不可以重用的，而 <code>CyclicBarrier</code> 是可以重用的。</p></li></ul></li><li><p><code>Semaphore</code> 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>工具类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发-线程池</title>
    <link href="/2020/07/27/concurrent-threadpool/"/>
    <url>/2020/07/27/concurrent-threadpool/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><blockquote><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。</p></blockquote><p>如果并发请求数量很多，但每个线程执行的时间很短，就会出现频繁的创建和销毁线程。如此一来，会大大降低系统的效率，可能频繁创建和销毁线程的时间、资源开销要大于实际工作的所需。</p><p>正是由于这个问题，所以有必要引入线程池。使用 <strong>线程池的好处</strong> 有以下几点：</p><ul><li><p><strong>降低资源消耗</strong> - 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p></li><li><p><strong>提高响应速度</strong> - 当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p><strong>提高线程的可管理性</strong> - 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p></li></ul><h1 id="executor-框架"><a class="markdownIt-Anchor" href="#executor-框架"></a> <code>Executor</code> 框架</h1><h2 id="简介-2"><a class="markdownIt-Anchor" href="#简介-2"></a> 简介</h2><p><code>Executor</code> 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。</p><p>还有关键的一点：有助于避免 <code>this</code> 逃逸问题。</p><blockquote><p><code>this</code> 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><h2 id="框架结构"><a class="markdownIt-Anchor" href="#框架结构"></a> 框架结构</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727102933.png" srcset="/img/loading.gif" alt="" /></p><h3 id="1-任务runnable-callable"><a class="markdownIt-Anchor" href="#1-任务runnable-callable"></a> 1. 任务(<code>Runnable</code> / <code>Callable</code>)</h3><p>执行任务需要实现的 <code>Runnable</code> 接口 或 <code>Callable</code> 接口。他们的实现类都可以被 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。</p><h3 id="2-任务的执行executor"><a class="markdownIt-Anchor" href="#2-任务的执行executor"></a> 2. 任务的执行(<code>Executor</code>)</h3><p>任务执行机制的核心接口 <code>Executor</code> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。<br /><code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 这两个关键类实现了 <code>ExecutorService</code> 接口。</p><h4 id="21-executor"><a class="markdownIt-Anchor" href="#21-executor"></a> 2.1 <code>Executor</code></h4><p><code>Executor</code> 接口中只定义了一个 <code>execute</code> 方法，用于接收一个 <code>Runnable</code> 对象。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;&#125;</code></pre><h4 id="22-executorservice"><a class="markdownIt-Anchor" href="#22-executorservice"></a> 2.2 <code>ExecutorService</code></h4><p><code>ExecutorService</code> 接口继承了 <code>Executor</code> 接口，它还提供了 <code>invokeAll</code>、<code>invokeAny</code>、<code>shutdown</code>、<code>submit</code> 等方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Executor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException</span>;    &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;    &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span></span>;    Future&lt;?&gt; submit(Runnable task);    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        <span class="hljs-keyword">throws</span> InterruptedException;    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                  <span class="hljs-keyword">long</span> timeout, TimeUnit unit)        <span class="hljs-keyword">throws</span> InterruptedException;    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;&#125;</code></pre><p>比于 <code>Executor</code> 接口，<code>ExecutorService</code> 接口主要的扩展是：</p><ul><li>支持有返回值的线程 - <code>sumbit</code>、<code>invokeAll</code>、<code>invokeAny</code> 方法中都支持传入 <code>Callable</code> 对象。</li><li>支持管理线程生命周期 - <code>shutdown</code>、<code>shutdownNow</code>、<code>isShutdown</code> 等方法。</li></ul><h4 id="23-scheduledexecutorservice"><a class="markdownIt-Anchor" href="#23-scheduledexecutorservice"></a> 2.3 <code>ScheduledExecutorService</code></h4><p><code>ScheduledExecutorService</code> 接口扩展了 <code>ExecutorService</code> 接口。</p><p>它除了支持前面两个接口的所有能力以外，还支持定时调度线程。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ScheduledExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExecutorService</span> </span>&#123;    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-keyword">long</span> delay, TimeUnit unit);    <span class="hljs-keyword">public</span> &lt;V&gt; <span class="hljs-function">ScheduledFuture&lt;V&gt; <span class="hljs-title">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable, <span class="hljs-keyword">long</span> delay, TimeUnit unit)</span></span>;    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,                                                  <span class="hljs-keyword">long</span> initialDelay,                                                  <span class="hljs-keyword">long</span> period,                                                  TimeUnit unit);    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,                                                     <span class="hljs-keyword">long</span> initialDelay,                                                     <span class="hljs-keyword">long</span> delay,                                                     TimeUnit unit);&#125;</code></pre><p>其扩展的接口提供以下能力：</p><ul><li><p><code>schedule</code> 方法可以在指定的延时后执行一个 <code>Runnable</code> 或者 <code>Callable</code> 任务。</p></li><li><p><code>scheduleAtFixedRate</code> 方法和 <code>scheduleWithFixedDelay</code> 方法可以按照指定时间间隔，定期执行任务。</p></li></ul><h3 id="3-异步计算的结果future"><a class="markdownIt-Anchor" href="#3-异步计算的结果future"></a> 3. 异步计算的结果(<code>Future</code>)</h3><blockquote><p><code>Future</code> 接口以及 <code>Future</code> 接口的实现类 <code>FutureTask</code> 类都可以代表异步计算的结果。</p></blockquote><p>当我们把 <code>Runnable</code> 接口或 <code>Callable</code> 接口的实现类提交给 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行，调用 <code>submit()</code> 方法时会返回一个 <code>FutureTask</code> 对象，可通过 <code>FutureTask.get()</code> 捕获抛出的异常。</p><h2 id="executor-框架的使用示意图"><a class="markdownIt-Anchor" href="#executor-框架的使用示意图"></a> <code>Executor</code> 框架的使用示意图</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727105429.png" srcset="/img/loading.gif" alt="" /></p><ul><li><p>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</p></li><li><p>把创建完成的实现 <code>Runnable</code> / <code>Callable</code> 接口的对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit(Runnable task)</code>或 <code>ExecutorService.submit(Callable &lt;T&gt; task)</code>）。</p></li><li><p>如果执行 <code>ExecutorService.submit(...)</code>，<code>ExecutorService</code> 将返回一个实现 <code>Future</code> 接口的对象。由于 <code>FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</p></li><li><p>最后，主线程可以执行 <code>FutureTask.get()</code> 方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel(boolean mayInterruptIfRunning)</code>来取消此任务的执行。</p></li></ul><h1 id="threadpoolexecutor"><a class="markdownIt-Anchor" href="#threadpoolexecutor"></a> <code>ThreadPoolExecutor</code></h1><h2 id="使用示例"><a class="markdownIt-Anchor" href="#使用示例"></a> 使用示例</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : ThreadPoolTest.java 2020/07/27 Mon 3:29 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolTest</span> </span>&#123;    <span class="hljs-comment">// 核心线程数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CORE_POOL_SIZE = <span class="hljs-number">5</span>;    <span class="hljs-comment">// 最大线程数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_POOL_SIZE = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 任务队列容量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> QUEUE_CAPACITY = <span class="hljs-number">100</span>;    <span class="hljs-comment">// 等待时间</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> KEEP_ALIVE_TIME = <span class="hljs-number">1L</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建线程池</span>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                CORE_POOL_SIZE,                MAX_POOL_SIZE,                KEEP_ALIVE_TIME,                TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),                <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">// 执行工作线程</span>            Runnable worker = <span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-string">""</span> + i);            executor.execute(worker);            String info = String.format(<span class="hljs-string">"线程池中线程数目：%s，队列中等待执行的任务数目：%s，已执行完的任务数目：%s"</span>,                    executor.getPoolSize(),                    executor.getQueue().size(),                    executor.getCompletedTaskCount());            System.out.println(info);        &#125;        <span class="hljs-comment">// 终止线程池</span>        executor.shutdown();        <span class="hljs-keyword">while</span> (!executor.isTerminated()) &#123;        &#125;        System.out.println(<span class="hljs-string">"Finish all threads"</span>);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 工作线程类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> String cmd;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRunnable</span><span class="hljs-params">(String cmd)</span> </span>&#123;        <span class="hljs-keyword">this</span>.cmd = cmd;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" Start time = "</span> + <span class="hljs-keyword">new</span> Date());        processCmd();        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" End time = "</span> + <span class="hljs-keyword">new</span> Date());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCmd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">2000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"MyRunnable&#123;"</span> +                <span class="hljs-string">"cmd='"</span> + cmd + <span class="hljs-string">'\''</span> +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre><h2 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h2><p><code>ThreadPoolExecutor</code> 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, // 线程池的核心线程数量</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize, // 线程池的最大线程数</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime, // 当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit, // 时间单位</span></span><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列，用来储存等待执行任务的队列</span></span><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory, // 线程工厂，用来创建线程，一般默认即可</span></span><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler // 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><span class="hljs-function"><span class="hljs-params">                           )</span> </span>&#123;    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;    <span class="hljs-keyword">this</span>.workQueue = workQueue;    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;    <span class="hljs-keyword">this</span>.handler = handler;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727145107.png" srcset="/img/loading.gif" alt="" /></p><p>参数说明：</p><ol><li><p><code>corePoolSize</code> - <strong>核心线程数量</strong>。当有新任务通过 <code>execute</code> 方法提交时 ，线程池会执行以下判断：</p><ul><li>如果运行的线程数少于 <code>corePoolSize</code>，则创建新线程来处理任务，即使线程池中的其他线程是空闲的。</li><li>如果线程池中的线程数量大于等于 <code>corePoolSize</code> 且小于 <code>maximumPoolSize</code>，则只有当 <code>workQueue</code> 满时才创建新的线程去处理任务，否则将任务存储在队列里；</li><li>如果设置的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 相同，则创建的线程池的大小是固定的。这时如果有新任务提交，若 <code>workQueue</code> 未满，则将请求放入 <code>workQueue</code> 中，等待有空闲的线程去从 <code>workQueue</code> 中取任务并处理；</li><li>如果运行的线程数量大于等于 <code>maximumPoolSize</code>，这时如果 <code>workQueue</code> 已经满了，则使用 <code>handler</code> 所指定的策略来处理任务；</li><li>所以，任务提交时，判断的顺序为 <code>corePoolSize</code> =&gt; <code>workQueue</code> =&gt; <code>maximumPoolSize</code>。</li></ul></li><li><p><code>maximumPoolSize</code> - <strong>最大线程数量</strong>。</p><ul><li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</li><li>值得注意的是：如果使用了无界的任务队列这个参数就没什么效果。</li></ul></li><li><p><code>keepAliveTime</code> - <strong>线程保持活动的时间</strong>。</p><ul><li>当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>。</li><li>所以，如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li></ul></li><li><p><code>unit</code> - <strong><code>keepAliveTime</code> 的时间单位</strong>。<br />有 7 种取值。可选的单位有天（<code>DAYS</code>），小时（<code>HOURS</code>），分钟（<code>MINUTES</code>），毫秒(<code>MILLISECONDS</code>)，微秒(<code>MICROSECONDS</code>, 千分之一毫秒)和毫微秒(<code>NANOSECONDS</code>, 千分之一微秒)。</p></li><li><p><code>workQueue</code> - <strong>等待执行的任务队列</strong>。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。</p><ul><li><p><code>ArrayBlockingQueue</code> - <strong>有界阻塞队列</strong>。</p><ul><li>此队列是基于<strong>数组</strong>的先进先出队列（<code>FIFO</code>）。</li><li>创建时必须指定大小。</li></ul></li><li><p><code>LinkedBlockingQueue</code> - <strong>无界阻塞队列</strong>。</p><ul><li>此队列是基于<strong>链表</strong>的先进先出队列（<code>FIFO</code>）。</li><li>如果创建时没有指定此队列大小，则默认为 <code>Integer.MAX_VALUE</code>。</li><li>吞吐量通常要高于 <code>ArrayBlockingQueue</code>。</li><li>使用 <code>LinkedBlockingQueue</code> 意味着： <code>maximumPoolSize</code> 将不起作用，线程池能创建的最大线程数为 <code>corePoolSize</code>，因为任务等待队列是无界队列。</li><li><code>Executors.newFixedThreadPool</code> 使用了这个队列。</li></ul></li><li><p><code>SynchronousQueue</code> - <strong>不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</strong></p><ul><li>每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。</li><li>吞吐量通常要高于 <code>LinkedBlockingQueue</code>。</li><li><code>Executors.newCachedThreadPool</code> 使用了这个队列。</li></ul></li></ul></li><li><p><code>threadFactory</code> - <strong>线程工厂</strong>。可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</p></li><li><p><code>handler</code> - <strong>饱和策略</strong>。它是 <code>RejectedExecutionHandler</code> 类型的变量。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。线程池支持以下策略：</p><ul><li><p><code>AbortPolicy</code> - 抛出  <code>RejectedExecutionException</code> 来拒绝新任务的处理。这也是默认策略。</p></li><li><p><code>DiscardPolicy</code> - 丢弃任务，但不抛出异常。</p></li><li><p><code>DiscardOldestPolicy</code> - 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。</p></li><li><p><code>CallerRunsPolicy</code> - 只用调用者所在的线程来运行任务。</p></li><li><p>如果以上策略都不能满足需要，也可以通过实现           <code>RejectedExecutionHandler</code> 接口来定制处理策略。如记录日志或持久化不能处理的任务。</p></li></ul></li></ol><p>工作流程如下图：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727145919.png" srcset="/img/loading.gif" alt="" /></p><h2 id="execute-方法"><a class="markdownIt-Anchor" href="#execute-方法"></a> <code>execute</code> 方法</h2><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</p><p>提交任务可以使用 <code>execute</code> 方法，它是 <code>ThreadPoolExecutor</code> 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p><p><code>execute</code> 方法工作流程如下：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727162758.png" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs java"><span class="hljs-comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>)); <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;     <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125; <span class="hljs-comment">// 任务队列</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;     <span class="hljs-comment">// 如果任务为 null，则抛出异常。</span>     <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();     <span class="hljs-comment">// ctl 中保存的线程池当前的一些状态信息</span>     <span class="hljs-keyword">int</span> c = ctl.get();     <span class="hljs-comment">//  下面会涉及到 3 步 操作</span>     <span class="hljs-comment">// 1.首先判断当前线程池中之行的任务数量是否小于  corePoolSize</span>     <span class="hljs-comment">// 如果小于的话，则创建新的核心线程并且执行传入的任务</span>     <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;         <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))             <span class="hljs-comment">// 如果创建新的核心线程成功则直接返回</span>             <span class="hljs-keyword">return</span>;         <span class="hljs-comment">// 这里说明创建核心线程失败，需要更新 ctl 的临时变量 c</span>         c = ctl.get();     &#125;     <span class="hljs-comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span>     <span class="hljs-comment">// 判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务</span>     <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;         <span class="hljs-keyword">int</span> recheck = ctl.get();         <span class="hljs-comment">// 二次检查线程池状态。如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span>         <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))             <span class="hljs-comment">// 调用拒绝策略处理任务 - 返回</span>             reject(command);             <span class="hljs-comment">// 如果当前线程池为空就新创建一个线程并执行。</span>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)             addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);     &#125;     <span class="hljs-comment">// 3. 如果任务不能加入任务队列，则会尝试创建非核心线程传入任务执行</span>     <span class="hljs-comment">// 创建非核心线程失败，此时需要拒绝执行任务</span>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))         <span class="hljs-comment">// 调用拒绝策略处理任务 - 返回</span>         reject(command); &#125;</code></pre><p>关于二次检查线程池运行状态：</p><blockquote><p>如果一个任务成功加入任务队列，我们依然需要二次检查是否需要添加一个工作线程（因为所有存活的工作线程有可能在最后一次检查之后已经终结）或者执行当前方法的时候线程池是否已经终结了。所以我们需要二次检查线程池的状态，必须时把任务从任务队列中移除或者在没有可用的工作线程的前提下新建一个工作线程。</p></blockquote><h2 id="其他重要方法"><a class="markdownIt-Anchor" href="#其他重要方法"></a> 其他重要方法</h2><ul><li><code>submit</code> 类似于 <code>execute</code>，但是针对的是有返回值的线程。<code>submit</code> 方法是在 <code>ExecutorService</code> 中声明的方法，在 <code>AbstractExecutorService</code> 就已经有了具体的实现。<code>ThreadPoolExecutor</code> 直接复用 <code>AbstractExecutorService</code> 的 <code>submit</code> 方法。</li><li><code>shutdown</code> - 不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</li><li><code>shutdownNow</code> - 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</li><li><code>isShutdown</code> - 调用了 <code>shutdown</code> 或 <code>shutdownNow</code> 方法后，<code>isShutdown</code> 方法就会返回 <code>true</code>。</li><li><code>isTerminaed</code> - 当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 <code>isTerminaed</code> 方法会返回 <code>true</code>。</li></ul><h1 id="scheduledthreadpoolexecutor"><a class="markdownIt-Anchor" href="#scheduledthreadpoolexecutor"></a> <code>ScheduledThreadPoolExecutor</code></h1><p><code>ScheduledThreadPoolExecutor</code> 主要用来在给定的延迟后运行任务，或者定期执行任务。 这个在实际项目中基本不会被用到，因为有其他方案选择比如 <code>quartz</code>。</p><h2 id="简介-3"><a class="markdownIt-Anchor" href="#简介-3"></a> 简介</h2><p><code>ScheduledThreadPoolExecutor</code> 使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</p><h2 id="运行机制"><a class="markdownIt-Anchor" href="#运行机制"></a> 运行机制</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727200044.png" srcset="/img/loading.gif" alt="" /></p><p><code>ScheduledThreadPoolExecutor</code> 的执行主要分为两大部分：</p><ul><li><p>当调用 <code>ScheduledThreadPoolExecutor</code> 的 <code>scheduleAtFixedRate()</code> 方法或者 <code>scheduleWirhFixedDelay()</code> 方法时，会向 <code>ScheduledThreadPoolExecutor</code> 的 <code>DelayQueue</code> 添加一个实现了 <code>RunnableScheduledFuture</code> 接口的 <code>ScheduledFutureTask</code> 。</p></li><li><p>线程池中的线程从 <code>DelayQueue</code> 中获取 <code>ScheduledFutureTask</code>，然后执行任务。</p></li></ul><p><code>ScheduledThreadPoolExecutor</code> 为了实现周期性的执行任务，对 <code>ThreadPoolExecutor</code> 做了如下修改：</p><ul><li><p>使用 <code>DelayQueue</code> 作为任务队列；</p></li><li><p>获取任务的方不同</p></li><li><p>执行周期任务后，增加了额外的处理</p></li></ul><h2 id="执行周期任务的步骤"><a class="markdownIt-Anchor" href="#执行周期任务的步骤"></a> 执行周期任务的步骤</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727200325.png" srcset="/img/loading.gif" alt="" /></p><ul><li><p>线程 1 从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask</code>（<code>DelayQueue.take()</code>）。到期任务是指 <code>ScheduledFutureTask</code> 的 <code>time</code> 大于等于当前系统的时间；</p></li><li><p>线程 1 执行这个 <code>ScheduledFutureTask</code>；</p></li><li><p>线程 1 修改 <code>ScheduledFutureTask</code> 的 <code>time</code> 变量为下次将要被执行的时间；</p></li><li><p>线程 1 把这个修改 <code>time</code> 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中 (<code>DelayQueue.add()</code>)。</p></li></ul><h1 id="常见线程池"><a class="markdownIt-Anchor" href="#常见线程池"></a> 常见线程池</h1><p><code>JDK</code> 的 <code>Executors</code> 类中提供了几种具有代表性的线程池，这些线程池 都是基于 <code>ThreadPoolExecutor</code> 的定制化实现。</p><blockquote><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p></blockquote><h2 id="创建线程池方式"><a class="markdownIt-Anchor" href="#创建线程池方式"></a> 创建线程池方式</h2><ol><li>通过 <code>ThreadPoolExecutor</code> 构造函数实现（推荐）</li><li>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现 我们可以创建三种类型的 <code>ThreadPoolExecutor</code><ul><li><code>FixedThreadPool</code></li><li><code>SingleThreadExecutor</code></li><li><code>CachedThreadPool</code></li></ul></li></ol><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 <code>OOM</code>。</li><li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 <code>OOM</code>。</li></ul><h2 id="fixedthreadpool"><a class="markdownIt-Anchor" href="#fixedthreadpool"></a> <code>FixedThreadPool</code></h2><p>创建一个<strong>固定大小</strong>的线程池。</p><p>每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中。</p><p><code>FixedThreadPool</code> 是一个典型且优秀的线程池，它具有线程池<strong>提高程序效率</strong>和<strong>节省创建线程时所耗的开销</strong>的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p><pre><code class="hljs java"> <span class="hljs-comment">/**</span><span class="hljs-comment">  * 创建一个可重用固定数量线程的线程池</span><span class="hljs-comment">  */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(        nThreads,        nThreads,        <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,        <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),        threadFactory);    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727191728.png" srcset="/img/loading.gif" alt="" /></p><p>上图说明：</p><ul><li><p>如果当前运行的线程数小于 <code>corePoolSize</code>， 如果再来新任务的话，就创建新的线程来执行任务；</p></li><li><p>当前运行的线程数等于 <code>corePoolSize</code> 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</p></li><li><p>线程池中的线程执行完 手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</p></li></ul><p><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 <code>Intger.MAX_VALUE</code>）作为线程池的工作队列会对线程池带来如下影响 ：</p><ul><li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code>corePoolSize</code></li><li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况</li><li>使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数</li><li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code> 或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 <code>OOM</code></li></ul><h2 id="singlethreadexecutor"><a class="markdownIt-Anchor" href="#singlethreadexecutor"></a> <code>SingleThreadExecutor</code></h2><p>创建一个<strong>单线程</strong>的线程池。</p><p>只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序(<code>FIFO</code>, <code>LIFO</code>, 优先级)执行。 如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它 。</p><p>单工作线程最大的特点是：<strong>可保证顺序地执行各个任务</strong>。</p><pre><code class="hljs java">  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 返回只有一个线程的线程池</span><span class="hljs-comment">   */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),                                    threadFactory));    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727192058.png" srcset="/img/loading.gif" alt="" /></p><p>上图说明：</p><ul><li><p>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</p></li><li><p>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></p></li><li><p>线程执行完当前的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</p></li></ul><p>影响： <code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 <code>Intger.MAX_VALUE</code>）。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同，也可能导致 <code>OOM</code>。</p><h2 id="cachedthreadpool"><a class="markdownIt-Anchor" href="#cachedthreadpool"></a> <code>CachedThreadPool</code></h2><p>创建一个<strong>可缓存</strong>的线程池。</p><ul><li><p>如果线程池大小超过处理任务所需要的线程数，就会回收部分空闲的线程；</p></li><li><p>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p></li><li><p>此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 <code>JVM</code>）能够创建的最大线程大小。因此，使用 <code>CachedThreadPool</code> 时，一定要注意<strong>控制任务的数量</strong>，否则，由于大量线程同时运行，很有会造成系统瘫痪。</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                                      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),                                      threadFactory);    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727192747.png" srcset="/img/loading.gif" alt="" /></p><p>上图说明：</p><ul><li><p>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 <code>offer</code> 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code> 方法执行完成，否则执行下面的步骤 2；</p></li><li><p>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，<code>execute</code> 方法执行完成；</p></li></ul><p>影响：<code>CachedThreadPool</code> 允许创建的线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致 <code>OOM</code>。</p><h1 id="线程池大小确定"><a class="markdownIt-Anchor" href="#线程池大小确定"></a> 线程池大小确定</h1><blockquote><p>上下文切换：</p><p>多线程编程中一般线程的个数都大于 <code>CPU</code> 核心的个数，而一个 <code>CPU</code> 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，<code>CPU</code> 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 <code>CPU</code> 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p><p>上下文切换通常是<strong>计算密集型</strong>的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 <code>CPU</code> 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p><code>Linux</code> 相比与其他操作系统（包括其他类 <code>Unix</code> 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p></blockquote><p>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 <code>OOM</code>。这样很明显是有问题的！ <code>CPU</code> 根本没有得到充分利用。</p><p>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 <code>CPU</code> 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</p><p>有一个简单并且适用面比较广的公式：</p><ul><li><p><code>CPU</code> 密集型任务(<code>N + 1</code>)：这种任务消耗的主要是 <code>CPU</code> 资源，可以将线程数设置为 <code>N（CPU 核心数）+ 1</code>，比 <code>CPU</code> 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，<code>CPU</code> 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 <code>CPU</code> 的空闲时间。</p></li><li><p><code>I/O</code> 密集型任务(<code>2N</code>)：这种任务应用起来，系统会用大部分的时间来处理 <code>I/O</code> 交互，而线程在处理 <code>I/O</code> 的时间段内不会占用 <code>CPU</code> 来处理，这时就可以将 <code>CPU</code> 交出给其它线程使用。因此在 <code>I/O</code> 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 <code>2N</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发-容器</title>
    <link href="/2020/07/24/concurrent-container/"/>
    <url>/2020/07/24/concurrent-container/</url>
    
    <content type="html"><![CDATA[<h1 id="同步容器"><a class="markdownIt-Anchor" href="#同步容器"></a> 同步容器</h1><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>在 <code>Java</code> 中，同步容器主要包括 <code>2</code> 类：</p><ul><li><p><code>Vector</code>, <code>Stack</code>, <code>HashTable</code></p><ul><li><code>Vector</code> - <code>Vector</code> 实现了 <code>List</code> 接口。<code>Vector</code> 实际上就是一个数组，和 <code>ArrayList</code> 类似。但是 <code>Vector</code> 中的方法都是 <code>synchronized</code> 方法，即进行了同步措施。</li><li><code>Stack</code> - <code>Stack</code> 继承于 <code>Vector</code> 类，也是一个同步容器，它的方法也用 <code>synchronized</code> 进行了同步。</li><li><code>Hashtable</code>- <code>Hashtable</code> 实现了 <code>Map</code> 接口，但是 <code>Hashtable</code> 用 <code>synchronized</code> 进行了同步。</li></ul></li><li><p><code>Collections</code> 类中提供的静态工厂方法创建的类（由 <code>Collections.synchronizedXXX</code> 等方法）。</p></li></ul><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>同步容器的同步原理就是在方法上用 <code>synchronized</code> 修饰。</p><h3 id="性能问题"><a class="markdownIt-Anchor" href="#性能问题"></a> 性能问题</h3><p><code>synchronized</code> 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 <code>synchronized</code> 的容器性能要差。</p><h3 id="安全问题"><a class="markdownIt-Anchor" href="#安全问题"></a> 安全问题</h3><p>同步容器真的绝对安全吗？</p><p>其实也未必。在做复合操作（非原子操作）时，仍然需要加锁来保护。常见复合操作如下：</p><ul><li><p>迭代：反复访问元素，直到遍历完全部元素；</p></li><li><p>跳转：根据指定顺序寻找当前元素的下一个（下 <code>n</code> 个）元素；</p></li><li><p>条件运算：例如若没有则添加等；</p></li></ul><p>❌ 不安全的示例</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : ConcurrentContainerTest.java 2020/07/24 Fri 1:56 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentContainerTest</span> </span>&#123;    <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; vector = <span class="hljs-keyword">new</span> Vector&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            vector.clear();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                vector.add(i);            &#125;            Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;                    vector.remove(i);                &#125;            &#125;);            Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;                    vector.get(i);                &#125;            &#125;);            t1.start();            t2.start();            <span class="hljs-keyword">while</span> (Thread.activeCount() &gt; <span class="hljs-number">10</span>) &#123;                System.out.println(<span class="hljs-string">"同时存在十个以上线程， 退出"</span>);                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;&#125;</code></pre><p>以上程序执行时可能会出现数组越界错误。</p><p>这是因为，对于 <code>Vector</code>，虽然能保证每一个时刻只能有一个线程访问它，但是不排除这种可能：<br />当某个线程进行读操作时，其他线程可能已经删除了该线程所要读的那个元素。</p><p>因此为了保证线程安全，必须在方法调用端做额外的同步措施，如下面所示：</p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (vector) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;        vector.remove(i);    &#125;&#125;<span class="hljs-keyword">synchronized</span> (vector) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;        vector.remove(i);    &#125;&#125;</code></pre><h1 id="并发容器简介"><a class="markdownIt-Anchor" href="#并发容器简介"></a> 并发容器简介</h1><blockquote><p>同步容器将所有对容器状态的访问都串行化，以保证线程安全性，这种策略会严重降低并发性。</p><p>Java 1.5 后提供了多种并发容器，使用并发容器来替代同步容器，可以极大地提高伸缩性并降低风险。</p></blockquote><p>J.U.C 包中提供了几个非常有用的并发容器作为线程安全的容器：</p><table><thead><tr><th style="text-align:center">并发容器</th><th style="text-align:center">对应的普通容器</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>ConcurrentHashMap</code></td><td style="text-align:center"><code>HashMap</code></td><td style="text-align:center"><code>Java 1.8</code> 之前采用<strong>分段锁机制</strong>细化锁粒度，降低阻塞，从而提高并发性；<code>Java 1.8</code> 之后基于 <code>CAS</code> 实现。</td></tr><tr><td style="text-align:center"><code>ConcurrentSkipListMap</code></td><td style="text-align:center"><code>SortedMap</code></td><td style="text-align:center">基于跳表实现的</td></tr><tr><td style="text-align:center"><code>CopyOnWriteArrayList</code></td><td style="text-align:center"><code>ArrayList</code></td><td style="text-align:center">写时复制</td></tr><tr><td style="text-align:center"><code>CopyOnWriteArraySet</code></td><td style="text-align:center"><code>Set</code></td><td style="text-align:center">基于 <code>CopyOnWriteArrayList</code> 实现。</td></tr><tr><td style="text-align:center"><code>ConcurrentSkipListSet</code></td><td style="text-align:center"><code>SortedSet</code></td><td style="text-align:center">基于 <code>ConcurrentSkipListMap</code> 实现。</td></tr><tr><td style="text-align:center"><code>ConcurrentLinkedQueue</code></td><td style="text-align:center"><code>Queue</code></td><td style="text-align:center">线程安全的无界队列。底层采用单链表。支持 <code>FIFO</code>。</td></tr><tr><td style="text-align:center"><code>ConcurrentLinkedDeque</code></td><td style="text-align:center"><code>Deque</code></td><td style="text-align:center">线程安全的无界双端队列。底层采用双向链表。支持 <code>FIFO</code> 和 <code>FILO</code>。</td></tr><tr><td style="text-align:center"><code>ArrayBlockingQueue</code></td><td style="text-align:center"><code>Queue</code></td><td style="text-align:center">数组实现的阻塞队列。</td></tr><tr><td style="text-align:center"><code>LinkedBlockingQueue</code></td><td style="text-align:center"><code>Queue</code></td><td style="text-align:center">链表实现的阻塞队列。</td></tr><tr><td style="text-align:center"><code>LinkedBlockingDeque</code></td><td style="text-align:center"><code>Deque</code></td><td style="text-align:center">双向链表实现的双端阻塞队列。</td></tr></tbody></table><h1 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> <code>ConcurrentHashMap</code></h1><blockquote><p><code>ConcurrentHashMap</code> 是线程安全的 <code>HashMap</code> ，用于替代 <code>Hashtable</code>。</p></blockquote><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><p><code>ConcurrentHashMap</code> 实现了 <code>ConcurrentMap</code> 接口，而 <code>ConcurrentMap</code> 接口扩展了 <code>Map</code> 接口。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p><code>ConcurrentHashMap</code> 的实现包含了 <code>HashMap</code> 所有的基本特性，如：数据结构、读写策略等。</p><p><code>ConcurrentHashMap</code> 没有实现对 <code>Map</code> 加锁以提供独占访问。因此无法通过在客户端加锁的方式来创建新的原子操作。但是，一些常见的复合操作，如：“若没有则添加”、“若相等则移除”、“若相等则替换”，都已经实现为原子操作，并且是围绕 <code>ConcurrentMap</code> 的扩展接口而实现。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-comment">// 仅当 K 没有相应的映射值才插入</span>    <span class="hljs-function">V <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(K key, V value)</span></span>;    <span class="hljs-comment">// 仅当 K 被映射到 V 时才移除</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object key, Object value)</span></span>;    <span class="hljs-comment">// 仅当 K 被映射到 oldValue 时才替换为 newValue</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">replace</span><span class="hljs-params">(K key, V oldValue, V newValue)</span></span>;    <span class="hljs-comment">// 仅当 K 被映射到某个值时才替换为 newValue</span>    <span class="hljs-function">V <span class="hljs-title">replace</span><span class="hljs-params">(K key, V value)</span></span>;&#125;</code></pre><p>不同于 <code>Hashtable</code>，<code>ConcurrentHashMap</code> 提供的迭代器不会抛出 <code>ConcurrentModificationException</code>，因此不需要在迭代过程中对容器加锁。</p><blockquote><p>🔔 注意：一些需要对整个 <code>Map</code> 进行计算的方法，如 <code>size</code> 和 <code>isEmpty</code> ，由于返回的结果在计算时可能已经过期，所以并非实时的精确值。这是一种策略上的权衡，在并发环境下，这类方法由于总在不断变化，所以获取其实时精确值的意义不大。<code>ConcurrentHashMap</code> 弱化这类方法，以换取更重要操作（如：<code>get</code>、<code>put</code>、<code>containesKey</code>、<code>remove</code> 等）的性能。</p></blockquote><h2 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法</h2><p>同 <code>HashMap</code></p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p><code>ConcurrentHashMap</code> 在 <code>Java 1.8</code> 之前和 <code>Java 1.8</code> 之后的实现有很大差异：</p><ul><li><code>Java 1.8</code> 之前采用<strong>分段锁机制</strong>细化锁粒度，降低阻塞，从而提高并发性。</li><li><code>Java 1.8</code> 之后基于 <code>CAS</code> 实现。</li></ul><h3 id="java-17-的实现"><a class="markdownIt-Anchor" href="#java-17-的实现"></a> Java 1.7 的实现</h3><p>每一个 <code>segment</code> 都是一个 <code>HashEntry&lt;K,V&gt;[] table</code>， <code>table</code> 中的每一个元素本质上都是一个 <code>HashEntry</code> 的单向队列。比如 <code>table[3]</code> 为首节点，<code>table[3]-&gt;next</code> 为节点 <code>1</code>，之后为节点 <code>2</code>，依次类推。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// 将整个 hashmap 分成几个小的 map，每个 segment 都是一个锁；与 hashtable 相比，这么设计的目的是对于 put, remove 等操作，可以减少并发冲突，对</span>    <span class="hljs-comment">// 不属于同一个片段的节点可以并发操作，大大提高了性能</span>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;    <span class="hljs-comment">// 本质上 Segment 类就是一个小的 hashmap，里面 table 数组存储了各个节点的数据，继承了 ReentrantLock, 可以作为互斥锁使用</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;    &#125;    <span class="hljs-comment">// 基本节点，存储 Key, Value 值</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;        <span class="hljs-keyword">final</span> K key;        <span class="hljs-keyword">volatile</span> V value;        <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;    &#125;&#125;</code></pre><h3 id="java-18-的实现"><a class="markdownIt-Anchor" href="#java-18-的实现"></a> Java 1.8 的实现</h3><p><code>JDK 8</code> 中主要做了 2 方面的改进</p><ul><li><p>取消 <code>segments</code> 字段，直接采用 <code>transient volatile HashEntry&lt;K,V&gt;[] table</code> 保存数据，采用 <code>table</code> 数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</p></li><li><p>将原先 <strong>数组＋单链表</strong> 的数据结构，变更为 <strong>数组＋单链表＋红黑树</strong> 的结构。对于 <code>hash</code> 表来说，最核心的能力在于将 <code>key hash</code> 之后能均匀的分布在数组中。如果 <code>hash</code> 之后散列的很均匀，那么 <code>table</code> 数组中的每个队列长度主要为 <code>0</code> 或者 <code>1</code>。但实际情况并非总是如此理想，虽然 <code>ConcurrentHashMap</code> 类默认的加载因子为 <code>0.75</code>，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为 <code>O(n)</code>；因此，对于个数超过 <code>8</code>(默认值)的列表，<code>JDK 1.8</code> 中采用了红黑树的结构，那么查询的时间复杂度可以降低到 <code>O(logN)</code>，可以改进性能。</p></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;        <span class="hljs-comment">// 如果 table 为空，初始化；否则，根据 hash 值计算得到数组索引i，如果 tab[i] 为空，直接新建节点 Node 即可。注：tab[i] 实质为链表或者红黑树的首节点。</span>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            tab = initTable();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,                         <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>        &#125;        <span class="hljs-comment">// 如果 tab[i] 不为空并且 hash 值为 MOVED，说明该链表正在进行 transfer 操作，返回扩容完成后的 table。</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)            tab = helpTransfer(tab, f);        <span class="hljs-keyword">else</span> &#123;            V oldVal = <span class="hljs-keyword">null</span>;            <span class="hljs-comment">// 针对首个节点进行加锁操作，而不是 segment，进一步减少线程冲突</span>            <span class="hljs-keyword">synchronized</span> (f) &#123;                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;                        binCount = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                            K ek;                            <span class="hljs-comment">// 如果在链表中找到值为 key 的节点 e，直接设置 e.val = value 即可。</span>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;                                oldVal = e.val;                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                    e.val = value;                                <span class="hljs-keyword">break</span>;                            &#125;                            <span class="hljs-comment">// 如果没有找到值为 key 的节点，直接新建 Node 并加入链表即可。</span>                            Node&lt;K,V&gt; pred = e;                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,                                                          value, <span class="hljs-keyword">null</span>);                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                    &#125;                    <span class="hljs-comment">// 如果首节点为 TreeBin 类型，说明为红黑树结构，执行 utTreeVal 操作。</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;                        Node&lt;K,V&gt; p;                        binCount = <span class="hljs-number">2</span>;                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                       value)) != <span class="hljs-keyword">null</span>) &#123;                            oldVal = p.val;                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                p.val = value;                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 如果节点数 &gt;＝8，那么转换链表结构为红黑树结构。</span>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> oldVal;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 计数增加1，有可能触发 transfer 操作(扩容)。</span>    addCount(<span class="hljs-number">1L</span>, binCount);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h1 id="copyonwritearraylist"><a class="markdownIt-Anchor" href="#copyonwritearraylist"></a> <code>CopyOnWriteArrayList</code></h1><p>每个 <code>CopyOnWriteArrayList</code> 对象里有一个 <code>array</code> 数组用来存放具体元素。<code>ReentrantLock</code> 独占锁用来保证同时只有一个线程对 <code>array</code> 进行修改。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200724151232.png" srcset="/img/loading.gif" alt="" /></p><h2 id="要点"><a class="markdownIt-Anchor" href="#要点"></a> 要点</h2><ul><li><p>好处：<strong>任何的读操作都不用加锁</strong>，而且保证读取到的是读那一刻 <code>List</code> 完整的快照数据。由于读操作无法感知最新正在变化的数据，所以 <code>CopyOnWriteArrayList</code> 是<strong>弱一致性</strong>的。</p></li><li><p>写时复制技术因为每次修改都需要完整拷贝一次底层数组，所以有额外的性能开销，但是特别适用于<strong>读多写少</strong>的数据访问场景。</p></li></ul><h2 id="弱一致性问题"><a class="markdownIt-Anchor" href="#弱一致性问题"></a> 弱一致性问题</h2><p>线程1在执行完步骤 <code>A</code> 后，执行步骤 <code>B</code> 前，线程2进行了 <code>remove</code> 操作。<br />虽然线程2已经删除了 <code>index</code> 处的元素，但由于 <code>array</code>指向的数组引用计数为 1 而不是 0，仍会返回 <code>index</code> 处的元素。</p><h2 id="添加元素"><a class="markdownIt-Anchor" href="#添加元素"></a> 添加元素</h2><p>先将原容器 copy 一份，然后在新副本上执行写操作，之后再切换引用。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 1.获取独占锁</span>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 2.获取 array 数组</span>        Object[] elements = getArray();        <span class="hljs-keyword">int</span> len = elements.length;        <span class="hljs-comment">// 3.复制 array 到新数组</span>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 4.添加元素到新数组</span>        newElements[len] = e;        <span class="hljs-comment">// 5.用新数组替换原数组</span>        setArray(newElements);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 6.释放锁</span>        lock.unlock();    &#125;&#125;</code></pre><h2 id="删除元素"><a class="markdownIt-Anchor" href="#删除元素"></a> 删除元素</h2><p>将除要删除元素之外的其他元素拷贝到新副本中，然后切换引用，将原容器引用指向新副本。同属写操作，需要加锁。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">// 获取独占锁</span>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        Object[] elements = getArray();        <span class="hljs-keyword">int</span> len = elements.length;        E oldValue = get(elements, index);        <span class="hljs-comment">// 需要移动的元素个数</span>        <span class="hljs-keyword">int</span> numMoved = len - index - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 若删除的是最后一个元素</span>        <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)           <span class="hljs-comment">// 拷贝前len-1个数据到新副本上，再切换引用</span>           setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));        <span class="hljs-keyword">else</span> &#123;            Object[] newElements = <span class="hljs-keyword">new</span> Object[len - <span class="hljs-number">1</span>];            <span class="hljs-comment">// 分两块复制到新数组</span>            System.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);            System.arraycopy(elements, index + <span class="hljs-number">1</span>, newElements, index,                             numMoved);            <span class="hljs-comment">// 设置新数组</span>            setArray(newElements);        &#125;        <span class="hljs-keyword">return</span> oldValue;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 释放锁</span>        lock.unlock();    &#125;&#125;</code></pre><h2 id="读操作"><a class="markdownIt-Anchor" href="#读操作"></a> 读操作</h2><p><code>E get(int index)</code><br />读操作是不用加锁的，性能很高。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">return</span> get(getArray(), index);&#125;<span class="hljs-comment">// A.获取 array 数组</span><span class="hljs-keyword">final</span> Object[] getArray() &#123;    <span class="hljs-keyword">return</span> array;&#125;<span class="hljs-comment">// B.通过下标访问指定位置的数组元素</span><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">get</span><span class="hljs-params">(Object[] a, <span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">return</span> (E) a[index];&#125;</code></pre><h2 id="修改指定元素"><a class="markdownIt-Anchor" href="#修改指定元素"></a> 修改指定元素</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;    <span class="hljs-comment">// 获取独占锁</span>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 获取 array 数组</span>        Object[] elements = getArray();        <span class="hljs-comment">// 找到原位置上的值</span>        E oldValue = get(elements, index);        <span class="hljs-keyword">if</span> (oldValue != element) &#123;            <span class="hljs-keyword">int</span> len = elements.length;            <span class="hljs-comment">// 复制 array 到新数组</span>            Object[] newElements = Arrays.copyOf(elements, len);            <span class="hljs-comment">// 设置 index 位置的元素</span>            newElements[index] = element;            <span class="hljs-comment">// 用新数组替换旧数组</span>            setArray(newElements);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// Not quite a no-op; ensures volatile write semantics</span>            setArray(elements);        &#125;        <span class="hljs-keyword">return</span> oldValue;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 释放锁</span>        lock.unlock();    &#125;&#125;</code></pre><h1 id="blockingqueue"><a class="markdownIt-Anchor" href="#blockingqueue"></a> <code>BlockingQueue</code></h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;&#125;</code></pre><p>在 <code>BlockingQueue</code> 中，如果获取队列元素但是队列为空时，会阻塞，等待队列中有元素再返回；如果添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p><p><code>BlockingQueue</code> 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：</p><p>抛出异常；</p><ul><li>返回特殊值（<code>null</code> 或 <code>true</code>/<code>false</code>，取决于具体的操作）；</li><li>阻塞等待此操作，直到这个操作成功；</li><li>阻塞等待此操作，直到成功或者超时指定时间。<br />总结如下：</li></ul><table><thead><tr><th style="text-align:center">Operation</th><th style="text-align:center">Throws exception</th><th style="text-align:center">Special value</th><th style="text-align:center">Blocks</th><th style="text-align:center">Times out</th></tr></thead><tbody><tr><td style="text-align:center">Insert</td><td style="text-align:center">add(e)</td><td style="text-align:center">offer(e)</td><td style="text-align:center">put(e)</td><td style="text-align:center">offer(e, time, unit)</td></tr><tr><td style="text-align:center">Remove</td><td style="text-align:center">remove()</td><td style="text-align:center">poll()</td><td style="text-align:center">take()</td><td style="text-align:center">poll(time, unit)</td></tr><tr><td style="text-align:center">Examine</td><td style="text-align:center">element()</td><td style="text-align:center">peek()</td><td style="text-align:center">not applicable</td><td style="text-align:center">not applicable</td></tr></tbody></table><p><code>BlockingQueue</code> 的各个实现类都遵循了这些规则。</p><p><code>BlockingQueue</code> 不接受 <code>null</code> 值元素。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发-原子类</title>
    <link href="/2020/07/21/concurrent-atomic/"/>
    <url>/2020/07/21/concurrent-atomic/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><h2 id="为何需要原子变量类"><a class="markdownIt-Anchor" href="#为何需要原子变量类"></a> 为何需要原子变量类</h2><p>保证线程安全是 <code>Java</code> 并发编程必须要解决的重要问题。<code>Java</code> 从原子性、可见性、有序性这三大特性入手，确保多线程的数据一致性。</p><ul><li><p>确保线程安全最常见的做法是利用锁机制（<code>Lock</code>、<code>sychronized</code>）来对共享数据做互斥同步，这样在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，那么操作必然是原子性的，线程安全的。互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题。</p></li><li><p><code>volatile</code> 是轻量级的锁（自然比普通锁性能要好），它保证了共享变量在多线程中的可见性，但无法保证原子性。所以，它只能在一些特定场景下使用。</p></li><li><p>为了兼顾原子性以及锁带来的性能问题，<code>Java</code> 引入了 <code>CAS</code> （主要体现在 Unsafe 类）来实现非阻塞同步（也叫乐观锁）。并基于 <code>CAS</code> ，提供了一套原子工具类。</p></li></ul><h2 id="原子变量类的作用"><a class="markdownIt-Anchor" href="#原子变量类的作用"></a> 原子变量类的作用</h2><p>原子变量类 <strong>比锁的粒度更细，更轻量级</strong>，并且对于在多处理器系统上实现高性能的并发代码来说是非常关键的。原子变量将发生竞争的范围缩小到单个变量上。</p><p>原子变量类相当于一种泛化的 <code>volatile</code> 变量，能够支持<strong>原子的、有条件的读/改/写</strong>操作。</p><p>原子类在内部使用 <code>CAS</code> 指令（基于硬件的支持）来实现同步。这些指令通常比锁更快。</p><p>原子变量类可以分为 <code>4</code> 组：</p><ul><li>基本类型<ul><li><code>AtomicBoolean</code> - 布尔类型原子类</li><li><code>AtomicInteger</code> - 整型原子类</li><li><code>AtomicLong</code> - 长整型原子类</li></ul></li><li>引用类型<ul><li><code>AtomicReference</code> - 引用类型原子类</li><li><code>AtomicMarkableReference</code> - 带有标记位的引用类型原子类</li><li><code>AtomicStampedReference</code> - 带有版本号的引用类型原子类</li></ul></li><li>数组类型<ul><li><code>AtomicIntegerArray</code> - 整形数组原子类</li><li><code>AtomicLongArray</code> - 长整型数组原子类</li><li><code>AtomicReferenceArray</code> - 引用类型数组原子类</li></ul></li><li>属性更新器类型<ul><li><code>AtomicIntegerFieldUpdater</code> - 整型字段的原子更新器。</li><li><code>AtomicLongFieldUpdater</code> - 长整型字段的原子更新器。</li><li><code>AtomicReferenceFieldUpdater</code> - 原子更新引用类型里的字段。</li></ul></li></ul><h1 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型"></a> 基本类型</h1><p>这一类型的原子类是针对 <code>Java</code> 基本类型进行操作。</p><ul><li><p><code>AtomicBoolean</code> - 布尔类型原子类</p></li><li><p><code>AtomicInteger</code> - 整型原子类</p></li><li><p><code>AtomicLong</code> - 长整型原子类</p></li></ul><p>以上类都支持 <code>CAS</code>，此外，<code>AtomicInteger</code>、<code>AtomicLong</code> 还支持算术运算。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取当前值</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span> <span class="hljs-comment">// 获取当前值，并设置新值</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span><span class="hljs-comment">// 获取当前值，并自增</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndDecrement</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取当前值，并自减</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> delta)</span> <span class="hljs-comment">// 获取当前值，并加上预期值</span></span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> <span class="hljs-comment">// 如果输入值（update）等于预期值，将该值设置为输入值</span></span><span class="hljs-function"><span class="hljs-comment">// 最终设置为 newValue，使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lazySet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span></span></code></pre><h1 id="引用类型"><a class="markdownIt-Anchor" href="#引用类型"></a> 引用类型</h1><ul><li><p><code>AtomicReference</code> - 引用类型原子类</p></li><li><p><code>AtomicMarkableReference</code> - 带有标记位的引用类型原子类</p></li><li><p><code>AtomicStampedReference</code> - 带有版本号的引用类型原子类</p></li></ul><blockquote><p><code>AtomicStampedReference</code> 类在引用类型原子类中，彻底地解决了 <code>ABA</code> 问题，其它的 <code>CAS</code> 能力与另外两个类相近，所以最具代表性。因此，本节只针对 <code>AtomicStampedReference</code> 进行说明。</p></blockquote><h2 id="atomicreference"><a class="markdownIt-Anchor" href="#atomicreference"></a> AtomicReference</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于 AtomicReference 实现自旋锁</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicRefTest.java 2020/07/21 Tue 4:00 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicRefTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpinLock lock = <span class="hljs-keyword">new</span> SpinLock();        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            executorService.execute(<span class="hljs-keyword">new</span> MyThread(lock));        &#125;        executorService.shutdown();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * SpinLock</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span> </span>&#123;        <span class="hljs-keyword">private</span> AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;            Thread current = Thread.currentThread();            <span class="hljs-comment">// 自旋，为当前线程加锁</span>            <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-keyword">null</span>, current)) &#123;            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;            Thread current = Thread.currentThread();            <span class="hljs-comment">// 只有当前线程才释放锁</span>            atomicReference.compareAndSet(current, <span class="hljs-keyword">null</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * sell ticket by spin lock</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-keyword">private</span> SpinLock lock;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(SpinLock lock)</span> </span>&#123;            <span class="hljs-keyword">this</span>.lock = lock;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;                lock.lock();                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" sell ticket "</span> + ticket);                    ticket--;                &#125;                lock.unlock();            &#125;        &#125;            &#125;&#125;</code></pre><h2 id="atomicmarkablereference"><a class="markdownIt-Anchor" href="#atomicmarkablereference"></a> AtomicMarkableReference</h2><p>原子类的实现基于 <code>CAS</code> 机制，而 <code>CAS</code> 存在 <code>ABA</code> 问题。正是为了解决 <code>ABA</code> 问题，才有了 <code>AtomicMarkableReference</code> 和 <code>AtomicStampedReference</code>。</p><p><code>AtomicMarkableReference</code> 使用一个布尔值作为标记，修改时在 <code>true</code> / <code>false</code> 之间切换。这种策略不能根本上解决 <code>ABA</code> 问题，但是可以降低 <code>ABA</code> 发生的几率。常用于缓存或者状态描述这样的场景。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AtomicMarkableReference 使用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicMarkableRefTest.java 2020/07/21 Tue 4:32 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicMarkableRefTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String INIT_TEXT = <span class="hljs-string">"abc"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> AtomicMarkableReference&lt;String&gt; amr = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(INIT_TEXT, <span class="hljs-keyword">false</span>);        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            executorService.submit(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(Math.abs((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">100</span>));                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                String name = Thread.currentThread().getName();                <span class="hljs-comment">// 若变量为 INIT &amp;&amp; 已被标记，则修改</span>                <span class="hljs-keyword">if</span> (amr.compareAndSet(INIT_TEXT, name, amr.isMarked(), !amr.isMarked())) &#123;                String name = Thread.currentThread().getName();                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 修改了对象"</span>);                    System.out.println(<span class="hljs-string">"新的对象为："</span> + amr.getReference());                &#125;            &#125;);        &#125;        executorService.shutdown();        executorService.awaitTermination(<span class="hljs-number">3</span>, TimeUnit.SECONDS);    &#125;&#125;</code></pre><h2 id="atomicstampedreference"><a class="markdownIt-Anchor" href="#atomicstampedreference"></a> AtomicStampedReference</h2><p><code>AtomicStampedReference</code> 使用一个整型值做为版本号，每次更新前先比较版本号，如果一致，才进行修改。通过这种策略，可以根本上解决 <code>ABA</code> 问题。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AtomicStampedReference 使用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicStampedRefTest.java 2020/07/21 Tue 7:02 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicStampedRefTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String INIT_REF = <span class="hljs-string">"pool-1-thread-3"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; asr = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(INIT_REF, <span class="hljs-number">0</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        System.out.println(<span class="hljs-string">"初始对象为: "</span> + asr.getReference());        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            executorService.submit(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(Math.abs((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">100</span>));                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> stamp = asr.getStamp();                String name = Thread.currentThread().getName();                <span class="hljs-comment">// 若变量为 INIT &amp;&amp; 版本号为 stamp，则修改</span>                <span class="hljs-keyword">if</span> (asr.compareAndSet(INIT_REF, name, stamp, stamp + <span class="hljs-number">1</span>)) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 修改了对象"</span>);                    System.out.println(<span class="hljs-string">"新的对象为："</span> + asr.getReference());                &#125;            &#125;);        &#125;        executorService.shutdown();        executorService.awaitTermination(<span class="hljs-number">3</span>, TimeUnit.SECONDS);    &#125;&#125;</code></pre><h1 id="数组类型"><a class="markdownIt-Anchor" href="#数组类型"></a> 数组类型</h1><ul><li><p><code>AtomicIntegerArray</code> - 整形数组原子类</p></li><li><p><code>AtomicLongArray</code> - 长整型数组原子类</p></li><li><p><code>AtomicReferenceArray</code> - 引用类型数组原子类</p></li></ul><p>数组类型的原子类为 <strong>数组元素</strong> 提供了 <code>volatile</code> 类型的访问语义，这是普通数组所不具备的特性 —— <code>volatile</code> 类型的数组仅在<strong>数组引用</strong>上具有 <code>volatile</code> 语义。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AtomicIntegerArray 使用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicIntegerArrayTest.java 2020/07/21 Tue 7:17 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerArrayTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicIntegerArray atomicIntegerArray = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        System.out.println(<span class="hljs-string">"Init Values: "</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;            atomicIntegerArray.set(i, i);            System.out.print(atomicIntegerArray.get(i) + <span class="hljs-string">" "</span>);        &#125;        System.out.println();        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Increasement());        Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Compare());        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(<span class="hljs-string">"Final Values: "</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;            System.out.print(atomicIntegerArray.get(i) + <span class="hljs-string">" "</span>);        &#125;        System.out.println();    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Increasement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 对数组的每个元素自增 1</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;                <span class="hljs-keyword">int</span> value = atomicIntegerArray.incrementAndGet(i);                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">", index = "</span> + i + <span class="hljs-string">", value = "</span> + value);            &#125;        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compare</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 找到数组值为 2 的元素，修改为 3</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;                <span class="hljs-keyword">boolean</span> swapped = atomicIntegerArray.compareAndSet(i, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);                <span class="hljs-keyword">if</span> (swapped) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" swapped, index = "</span> + i + <span class="hljs-string">", value = 3"</span>);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="属性更新器类型"><a class="markdownIt-Anchor" href="#属性更新器类型"></a> 属性更新器类型</h1><p>更新器类支持基于<strong>反射</strong>机制的更新字段值的原子操作。</p><ul><li><p><code>AtomicIntegerFieldUpdater</code> - 整型字段的原子更新器。</p></li><li><p><code>AtomicLongFieldUpdater</code> - 长整型字段的原子更新器。</p></li><li><p><code>AtomicReferenceFieldUpdater</code> - 原子更新引用类型里的字段。</p></li></ul><p>这些类的使用有一定限制：</p><ul><li>因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 <code>newUpdater()</code> 创建一个更新器，并且需要设置想要更新的类和属性。</li><li>字段必须是 <code>volatile</code> 类型的；</li><li>不能作用于静态变量（<code>static</code>）；</li><li>不能作用于常量（<code>final</code>）；</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AtomicReferenceFieldUpdater 使用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicFieldUpdaterTest.java 2020/07/21 Tue 7:33 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicFieldUpdaterTest</span> </span>&#123;    <span class="hljs-keyword">static</span> User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"begin"</span>);    <span class="hljs-keyword">static</span> AtomicReferenceFieldUpdater&lt;User, String&gt; updater =            AtomicReferenceFieldUpdater.newUpdater(User.class, String.class, "name");    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            executorService.submit(() -&gt; &#123;            <span class="hljs-comment">// 若 name 的值为 ”begin“，则修改为 “end“</span>                <span class="hljs-keyword">if</span> (updater.compareAndSet(user, <span class="hljs-string">"begin"</span>, <span class="hljs-string">"end"</span>)) &#123;                    <span class="hljs-keyword">try</span> &#123;                        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 已修改 name = "</span> + user.getName());                &#125; <span class="hljs-keyword">else</span> &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"已被其他线程修改"</span>);                &#125;            &#125;);        &#125;        executorService.shutdown();    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;        <span class="hljs-keyword">volatile</span> String name;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并发-锁原理</title>
    <link href="/2020/07/17/concurrent-lock/"/>
    <url>/2020/07/17/concurrent-lock/</url>
    
    <content type="html"><![CDATA[<h1 id="并发锁"><a class="markdownIt-Anchor" href="#并发锁"></a> 并发锁</h1><h2 id="乐观锁和悲观锁"><a class="markdownIt-Anchor" href="#乐观锁和悲观锁"></a> 乐观锁和悲观锁</h2><p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p><h3 id="乐观锁"><a class="markdownIt-Anchor" href="#乐观锁"></a> 乐观锁</h3><p>乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此<strong>乐观锁不会上锁</strong>，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</p><h4 id="实现方式"><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式</h4><ol><li><code>CAS</code> 机制</li></ol><p><code>CAS</code> 操作包括了 3 个操作数：<br />(1) 需要读写的内存位置(<code>V</code>)<br />(2) 进行比较的预期值(<code>A</code>)<br />(3) 拟写入的新值(<code>B</code>)</p><p><code>CAS</code> 操作逻辑如下：如果内存位置 <code>V</code> 的值等于预期的 <code>A</code> 值，则将该位置更新为新值 <code>B</code>，否则不进行任何操作。许多 <code>CAS</code> 的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。</p><blockquote><p><code>CAS</code> 是由 <code>CPU</code> 支持的原子操作，其原子性是在硬件层面进行保证的。</p></blockquote><ol start="2"><li>版本号机制<br />版本号机制的基本思路是在数据中增加一个字段 <code>version</code>，表示该数据的版本号，每当数据被修改，版本号 <code>+1</code>。</li></ol><ul><li>当某个线程查询数据时，将该数据的版本号一起查出来；</li><li>当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。</li></ul><h3 id="悲观锁"><a class="markdownIt-Anchor" href="#悲观锁"></a> 悲观锁</h3><p>悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</p><h4 id="实现方式-2"><a class="markdownIt-Anchor" href="#实现方式-2"></a> 实现方式</h4><p>悲观锁的实现方式是<strong>加锁</strong>，加锁既可以是对<strong>代码块加锁</strong>（如 <code>Java</code>的 <code>synchronized</code> 关键字和 <code>Lock</code>），也可以是对<strong>数据加锁</strong>（如 <code>MySQL</code> 中的排它锁）。</p><h2 id="公平锁与非公平锁"><a class="markdownIt-Anchor" href="#公平锁与非公平锁"></a> 公平锁与非公平锁</h2><p>根据线程获取锁的抢占机制，锁可分为公平锁与非公平锁。</p><ul><li>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。</li><li>非公平锁在运行时闯入，也就是先来不一定先得，如 <code>synchronized</code>。</li><li><code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>，默认是非公平锁，但支持公平锁。</li><li>在没有公平性需求的情况下尽量使用非公平锁，因为公平锁会带来性能开销。</li></ul><h2 id="独占锁与共享锁"><a class="markdownIt-Anchor" href="#独占锁与共享锁"></a> 独占锁与共享锁</h2><p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁可分为独占锁与共享锁。</p><ul><li>独占锁是一种悲观锁，每次访问资源都加上了互斥锁，在同一时间只允许一个线程读取数据。</li><li>共享锁是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</li></ul><h2 id="可重入锁"><a class="markdownIt-Anchor" href="#可重入锁"></a> 可重入锁</h2><p>当一个线程再次获取它已经获取的琐时，如果不被阻塞，那么该锁是可被重入的。</p><p><code>synchronized</code> 内部锁是可重入锁，在其内部维护一个标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。当一个线程获取了该锁时，计数器的值会变成 <code>1</code>，这时其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞挂起。</p><p>但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值 <code>+1</code>，当释放锁后值 <code>-1</code>。当计数器值为 <code>0</code>，线程标示被重置为 <code>null</code>，这时候被阻塞的线程会被唤醒来竞争该锁。</p><h2 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h2><p>当前线程在获取锁时，如果发现锁已被其他线程占有，它不马上阻塞自己，在不放弃 <code>CPU</code> 使用权的情况下，多次尝试获取（默认10次，可以使用 <code>-XX:PreBlockSpinsh</code> 参数设置该值），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定次数后仍没有获取到锁则当前线程才会被阻塞挂起。<br />自旋锁是使用 <code>CPU</code> 时间换取线程阻塞与调度的开销，但是很有可能这些 <code>CPU</code> 时间白白浪费了。</p><h1 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h1><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的相互等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去</p><h2 id="基本条件"><a class="markdownIt-Anchor" href="#基本条件"></a> 基本条件</h2><ol><li>互斥</li><li>请求并持有</li><li>不可剥夺</li><li>环路等待</li></ol><h2 id="避免死锁"><a class="markdownIt-Anchor" href="#避免死锁"></a> 避免死锁</h2><blockquote><p>使用申请资源的有序性，破坏请求并持有和环路等待条件。</p></blockquote><ul><li><p>避免一个线程同时获取多个锁。</p></li><li><p>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</p></li><li><p>尝试使用定时锁 <code>lock.tryLock(timeout)</code>，避免锁一直不能释放。</p></li><li><p>对于数据库锁，加锁和解锁必须在一个数据库连接中里，否则会出现解锁失败的情况。</p></li></ul><h1 id="aqs"><a class="markdownIt-Anchor" href="#aqs"></a> AQS</h1><blockquote><p><code>AbstractQueuedSynchronizer</code>（简称 <code>AQS</code>）是队列同步器，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>Semaphore</code> 等）。</p><p>因此，要想深入理解 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 等并发锁和同步工具，必须先理解 <code>AQS</code> 的要点和原理。</p></blockquote><h2 id="aqs-的要点"><a class="markdownIt-Anchor" href="#aqs-的要点"></a> <code>AQS</code> 的要点</h2><p>在 <code>java.util.concurrent.locks</code> 包中的相关锁(常用的有 <code>ReentrantLock</code>、 <code>ReadWriteLock</code>)都是基于 <code>AQS</code> 来实现。这些锁都没有直接继承 <code>AQS</code>，而是定义了一个 <code>Sync</code> 类去继承 <code>AQS</code>。为什么要这样呢？因为锁面向的是使用用户，而同步器面向的则是线程控制，那么在锁的实现中聚合同步器而不是直接继承 <code>AQS</code> 就可以很好的隔离二者所关注的事情。</p><p><strong><code>AQS</code> 提供了对独享锁与共享锁的支持。</strong></p><h3 id="独享锁-api"><a class="markdownIt-Anchor" href="#独享锁-api"></a> 独享锁 <code>API</code></h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span></code></pre><ul><li><code>acquire</code> - 获取独占锁。</li><li><code>acquireInterruptibly</code> - 获取可中断的独占锁。</li><li><code>tryAcquireNanos</code> - 尝试在指定时间内获取可中断的独占锁。在以下三种情况下回返回：<ul><li>在超时时间内，当前线程成功获取了锁；</li><li>当前线程在超时时间内被中断；</li><li>超时时间结束，仍未获得锁返回 false。</li></ul></li><li><code>release</code> - 释放独占锁。</li></ul><h3 id="共享锁-api"><a class="markdownIt-Anchor" href="#共享锁-api"></a> 共享锁 <code>API</code></h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquireSharedNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span></code></pre><ul><li><code>acquireShared</code> - 获取共享锁。</li><li><code>acquireSharedInterruptibly</code> - 获取可中断的共享锁。</li><li><code>tryAcquireSharedNanos</code> - 尝试在指定时间内获取可中断的共享锁。</li><li><code>release</code> - 释放共享锁。</li></ul><h2 id="aqs-的原理"><a class="markdownIt-Anchor" href="#aqs-的原理"></a> <code>AQS</code> 的原理</h2><h3 id="aqs-的数据结构"><a class="markdownIt-Anchor" href="#aqs-的数据结构"></a> <code>AQS</code> 的数据结构</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">/** 等待队列的队头，懒加载。只能通过 setHead 方法修改。 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;    <span class="hljs-comment">/** 等待队列的队尾，懒加载。只能通过 enq 方法添加新的等待节点。*/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;    <span class="hljs-comment">/** 同步状态 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;&#125;</code></pre><ul><li><p><code>state</code> - <code>AQS</code> 使用一个整型的 <code>volatile</code> 变量来 维护同步状态。</p><ul><li>这个整数状态的意义由子类来赋予，如 <code>ReentrantLock</code> 中该状态值表示所有者线程已经重复获取该锁的次数，<code>Semaphore</code> 中该状态值表示剩余的许可数量。</li></ul></li><li><p><code>head</code> 和 <code>tail</code> - <code>AQS</code> 维护了一个 <code>Node</code> 类型（<code>AQS</code> 的内部类）的双链表来完成同步状态的管理。这个双链表是一个双向的 <code>FIFO</code> 队列，通过 <code>head</code> 和 <code>tail</code> 指针进行访问。当有线程获取锁失败后，就被添加到队列末尾。</p></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200718161601.png" srcset="/img/loading.gif" alt="AQS结构" /></p><p><code>Node</code> 的源码</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-comment">/** 该等待同步的节点处于共享模式 */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();    <span class="hljs-comment">/** 该等待同步的节点处于独占模式 */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">/** 线程等待状态，状态值有: 0、1、-1、-2、-3 */</span>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;    <span class="hljs-comment">/** 前驱节点 */</span>    <span class="hljs-keyword">volatile</span> Node prev;    <span class="hljs-comment">/** 后继节点 */</span>    <span class="hljs-keyword">volatile</span> Node next;    <span class="hljs-comment">/** 等待锁的线程 */</span>    <span class="hljs-keyword">volatile</span> Thread thread;        <span class="hljs-comment">/** 和节点是否共享有关 */</span>    Node nextWaiter;&#125;</code></pre><p>很显然，<code>Node</code> 是一个双链表结构。</p><p><code>waitStatus</code> - <code>Node</code> 使用一个整型的 <code>volatile</code> 变量来 维护 <code>AQS</code> 同步队列中线程节点的状态。<code>waitStatus</code> 有五个状态值：</p><ul><li><p><code>CANCELLED(1)</code> - 此状态表示：该节点的线程可能由于超时或被中断而 <strong>处于被取消(作废)状态</strong>，一旦处于这个状态，表示这个节点应该从等待队列中移除。</p></li><li><p><code>SIGNAL(-1)</code> - 此状态表示：后继节点会被挂起，因此在当前节点释放锁或被取消之后，必须唤醒(<code>unparking</code>)其后继结点。</p></li><li><p><code>CONDITION(-2)</code> - 此状态表示：该节点的线程 处于等待条件状态，不会被当作是同步队列上的节点，直到被唤醒(<code>signal</code>)，设置其值为 0，再重新进入阻塞状态。</p></li><li><p><code>PROPAGATE(-3)</code> - 此状态表示：下一个 <code>acquireShared</code> 应无条件传播。</p></li><li><p><code>0</code> - 非以上状态。</p></li></ul><h3 id="独占锁的获取和释放"><a class="markdownIt-Anchor" href="#独占锁的获取和释放"></a> 独占锁的获取和释放</h3><h4 id="获取独占锁"><a class="markdownIt-Anchor" href="#获取独占锁"></a> 获取独占锁</h4><p><code>AQS</code> 中使用 <code>acquire(int arg)</code> 方法获取独占锁，其大致流程如下：</p><ol><li><p>先尝试获取同步状态，如果获取同步状态成功，则结束方法，直接返回。</p></li><li><p>如果获取同步状态不成功，<code>AQS</code> 会不断尝试利用 <code>CAS</code> 操作将当前线程插入等待同步队列的队尾，直到成功为止。</p></li><li><p>接着，不断尝试为等待队列中的线程节点获取独占锁。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200718161748.png" srcset="/img/loading.gif" alt="获取锁前" /><br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200718162338.png" srcset="/img/loading.gif" alt="获取锁" /><br />详细流程可以用下图来表示，请结合源码来理解（一图胜千言）：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200718162114.png" srcset="/img/loading.gif" alt="AQS获取锁工作流程" /></p></li></ol><h4 id="释放独占锁"><a class="markdownIt-Anchor" href="#释放独占锁"></a> 释放独占锁</h4><p><code>AQS</code> 中使用 <code>release(int arg)</code> 方法释放独占锁，其大致流程如下：</p><ol><li><p>先尝试获取解锁线程的同步状态，如果获取同步状态不成功，则结束方法，直接返回。</p></li><li><p>如果获取同步状态成功，<code>AQS</code> 会尝试唤醒当前线程节点的后继节点。</p></li></ol><h4 id="获取可中断的独占锁"><a class="markdownIt-Anchor" href="#获取可中断的独占锁"></a> 获取可中断的独占锁</h4><p><code>AQS</code> 中使用 <code>acquireInterruptibly(int arg)</code> 方法获取可中断的独占锁。</p><p><code>acquireInterruptibly(int arg)</code> 实现方式相较于获取独占锁方法（<code>acquire</code>）非常相似，区别仅在于它会通过 <code>Thread.interrupted</code> 检测当前线程是否被中断，如果是，则立即抛出中断异常（<code>InterruptedException</code>）。</p><h4 id="获取超时等待式的独占锁"><a class="markdownIt-Anchor" href="#获取超时等待式的独占锁"></a> 获取超时等待式的独占锁</h4><p><code>AQS</code> 中使用 <code>tryAcquireNanos(int arg)</code> 方法获取超时等待的独占锁。</p><p><code>doAcquireNanos</code> 的实现方式 相较于获取独占锁方法（ <code>acquire</code>）非常相似，区别在于它会根据超时时间和当前时间计算出截止时间。在获取锁的流程中，会不断判断是否超时，如果超时，直接返回 <code>false</code>；如果没超时，则用 <code>LockSupport.parkNanos</code> 来阻塞当前线程。</p><h3 id="共享锁的获取和释放"><a class="markdownIt-Anchor" href="#共享锁的获取和释放"></a> 共享锁的获取和释放</h3><h4 id="获取共享锁"><a class="markdownIt-Anchor" href="#获取共享锁"></a> 获取共享锁</h4><p><code>AQS</code> 中使用 <code>acquireShared(int arg)</code> 方法获取共享锁。</p><p><code>acquireShared</code> 方法和 <code>acquire</code> 方法的逻辑很相似，区别仅在于自旋的条件以及节点出队的操作有所不同。</p><p>成功获得共享锁的条件如下：</p><ul><li><p><code>tryAcquireShared(arg)</code> 返回值大于等于 <code>0</code> （这意味着共享锁的 permit 还没有用完）。</p></li><li><p>当前节点的前驱节点是头结点。</p></li></ul><h4 id="释放共享锁"><a class="markdownIt-Anchor" href="#释放共享锁"></a> 释放共享锁</h4><p><code>AQS</code> 中使用 <code>releaseShared(int arg)</code> 方法释放共享锁。</p><p><code>releaseShared</code> 首先会尝试释放同步状态，如果成功，则解锁一个或多个后继线程节点。释放共享锁和释放独享锁流程大体相似，区别在于：</p><p>对于独享模式，如果需要 <code>SIGNAL</code>，释放仅相当于调用头节点的 <code>unparkSuccessor</code>。</p><h4 id="获取可中断的共享锁"><a class="markdownIt-Anchor" href="#获取可中断的共享锁"></a> 获取可中断的共享锁</h4><p><code>AQS</code> 中使用 <code>acquireSharedInterruptibly(int arg)</code> 方法获取可中断的共享锁。</p><p><code>acquireSharedInterruptibly</code> 方法与 <code>acquireInterruptibly</code> 几乎一致，不再赘述。</p><h4 id="获取超时等待式的共享锁"><a class="markdownIt-Anchor" href="#获取超时等待式的共享锁"></a> 获取超时等待式的共享锁</h4><p><code>AQS</code> 中使用 <code>tryAcquireSharedNanos(int arg)</code> 方法获取超时等待式的共享锁。</p><p><code>tryAcquireSharedNanos</code> 方法与 <code>tryAcquireNanos</code> 几乎一致，不再赘述。</p><h1 id="reentrantlock"><a class="markdownIt-Anchor" href="#reentrantlock"></a> <code>ReentrantLock</code></h1><blockquote><p><code>ReentrantLock</code> 类是 <code>Lock</code> 接口的具体实现，它是一个可重入锁。与内置锁 <code>synchronized</code> 不同，<code>ReentrantLock</code> 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作，所有获取锁、释放锁的操作都是显式的操作。</p></blockquote><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><ul><li><p><code>ReentrantLock</code> 提供了与 <code>synchronized</code> 相同的互斥性、内存可见性和可重入性。</p></li><li><p><code>ReentrantLock</code> 支持公平锁和**非公平锁（默认）**两种模式。</p></li><li><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，支持了 <code>synchronized</code> 所不具备的灵活性。</p><ul><li><p><code>synchronized</code> 无法中断一个正在等待获取锁的线程</p></li><li><p><code>synchronized</code> 无法在请求获取一个锁时无休止地等待</p></li></ul></li></ul><p><code>Lcok</code> 接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lock</span> </span>&#123;    <span class="hljs-comment">// 获取锁</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 锁未被另一个线程持有，且线程没有被中断的情况下，才能获取锁。</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-comment">// 尝试获取锁，仅在调用时锁未被另一个线程持有的情况下，才获取该锁。</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 和 tryLock() 类似，区别仅在于限定时间，如果限定时间内未获取到锁，视为失败。</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-comment">// 释放锁</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 返回一个绑定到 Lock 对象上的 Condition 实例</span>    <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h2 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法</h2><h3 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;&#125;</code></pre><ul><li><code>ReentrantLock()</code> - 默认构造方法会初始化一个非公平锁（<code>NonfairSync</code>）；</li><li><code>ReentrantLock(boolean)</code> - <code>new ReentrantLock(true)</code> 会初始化一个公平锁（<code>FairSync</code>）。</li></ul><h3 id="lock-和-unlock-方法"><a class="markdownIt-Anchor" href="#lock-和-unlock-方法"></a> <code>lock</code> 和 <code>unlock</code> 方法</h3><ul><li><p><code>lock()</code> - <strong>无条件获取锁</strong>。如果当前线程无法获取锁，则当前线程进入休眠状态不可用，直至当前线程获取到锁。如果该锁没有被另一个线程持有，则获取该锁并立即返回，将锁的持有计数设置为 <code>1</code>。</p></li><li><p><code>unlock()</code> - 用于释放锁。</p></li></ul><blockquote><p>🔔 注意：获取锁操作 <code>lock()</code> 必须在 <code>try catch</code> 块中进行，并且将释放锁操作 <code>unlock()</code> 放在 <code>finally</code> 块中进行，以保证锁一定被被释放，防止死锁的发生。</p></blockquote><h3 id="trylock-方法"><a class="markdownIt-Anchor" href="#trylock-方法"></a> <code>tryLock</code> 方法</h3><p>与无条件获取锁相比，<code>tryLock</code> 有更完善的容错机制。</p><ul><li><p><code>tryLock()</code> - 可轮询获取锁。如果成功，则返回 <code>true</code>；如果失败，则返回 <code>false</code>。也就是说，这个方法无论成败都会<strong>立即返回</strong>，获取不到锁（锁已被其他线程获取）时不会一直等待。</p></li><li><p><code>tryLock(long, TimeUnit)</code> - 可定时获取锁。和 <code>tryLock()</code> 类似，区别仅在于这个方法在获取不到锁时会等待一定的时间，在时间期限之内如果还获取不到锁，就返回 <code>false</code>。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 <code>true</code>。</p></li></ul><h3 id="lockinterruptibly-方法"><a class="markdownIt-Anchor" href="#lockinterruptibly-方法"></a> <code>lockInterruptibly</code> 方法</h3><p><code>lockInterruptibly()</code> - 可中断获取锁。可中断获取锁可以在获得锁的同时保持对中断的响应。可中断获取锁比其它获取锁的方式稍微复杂一些，需要两个 <code>try-catch</code> 块（如果在获取锁的操作中抛出了 <code>InterruptedException</code> ，那么可以使用标准的 <code>try-finally</code> 加锁模式）。</p><p>举例来说：假设有两个线程同时通过 <code>lock.lockInterruptibly()</code> 获取某个锁时，若线程 <code>A</code> 获取到了锁，则线程 <code>B</code> 只能等待。若此时对线程 <code>B</code> 调用 <code>threadB.interrupt()</code> 方法能够中断线程 <code>B</code> 的等待过程。由于 <code>lockInterruptibly()</code> 的声明中抛出了异常，所以 <code>lock.lockInterruptibly()</code> 必须放在 <code>try</code> 块中或者在调用 <code>lockInterruptibly()</code> 的方法外声明抛出 <code>InterruptedException</code>。</p><blockquote><p>🔔 注意：当一个线程获取了锁之后，是不会被 <code>interrupt()</code> 方法中断的。单独调用 <code>interrupt()</code> 方法不能中断正在运行状态中的线程，只能中断阻塞状态中的线程。因此当通过 <code>lockInterruptibly()</code> 方法获取某个锁时，如果未获取到锁，只有在等待的状态下，才可以响应中断。</p></blockquote><h3 id="newcondition-方法"><a class="markdownIt-Anchor" href="#newcondition-方法"></a> <code>newCondition</code> 方法</h3><p><code>newCondition()</code> - 返回一个绑定到 <code>Lock</code> 对象上的 <code>Condition</code> 实例。</p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><h3 id="reentrantlock-的数据结构"><a class="markdownIt-Anchor" href="#reentrantlock-的数据结构"></a> <code>ReentrantLock</code> 的数据结构</h3><p>它有一个核心字段：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;</code></pre><p><code>sync</code> - 内部抽象类 <code>ReentrantLock.Sync</code> 对象，<code>Sync</code> 继承自 <code>AQS</code>。它有两个子类：</p><ol><li><p><code>ReentrantLock.FairSync</code> - 公平锁。</p></li><li><p><code>ReentrantLock.NonfairSync</code> - 非公平锁。</p></li></ol><h3 id="获取锁和释放锁"><a class="markdownIt-Anchor" href="#获取锁和释放锁"></a> 获取锁和释放锁</h3><p><code>ReentrantLock</code> 获取锁和释放锁的接口，从表象看，是调用 <code>ReentrantLock.FairSync</code> 或 <code>ReentrantLock.NonfairSync</code> 中各自的实现；从本质上看，是基于 <code>AQS</code> 的实现。</p><ul><li><p><code>void lock()</code> 调用 <code>Sync</code> 的 <code>lock()</code> 方法。</p></li><li><p><code>void lockInterruptibly()</code> 直接调用 <code>AQS</code> 的 获取可中断的独占锁 方法 <code>lockInterruptibly()</code>。</p></li><li><p><code>boolean tryLock()</code> 调用 <code>Sync</code> 的 <code>nonfairTryAcquire()</code> 。</p></li><li><p><code>boolean tryLock(long time, TimeUnit unit)</code> 直接调用 <code>AQS</code> 的 获取超时等待式的独占锁 方法 <code>tryAcquireNanos(int arg, long nanosTimeout)</code>。</p></li><li><p><code>void unlock()</code> 直接调用 <code>AQS</code> 的 释放独占锁 方法 <code>release(int arg)</code> 。</p></li></ul><h1 id="reentrantreadwritelock"><a class="markdownIt-Anchor" href="#reentrantreadwritelock"></a> <code>ReentrantReadWriteLock</code></h1><blockquote><p><code>ReentrantReadWriteLock</code> 类是 <code>ReadWriteLock</code> 接口的具体实现，它是一个<strong>可重入</strong>的读写锁。<code>ReentrantReadWriteLock</code> 维护了一对读写锁，将读写锁分开，有利于提高并发效率。</p></blockquote><p><code>ReentrantLock</code> 实现了一种标准的互斥锁：每次最多只有一个线程能持有 <code>ReentrantLock</code>。但对于维护数据的完整性来说，互斥通常是一种过于强硬的加锁策略，因此也就不必要地限制了并发性。大多数场景下，读操作比写操作频繁，只要保证每个线程都能读取到最新数据，并且在读数据时不会有其它线程在修改数据，那么就不会出现线程安全问题。这种策略减少了互斥同步，自然也提升了并发性能，<code>ReentrantReadWriteLock</code> 就是这种策略的具体实现。</p><h2 id="特性-2"><a class="markdownIt-Anchor" href="#特性-2"></a> 特性</h2><ul><li><p><code>ReentrantReadWriteLock</code> 适用于读多写少的场景。如果是写多读少的场景，由于 <code>ReentrantReadWriteLock</code> 其内部实现比 <code>ReentrantLock</code> 复杂，性能可能反而要差一些。如果存在这样的问题，需要具体问题具体分析。由于 <code>ReentrantReadWriteLock</code> 的读写锁（<code>ReadLock</code>、<code>WriteLock</code>）都实现了 <code>Lock</code> 接口，所以要替换为 <code>ReentrantLock</code> 也较为容易。</p></li><li><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> 接口，支持了 <code>ReentrantLock</code> 所不具备的读写锁分离。<code>ReentrantReadWriteLock</code> 维护了一对读写锁（<code>ReadLock</code>、<code>WriteLock</code>）。将读写锁分开，有利于提高并发效率。<code>ReentrantReadWriteLock</code> 的加锁策略是：<strong>允许多个读操作并发执行，但每次只允许一个写操作</strong>。</p></li><li><p><code>ReentrantReadWriteLock</code> 为读写锁都提供了可重入的加锁语义。</p></li><li><p><code>ReentrantReadWriteLock</code> 支持公平锁和非公平锁（默认）两种模式。</p></li></ul><p><code>ReadWriteLock</code> 接口定义如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReadWriteLock</span> </span>&#123;    <span class="hljs-comment">// 返回用于读操作的锁</span>    <span class="hljs-function">Lock <span class="hljs-title">readLock</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 返回用于写操作的锁</span>    <span class="hljs-function">Lock <span class="hljs-title">writeLock</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h2 id="用法-2"><a class="markdownIt-Anchor" href="#用法-2"></a> 用法</h2><h3 id="构造方法-2"><a class="markdownIt-Anchor" href="#构造方法-2"></a> 构造方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantReadWriteLock</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;&#125;</code></pre><ul><li><p><code>ReentrantReadWriteLock()</code> - 默认构造方法会初始化一个非公平锁（<code>NonfairSync</code>）。在非公平的锁中，线程获得锁的顺序是不确定的。写线程降级为读线程是可以的，但读线程升级为写线程是不可以的（这样会导致死锁）。</p></li><li><p><code>ReentrantReadWriteLock(boolean)</code> - <code>new ReentrantLock(true)</code> 会初始化一个公平锁（<code>FairSync</code>）。对于公平锁，等待时间最长的线程将优先获得锁。如果这个锁是读线程持有，则另一个线程请求写锁，那么其他读线程都不能获得读锁，直到写线程释放写锁。</p></li></ul><h3 id="使用实例"><a class="markdownIt-Anchor" href="#使用实例"></a> 使用实例</h3><p><code>ReentrantReadWriteLock</code> 与 <code>ReentrantLock</code> 用法上的差异，主要在于<strong>读写锁的配合使用</strong>。本文以一个典型使用场景来进行讲解。</p><p>示例：基于 <code>ReentrantReadWriteLock</code> 实现一个简单的本地缓存</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 简单的无界缓存实现</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 使用 WeakHashMap 存储键值对。WeakHashMap 中存储的对象是弱引用，JVM GC 时会自动清除没有被引用的弱引用对象。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnboundedCache</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; cacheMap = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock cacheLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;        cacheLock.readLock().lock();        V value;        <span class="hljs-keyword">try</span> &#123;            value = cacheMap.get(key);            String log = String.format(<span class="hljs-string">"%s 读数据 %s:%s"</span>, Thread.currentThread().getName(), key, value);            System.out.println(log);        &#125; <span class="hljs-keyword">finally</span> &#123;            cacheLock.readLock().unlock();        &#125;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;        cacheLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            cacheMap.put(key, value);            String log = String.format(<span class="hljs-string">"%s 写入数据 %s:%s"</span>, Thread.currentThread().getName(), key, value);            System.out.println(log);        &#125; <span class="hljs-keyword">finally</span> &#123;            cacheLock.writeLock().unlock();        &#125;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span> </span>&#123;        cacheLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> cacheMap.remove(key);        &#125; <span class="hljs-keyword">finally</span> &#123;            cacheLock.writeLock().unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        cacheLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.cacheMap.clear();        &#125; <span class="hljs-keyword">finally</span> &#123;            cacheLock.writeLock().unlock();        &#125;    &#125;&#125;</code></pre><ul><li><p>使用 <code>WeakHashMap</code> 而不是 <code>HashMap</code> 来存储键值对。<code>WeakHashMap</code> 中存储的对象是弱引用，<code>JVM GC</code> 时会自动清除没有被引用的弱引用对象。</p></li><li><p>向 Map 写数据前加写锁，写完后，释放写锁。</p></li><li><p>向 Map 读数据前加读锁，读完后，释放读锁。</p></li></ul><h2 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h2><h3 id="reentrantreadwritelock-的数据结构"><a class="markdownIt-Anchor" href="#reentrantreadwritelock-的数据结构"></a> <code>ReentrantReadWriteLock</code> 的数据结构</h3><pre><code class="hljs java"><span class="hljs-comment">/** Inner class providing readlock */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;<span class="hljs-comment">/** Inner class providing writelock */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;<span class="hljs-comment">/** Performs all synchronization mechanics */</span><span class="hljs-keyword">final</span> Sync sync;<span class="hljs-keyword">public</span> ReentrantReadWriteLock.<span class="hljs-function">WriteLock <span class="hljs-title">writeLock</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> writerLock; &#125;<span class="hljs-keyword">public</span> ReentrantReadWriteLock.<span class="hljs-function">ReadLock  <span class="hljs-title">readLock</span><span class="hljs-params">()</span>  </span>&#123; <span class="hljs-keyword">return</span> readerLock; &#125;</code></pre><ul><li><p><code>sync</code> - 内部类 <code>ReentrantReadWriteLock.Sync</code> 对象。与 <code>ReentrantLock</code> 类似，它有两个子类：<code>ReentrantReadWriteLock.FairSync</code> 和 <code>ReentrantReadWriteLock.NonfairSync</code> ，分别表示公平锁和非公平锁的实现。</p></li><li><p><code>readerLock</code> - 内部类 <code>ReentrantReadWriteLock.ReadLock</code> 对象，这是一把读锁。</p></li><li><p><code>writerLock</code> - 内部类 <code>ReentrantReadWriteLock.WriteLock</code> 对象，这是一把写锁。</p></li></ul><h3 id="获取锁和释放锁-2"><a class="markdownIt-Anchor" href="#获取锁和释放锁-2"></a> 获取锁和释放锁</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// 调用 AQS 获取共享锁方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        sync.acquireShared(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// 调用 AQS 释放共享锁方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.releaseShared(<span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// 调用 AQS 获取独占锁方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        sync.acquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// 调用 AQS 释放独占锁方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.release(<span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h1 id="condition"><a class="markdownIt-Anchor" href="#condition"></a> Condition</h1><p><code>Java 1.5</code> 之前，主要是利用 <code>Object</code> 类中的 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 配合 <code>synchronized</code> 来进行线程间通信。</p><p><code>wait</code>、<code>notify</code>、<code>notifyAll</code> 需要配合 <code>synchronized</code> 使用，不适用于 <code>Lock</code>。而使用 <code>Lock</code> 的线程，彼此间通信应该使用 <code>Condition</code>。<br />这可以理解为，什么样的锁配什么样的钥匙。内置锁（<code>synchronized</code>）配合内置条件队列（<code>wait</code>、<code>notify</code>、<code>notifyAll</code>），显式锁（<code>Lock</code>）配合显式条件队列（<code>Condition</code>）。</p><h2 id="特性-3"><a class="markdownIt-Anchor" href="#特性-3"></a> 特性</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Condition</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">awaitNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>其中，<code>await</code>、<code>signal</code>、<code>signalAll</code> 与 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 相对应，功能也相似。除此以外，<code>Condition</code> 相比内置条件队列（<code>wait</code>、<code>notify</code>、<code>notifyAll</code>），提供了更为丰富的功能：</p><ul><li><p>每个锁（<code>Lock</code>）上可以存在多个 <code>Condition</code>，这意味着锁的状态条件可以有多个。</p></li><li><p>支持公平的或非公平的队列操作。</p></li><li><p>支持可中断的条件等待，相关方法：<code>awaitUninterruptibly()</code>。</p></li><li><p>支持可定时的等待，相关方法：<code>awaitNanos(long)</code> 、<code>await(long, TimeUnit)</code>、<code>awaitUntil(Date)</code>。</p></li></ul><h2 id="用法-3"><a class="markdownIt-Anchor" href="#用法-3"></a> 用法</h2><p>这里以 <code>Condition</code> 来实现一个消费者、生产者模式。</p><blockquote><p>🔔 注意：事实上，解决此类问题使用 <code>CountDownLatch</code>、<code>Semaphore</code> 等工具更为便捷、安全。</p></blockquote><p>消息类：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition consumeCondition = lock.newCondition();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition produceCondition = lock.newCondition();    <span class="hljs-keyword">private</span> String message;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> state;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> end;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//lock</span>        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// no new message wait for new message</span>            <span class="hljs-keyword">while</span> (!state) &#123;                consumeCondition.await();            &#125;            System.out.println(<span class="hljs-string">"consume message : "</span> + message);            state = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// message consumed, notify waiting thread</span>            produceCondition.signal();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;            System.out.println(<span class="hljs-string">"Thread interrupted - viewMessage"</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(String message)</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// last message not consumed, wait for it be consumed</span>            <span class="hljs-keyword">while</span> (state) &#123;                produceCondition.await();            &#125;            System.out.println(<span class="hljs-string">"produce msg: "</span> + message);            <span class="hljs-keyword">this</span>.message = message;            state = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">// new message added, notify waiting thread</span>            consumeCondition.signal();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;            System.out.println(<span class="hljs-string">"Thread interrupted - publishMessage"</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> end;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnd</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> end)</span> </span>&#123;        <span class="hljs-keyword">this</span>.end = end;    &#125;&#125;</code></pre><p>生产者：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> Message message;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageProducer</span><span class="hljs-params">(Message msg)</span> </span>&#123;        message = msg;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        produce();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;        List&lt;String&gt; msgs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        msgs.add(<span class="hljs-string">"Begin"</span>);        msgs.add(<span class="hljs-string">"Msg1"</span>);        msgs.add(<span class="hljs-string">"Msg2"</span>);        <span class="hljs-keyword">for</span> (String msg : msgs) &#123;            message.produce(msg);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">100</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        message.produce(<span class="hljs-string">"End"</span>);        message.setEnd(<span class="hljs-keyword">true</span>);    &#125;&#125;</code></pre><p>消费者：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> Message message;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageConsumer</span><span class="hljs-params">(Message msg)</span> </span>&#123;        message = msg;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (!message.isEnd()) &#123; message.consume(); &#125;    &#125;&#125;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockConditionDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Message msg = <span class="hljs-keyword">new</span> Message();        Thread producer = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MessageProducer(msg));        Thread consumer = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MessageConsumer(msg));        producer.start();        consumer.start();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Overview</title>
    <link href="/2018/12/28/overview/"/>
    <url>/2018/12/28/overview/</url>
    
    <content type="html"><![CDATA[<p>During the past six months, I was focusing on preparing for the entrance exam of postgraduate schools, owing to that, I could barely write posts or sorting out my blog. What’s worse, I figured out that I got my server expired and lost most of my posts that I have written in the almost past three years, in which I have made some records in my study and lives, including programming thoughts and life experiences.</p><p>As you’ll find out, I plan to migrate my blog from cloud server to git pages, it’s kind of a large project. Thanks to the exam which I have mentioned above, actually I did not expect that I could spend a surprisingly large amount of time in concentrating on one thing. It’s helpful in building up a hard-working, persistent personality.</p><p>In short, now that I’ve finished my exam, I plan to get a vacation for a couple of weeks and then back to my blog’s migration.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
