<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>并发-线程池</title>
    <link href="/2020/07/27/concurrent-threadpool/"/>
    <url>/2020/07/27/concurrent-threadpool/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。</p></blockquote><p>如果并发请求数量很多，但每个线程执行的时间很短，就会出现频繁的创建和销毁线程。如此一来，会大大降低系统的效率，可能频繁创建和销毁线程的时间、资源开销要大于实际工作的所需。</p><p>正是由于这个问题，所以有必要引入线程池。使用 <strong>线程池的好处</strong> 有以下几点：</p><ul><li><p><strong>降低资源消耗</strong> - 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p></li><li><p><strong>提高响应速度</strong> - 当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p><strong>提高线程的可管理性</strong> - 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p></li></ul><h1 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a><code>Executor</code> 框架</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><code>Executor</code> 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。</p><p>还有关键的一点：有助于避免 <code>this</code> 逃逸问题。</p><blockquote><p><code>this</code> 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727102933.png" srcset="/img/loading.gif" alt=""></p><h3 id="1-任务-Runnable-Callable"><a href="#1-任务-Runnable-Callable" class="headerlink" title="1. 任务(Runnable / Callable)"></a>1. 任务(<code>Runnable</code> / <code>Callable</code>)</h3><p>执行任务需要实现的 <code>Runnable</code> 接口 或 <code>Callable</code> 接口。他们的实现类都可以被 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。</p><h3 id="2-任务的执行-Executor"><a href="#2-任务的执行-Executor" class="headerlink" title="2. 任务的执行(Executor)"></a>2. 任务的执行(<code>Executor</code>)</h3><p>任务执行机制的核心接口 <code>Executor</code> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。<br><code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 这两个关键类实现了 <code>ExecutorService</code> 接口。</p><h4 id="2-1-Executor"><a href="#2-1-Executor" class="headerlink" title="2.1 Executor"></a>2.1 <code>Executor</code></h4><p><code>Executor</code> 接口中只定义了一个 <code>execute</code> 方法，用于接收一个 <code>Runnable</code> 对象。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;&#125;</code></pre><h4 id="2-2-ExecutorService"><a href="#2-2-ExecutorService" class="headerlink" title="2.2 ExecutorService"></a>2.2 <code>ExecutorService</code></h4><p><code>ExecutorService</code> 接口继承了 <code>Executor</code> 接口，它还提供了 <code>invokeAll</code>、<code>invokeAny</code>、<code>shutdown</code>、<code>submit</code> 等方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Executor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException</span>;    &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;    &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span></span>;    Future&lt;?&gt; submit(Runnable task);    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        <span class="hljs-keyword">throws</span> InterruptedException;    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                  <span class="hljs-keyword">long</span> timeout, TimeUnit unit)        <span class="hljs-keyword">throws</span> InterruptedException;    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;&#125;</code></pre><p>比于 <code>Executor</code> 接口，<code>ExecutorService</code> 接口主要的扩展是：</p><ul><li>支持有返回值的线程 - <code>sumbit</code>、<code>invokeAll</code>、<code>invokeAny</code> 方法中都支持传入 <code>Callable</code> 对象。</li><li>支持管理线程生命周期 - <code>shutdown</code>、<code>shutdownNow</code>、<code>isShutdown</code> 等方法。</li></ul><h4 id="2-3-ScheduledExecutorService"><a href="#2-3-ScheduledExecutorService" class="headerlink" title="2.3 ScheduledExecutorService"></a>2.3 <code>ScheduledExecutorService</code></h4><p><code>ScheduledExecutorService</code> 接口扩展了 <code>ExecutorService</code> 接口。</p><p>它除了支持前面两个接口的所有能力以外，还支持定时调度线程。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ScheduledExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExecutorService</span> </span>&#123;    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-keyword">long</span> delay, TimeUnit unit);    <span class="hljs-keyword">public</span> &lt;V&gt; <span class="hljs-function">ScheduledFuture&lt;V&gt; <span class="hljs-title">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable, <span class="hljs-keyword">long</span> delay, TimeUnit unit)</span></span>;    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,                                                  <span class="hljs-keyword">long</span> initialDelay,                                                  <span class="hljs-keyword">long</span> period,                                                  TimeUnit unit);    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,                                                     <span class="hljs-keyword">long</span> initialDelay,                                                     <span class="hljs-keyword">long</span> delay,                                                     TimeUnit unit);&#125;</code></pre><p>其扩展的接口提供以下能力：</p><ul><li><p><code>schedule</code> 方法可以在指定的延时后执行一个 <code>Runnable</code> 或者 <code>Callable</code> 任务。</p></li><li><p><code>scheduleAtFixedRate</code> 方法和 <code>scheduleWithFixedDelay</code> 方法可以按照指定时间间隔，定期执行任务。</p></li></ul><h3 id="3-异步计算的结果-Future"><a href="#3-异步计算的结果-Future" class="headerlink" title="3. 异步计算的结果(Future)"></a>3. 异步计算的结果(<code>Future</code>)</h3><blockquote><p><code>Future</code> 接口以及 <code>Future</code> 接口的实现类 <code>FutureTask</code> 类都可以代表异步计算的结果。</p></blockquote><p>当我们把 <code>Runnable</code> 接口或 <code>Callable</code> 接口的实现类提交给 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行，调用 <code>submit()</code> 方法时会返回一个 <code>FutureTask</code> 对象，可通过 <code>FutureTask.get()</code> 捕获抛出的异常。</p><h2 id="Executor-框架的使用示意图"><a href="#Executor-框架的使用示意图" class="headerlink" title="Executor 框架的使用示意图"></a><code>Executor</code> 框架的使用示意图</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727105429.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</p></li><li><p>把创建完成的实现 <code>Runnable</code> / <code>Callable</code> 接口的对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit(Runnable task)</code>或 <code>ExecutorService.submit(Callable &lt;T&gt; task)</code>）。</p></li><li><p>如果执行 <code>ExecutorService.submit(...)</code>，<code>ExecutorService</code> 将返回一个实现 <code>Future</code> 接口的对象。由于 <code>FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</p></li><li><p>最后，主线程可以执行 <code>FutureTask.get()</code> 方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel(boolean mayInterruptIfRunning)</code>来取消此任务的执行。</p></li></ul><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a><code>ThreadPoolExecutor</code></h1><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : ThreadPoolTest.java 2020/07/27 Mon 3:29 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolTest</span> </span>&#123;    <span class="hljs-comment">// 核心线程数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CORE_POOL_SIZE = <span class="hljs-number">5</span>;    <span class="hljs-comment">// 最大线程数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_POOL_SIZE = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 任务队列容量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> QUEUE_CAPACITY = <span class="hljs-number">100</span>;    <span class="hljs-comment">// 等待时间</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> KEEP_ALIVE_TIME = <span class="hljs-number">1L</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建线程池</span>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                CORE_POOL_SIZE,                MAX_POOL_SIZE,                KEEP_ALIVE_TIME,                TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),                <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">// 执行工作线程</span>            Runnable worker = <span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-string">""</span> + i);            executor.execute(worker);            String info = String.format(<span class="hljs-string">"线程池中线程数目：%s，队列中等待执行的任务数目：%s，已执行完的任务数目：%s"</span>,                    executor.getPoolSize(),                    executor.getQueue().size(),                    executor.getCompletedTaskCount());            System.out.println(info);        &#125;        <span class="hljs-comment">// 终止线程池</span>        executor.shutdown();        <span class="hljs-keyword">while</span> (!executor.isTerminated()) &#123;        &#125;        System.out.println(<span class="hljs-string">"Finish all threads"</span>);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 工作线程类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> String cmd;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRunnable</span><span class="hljs-params">(String cmd)</span> </span>&#123;        <span class="hljs-keyword">this</span>.cmd = cmd;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" Start time = "</span> + <span class="hljs-keyword">new</span> Date());        processCmd();        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" End time = "</span> + <span class="hljs-keyword">new</span> Date());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCmd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">2000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"MyRunnable&#123;"</span> +                <span class="hljs-string">"cmd='"</span> + cmd + <span class="hljs-string">'\''</span> +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>ThreadPoolExecutor</code> 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, // 线程池的核心线程数量</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize, // 线程池的最大线程数</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime, // 当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit, // 时间单位</span></span><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列，用来储存等待执行任务的队列</span></span><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory, // 线程工厂，用来创建线程，一般默认即可</span></span><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler // 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><span class="hljs-function"><span class="hljs-params">                           )</span> </span>&#123;    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;    <span class="hljs-keyword">this</span>.workQueue = workQueue;    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;    <span class="hljs-keyword">this</span>.handler = handler;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727145107.png" srcset="/img/loading.gif" alt=""></p><p>参数说明：</p><ol><li><p><code>corePoolSize</code> - <strong>核心线程数量</strong>。当有新任务通过 <code>execute</code> 方法提交时 ，线程池会执行以下判断：</p><ul><li>如果运行的线程数少于 <code>corePoolSize</code>，则创建新线程来处理任务，即使线程池中的其他线程是空闲的。</li><li>如果线程池中的线程数量大于等于 <code>corePoolSize</code> 且小于 <code>maximumPoolSize</code>，则只有当 <code>workQueue</code> 满时才创建新的线程去处理任务，否则将任务存储在队列里；</li><li>如果设置的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 相同，则创建的线程池的大小是固定的。这时如果有新任务提交，若 <code>workQueue</code> 未满，则将请求放入 <code>workQueue</code> 中，等待有空闲的线程去从 <code>workQueue</code> 中取任务并处理；</li><li>如果运行的线程数量大于等于 <code>maximumPoolSize</code>，这时如果 <code>workQueue</code> 已经满了，则使用 <code>handler</code> 所指定的策略来处理任务；</li><li>所以，任务提交时，判断的顺序为 <code>corePoolSize</code> =&gt; <code>workQueue</code> =&gt; <code>maximumPoolSize</code>。</li></ul></li><li><p><code>maximumPoolSize</code> - <strong>最大线程数量</strong>。</p><ul><li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</li><li>值得注意的是：如果使用了无界的任务队列这个参数就没什么效果。</li></ul></li><li><p><code>keepAliveTime</code> - <strong>线程保持活动的时间</strong>。</p><ul><li>当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>。</li><li>所以，如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li></ul></li><li><p><code>unit</code> - <strong><code>keepAliveTime</code> 的时间单位</strong>。<br>有 7 种取值。可选的单位有天（<code>DAYS</code>），小时（<code>HOURS</code>），分钟（<code>MINUTES</code>），毫秒(<code>MILLISECONDS</code>)，微秒(<code>MICROSECONDS</code>, 千分之一毫秒)和毫微秒(<code>NANOSECONDS</code>, 千分之一微秒)。</p></li><li><p><code>workQueue</code> - <strong>等待执行的任务队列</strong>。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。</p><ul><li><p><code>ArrayBlockingQueue</code> - <strong>有界阻塞队列</strong>。</p><ul><li>此队列是基于<strong>数组</strong>的先进先出队列（<code>FIFO</code>）。</li><li>创建时必须指定大小。</li></ul></li><li><p><code>LinkedBlockingQueue</code> - <strong>无界阻塞队列</strong>。</p><ul><li>此队列是基于<strong>链表</strong>的先进先出队列（<code>FIFO</code>）。</li><li>如果创建时没有指定此队列大小，则默认为 <code>Integer.MAX_VALUE</code>。</li><li>吞吐量通常要高于 <code>ArrayBlockingQueue</code>。</li><li>使用 <code>LinkedBlockingQueue</code> 意味着： <code>maximumPoolSize</code> 将不起作用，线程池能创建的最大线程数为 <code>corePoolSize</code>，因为任务等待队列是无界队列。</li><li><code>Executors.newFixedThreadPool</code> 使用了这个队列。</li></ul></li><li><p><code>SynchronousQueue</code> - <strong>不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</strong></p><ul><li>每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。</li><li>吞吐量通常要高于 <code>LinkedBlockingQueue</code>。</li><li><code>Executors.newCachedThreadPool</code> 使用了这个队列。</li></ul></li></ul></li><li><p><code>threadFactory</code> - <strong>线程工厂</strong>。可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</p></li><li><p><code>handler</code> - <strong>饱和策略</strong>。它是 <code>RejectedExecutionHandler</code> 类型的变量。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。线程池支持以下策略：</p><ul><li><p><code>AbortPolicy</code> - 抛出  <code>RejectedExecutionException</code> 来拒绝新任务的处理。这也是默认策略。</p></li><li><p><code>DiscardPolicy</code> - 丢弃任务，但不抛出异常。</p></li><li><p><code>DiscardOldestPolicy</code> - 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。</p></li><li><p><code>CallerRunsPolicy</code> - 只用调用者所在的线程来运行任务。</p></li><li><p>如果以上策略都不能满足需要，也可以通过实现           <code>RejectedExecutionHandler</code> 接口来定制处理策略。如记录日志或持久化不能处理的任务。</p></li></ul></li></ol><p>工作流程如下图：<br><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727145919.png" srcset="/img/loading.gif" alt=""></p><h2 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute 方法"></a><code>execute</code> 方法</h2><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</p><p>提交任务可以使用 <code>execute</code> 方法，它是 <code>ThreadPoolExecutor</code> 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p><p><code>execute</code> 方法工作流程如下：<br><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727162758.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>)); <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;     <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125; <span class="hljs-comment">// 任务队列</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;     <span class="hljs-comment">// 如果任务为 null，则抛出异常。</span>     <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();     <span class="hljs-comment">// ctl 中保存的线程池当前的一些状态信息</span>     <span class="hljs-keyword">int</span> c = ctl.get();     <span class="hljs-comment">//  下面会涉及到 3 步 操作</span>     <span class="hljs-comment">// 1.首先判断当前线程池中之行的任务数量是否小于  corePoolSize</span>     <span class="hljs-comment">// 如果小于的话，则创建新的核心线程并且执行传入的任务</span>     <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;         <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))             <span class="hljs-comment">// 如果创建新的核心线程成功则直接返回</span>             <span class="hljs-keyword">return</span>;         <span class="hljs-comment">// 这里说明创建核心线程失败，需要更新 ctl 的临时变量 c</span>         c = ctl.get();     &#125;     <span class="hljs-comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span>     <span class="hljs-comment">// 判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务</span>     <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;         <span class="hljs-keyword">int</span> recheck = ctl.get();         <span class="hljs-comment">// 二次检查线程池状态。如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span>         <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))             <span class="hljs-comment">// 调用拒绝策略处理任务 - 返回</span>             reject(command);             <span class="hljs-comment">// 如果当前线程池为空就新创建一个线程并执行。</span>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)             addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);     &#125;     <span class="hljs-comment">// 3. 如果任务不能加入任务队列，则会尝试创建非核心线程传入任务执行</span>     <span class="hljs-comment">// 创建非核心线程失败，此时需要拒绝执行任务</span>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))         <span class="hljs-comment">// 调用拒绝策略处理任务 - 返回</span>         reject(command); &#125;</code></pre><p>关于二次检查线程池运行状态：</p><blockquote><p>如果一个任务成功加入任务队列，我们依然需要二次检查是否需要添加一个工作线程（因为所有存活的工作线程有可能在最后一次检查之后已经终结）或者执行当前方法的时候线程池是否已经终结了。所以我们需要二次检查线程池的状态，必须时把任务从任务队列中移除或者在没有可用的工作线程的前提下新建一个工作线程。</p></blockquote><h2 id="其他重要方法"><a href="#其他重要方法" class="headerlink" title="其他重要方法"></a>其他重要方法</h2><ul><li><code>submit</code> 类似于 <code>execute</code>，但是针对的是有返回值的线程。<code>submit</code> 方法是在 <code>ExecutorService</code> 中声明的方法，在 <code>AbstractExecutorService</code> 就已经有了具体的实现。<code>ThreadPoolExecutor</code> 直接复用 <code>AbstractExecutorService</code> 的 <code>submit</code> 方法。</li><li><code>shutdown</code> - 不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</li><li><code>shutdownNow</code> - 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</li><li><code>isShutdown</code> - 调用了 <code>shutdown</code> 或 <code>shutdownNow</code> 方法后，<code>isShutdown</code> 方法就会返回 <code>true</code>。</li><li><code>isTerminaed</code> - 当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 <code>isTerminaed</code> 方法会返回 <code>true</code>。</li></ul><h1 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a><code>ScheduledThreadPoolExecutor</code></h1><p><code>ScheduledThreadPoolExecutor</code> 主要用来在给定的延迟后运行任务，或者定期执行任务。 这个在实际项目中基本不会被用到，因为有其他方案选择比如 <code>quartz</code>。</p><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p><code>ScheduledThreadPoolExecutor</code> 使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727200044.png" srcset="/img/loading.gif" alt=""></p><p><code>ScheduledThreadPoolExecutor</code> 的执行主要分为两大部分：</p><ul><li><p>当调用 <code>ScheduledThreadPoolExecutor</code> 的 <code>scheduleAtFixedRate()</code> 方法或者 <code>scheduleWirhFixedDelay()</code> 方法时，会向 <code>ScheduledThreadPoolExecutor</code> 的 <code>DelayQueue</code> 添加一个实现了 <code>RunnableScheduledFuture</code> 接口的 <code>ScheduledFutureTask</code> 。</p></li><li><p>线程池中的线程从 <code>DelayQueue</code> 中获取 <code>ScheduledFutureTask</code>，然后执行任务。</p></li></ul><p><code>ScheduledThreadPoolExecutor</code> 为了实现周期性的执行任务，对 <code>ThreadPoolExecutor</code> 做了如下修改：</p><ul><li><p>使用 <code>DelayQueue</code> 作为任务队列；</p></li><li><p>获取任务的方不同</p></li><li><p>执行周期任务后，增加了额外的处理</p></li></ul><h2 id="执行周期任务的步骤"><a href="#执行周期任务的步骤" class="headerlink" title="执行周期任务的步骤"></a>执行周期任务的步骤</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727200325.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>线程 1 从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask</code>（<code>DelayQueue.take()</code>）。到期任务是指 <code>ScheduledFutureTask</code> 的 <code>time</code> 大于等于当前系统的时间；</p></li><li><p>线程 1 执行这个 <code>ScheduledFutureTask</code>；</p></li><li><p>线程 1 修改 <code>ScheduledFutureTask</code> 的 <code>time</code> 变量为下次将要被执行的时间；</p></li><li><p>线程 1 把这个修改 <code>time</code> 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中 (<code>DelayQueue.add()</code>)。</p></li></ul><h1 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h1><p><code>JDK</code> 的 <code>Executors</code> 类中提供了几种具有代表性的线程池，这些线程池 都是基于 <code>ThreadPoolExecutor</code> 的定制化实现。</p><blockquote><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p></blockquote><h2 id="创建线程池方式"><a href="#创建线程池方式" class="headerlink" title="创建线程池方式"></a>创建线程池方式</h2><ol><li>通过 <code>ThreadPoolExecutor</code> 构造函数实现（推荐）</li><li>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现 我们可以创建三种类型的 <code>ThreadPoolExecutor</code><ul><li><code>FixedThreadPool</code></li><li><code>SingleThreadExecutor</code></li><li><code>CachedThreadPool</code></li></ul></li></ol><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 <code>OOM</code>。</li><li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 <code>OOM</code>。</li></ul><h2 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a><code>FixedThreadPool</code></h2><p>创建一个<strong>固定大小</strong>的线程池。</p><p>每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中。</p><p><code>FixedThreadPool</code> 是一个典型且优秀的线程池，它具有线程池<strong>提高程序效率</strong>和<strong>节省创建线程时所耗的开销</strong>的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p><pre><code class="hljs java"> <span class="hljs-comment">/**</span><span class="hljs-comment">  * 创建一个可重用固定数量线程的线程池</span><span class="hljs-comment">  */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(        nThreads,        nThreads,        <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,        <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),        threadFactory);    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727191728.png" srcset="/img/loading.gif" alt=""></p><p>上图说明：</p><ul><li><p>如果当前运行的线程数小于 <code>corePoolSize</code>， 如果再来新任务的话，就创建新的线程来执行任务；</p></li><li><p>当前运行的线程数等于 <code>corePoolSize</code> 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</p></li><li><p>线程池中的线程执行完 手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</p></li></ul><p><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 <code>Intger.MAX_VALUE</code>）作为线程池的工作队列会对线程池带来如下影响 ：</p><ul><li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code>corePoolSize</code></li><li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况</li><li>使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数</li><li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code> 或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 <code>OOM</code></li></ul><h2 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a><code>SingleThreadExecutor</code></h2><p>创建一个<strong>单线程</strong>的线程池。</p><p>只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序(<code>FIFO</code>, <code>LIFO</code>, 优先级)执行。 如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它 。</p><p>单工作线程最大的特点是：<strong>可保证顺序地执行各个任务</strong>。</p><pre><code class="hljs java">  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 返回只有一个线程的线程池</span><span class="hljs-comment">   */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),                                    threadFactory));    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727192058.png" srcset="/img/loading.gif" alt=""></p><p>上图说明：</p><ul><li><p>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</p></li><li><p>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></p></li><li><p>线程执行完当前的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</p></li></ul><p>影响： <code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 <code>Intger.MAX_VALUE</code>）。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同，也可能导致 <code>OOM</code>。</p><h2 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a><code>CachedThreadPool</code></h2><p>创建一个<strong>可缓存</strong>的线程池。</p><ul><li><p>如果线程池大小超过处理任务所需要的线程数，就会回收部分空闲的线程；</p></li><li><p>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p></li><li><p>此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 <code>JVM</code>）能够创建的最大线程大小。因此，使用 <code>CachedThreadPool</code> 时，一定要注意<strong>控制任务的数量</strong>，否则，由于大量线程同时运行，很有会造成系统瘫痪。</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                                      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),                                      threadFactory);    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727192747.png" srcset="/img/loading.gif" alt=""></p><p>上图说明：</p><ul><li><p>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 <code>offer</code> 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code> 方法执行完成，否则执行下面的步骤 2；</p></li><li><p>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，<code>execute</code> 方法执行完成；</p></li></ul><p>影响：<code>CachedThreadPool</code> 允许创建的线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致 <code>OOM</code>。</p><h1 id="线程池大小确定"><a href="#线程池大小确定" class="headerlink" title="线程池大小确定"></a>线程池大小确定</h1><blockquote><p>上下文切换：</p><p>多线程编程中一般线程的个数都大于 <code>CPU</code> 核心的个数，而一个 <code>CPU</code> 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，<code>CPU</code> 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 <code>CPU</code> 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p><p>上下文切换通常是<strong>计算密集型</strong>的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 <code>CPU</code> 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p><code>Linux</code> 相比与其他操作系统（包括其他类 <code>Unix</code> 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p></blockquote><p>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 <code>OOM</code>。这样很明显是有问题的！ <code>CPU</code> 根本没有得到充分利用。</p><p>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 <code>CPU</code> 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</p><p>有一个简单并且适用面比较广的公式：</p><ul><li><p><code>CPU</code> 密集型任务(<code>N + 1</code>)：这种任务消耗的主要是 <code>CPU</code> 资源，可以将线程数设置为 <code>N（CPU 核心数）+ 1</code>，比 <code>CPU</code> 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，<code>CPU</code> 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 <code>CPU</code> 的空闲时间。</p></li><li><p><code>I/O</code> 密集型任务(<code>2N</code>)：这种任务应用起来，系统会用大部分的时间来处理 <code>I/O</code> 交互，而线程在处理 <code>I/O</code> 的时间段内不会占用 <code>CPU</code> 来处理，这时就可以将 <code>CPU</code> 交出给其它线程使用。因此在 <code>I/O</code> 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 <code>2N</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发-容器</title>
    <link href="/2020/07/24/concurrent-container/"/>
    <url>/2020/07/24/concurrent-container/</url>
    
    <content type="html"><![CDATA[<h1 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 <code>Java</code> 中，同步容器主要包括 <code>2</code> 类：</p><ul><li><p><code>Vector</code>, <code>Stack</code>, <code>HashTable</code></p><ul><li><code>Vector</code> - <code>Vector</code> 实现了 <code>List</code> 接口。<code>Vector</code> 实际上就是一个数组，和 <code>ArrayList</code> 类似。但是 <code>Vector</code> 中的方法都是 <code>synchronized</code> 方法，即进行了同步措施。</li><li><code>Stack</code> - <code>Stack</code> 继承于 <code>Vector</code> 类，也是一个同步容器，它的方法也用 <code>synchronized</code> 进行了同步。</li><li><code>Hashtable</code>- <code>Hashtable</code> 实现了 <code>Map</code> 接口，但是 <code>Hashtable</code> 用 <code>synchronized</code> 进行了同步。</li></ul></li><li><p><code>Collections</code> 类中提供的静态工厂方法创建的类（由 <code>Collections.synchronizedXXX</code> 等方法）。</p></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>同步容器的同步原理就是在方法上用 <code>synchronized</code> 修饰。</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p><code>synchronized</code> 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 <code>synchronized</code> 的容器性能要差。</p><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>同步容器真的绝对安全吗？</p><p>其实也未必。在做复合操作（非原子操作）时，仍然需要加锁来保护。常见复合操作如下：</p><ul><li><p>迭代：反复访问元素，直到遍历完全部元素；</p></li><li><p>跳转：根据指定顺序寻找当前元素的下一个（下 <code>n</code> 个）元素；</p></li><li><p>条件运算：例如若没有则添加等；</p></li></ul><p>❌ 不安全的示例</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : ConcurrentContainerTest.java 2020/07/24 Fri 1:56 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentContainerTest</span> </span>&#123;    <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; vector = <span class="hljs-keyword">new</span> Vector&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            vector.clear();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                vector.add(i);            &#125;            Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;                    vector.remove(i);                &#125;            &#125;);            Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;                    vector.get(i);                &#125;            &#125;);            t1.start();            t2.start();            <span class="hljs-keyword">while</span> (Thread.activeCount() &gt; <span class="hljs-number">10</span>) &#123;                System.out.println(<span class="hljs-string">"同时存在十个以上线程， 退出"</span>);                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;&#125;</code></pre><p>以上程序执行时可能会出现数组越界错误。</p><p>这是因为，对于 <code>Vector</code>，虽然能保证每一个时刻只能有一个线程访问它，但是不排除这种可能：<br>当某个线程进行读操作时，其他线程可能已经删除了该线程所要读的那个元素。</p><p>因此为了保证线程安全，必须在方法调用端做额外的同步措施，如下面所示：</p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (vector) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;        vector.remove(i);    &#125;&#125;<span class="hljs-keyword">synchronized</span> (vector) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;        vector.remove(i);    &#125;&#125;</code></pre><h1 id="并发容器简介"><a href="#并发容器简介" class="headerlink" title="并发容器简介"></a>并发容器简介</h1><blockquote><p>同步容器将所有对容器状态的访问都串行化，以保证线程安全性，这种策略会严重降低并发性。</p><p>Java 1.5 后提供了多种并发容器，使用并发容器来替代同步容器，可以极大地提高伸缩性并降低风险。</p></blockquote><p>J.U.C 包中提供了几个非常有用的并发容器作为线程安全的容器：</p><table><thead><tr><th align="center">并发容器</th><th align="center">对应的普通容器</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>ConcurrentHashMap</code></td><td align="center"><code>HashMap</code></td><td align="center"><code>Java 1.8</code> 之前采用<strong>分段锁机制</strong>细化锁粒度，降低阻塞，从而提高并发性；<code>Java 1.8</code> 之后基于 <code>CAS</code> 实现。</td></tr><tr><td align="center"><code>ConcurrentSkipListMap</code></td><td align="center"><code>SortedMap</code></td><td align="center">基于跳表实现的</td></tr><tr><td align="center"><code>CopyOnWriteArrayList</code></td><td align="center"><code>ArrayList</code></td><td align="center">写时复制</td></tr><tr><td align="center"><code>CopyOnWriteArraySet</code></td><td align="center"><code>Set</code></td><td align="center">基于 <code>CopyOnWriteArrayList</code> 实现。</td></tr><tr><td align="center"><code>ConcurrentSkipListSet</code></td><td align="center"><code>SortedSet</code></td><td align="center">基于 <code>ConcurrentSkipListMap</code> 实现。</td></tr><tr><td align="center"><code>ConcurrentLinkedQueue</code></td><td align="center"><code>Queue</code></td><td align="center">线程安全的无界队列。底层采用单链表。支持 <code>FIFO</code>。</td></tr><tr><td align="center"><code>ConcurrentLinkedDeque</code></td><td align="center"><code>Deque</code></td><td align="center">线程安全的无界双端队列。底层采用双向链表。支持 <code>FIFO</code> 和 <code>FILO</code>。</td></tr><tr><td align="center"><code>ArrayBlockingQueue</code></td><td align="center"><code>Queue</code></td><td align="center">数组实现的阻塞队列。</td></tr><tr><td align="center"><code>LinkedBlockingQueue</code></td><td align="center"><code>Queue</code></td><td align="center">链表实现的阻塞队列。</td></tr><tr><td align="center"><code>LinkedBlockingDeque</code></td><td align="center"><code>Deque</code></td><td align="center">双向链表实现的双端阻塞队列。</td></tr></tbody></table><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h1><blockquote><p><code>ConcurrentHashMap</code> 是线程安全的 <code>HashMap</code> ，用于替代 <code>Hashtable</code>。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><code>ConcurrentHashMap</code> 实现了 <code>ConcurrentMap</code> 接口，而 <code>ConcurrentMap</code> 接口扩展了 <code>Map</code> 接口。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p><code>ConcurrentHashMap</code> 的实现包含了 <code>HashMap</code> 所有的基本特性，如：数据结构、读写策略等。</p><p><code>ConcurrentHashMap</code> 没有实现对 <code>Map</code> 加锁以提供独占访问。因此无法通过在客户端加锁的方式来创建新的原子操作。但是，一些常见的复合操作，如：“若没有则添加”、“若相等则移除”、“若相等则替换”，都已经实现为原子操作，并且是围绕 <code>ConcurrentMap</code> 的扩展接口而实现。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-comment">// 仅当 K 没有相应的映射值才插入</span>    <span class="hljs-function">V <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(K key, V value)</span></span>;    <span class="hljs-comment">// 仅当 K 被映射到 V 时才移除</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object key, Object value)</span></span>;    <span class="hljs-comment">// 仅当 K 被映射到 oldValue 时才替换为 newValue</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">replace</span><span class="hljs-params">(K key, V oldValue, V newValue)</span></span>;    <span class="hljs-comment">// 仅当 K 被映射到某个值时才替换为 newValue</span>    <span class="hljs-function">V <span class="hljs-title">replace</span><span class="hljs-params">(K key, V value)</span></span>;&#125;</code></pre><p>不同于 <code>Hashtable</code>，<code>ConcurrentHashMap</code> 提供的迭代器不会抛出 <code>ConcurrentModificationException</code>，因此不需要在迭代过程中对容器加锁。</p><blockquote><p>🔔 注意：一些需要对整个 <code>Map</code> 进行计算的方法，如 <code>size</code> 和 <code>isEmpty</code> ，由于返回的结果在计算时可能已经过期，所以并非实时的精确值。这是一种策略上的权衡，在并发环境下，这类方法由于总在不断变化，所以获取其实时精确值的意义不大。<code>ConcurrentHashMap</code> 弱化这类方法，以换取更重要操作（如：<code>get</code>、<code>put</code>、<code>containesKey</code>、<code>remove</code> 等）的性能。</p></blockquote><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>同 <code>HashMap</code></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><code>ConcurrentHashMap</code> 在 <code>Java 1.8</code> 之前和 <code>Java 1.8</code> 之后的实现有很大差异：</p><ul><li><code>Java 1.8</code> 之前采用<strong>分段锁机制</strong>细化锁粒度，降低阻塞，从而提高并发性。</li><li><code>Java 1.8</code> 之后基于 <code>CAS</code> 实现。</li></ul><h3 id="Java-1-7-的实现"><a href="#Java-1-7-的实现" class="headerlink" title="Java 1.7 的实现"></a>Java 1.7 的实现</h3><p>每一个 <code>segment</code> 都是一个 <code>HashEntry&lt;K,V&gt;[] table</code>， <code>table</code> 中的每一个元素本质上都是一个 <code>HashEntry</code> 的单向队列。比如 <code>table[3]</code> 为首节点，<code>table[3]-&gt;next</code> 为节点 <code>1</code>，之后为节点 <code>2</code>，依次类推。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// 将整个 hashmap 分成几个小的 map，每个 segment 都是一个锁；与 hashtable 相比，这么设计的目的是对于 put, remove 等操作，可以减少并发冲突，对</span>    <span class="hljs-comment">// 不属于同一个片段的节点可以并发操作，大大提高了性能</span>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;    <span class="hljs-comment">// 本质上 Segment 类就是一个小的 hashmap，里面 table 数组存储了各个节点的数据，继承了 ReentrantLock, 可以作为互斥锁使用</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;    &#125;    <span class="hljs-comment">// 基本节点，存储 Key, Value 值</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;        <span class="hljs-keyword">final</span> K key;        <span class="hljs-keyword">volatile</span> V value;        <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;    &#125;&#125;</code></pre><h3 id="Java-1-8-的实现"><a href="#Java-1-8-的实现" class="headerlink" title="Java 1.8 的实现"></a>Java 1.8 的实现</h3><p><code>JDK 8</code> 中主要做了 2 方面的改进</p><ul><li><p>取消 <code>segments</code> 字段，直接采用 <code>transient volatile HashEntry&lt;K,V&gt;[] table</code> 保存数据，采用 <code>table</code> 数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</p></li><li><p>将原先 <strong>数组＋单链表</strong> 的数据结构，变更为 <strong>数组＋单链表＋红黑树</strong> 的结构。对于 <code>hash</code> 表来说，最核心的能力在于将 <code>key hash</code> 之后能均匀的分布在数组中。如果 <code>hash</code> 之后散列的很均匀，那么 <code>table</code> 数组中的每个队列长度主要为 <code>0</code> 或者 <code>1</code>。但实际情况并非总是如此理想，虽然 <code>ConcurrentHashMap</code> 类默认的加载因子为 <code>0.75</code>，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为 <code>O(n)</code>；因此，对于个数超过 <code>8</code>(默认值)的列表，<code>JDK 1.8</code> 中采用了红黑树的结构，那么查询的时间复杂度可以降低到 <code>O(logN)</code>，可以改进性能。</p></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;        <span class="hljs-comment">// 如果 table 为空，初始化；否则，根据 hash 值计算得到数组索引i，如果 tab[i] 为空，直接新建节点 Node 即可。注：tab[i] 实质为链表或者红黑树的首节点。</span>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            tab = initTable();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,                         <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>        &#125;        <span class="hljs-comment">// 如果 tab[i] 不为空并且 hash 值为 MOVED，说明该链表正在进行 transfer 操作，返回扩容完成后的 table。</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)            tab = helpTransfer(tab, f);        <span class="hljs-keyword">else</span> &#123;            V oldVal = <span class="hljs-keyword">null</span>;            <span class="hljs-comment">// 针对首个节点进行加锁操作，而不是 segment，进一步减少线程冲突</span>            <span class="hljs-keyword">synchronized</span> (f) &#123;                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;                        binCount = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                            K ek;                            <span class="hljs-comment">// 如果在链表中找到值为 key 的节点 e，直接设置 e.val = value 即可。</span>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;                                oldVal = e.val;                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                    e.val = value;                                <span class="hljs-keyword">break</span>;                            &#125;                            <span class="hljs-comment">// 如果没有找到值为 key 的节点，直接新建 Node 并加入链表即可。</span>                            Node&lt;K,V&gt; pred = e;                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,                                                          value, <span class="hljs-keyword">null</span>);                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                    &#125;                    <span class="hljs-comment">// 如果首节点为 TreeBin 类型，说明为红黑树结构，执行 utTreeVal 操作。</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;                        Node&lt;K,V&gt; p;                        binCount = <span class="hljs-number">2</span>;                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                       value)) != <span class="hljs-keyword">null</span>) &#123;                            oldVal = p.val;                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                p.val = value;                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 如果节点数 &gt;＝8，那么转换链表结构为红黑树结构。</span>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> oldVal;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 计数增加1，有可能触发 transfer 操作(扩容)。</span>    addCount(<span class="hljs-number">1L</span>, binCount);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><code>CopyOnWriteArrayList</code></h1><p>每个 <code>CopyOnWriteArrayList</code> 对象里有一个 <code>array</code> 数组用来存放具体元素。<code>ReentrantLock</code> 独占锁用来保证同时只有一个线程对 <code>array</code> 进行修改。<br><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200724151232.png" srcset="/img/loading.gif" alt=""></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li><p>好处：<strong>任何的读操作都不用加锁</strong>，而且保证读取到的是读那一刻 <code>List</code> 完整的快照数据。由于读操作无法感知最新正在变化的数据，所以 <code>CopyOnWriteArrayList</code> 是<strong>弱一致性</strong>的。</p></li><li><p>写时复制技术因为每次修改都需要完整拷贝一次底层数组，所以有额外的性能开销，但是特别适用于<strong>读多写少</strong>的数据访问场景。</p></li></ul><h2 id="弱一致性问题"><a href="#弱一致性问题" class="headerlink" title="弱一致性问题"></a>弱一致性问题</h2><p>线程1在执行完步骤 <code>A</code> 后，执行步骤 <code>B</code> 前，线程2进行了 <code>remove</code> 操作。<br>虽然线程2已经删除了 <code>index</code> 处的元素，但由于 <code>array</code>指向的数组引用计数为 1 而不是 0，仍会返回 <code>index</code> 处的元素。</p><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>先将原容器 copy 一份，然后在新副本上执行写操作，之后再切换引用。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 1.获取独占锁</span>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 2.获取 array 数组</span>        Object[] elements = getArray();        <span class="hljs-keyword">int</span> len = elements.length;        <span class="hljs-comment">// 3.复制 array 到新数组</span>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 4.添加元素到新数组</span>        newElements[len] = e;        <span class="hljs-comment">// 5.用新数组替换原数组</span>        setArray(newElements);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 6.释放锁</span>        lock.unlock();    &#125;&#125;</code></pre><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>将除要删除元素之外的其他元素拷贝到新副本中，然后切换引用，将原容器引用指向新副本。同属写操作，需要加锁。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">// 获取独占锁</span>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        Object[] elements = getArray();        <span class="hljs-keyword">int</span> len = elements.length;        E oldValue = get(elements, index);        <span class="hljs-comment">// 需要移动的元素个数</span>        <span class="hljs-keyword">int</span> numMoved = len - index - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 若删除的是最后一个元素</span>        <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)           <span class="hljs-comment">// 拷贝前len-1个数据到新副本上，再切换引用</span>           setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));        <span class="hljs-keyword">else</span> &#123;            Object[] newElements = <span class="hljs-keyword">new</span> Object[len - <span class="hljs-number">1</span>];            <span class="hljs-comment">// 分两块复制到新数组</span>            System.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);            System.arraycopy(elements, index + <span class="hljs-number">1</span>, newElements, index,                             numMoved);            <span class="hljs-comment">// 设置新数组</span>            setArray(newElements);        &#125;        <span class="hljs-keyword">return</span> oldValue;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 释放锁</span>        lock.unlock();    &#125;&#125;</code></pre><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p><code>E get(int index)</code><br>读操作是不用加锁的，性能很高。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">return</span> get(getArray(), index);&#125;<span class="hljs-comment">// A.获取 array 数组</span><span class="hljs-keyword">final</span> Object[] getArray() &#123;    <span class="hljs-keyword">return</span> array;&#125;<span class="hljs-comment">// B.通过下标访问指定位置的数组元素</span><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">get</span><span class="hljs-params">(Object[] a, <span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">return</span> (E) a[index];&#125;</code></pre><h2 id="修改指定元素"><a href="#修改指定元素" class="headerlink" title="修改指定元素"></a>修改指定元素</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;    <span class="hljs-comment">// 获取独占锁</span>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 获取 array 数组</span>        Object[] elements = getArray();        <span class="hljs-comment">// 找到原位置上的值</span>        E oldValue = get(elements, index);        <span class="hljs-keyword">if</span> (oldValue != element) &#123;            <span class="hljs-keyword">int</span> len = elements.length;            <span class="hljs-comment">// 复制 array 到新数组</span>            Object[] newElements = Arrays.copyOf(elements, len);            <span class="hljs-comment">// 设置 index 位置的元素</span>            newElements[index] = element;            <span class="hljs-comment">// 用新数组替换旧数组</span>            setArray(newElements);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// Not quite a no-op; ensures volatile write semantics</span>            setArray(elements);        &#125;        <span class="hljs-keyword">return</span> oldValue;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 释放锁</span>        lock.unlock();    &#125;&#125;</code></pre><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a><code>BlockingQueue</code></h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;&#125;</code></pre><p>在 <code>BlockingQueue</code> 中，如果获取队列元素但是队列为空时，会阻塞，等待队列中有元素再返回；如果添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p><p><code>BlockingQueue</code> 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：</p><p>抛出异常；</p><ul><li>返回特殊值（<code>null</code> 或 <code>true</code>/<code>false</code>，取决于具体的操作）；</li><li>阻塞等待此操作，直到这个操作成功；</li><li>阻塞等待此操作，直到成功或者超时指定时间。<br>总结如下：</li></ul><table><thead><tr><th align="center">Operation</th><th align="center">Throws exception</th><th align="center">Special value</th><th align="center">Blocks</th><th align="center">Times out</th></tr></thead><tbody><tr><td align="center">Insert</td><td align="center">add(e)</td><td align="center">offer(e)</td><td align="center">put(e)</td><td align="center">offer(e, time, unit)</td></tr><tr><td align="center">Remove</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll(time, unit)</td></tr><tr><td align="center">Examine</td><td align="center">element()</td><td align="center">peek()</td><td align="center">not applicable</td><td align="center">not applicable</td></tr></tbody></table><p><code>BlockingQueue</code> 的各个实现类都遵循了这些规则。</p><p><code>BlockingQueue</code> 不接受 <code>null</code> 值元素。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发-原子类</title>
    <link href="/2020/07/21/concurrent-atomic/"/>
    <url>/2020/07/21/concurrent-atomic/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="为何需要原子变量类"><a href="#为何需要原子变量类" class="headerlink" title="为何需要原子变量类"></a>为何需要原子变量类</h2><p>保证线程安全是 <code>Java</code> 并发编程必须要解决的重要问题。<code>Java</code> 从原子性、可见性、有序性这三大特性入手，确保多线程的数据一致性。</p><ul><li><p>确保线程安全最常见的做法是利用锁机制（<code>Lock</code>、<code>sychronized</code>）来对共享数据做互斥同步，这样在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，那么操作必然是原子性的，线程安全的。互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题。</p></li><li><p><code>volatile</code> 是轻量级的锁（自然比普通锁性能要好），它保证了共享变量在多线程中的可见性，但无法保证原子性。所以，它只能在一些特定场景下使用。</p></li><li><p>为了兼顾原子性以及锁带来的性能问题，<code>Java</code> 引入了 <code>CAS</code> （主要体现在 Unsafe 类）来实现非阻塞同步（也叫乐观锁）。并基于 <code>CAS</code> ，提供了一套原子工具类。</p></li></ul><h2 id="原子变量类的作用"><a href="#原子变量类的作用" class="headerlink" title="原子变量类的作用"></a>原子变量类的作用</h2><p>原子变量类 <strong>比锁的粒度更细，更轻量级</strong>，并且对于在多处理器系统上实现高性能的并发代码来说是非常关键的。原子变量将发生竞争的范围缩小到单个变量上。</p><p>原子变量类相当于一种泛化的 <code>volatile</code> 变量，能够支持<strong>原子的、有条件的读/改/写</strong>操作。</p><p>原子类在内部使用 <code>CAS</code> 指令（基于硬件的支持）来实现同步。这些指令通常比锁更快。</p><p>原子变量类可以分为 <code>4</code> 组：</p><ul><li>基本类型<ul><li><code>AtomicBoolean</code> - 布尔类型原子类</li><li><code>AtomicInteger</code> - 整型原子类</li><li><code>AtomicLong</code> - 长整型原子类</li></ul></li><li>引用类型<ul><li><code>AtomicReference</code> - 引用类型原子类</li><li><code>AtomicMarkableReference</code> - 带有标记位的引用类型原子类</li><li><code>AtomicStampedReference</code> - 带有版本号的引用类型原子类</li></ul></li><li>数组类型<ul><li><code>AtomicIntegerArray</code> - 整形数组原子类</li><li><code>AtomicLongArray</code> - 长整型数组原子类</li><li><code>AtomicReferenceArray</code> - 引用类型数组原子类</li></ul></li><li>属性更新器类型<ul><li><code>AtomicIntegerFieldUpdater</code> - 整型字段的原子更新器。</li><li><code>AtomicLongFieldUpdater</code> - 长整型字段的原子更新器。</li><li><code>AtomicReferenceFieldUpdater</code> - 原子更新引用类型里的字段。</li></ul></li></ul><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>这一类型的原子类是针对 <code>Java</code> 基本类型进行操作。</p><ul><li><p><code>AtomicBoolean</code> - 布尔类型原子类</p></li><li><p><code>AtomicInteger</code> - 整型原子类</p></li><li><p><code>AtomicLong</code> - 长整型原子类</p></li></ul><p>以上类都支持 <code>CAS</code>，此外，<code>AtomicInteger</code>、<code>AtomicLong</code> 还支持算术运算。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取当前值</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span> <span class="hljs-comment">// 获取当前值，并设置新值</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span><span class="hljs-comment">// 获取当前值，并自增</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndDecrement</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取当前值，并自减</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> delta)</span> <span class="hljs-comment">// 获取当前值，并加上预期值</span></span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> <span class="hljs-comment">// 如果输入值（update）等于预期值，将该值设置为输入值</span></span><span class="hljs-function"><span class="hljs-comment">// 最终设置为 newValue，使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lazySet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span></span></code></pre><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><ul><li><p><code>AtomicReference</code> - 引用类型原子类</p></li><li><p><code>AtomicMarkableReference</code> - 带有标记位的引用类型原子类</p></li><li><p><code>AtomicStampedReference</code> - 带有版本号的引用类型原子类</p></li></ul><blockquote><p><code>AtomicStampedReference</code> 类在引用类型原子类中，彻底地解决了 <code>ABA</code> 问题，其它的 <code>CAS</code> 能力与另外两个类相近，所以最具代表性。因此，本节只针对 <code>AtomicStampedReference</code> 进行说明。</p></blockquote><h2 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于 AtomicReference 实现自旋锁</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicRefTest.java 2020/07/21 Tue 4:00 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicRefTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpinLock lock = <span class="hljs-keyword">new</span> SpinLock();        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            executorService.execute(<span class="hljs-keyword">new</span> MyThread(lock));        &#125;        executorService.shutdown();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * SpinLock</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span> </span>&#123;        <span class="hljs-keyword">private</span> AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;            Thread current = Thread.currentThread();            <span class="hljs-comment">// 自旋，为当前线程加锁</span>            <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-keyword">null</span>, current)) &#123;            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;            Thread current = Thread.currentThread();            <span class="hljs-comment">// 只有当前线程才释放锁</span>            atomicReference.compareAndSet(current, <span class="hljs-keyword">null</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * sell ticket by spin lock</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-keyword">private</span> SpinLock lock;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(SpinLock lock)</span> </span>&#123;            <span class="hljs-keyword">this</span>.lock = lock;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;                lock.lock();                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" sell ticket "</span> + ticket);                    ticket--;                &#125;                lock.unlock();            &#125;        &#125;            &#125;&#125;</code></pre><h2 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h2><p>原子类的实现基于 <code>CAS</code> 机制，而 <code>CAS</code> 存在 <code>ABA</code> 问题。正是为了解决 <code>ABA</code> 问题，才有了 <code>AtomicMarkableReference</code> 和 <code>AtomicStampedReference</code>。</p><p><code>AtomicMarkableReference</code> 使用一个布尔值作为标记，修改时在 <code>true</code> / <code>false</code> 之间切换。这种策略不能根本上解决 <code>ABA</code> 问题，但是可以降低 <code>ABA</code> 发生的几率。常用于缓存或者状态描述这样的场景。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AtomicMarkableReference 使用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicMarkableRefTest.java 2020/07/21 Tue 4:32 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicMarkableRefTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String INIT_TEXT = <span class="hljs-string">"abc"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> AtomicMarkableReference&lt;String&gt; amr = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(INIT_TEXT, <span class="hljs-keyword">false</span>);        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            executorService.submit(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(Math.abs((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">100</span>));                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                String name = Thread.currentThread().getName();                <span class="hljs-comment">// 若变量为 INIT &amp;&amp; 已被标记，则修改</span>                <span class="hljs-keyword">if</span> (amr.compareAndSet(INIT_TEXT, name, amr.isMarked(), !amr.isMarked())) &#123;                String name = Thread.currentThread().getName();                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 修改了对象"</span>);                    System.out.println(<span class="hljs-string">"新的对象为："</span> + amr.getReference());                &#125;            &#125;);        &#125;        executorService.shutdown();        executorService.awaitTermination(<span class="hljs-number">3</span>, TimeUnit.SECONDS);    &#125;&#125;</code></pre><h2 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h2><p><code>AtomicStampedReference</code> 使用一个整型值做为版本号，每次更新前先比较版本号，如果一致，才进行修改。通过这种策略，可以根本上解决 <code>ABA</code> 问题。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AtomicStampedReference 使用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicStampedRefTest.java 2020/07/21 Tue 7:02 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicStampedRefTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String INIT_REF = <span class="hljs-string">"pool-1-thread-3"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; asr = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(INIT_REF, <span class="hljs-number">0</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        System.out.println(<span class="hljs-string">"初始对象为: "</span> + asr.getReference());        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            executorService.submit(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(Math.abs((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">100</span>));                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> stamp = asr.getStamp();                String name = Thread.currentThread().getName();                <span class="hljs-comment">// 若变量为 INIT &amp;&amp; 版本号为 stamp，则修改</span>                <span class="hljs-keyword">if</span> (asr.compareAndSet(INIT_REF, name, stamp, stamp + <span class="hljs-number">1</span>)) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 修改了对象"</span>);                    System.out.println(<span class="hljs-string">"新的对象为："</span> + asr.getReference());                &#125;            &#125;);        &#125;        executorService.shutdown();        executorService.awaitTermination(<span class="hljs-number">3</span>, TimeUnit.SECONDS);    &#125;&#125;</code></pre><h1 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h1><ul><li><p><code>AtomicIntegerArray</code> - 整形数组原子类</p></li><li><p><code>AtomicLongArray</code> - 长整型数组原子类</p></li><li><p><code>AtomicReferenceArray</code> - 引用类型数组原子类</p></li></ul><p>数组类型的原子类为 <strong>数组元素</strong> 提供了 <code>volatile</code> 类型的访问语义，这是普通数组所不具备的特性 —— <code>volatile</code> 类型的数组仅在<strong>数组引用</strong>上具有 <code>volatile</code> 语义。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AtomicIntegerArray 使用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicIntegerArrayTest.java 2020/07/21 Tue 7:17 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerArrayTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicIntegerArray atomicIntegerArray = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        System.out.println(<span class="hljs-string">"Init Values: "</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;            atomicIntegerArray.set(i, i);            System.out.print(atomicIntegerArray.get(i) + <span class="hljs-string">" "</span>);        &#125;        System.out.println();        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Increasement());        Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Compare());        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(<span class="hljs-string">"Final Values: "</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;            System.out.print(atomicIntegerArray.get(i) + <span class="hljs-string">" "</span>);        &#125;        System.out.println();    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Increasement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 对数组的每个元素自增 1</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;                <span class="hljs-keyword">int</span> value = atomicIntegerArray.incrementAndGet(i);                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">", index = "</span> + i + <span class="hljs-string">", value = "</span> + value);            &#125;        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compare</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 找到数组值为 2 的元素，修改为 3</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;                <span class="hljs-keyword">boolean</span> swapped = atomicIntegerArray.compareAndSet(i, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);                <span class="hljs-keyword">if</span> (swapped) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" swapped, index = "</span> + i + <span class="hljs-string">", value = 3"</span>);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="属性更新器类型"><a href="#属性更新器类型" class="headerlink" title="属性更新器类型"></a>属性更新器类型</h1><p>更新器类支持基于<strong>反射</strong>机制的更新字段值的原子操作。</p><ul><li><p><code>AtomicIntegerFieldUpdater</code> - 整型字段的原子更新器。</p></li><li><p><code>AtomicLongFieldUpdater</code> - 长整型字段的原子更新器。</p></li><li><p><code>AtomicReferenceFieldUpdater</code> - 原子更新引用类型里的字段。</p></li></ul><p>这些类的使用有一定限制：</p><ul><li>因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 <code>newUpdater()</code> 创建一个更新器，并且需要设置想要更新的类和属性。</li><li>字段必须是 <code>volatile</code> 类型的；</li><li>不能作用于静态变量（<code>static</code>）；</li><li>不能作用于常量（<code>final</code>）；</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AtomicReferenceFieldUpdater 使用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicFieldUpdaterTest.java 2020/07/21 Tue 7:33 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicFieldUpdaterTest</span> </span>&#123;    <span class="hljs-keyword">static</span> User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"begin"</span>);    <span class="hljs-keyword">static</span> AtomicReferenceFieldUpdater&lt;User, String&gt; updater =            AtomicReferenceFieldUpdater.newUpdater(User.class, String.class, "name");    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            executorService.submit(() -&gt; &#123;            <span class="hljs-comment">// 若 name 的值为 ”begin“，则修改为 “end“</span>                <span class="hljs-keyword">if</span> (updater.compareAndSet(user, <span class="hljs-string">"begin"</span>, <span class="hljs-string">"end"</span>)) &#123;                    <span class="hljs-keyword">try</span> &#123;                        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 已修改 name = "</span> + user.getName());                &#125; <span class="hljs-keyword">else</span> &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"已被其他线程修改"</span>);                &#125;            &#125;);        &#125;        executorService.shutdown();    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;        <span class="hljs-keyword">volatile</span> String name;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并发-锁原理</title>
    <link href="/2020/07/17/concurrent-lock/"/>
    <url>/2020/07/17/concurrent-lock/</url>
    
    <content type="html"><![CDATA[<h1 id="并发锁"><a href="#并发锁" class="headerlink" title="并发锁"></a>并发锁</h1><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此<strong>乐观锁不会上锁</strong>，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ol><li><code>CAS</code> 机制</li></ol><p><code>CAS</code> 操作包括了 3 个操作数：<br>    (1) 需要读写的内存位置(<code>V</code>)<br>    (2) 进行比较的预期值(<code>A</code>)<br>    (3) 拟写入的新值(<code>B</code>) </p><p><code>CAS</code> 操作逻辑如下：如果内存位置 <code>V</code> 的值等于预期的 <code>A</code> 值，则将该位置更新为新值 <code>B</code>，否则不进行任何操作。许多 <code>CAS</code> 的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。</p><blockquote><p><code>CAS</code> 是由 <code>CPU</code> 支持的原子操作，其原子性是在硬件层面进行保证的。</p></blockquote><ol start="2"><li>版本号机制<br>版本号机制的基本思路是在数据中增加一个字段 <code>version</code>，表示该数据的版本号，每当数据被修改，版本号 <code>+1</code>。</li></ol><ul><li>当某个线程查询数据时，将该数据的版本号一起查出来；</li><li>当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。</li></ul><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</p><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><p>悲观锁的实现方式是<strong>加锁</strong>，加锁既可以是对<strong>代码块加锁</strong>（如 <code>Java</code>的 <code>synchronized</code> 关键字和 <code>Lock</code>），也可以是对<strong>数据加锁</strong>（如 <code>MySQL</code> 中的排它锁）。</p><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>根据线程获取锁的抢占机制，锁可分为公平锁与非公平锁。</p><ul><li>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。</li><li>非公平锁在运行时闯入，也就是先来不一定先得，如 <code>synchronized</code>。</li><li><code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>，默认是非公平锁，但支持公平锁。</li><li>在没有公平性需求的情况下尽量使用非公平锁，因为公平锁会带来性能开销。</li></ul><h2 id="独占锁与共享锁"><a href="#独占锁与共享锁" class="headerlink" title="独占锁与共享锁"></a>独占锁与共享锁</h2><p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁可分为独占锁与共享锁。</p><ul><li>独占锁是一种悲观锁，每次访问资源都加上了互斥锁，在同一时间只允许一个线程读取数据。</li><li>共享锁是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</li></ul><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>当一个线程再次获取它已经获取的琐时，如果不被阻塞，那么该锁是可被重入的。</p><p><code>synchronized</code> 内部锁是可重入锁，在其内部维护一个标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。当一个线程获取了该锁时，计数器的值会变成 <code>1</code>，这时其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞挂起。</p><p>但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值 <code>+1</code>，当释放锁后值 <code>-1</code>。当计数器值为 <code>0</code>，线程标示被重置为 <code>null</code>，这时候被阻塞的线程会被唤醒来竞争该锁。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>当前线程在获取锁时，如果发现锁已被其他线程占有，它不马上阻塞自己，在不放弃 <code>CPU</code> 使用权的情况下，多次尝试获取（默认10次，可以使用 <code>-XX:PreBlockSpinsh</code> 参数设置该值），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定次数后仍没有获取到锁则当前线程才会被阻塞挂起。<br>自旋锁是使用 <code>CPU</code> 时间换取线程阻塞与调度的开销，但是很有可能这些 <code>CPU</code> 时间白白浪费了。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的相互等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去</p><h2 id="基本条件"><a href="#基本条件" class="headerlink" title="基本条件"></a>基本条件</h2><ol><li>互斥</li><li>请求并持有</li><li>不可剥夺</li><li>环路等待</li></ol><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><blockquote><p>使用申请资源的有序性，破坏请求并持有和环路等待条件。</p></blockquote><ul><li><p>避免一个线程同时获取多个锁。</p></li><li><p>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</p></li><li><p>尝试使用定时锁 <code>lock.tryLock(timeout)</code>，避免锁一直不能释放。</p></li><li><p>对于数据库锁，加锁和解锁必须在一个数据库连接中里，否则会出现解锁失败的情况。</p></li></ul><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><blockquote><p><code>AbstractQueuedSynchronizer</code>（简称 <code>AQS</code>）是队列同步器，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>Semaphore</code> 等）。</p><p>因此，要想深入理解 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 等并发锁和同步工具，必须先理解 <code>AQS</code> 的要点和原理。</p></blockquote><h2 id="AQS-的要点"><a href="#AQS-的要点" class="headerlink" title="AQS 的要点"></a><code>AQS</code> 的要点</h2><p>在 <code>java.util.concurrent.locks</code> 包中的相关锁(常用的有 <code>ReentrantLock</code>、 <code>ReadWriteLock</code>)都是基于 <code>AQS</code> 来实现。这些锁都没有直接继承 <code>AQS</code>，而是定义了一个 <code>Sync</code> 类去继承 <code>AQS</code>。为什么要这样呢？因为锁面向的是使用用户，而同步器面向的则是线程控制，那么在锁的实现中聚合同步器而不是直接继承 <code>AQS</code> 就可以很好的隔离二者所关注的事情。</p><p><strong><code>AQS</code> 提供了对独享锁与共享锁的支持。</strong></p><h3 id="独享锁-API"><a href="#独享锁-API" class="headerlink" title="独享锁 API"></a>独享锁 <code>API</code></h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span></code></pre><ul><li><code>acquire</code> - 获取独占锁。</li><li><code>acquireInterruptibly</code> - 获取可中断的独占锁。</li><li><code>tryAcquireNanos</code> - 尝试在指定时间内获取可中断的独占锁。在以下三种情况下回返回：<ul><li>在超时时间内，当前线程成功获取了锁；</li><li>当前线程在超时时间内被中断；</li><li>超时时间结束，仍未获得锁返回 false。</li></ul></li><li><code>release</code> - 释放独占锁。</li></ul><h3 id="共享锁-API"><a href="#共享锁-API" class="headerlink" title="共享锁 API"></a>共享锁 <code>API</code></h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquireSharedNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span></code></pre><ul><li><code>acquireShared</code> - 获取共享锁。</li><li><code>acquireSharedInterruptibly</code> - 获取可中断的共享锁。</li><li><code>tryAcquireSharedNanos</code> - 尝试在指定时间内获取可中断的共享锁。</li><li><code>release</code> - 释放共享锁。</li></ul><h2 id="AQS-的原理"><a href="#AQS-的原理" class="headerlink" title="AQS 的原理"></a><code>AQS</code> 的原理</h2><h3 id="AQS-的数据结构"><a href="#AQS-的数据结构" class="headerlink" title="AQS 的数据结构"></a><code>AQS</code> 的数据结构</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">/** 等待队列的队头，懒加载。只能通过 setHead 方法修改。 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;    <span class="hljs-comment">/** 等待队列的队尾，懒加载。只能通过 enq 方法添加新的等待节点。*/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;    <span class="hljs-comment">/** 同步状态 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;&#125;</code></pre><ul><li><p><code>state</code> - <code>AQS</code> 使用一个整型的 <code>volatile</code> 变量来 维护同步状态。</p><ul><li>这个整数状态的意义由子类来赋予，如 <code>ReentrantLock</code> 中该状态值表示所有者线程已经重复获取该锁的次数，<code>Semaphore</code> 中该状态值表示剩余的许可数量。</li></ul></li><li><p><code>head</code> 和 <code>tail</code> - <code>AQS</code> 维护了一个 <code>Node</code> 类型（<code>AQS</code> 的内部类）的双链表来完成同步状态的管理。这个双链表是一个双向的 <code>FIFO</code> 队列，通过 <code>head</code> 和 <code>tail</code> 指针进行访问。当有线程获取锁失败后，就被添加到队列末尾。</p></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200718161601.png" srcset="/img/loading.gif" alt="AQS结构"></p><p><code>Node</code> 的源码</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-comment">/** 该等待同步的节点处于共享模式 */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();    <span class="hljs-comment">/** 该等待同步的节点处于独占模式 */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">/** 线程等待状态，状态值有: 0、1、-1、-2、-3 */</span>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;    <span class="hljs-comment">/** 前驱节点 */</span>    <span class="hljs-keyword">volatile</span> Node prev;    <span class="hljs-comment">/** 后继节点 */</span>    <span class="hljs-keyword">volatile</span> Node next;    <span class="hljs-comment">/** 等待锁的线程 */</span>    <span class="hljs-keyword">volatile</span> Thread thread;        <span class="hljs-comment">/** 和节点是否共享有关 */</span>    Node nextWaiter;&#125;</code></pre><p>很显然，<code>Node</code> 是一个双链表结构。</p><p><code>waitStatus</code> - <code>Node</code> 使用一个整型的 <code>volatile</code> 变量来 维护 <code>AQS</code> 同步队列中线程节点的状态。<code>waitStatus</code> 有五个状态值：</p><ul><li><p><code>CANCELLED(1)</code> - 此状态表示：该节点的线程可能由于超时或被中断而 <strong>处于被取消(作废)状态</strong>，一旦处于这个状态，表示这个节点应该从等待队列中移除。</p></li><li><p><code>SIGNAL(-1)</code> - 此状态表示：后继节点会被挂起，因此在当前节点释放锁或被取消之后，必须唤醒(<code>unparking</code>)其后继结点。</p></li><li><p><code>CONDITION(-2)</code> - 此状态表示：该节点的线程 处于等待条件状态，不会被当作是同步队列上的节点，直到被唤醒(<code>signal</code>)，设置其值为 0，再重新进入阻塞状态。</p></li><li><p><code>PROPAGATE(-3)</code> - 此状态表示：下一个 <code>acquireShared</code> 应无条件传播。</p></li><li><p><code>0</code> - 非以上状态。</p></li></ul><h3 id="独占锁的获取和释放"><a href="#独占锁的获取和释放" class="headerlink" title="独占锁的获取和释放"></a>独占锁的获取和释放</h3><h4 id="获取独占锁"><a href="#获取独占锁" class="headerlink" title="获取独占锁"></a>获取独占锁</h4><p><code>AQS</code> 中使用 <code>acquire(int arg)</code> 方法获取独占锁，其大致流程如下：</p><ol><li><p>先尝试获取同步状态，如果获取同步状态成功，则结束方法，直接返回。</p></li><li><p>如果获取同步状态不成功，<code>AQS</code> 会不断尝试利用 <code>CAS</code> 操作将当前线程插入等待同步队列的队尾，直到成功为止。</p></li><li><p>接着，不断尝试为等待队列中的线程节点获取独占锁。<br><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200718161748.png" srcset="/img/loading.gif" alt="获取锁前"><br><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200718162338.png" srcset="/img/loading.gif" alt="获取锁"><br>详细流程可以用下图来表示，请结合源码来理解（一图胜千言）：<br><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200718162114.png" srcset="/img/loading.gif" alt="AQS获取锁工作流程"></p></li></ol><h4 id="释放独占锁"><a href="#释放独占锁" class="headerlink" title="释放独占锁"></a>释放独占锁</h4><p><code>AQS</code> 中使用 <code>release(int arg)</code> 方法释放独占锁，其大致流程如下：</p><ol><li><p>先尝试获取解锁线程的同步状态，如果获取同步状态不成功，则结束方法，直接返回。</p></li><li><p>如果获取同步状态成功，<code>AQS</code> 会尝试唤醒当前线程节点的后继节点。</p></li></ol><h4 id="获取可中断的独占锁"><a href="#获取可中断的独占锁" class="headerlink" title="获取可中断的独占锁"></a>获取可中断的独占锁</h4><p><code>AQS</code> 中使用 <code>acquireInterruptibly(int arg)</code> 方法获取可中断的独占锁。</p><p><code>acquireInterruptibly(int arg)</code> 实现方式相较于获取独占锁方法（<code>acquire</code>）非常相似，区别仅在于它会通过 <code>Thread.interrupted</code> 检测当前线程是否被中断，如果是，则立即抛出中断异常（<code>InterruptedException</code>）。</p><h4 id="获取超时等待式的独占锁"><a href="#获取超时等待式的独占锁" class="headerlink" title="获取超时等待式的独占锁"></a>获取超时等待式的独占锁</h4><p><code>AQS</code> 中使用 <code>tryAcquireNanos(int arg)</code> 方法获取超时等待的独占锁。</p><p><code>doAcquireNanos</code> 的实现方式 相较于获取独占锁方法（ <code>acquire</code>）非常相似，区别在于它会根据超时时间和当前时间计算出截止时间。在获取锁的流程中，会不断判断是否超时，如果超时，直接返回 <code>false</code>；如果没超时，则用 <code>LockSupport.parkNanos</code> 来阻塞当前线程。</p><h3 id="共享锁的获取和释放"><a href="#共享锁的获取和释放" class="headerlink" title="共享锁的获取和释放"></a>共享锁的获取和释放</h3><h4 id="获取共享锁"><a href="#获取共享锁" class="headerlink" title="获取共享锁"></a>获取共享锁</h4><p><code>AQS</code> 中使用 <code>acquireShared(int arg)</code> 方法获取共享锁。</p><p><code>acquireShared</code> 方法和 <code>acquire</code> 方法的逻辑很相似，区别仅在于自旋的条件以及节点出队的操作有所不同。</p><p>成功获得共享锁的条件如下：</p><ul><li><p><code>tryAcquireShared(arg)</code> 返回值大于等于 <code>0</code> （这意味着共享锁的 permit 还没有用完）。</p></li><li><p>当前节点的前驱节点是头结点。</p></li></ul><h4 id="释放共享锁"><a href="#释放共享锁" class="headerlink" title="释放共享锁"></a>释放共享锁</h4><p><code>AQS</code> 中使用 <code>releaseShared(int arg)</code> 方法释放共享锁。</p><p><code>releaseShared</code> 首先会尝试释放同步状态，如果成功，则解锁一个或多个后继线程节点。释放共享锁和释放独享锁流程大体相似，区别在于：</p><p>对于独享模式，如果需要 <code>SIGNAL</code>，释放仅相当于调用头节点的 <code>unparkSuccessor</code>。</p><h4 id="获取可中断的共享锁"><a href="#获取可中断的共享锁" class="headerlink" title="获取可中断的共享锁"></a>获取可中断的共享锁</h4><p><code>AQS</code> 中使用 <code>acquireSharedInterruptibly(int arg)</code> 方法获取可中断的共享锁。</p><p><code>acquireSharedInterruptibly</code> 方法与 <code>acquireInterruptibly</code> 几乎一致，不再赘述。</p><h4 id="获取超时等待式的共享锁"><a href="#获取超时等待式的共享锁" class="headerlink" title="获取超时等待式的共享锁"></a>获取超时等待式的共享锁</h4><p><code>AQS</code> 中使用 <code>tryAcquireSharedNanos(int arg)</code> 方法获取超时等待式的共享锁。</p><p><code>tryAcquireSharedNanos</code> 方法与 <code>tryAcquireNanos</code> 几乎一致，不再赘述。</p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h1><blockquote><p><code>ReentrantLock</code> 类是 <code>Lock</code> 接口的具体实现，它是一个可重入锁。与内置锁 <code>synchronized</code> 不同，<code>ReentrantLock</code> 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作，所有获取锁、释放锁的操作都是显式的操作。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><p><code>ReentrantLock</code> 提供了与 <code>synchronized</code> 相同的互斥性、内存可见性和可重入性。</p></li><li><p><code>ReentrantLock</code> 支持公平锁和<strong>非公平锁（默认）</strong>两种模式。</p></li><li><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，支持了 <code>synchronized</code> 所不具备的灵活性。</p><ul><li><p><code>synchronized</code> 无法中断一个正在等待获取锁的线程</p></li><li><p><code>synchronized</code> 无法在请求获取一个锁时无休止地等待</p></li></ul></li></ul><p><code>Lcok</code> 接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lock</span> </span>&#123;    <span class="hljs-comment">// 获取锁</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 锁未被另一个线程持有，且线程没有被中断的情况下，才能获取锁。</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-comment">// 尝试获取锁，仅在调用时锁未被另一个线程持有的情况下，才获取该锁。</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 和 tryLock() 类似，区别仅在于限定时间，如果限定时间内未获取到锁，视为失败。</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-comment">// 释放锁</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 返回一个绑定到 Lock 对象上的 Condition 实例</span>    <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;&#125;</code></pre><ul><li><code>ReentrantLock()</code> - 默认构造方法会初始化一个非公平锁（<code>NonfairSync</code>）；</li><li><code>ReentrantLock(boolean)</code> - <code>new ReentrantLock(true)</code> 会初始化一个公平锁（<code>FairSync</code>）。</li></ul><h3 id="lock-和-unlock-方法"><a href="#lock-和-unlock-方法" class="headerlink" title="lock 和 unlock 方法"></a><code>lock</code> 和 <code>unlock</code> 方法</h3><ul><li><p><code>lock()</code> - <strong>无条件获取锁</strong>。如果当前线程无法获取锁，则当前线程进入休眠状态不可用，直至当前线程获取到锁。如果该锁没有被另一个线程持有，则获取该锁并立即返回，将锁的持有计数设置为 <code>1</code>。</p></li><li><p><code>unlock()</code> - 用于释放锁。</p><blockquote><p>🔔 注意：获取锁操作 <code>lock()</code> 必须在 <code>try catch</code> 块中进行，并且将释放锁操作 <code>unlock()</code> 放在 <code>finally</code> 块中进行，以保证锁一定被被释放，防止死锁的发生。</p></blockquote></li></ul><h3 id="tryLock-方法"><a href="#tryLock-方法" class="headerlink" title="tryLock 方法"></a><code>tryLock</code> 方法</h3><p>与无条件获取锁相比，<code>tryLock</code> 有更完善的容错机制。</p><ul><li><p><code>tryLock()</code> - 可轮询获取锁。如果成功，则返回 <code>true</code>；如果失败，则返回 <code>false</code>。也就是说，这个方法无论成败都会<strong>立即返回</strong>，获取不到锁（锁已被其他线程获取）时不会一直等待。</p></li><li><p><code>tryLock(long, TimeUnit)</code> - 可定时获取锁。和 <code>tryLock()</code> 类似，区别仅在于这个方法在获取不到锁时会等待一定的时间，在时间期限之内如果还获取不到锁，就返回 <code>false</code>。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 <code>true</code>。</p></li></ul><h3 id="lockInterruptibly-方法"><a href="#lockInterruptibly-方法" class="headerlink" title="lockInterruptibly 方法"></a><code>lockInterruptibly</code> 方法</h3><p><code>lockInterruptibly()</code> - 可中断获取锁。可中断获取锁可以在获得锁的同时保持对中断的响应。可中断获取锁比其它获取锁的方式稍微复杂一些，需要两个 <code>try-catch</code> 块（如果在获取锁的操作中抛出了 <code>InterruptedException</code> ，那么可以使用标准的 <code>try-finally</code> 加锁模式）。</p><p>举例来说：假设有两个线程同时通过 <code>lock.lockInterruptibly()</code> 获取某个锁时，若线程 <code>A</code> 获取到了锁，则线程 <code>B</code> 只能等待。若此时对线程 <code>B</code> 调用 <code>threadB.interrupt()</code> 方法能够中断线程 <code>B</code> 的等待过程。由于 <code>lockInterruptibly()</code> 的声明中抛出了异常，所以 <code>lock.lockInterruptibly()</code> 必须放在 <code>try</code> 块中或者在调用 <code>lockInterruptibly()</code> 的方法外声明抛出 <code>InterruptedException</code>。</p><blockquote><p>🔔 注意：当一个线程获取了锁之后，是不会被 <code>interrupt()</code> 方法中断的。单独调用 <code>interrupt()</code> 方法不能中断正在运行状态中的线程，只能中断阻塞状态中的线程。因此当通过 <code>lockInterruptibly()</code> 方法获取某个锁时，如果未获取到锁，只有在等待的状态下，才可以响应中断。</p></blockquote><h3 id="newCondition-方法"><a href="#newCondition-方法" class="headerlink" title="newCondition 方法"></a><code>newCondition</code> 方法</h3><p><code>newCondition()</code> - 返回一个绑定到 <code>Lock</code> 对象上的 <code>Condition</code> 实例。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="ReentrantLock-的数据结构"><a href="#ReentrantLock-的数据结构" class="headerlink" title="ReentrantLock 的数据结构"></a><code>ReentrantLock</code> 的数据结构</h3><p>它有一个核心字段：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;</code></pre><p><code>sync</code> - 内部抽象类 <code>ReentrantLock.Sync</code> 对象，<code>Sync</code> 继承自 <code>AQS</code>。它有两个子类：</p><ol><li><p><code>ReentrantLock.FairSync</code> - 公平锁。</p></li><li><p><code>ReentrantLock.NonfairSync</code> - 非公平锁。</p></li></ol><h3 id="获取锁和释放锁"><a href="#获取锁和释放锁" class="headerlink" title="获取锁和释放锁"></a>获取锁和释放锁</h3><p><code>ReentrantLock</code> 获取锁和释放锁的接口，从表象看，是调用 <code>ReentrantLock.FairSync</code> 或 <code>ReentrantLock.NonfairSync</code> 中各自的实现；从本质上看，是基于 <code>AQS</code> 的实现。</p><ul><li><p><code>void lock()</code> 调用 <code>Sync</code> 的 <code>lock()</code> 方法。</p></li><li><p><code>void lockInterruptibly()</code> 直接调用 <code>AQS</code> 的 获取可中断的独占锁 方法 <code>lockInterruptibly()</code>。</p></li><li><p><code>boolean tryLock()</code> 调用 <code>Sync</code> 的 <code>nonfairTryAcquire()</code> 。</p></li><li><p><code>boolean tryLock(long time, TimeUnit unit)</code> 直接调用 <code>AQS</code> 的 获取超时等待式的独占锁 方法 <code>tryAcquireNanos(int arg, long nanosTimeout)</code>。</p></li><li><p><code>void unlock()</code> 直接调用 <code>AQS</code> 的 释放独占锁 方法 <code>release(int arg)</code> 。</p></li></ul><h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a><code>ReentrantReadWriteLock</code></h1><blockquote><p><code>ReentrantReadWriteLock</code> 类是 <code>ReadWriteLock</code> 接口的具体实现，它是一个<strong>可重入</strong>的读写锁。<code>ReentrantReadWriteLock</code> 维护了一对读写锁，将读写锁分开，有利于提高并发效率。</p></blockquote><p><code>ReentrantLock</code> 实现了一种标准的互斥锁：每次最多只有一个线程能持有 <code>ReentrantLock</code>。但对于维护数据的完整性来说，互斥通常是一种过于强硬的加锁策略，因此也就不必要地限制了并发性。大多数场景下，读操作比写操作频繁，只要保证每个线程都能读取到最新数据，并且在读数据时不会有其它线程在修改数据，那么就不会出现线程安全问题。这种策略减少了互斥同步，自然也提升了并发性能，<code>ReentrantReadWriteLock</code> 就是这种策略的具体实现。</p><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><ul><li><p><code>ReentrantReadWriteLock</code> 适用于读多写少的场景。如果是写多读少的场景，由于 <code>ReentrantReadWriteLock</code> 其内部实现比 <code>ReentrantLock</code> 复杂，性能可能反而要差一些。如果存在这样的问题，需要具体问题具体分析。由于 <code>ReentrantReadWriteLock</code> 的读写锁（<code>ReadLock</code>、<code>WriteLock</code>）都实现了 <code>Lock</code> 接口，所以要替换为 <code>ReentrantLock</code> 也较为容易。</p></li><li><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> 接口，支持了 <code>ReentrantLock</code> 所不具备的读写锁分离。<code>ReentrantReadWriteLock</code> 维护了一对读写锁（<code>ReadLock</code>、<code>WriteLock</code>）。将读写锁分开，有利于提高并发效率。<code>ReentrantReadWriteLock</code> 的加锁策略是：<strong>允许多个读操作并发执行，但每次只允许一个写操作</strong>。</p></li><li><p><code>ReentrantReadWriteLock</code> 为读写锁都提供了可重入的加锁语义。</p></li><li><p><code>ReentrantReadWriteLock</code> 支持公平锁和非公平锁（默认）两种模式。</p></li></ul><p><code>ReadWriteLock</code> 接口定义如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReadWriteLock</span> </span>&#123;    <span class="hljs-comment">// 返回用于读操作的锁</span>    <span class="hljs-function">Lock <span class="hljs-title">readLock</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 返回用于写操作的锁</span>    <span class="hljs-function">Lock <span class="hljs-title">writeLock</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantReadWriteLock</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;&#125;</code></pre><ul><li><p><code>ReentrantReadWriteLock()</code> - 默认构造方法会初始化一个非公平锁（<code>NonfairSync</code>）。在非公平的锁中，线程获得锁的顺序是不确定的。写线程降级为读线程是可以的，但读线程升级为写线程是不可以的（这样会导致死锁）。</p></li><li><p><code>ReentrantReadWriteLock(boolean)</code> - <code>new ReentrantLock(true)</code> 会初始化一个公平锁（<code>FairSync</code>）。对于公平锁，等待时间最长的线程将优先获得锁。如果这个锁是读线程持有，则另一个线程请求写锁，那么其他读线程都不能获得读锁，直到写线程释放写锁。</p></li></ul><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><code>ReentrantReadWriteLock</code> 与 <code>ReentrantLock</code> 用法上的差异，主要在于<strong>读写锁的配合使用</strong>。本文以一个典型使用场景来进行讲解。</p><p>示例：基于 <code>ReentrantReadWriteLock</code> 实现一个简单的本地缓存</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 简单的无界缓存实现</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 使用 WeakHashMap 存储键值对。WeakHashMap 中存储的对象是弱引用，JVM GC 时会自动清除没有被引用的弱引用对象。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnboundedCache</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; cacheMap = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock cacheLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;        cacheLock.readLock().lock();        V value;        <span class="hljs-keyword">try</span> &#123;            value = cacheMap.get(key);            String log = String.format(<span class="hljs-string">"%s 读数据 %s:%s"</span>, Thread.currentThread().getName(), key, value);            System.out.println(log);        &#125; <span class="hljs-keyword">finally</span> &#123;            cacheLock.readLock().unlock();        &#125;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;        cacheLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            cacheMap.put(key, value);            String log = String.format(<span class="hljs-string">"%s 写入数据 %s:%s"</span>, Thread.currentThread().getName(), key, value);            System.out.println(log);        &#125; <span class="hljs-keyword">finally</span> &#123;            cacheLock.writeLock().unlock();        &#125;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span> </span>&#123;        cacheLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> cacheMap.remove(key);        &#125; <span class="hljs-keyword">finally</span> &#123;            cacheLock.writeLock().unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        cacheLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.cacheMap.clear();        &#125; <span class="hljs-keyword">finally</span> &#123;            cacheLock.writeLock().unlock();        &#125;    &#125;&#125;</code></pre><ul><li><p>使用 <code>WeakHashMap</code> 而不是 <code>HashMap</code> 来存储键值对。<code>WeakHashMap</code> 中存储的对象是弱引用，<code>JVM GC</code> 时会自动清除没有被引用的弱引用对象。</p></li><li><p>向 Map 写数据前加写锁，写完后，释放写锁。</p></li><li><p>向 Map 读数据前加读锁，读完后，释放读锁。</p></li></ul><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h3 id="ReentrantReadWriteLock-的数据结构"><a href="#ReentrantReadWriteLock-的数据结构" class="headerlink" title="ReentrantReadWriteLock 的数据结构"></a><code>ReentrantReadWriteLock</code> 的数据结构</h3><pre><code class="hljs java"><span class="hljs-comment">/** Inner class providing readlock */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;<span class="hljs-comment">/** Inner class providing writelock */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;<span class="hljs-comment">/** Performs all synchronization mechanics */</span><span class="hljs-keyword">final</span> Sync sync;<span class="hljs-keyword">public</span> ReentrantReadWriteLock.<span class="hljs-function">WriteLock <span class="hljs-title">writeLock</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> writerLock; &#125;<span class="hljs-keyword">public</span> ReentrantReadWriteLock.<span class="hljs-function">ReadLock  <span class="hljs-title">readLock</span><span class="hljs-params">()</span>  </span>&#123; <span class="hljs-keyword">return</span> readerLock; &#125;</code></pre><ul><li><p><code>sync</code> - 内部类 <code>ReentrantReadWriteLock.Sync</code> 对象。与 <code>ReentrantLock</code> 类似，它有两个子类：<code>ReentrantReadWriteLock.FairSync</code> 和 <code>ReentrantReadWriteLock.NonfairSync</code> ，分别表示公平锁和非公平锁的实现。</p></li><li><p><code>readerLock</code> - 内部类 <code>ReentrantReadWriteLock.ReadLock</code> 对象，这是一把读锁。</p></li><li><p><code>writerLock</code> - 内部类 <code>ReentrantReadWriteLock.WriteLock</code> 对象，这是一把写锁。</p></li></ul><h3 id="获取锁和释放锁-1"><a href="#获取锁和释放锁-1" class="headerlink" title="获取锁和释放锁"></a>获取锁和释放锁</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// 调用 AQS 获取共享锁方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        sync.acquireShared(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// 调用 AQS 释放共享锁方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.releaseShared(<span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// 调用 AQS 获取独占锁方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        sync.acquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// 调用 AQS 释放独占锁方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.release(<span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><p><code>Java 1.5</code> 之前，主要是利用 <code>Object</code> 类中的 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 配合 <code>synchronized</code> 来进行线程间通信。</p><p><code>wait</code>、<code>notify</code>、<code>notifyAll</code> 需要配合 <code>synchronized</code> 使用，不适用于 <code>Lock</code>。而使用 <code>Lock</code> 的线程，彼此间通信应该使用 <code>Condition</code>。<br>这可以理解为，什么样的锁配什么样的钥匙。内置锁（<code>synchronized</code>）配合内置条件队列（<code>wait</code>、<code>notify</code>、<code>notifyAll</code>），显式锁（<code>Lock</code>）配合显式条件队列（<code>Condition</code>）。</p><h2 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Condition</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">awaitNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>其中，<code>await</code>、<code>signal</code>、<code>signalAll</code> 与 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 相对应，功能也相似。除此以外，<code>Condition</code> 相比内置条件队列（<code>wait</code>、<code>notify</code>、<code>notifyAll</code>），提供了更为丰富的功能：</p><ul><li><p>每个锁（<code>Lock</code>）上可以存在多个 <code>Condition</code>，这意味着锁的状态条件可以有多个。</p></li><li><p>支持公平的或非公平的队列操作。</p></li><li><p>支持可中断的条件等待，相关方法：<code>awaitUninterruptibly()</code>。</p></li><li><p>支持可定时的等待，相关方法：<code>awaitNanos(long)</code> 、<code>await(long, TimeUnit)</code>、<code>awaitUntil(Date)</code>。</p></li></ul><h2 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h2><p>这里以 <code>Condition</code> 来实现一个消费者、生产者模式。</p><blockquote><p>🔔 注意：事实上，解决此类问题使用 <code>CountDownLatch</code>、<code>Semaphore</code> 等工具更为便捷、安全。</p></blockquote><p>消息类：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition consumeCondition = lock.newCondition();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition produceCondition = lock.newCondition();    <span class="hljs-keyword">private</span> String message;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> state;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> end;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//lock</span>        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// no new message wait for new message</span>            <span class="hljs-keyword">while</span> (!state) &#123;                consumeCondition.await();            &#125;            System.out.println(<span class="hljs-string">"consume message : "</span> + message);            state = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// message consumed, notify waiting thread</span>            produceCondition.signal();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;            System.out.println(<span class="hljs-string">"Thread interrupted - viewMessage"</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(String message)</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// last message not consumed, wait for it be consumed</span>            <span class="hljs-keyword">while</span> (state) &#123;                produceCondition.await();            &#125;            System.out.println(<span class="hljs-string">"produce msg: "</span> + message);            <span class="hljs-keyword">this</span>.message = message;            state = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">// new message added, notify waiting thread</span>            consumeCondition.signal();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;            System.out.println(<span class="hljs-string">"Thread interrupted - publishMessage"</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> end;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnd</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> end)</span> </span>&#123;        <span class="hljs-keyword">this</span>.end = end;    &#125;&#125;</code></pre><p>生产者：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> Message message;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageProducer</span><span class="hljs-params">(Message msg)</span> </span>&#123;        message = msg;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        produce();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;        List&lt;String&gt; msgs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        msgs.add(<span class="hljs-string">"Begin"</span>);        msgs.add(<span class="hljs-string">"Msg1"</span>);        msgs.add(<span class="hljs-string">"Msg2"</span>);        <span class="hljs-keyword">for</span> (String msg : msgs) &#123;            message.produce(msg);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">100</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        message.produce(<span class="hljs-string">"End"</span>);        message.setEnd(<span class="hljs-keyword">true</span>);    &#125;&#125;</code></pre><p>消费者：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> Message message;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageConsumer</span><span class="hljs-params">(Message msg)</span> </span>&#123;        message = msg;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (!message.isEnd()) &#123; message.consume(); &#125;    &#125;&#125;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockConditionDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Message msg = <span class="hljs-keyword">new</span> Message();        Thread producer = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MessageProducer(msg));        Thread consumer = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MessageConsumer(msg));        producer.start();        consumer.start();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Overview</title>
    <link href="/2018/12/28/overview/"/>
    <url>/2018/12/28/overview/</url>
    
    <content type="html"><![CDATA[<p>During the past six months, I was focusing on preparing for the entrance exam of postgraduate schools, owing to that, I could barely write posts or sorting out my blog. What’s worse, I figured out that I got my server expired and lost most of my posts that I have written in the almost past three years, in which I have made some records in my study and lives, including programming thoughts and life experiences.</p><p>As you’ll find out, I plan to migrate my blog from cloud server to git pages, it’s kind of a large project. Thanks to the exam which I have mentioned above, actually I did not expect that I could spend a surprisingly large amount of time in concentrating on one thing. It’s helpful in building up a hard-working, persistent personality.</p><p>In short, now that I’ve finished my exam, I plan to get a vacation for a couple of weeks and then back to my blog’s migration.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
