<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode 347. 前 K 个高频元素</title>
    <link href="/2020/10/30/LeetCode-347-top-k-frequent-elements/"/>
    <url>/2020/10/30/LeetCode-347-top-k-frequent-elements/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. 前 K 个高频元素</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]);    <span class="hljs-comment">// 统计每个元素出现次数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">int</span> occur = map.getOrDefault(num, <span class="hljs-number">0</span>);        map.put(num, occur + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// 维护 size = k 的最小堆</span>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;        minHeap.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);        <span class="hljs-keyword">if</span> (minHeap.size() &gt; k) &#123;            minHeap.poll();        &#125;    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;        res[i] = minHeap.poll()[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 295. 数据流的中位数</title>
    <link href="/2020/10/30/LeetCode-295-find-median-from-data-stream/"/>
    <url>/2020/10/30/LeetCode-295-find-median-from-data-stream/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 总的数据个数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> count;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 左边保存大顶堆，奇数时中位数即堆顶</span><span class="hljs-comment">     */</span>    PriorityQueue&lt;Integer&gt; maxHeap;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 右边保存小顶堆，偶数时，取堆顶求均值</span><span class="hljs-comment">     */</span>    PriorityQueue&lt;Integer&gt; minHeap;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;        count = <span class="hljs-number">0</span>;        maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);        minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        count++;        <span class="hljs-comment">// 1 2 3    4 5</span>        <span class="hljs-comment">// 1 2 3    4 5 6</span>        <span class="hljs-comment">// 大顶堆的堆顶 &lt;= 小顶堆堆顶，</span>        <span class="hljs-comment">// 所以要取大的值加入小顶堆，小的值加入大顶堆</span>        maxHeap.add(num);        minHeap.add(maxHeap.poll());        <span class="hljs-comment">// 当总数为奇数时，大顶堆比小顶堆多一个元素</span>        <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;            maxHeap.add(minHeap.poll());        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>) (maxHeap.peek() + minHeap.peek()) / <span class="hljs-number">2</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>) maxHeap.peek();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 463. 岛屿的周长</title>
    <link href="/2020/10/30/LeetCode-463-island-perimeter/"/>
    <url>/2020/10/30/LeetCode-463-island-perimeter/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/island-perimeter/" target="_blank" rel="noopener">463. 岛屿的周长</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">islandPerimeter</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = grid.length;    <span class="hljs-keyword">int</span> cols = grid[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> backtrack(i, j, rows, cols, grid);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;    <span class="hljs-comment">// 越界 || 水面</span>    <span class="hljs-keyword">if</span> (!inArea(i, j, rows, cols) || grid[i][j] == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 已经遍历过</span>    <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    grid[i][j] = <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 四个方向遍历</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;        res += backtrack(i + dir[<span class="hljs-number">0</span>], j + dir[<span class="hljs-number">1</span>], rows, cols, grid);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;&#125;</code></pre><h1 id="遍历计算"><a class="markdownIt-Anchor" href="#遍历计算"></a> 遍历计算</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">islandPerimeter</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = grid.length;    <span class="hljs-keyword">int</span> cols = grid[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            res += <span class="hljs-number">4</span>;            <span class="hljs-comment">// 左边为陆地</span>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;                res -= <span class="hljs-number">2</span>;            &#125;            <span class="hljs-comment">// 上边为陆地</span>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) &#123;                res -= <span class="hljs-number">2</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 112. 路径总和</title>
    <link href="/2020/10/29/LeetCode-112-path-sum/"/>
    <url>/2020/10/29/LeetCode-112-path-sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> root.val == sum;    &#125;    <span class="hljs-keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> hasPath = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    getSum(root, root.val, sum);    <span class="hljs-keyword">return</span> hasPath;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (sum == target) &#123;            hasPath = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;        sum += root.left.val;        getSum(root.left, sum, target);        sum -= root.left.val;    &#125;    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;        sum += root.right.val;        getSum(root.right, sum, target);        sum -= root.right.val;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>树</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 129. 求根到叶子节点数字之和</title>
    <link href="/2020/10/29/LeetCode-129-sum-root-to-leaf-numbers/"/>
    <url>/2020/10/29/LeetCode-129-sum-root-to-leaf-numbers/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. 求根到叶子节点数字之和</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">return</span> preOrder(root, <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    sum = sum * <span class="hljs-number">10</span> + root.val;    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> sum;    &#125;    <span class="hljs-keyword">return</span> preOrder(root.left, sum) + preOrder(root.right, sum);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    List&lt;List&lt;TreeNode&gt;&gt; paths = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    List&lt;TreeNode&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    path.add(root);    preOrder(root, path, paths);    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (List&lt;TreeNode&gt; p : paths) &#123;        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (TreeNode node : p) &#123;            num = num * <span class="hljs-number">10</span> + node.val;        &#125;        res += num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root, List&lt;TreeNode&gt; path, List&lt;List&lt;TreeNode&gt;&gt; paths)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;        paths.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;        path.add(root.left);        preOrder(root.left, path, paths);        path.remove(root.left);    &#125;    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;        path.add(root.right);        preOrder(root.right, path, paths);        path.remove(root.right);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>树</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 220. 存在重复元素 III</title>
    <link href="/2020/10/29/LeetCode-220-contains-duplicate-iii/"/>
    <url>/2020/10/29/LeetCode-220-contains-duplicate-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. 存在重复元素 III</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> t)</span> </span>&#123;    TreeSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;        <span class="hljs-comment">// |nums[i] - nums[j]| &lt;= t</span>        <span class="hljs-comment">// nums[i] - nums[j] &lt;= t or nums[i] - nums[j] &gt;= -t</span>        <span class="hljs-comment">// nums[i] &lt;= nums[j] + t and nums[i] &gt;= nums[j] - t</span>        Long bound = set.ceiling((<span class="hljs-keyword">long</span>) nums[i] - (<span class="hljs-keyword">long</span>) t);        <span class="hljs-keyword">if</span> (bound != <span class="hljs-keyword">null</span> &amp;&amp; bound &lt;= (<span class="hljs-keyword">long</span>) nums[i] + (<span class="hljs-keyword">long</span>) t) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        set.add((<span class="hljs-keyword">long</span>) nums[i]);        <span class="hljs-comment">// 保持窗口大小 = k</span>        <span class="hljs-keyword">if</span> (set.size() &gt; k) &#123;            set.remove((<span class="hljs-keyword">long</span>) nums[i - k]);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1552. 两球之间的磁力</title>
    <link href="/2020/10/29/LeetCode-1552-magnetic-force-between-two-balls/"/>
    <url>/2020/10/29/LeetCode-1552-magnetic-force-between-two-balls/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/" target="_blank" rel="noopener">1552. 两球之间的磁力</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] position, <span class="hljs-keyword">int</span> m)</span> </span>&#123;    <span class="hljs-comment">// distance in [1, max - min]</span>    <span class="hljs-keyword">int</span> len = position.length;    Arrays.sort(position);    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = (position[len - <span class="hljs-number">1</span>] - position[<span class="hljs-number">0</span>]) / (m - <span class="hljs-number">1</span>);    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> numOfBalls = calcBallsByDistance(position, mid);        System.out.println(mid + <span class="hljs-string">" "</span> + numOfBalls);        <span class="hljs-keyword">if</span> (numOfBalls &gt;= m) &#123;            left = mid;            <span class="hljs-comment">// 球的个数太少，需要增加球，此时应该减小距离</span>        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 以最小距离 distance 来切分数组</span><span class="hljs-comment"> * 获取球的个数</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> position</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> minDistance</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calcBallsByDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] position, <span class="hljs-keyword">int</span> minDistance)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> distance = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; position.length; i++) &#123;        distance += position[i] - position[i - <span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (distance &gt;= minDistance) &#123;            count++;            distance = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 可靠传输</title>
    <link href="/2020/10/29/network-TCP-reliable-data-transfer/"/>
    <url>/2020/10/29/network-TCP-reliable-data-transfer/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="重传机制"><a class="markdownIt-Anchor" href="#重传机制"></a> 重传机制</h1><p>TCP 实现可靠传输的方式之一，是通过<strong>序列号与确认应答</strong>。<br />在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。针对数据包丢失的情况，会用重传机制解决。</p><p>常见的重传机制：</p><ul><li>超时重传</li><li>快速重传</li><li>SACK</li><li>D-SACK</li></ul><h2 id="超时重传"><a class="markdownIt-Anchor" href="#超时重传"></a> 超时重传</h2><blockquote><p>超时重传：在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据。</p></blockquote><p>TCP 会在以下两种情况发生超时重传：</p><ol><li>数据包丢失</li><li>确认应答丢失</li></ol><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029150717.jpeg" srcset="/img/loading.gif" alt="" /></p><h3 id="超时重传时间-rto"><a class="markdownIt-Anchor" href="#超时重传时间-rto"></a> 超时重传时间 RTO</h3><blockquote><p><code>RTT</code>（<code>Round-Trip Time</code> 往返时延）是数据从网络一端传送到另一端所需的时间，也就是包的<strong>往返时间</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029151521.png" srcset="/img/loading.gif" alt="" /></p><p>超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。</p><p>假设在重传的情况下，超时时间 RTO 「较长或较短」时，会发生什么事情呢？</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029151632.png" srcset="/img/loading.gif" alt="" /></p><p>上图中有两种超时时间不同的情况：</p><ol><li>当超时时间 <code>RTO</code> 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>当超时时间 <code>RTO</code> 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ol><p>精确的测量超时时间 <code>RTO</code> 的值是非常重要的，这可让我们的重传机制更高效。</p><p>根据上述的两种情况，我们可以得知，<strong>超时重传时间 <code>RTO</code> 的值应该略大于报文往返 <code>RTT</code> 的值。</strong></p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029151735.png" srcset="/img/loading.gif" alt="" /></p><p>实际上「报文往返 <code>RTT</code> 的值」是经常变化的，因为我们的<strong>网络也是时常变化</strong>的。也就因为「报文往返 <code>RTT</code> 的值」 是经常波动变化的，所以「超时重传时间 <code>RTO</code> 的值」应该是一个<strong>动态变化</strong>的值。</p><p>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时间隔加倍</strong>。<br />也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</p><p>超时触发重传存在的问题是，<strong>超时周期可能相对较长</strong>。于是就可以用「<strong>快速重传</strong>」机制来解决超时重发的时间等待。</p><h2 id="快速重传"><a class="markdownIt-Anchor" href="#快速重传"></a> 快速重传</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029152043.png" srcset="/img/loading.gif" alt="" /></p><blockquote><p>快速重传（<code>Fast Retransmit</code>）机制，它不以时间为驱动，而是以<strong>数据驱动</strong>重传。</p></blockquote><p>所以，快速重传的工作方式是当收到<strong>三个相同的 <code>ACK</code> 报文</strong>时，会在定时器过期之前，重传丢失的报文段。</p><p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传之前的一个，还是重传所有的问题。</strong></p><p>比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p><p>根据 TCP 不同的实现，以上两种情况都是有可能的。可见，这是一把双刃剑。</p><p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code>SACK 方法</code>。</p><h2 id="选择确认-ack"><a class="markdownIt-Anchor" href="#选择确认-ack"></a> 选择确认 ACK</h2><blockquote><p><code>SACK</code>（<code>Selective Acknowledgment</code> 选择性确认）：在 TCP 头部「选项」字段里加一个 <code>SACK</code> 字段，它可以将 <code>SACK</code> 发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。</p></blockquote><p>如下图，发送方收到了三次同样的 <code>ACK</code> 确认报文，于是就会触发<code>快速重发</code>机制，通过 <code>SACK</code> 信息发现只有 <code>200~299</code> 这段数据丢失，则重发时，就只选择了这个 <code>TCP</code> 段进行重复。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029152731.png" srcset="/img/loading.gif" alt="" /></p><h2 id="duplicate-sack"><a class="markdownIt-Anchor" href="#duplicate-sack"></a> Duplicate SACK</h2><blockquote><p><code>Duplicate SACK</code> 又称 <code>D-SACK</code>，其主要使用了 <code>SACK</code> 来告诉「发送方」有哪些数据被<strong>重复接收</strong>了。</p></blockquote><ol><li>ACK 丢包</li></ol><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029153037.png" srcset="/img/loading.gif" alt="" /></p><ul><li>「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</li><li>于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 <code>D-SACK</code>。</li><li>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</li></ul><ol start="2"><li>网络延时</li></ol><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029153559.png" srcset="/img/loading.gif" alt="" /></p><ul><li>数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。</li><li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；</li><li>所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</li><li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为<strong>网络延迟</strong>了。</li></ul><p>可见，D-SACK 有这么几个好处：</p><ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol><h1 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029161354.png" srcset="/img/loading.gif" alt="" /></p><p>为每个包确认应答的缺点：当上一个数据包收到了应答了， 再发送下一个。当<strong>数据包的往返时间越长，通信的效率就越低。</strong></p><p>为解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p><p>那么有了窗口，就可以指定窗口大小，<strong>窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。</strong></p><p><strong>窗口的实现实际上是操作系统开辟的一个缓存空间</strong>，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p>假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029155533.png" srcset="/img/loading.gif" alt="" /></p><p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p><h2 id="窗口大小"><a class="markdownIt-Anchor" href="#窗口大小"></a> 窗口大小</h2><p>TCP 首部的 <code>Window Size</code> 字段就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是<strong>发送端就可以根据这个接收端的处理能力来发送数据</strong>，而不会导致接收端处理不过来。</p><p>所以，通常窗口的大小是由接收方的窗口大小来决定的。<br />发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p><h2 id="发送方的滑动窗口"><a class="markdownIt-Anchor" href="#发送方的滑动窗口"></a> 发送方的滑动窗口</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029160218.png" srcset="/img/loading.gif" alt="" /></p><ul><li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li><li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li><li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li><li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li></ul><p>在下图，当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029160400.png" srcset="/img/loading.gif" alt="" /></p><h2 id="接收方的滑动窗口"><a class="markdownIt-Anchor" href="#接收方的滑动窗口"></a> 接收方的滑动窗口</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029161022.jpeg" srcset="/img/loading.gif" alt="" /></p><ul><li>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</li><li>#3 是未收到数据但可以接收的数据；</li><li>#4 未收到数据并不可以接收的数据；</li></ul><blockquote><p>接收窗口和发送窗口的大小并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。</p></blockquote><p>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 <code>Window Size</code> 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p><h1 id="流量控制"><a class="markdownIt-Anchor" href="#流量控制"></a> 流量控制</h1><p>发送方不能无限制的发数据给接收方，要考虑接收方处理能力。若对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p><p>为了解决这种现象发生，TCP 提供一种机制可以<strong>让「发送方」根据「接收方」的实际接收能力控制发送的数据量</strong>，这就是所谓的<strong>流量控制</strong>。</p><p>假设以下场景：</p><ul><li>客户端是接收方，服务端是发送方</li><li>假设接收窗口和发送窗口相同，都为 <code>200</code></li><li>假设两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029163937.png" srcset="/img/loading.gif" alt="" /></p><h2 id="操作系统缓冲区与滑动窗口的关系"><a class="markdownIt-Anchor" href="#操作系统缓冲区与滑动窗口的关系"></a> 操作系统缓冲区与滑动窗口的关系</h2><p>前面的流量控制例子，我们假定了发送窗口和接收窗口是不变的，但是实际上，<strong>发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的</strong>，而操作系统的缓冲区，会被操作系统调整。<br />当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。</p><p>当服务端系统资源非常紧张的时候，操心系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，那么这时候就有严重的事情发生了，会出现数据包丢失的现象。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201030153510.png" srcset="/img/loading.gif" alt="" /></p><ol><li>客户端发送 140 字节的数据，于是可用窗口减少到了 220。</li><li>服务端因为现在非常的繁忙，操作系统于是就把接收缓存减少了 120 字节，当收到 140 字节数据后，又因为应用程序没有读取任何数据，所以 140 字节留在了缓冲区中，于是接收窗口大小从 360 收缩成了 100，最后发送确认信息时，通告窗口大小给对方。</li><li>此时客户端因为还没有收到服务端的通告窗口报文，所以不知道此时接收窗口收缩成了 100，客户端只会看自己的可用窗口还有 220，所以客户端就发送了 180 字节数据，于是可用窗口减少到 40。</li><li>服务端收到了 180 字节数据时，发现数据大小超过了接收窗口的大小，于是就把数据包丢失了。</li><li>客户端收到第 2 步时，服务端发送的确认报文和通告窗口报文，尝试减少发送窗口到 100，把窗口的右端向左收缩了 80，此时可用窗口的大小就会出现诡异的负值。</li></ol><p>所以，如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。</p><p>为了防止这种情况发生，<strong>TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存</strong>，这样就可以避免了丢包情况。</p><h2 id="窗口关闭"><a class="markdownIt-Anchor" href="#窗口关闭"></a> 窗口关闭</h2><p>TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。</p><blockquote><p>窗口关闭：如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止。</p></blockquote><p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。</p><p>那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口<code>非 0 的 ACK 报文</code>，如果这个通告窗口的 <code>ACK</code> 报文在网络中丢失了，那麻烦就大了。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201030154802.png" srcset="/img/loading.gif" alt="" /></p><p>这会导致<strong>发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据</strong>，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p><p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p><p>如果持续计时器超时，就会发送<code>窗口探测 (Window probe)</code> 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201030155139.jpeg" srcset="/img/loading.gif" alt="" /></p><ul><li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li><li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li></ul><p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 <code>TCP</code> 实现就会发 <code>RST</code> 报文来中断连接。</p><h2 id="糊涂窗口综合症"><a class="markdownIt-Anchor" href="#糊涂窗口综合症"></a> 糊涂窗口综合症</h2><p>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。</p><p>到最后，<strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。</strong></p><p>接收方的窗口大小是 360 字节，但接收方由于某些原因陷入困境，假设接收方的应用层读取的能力如下：</p><ul><li>接收方每接收 3 个字节，应用程序就只能从缓冲区中读取 1 个字节的数据；</li><li>在下一个发送方的 TCP 段到达之前，应用程序还从缓冲区中读取了 40 个额外的字节；</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201030161555.png" srcset="/img/loading.gif" alt="" /></p><p>所以，糊涂窗口综合症的现象是可以发生在发送方和接收方：</p><ul><li>接收方可以通告一个小的窗口</li><li>而发送方可以发送小数据</li></ul><p>于是，要解决糊涂窗口综合症，就解决上面两个问题就可以了</p><ul><li><p>让接收方不通告小窗口给发送方<br />当<code>「窗口大小」&lt; min(MSS，缓存空间 / 2)</code>，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。<br />等到接收方处理了一些数据后，窗口大小 &gt;= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</p></li><li><p>让发送方避免发送小数据<br />使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：</p><ul><li>要等到<code>窗口大小 &gt;= MSS</code> 或是 <code>数据大小 &gt;= MSS</code></li><li>收到之前发送数据的 <code>ACK</code> 回包</li></ul></li></ul><h1 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制"></a> 拥塞控制</h1><blockquote><p>拥塞控制的目的就是避免「发送方」的数据填满整个网络。</p></blockquote><p>只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了<strong>超时重传</strong>，就会认为网络出现了拥塞。</p><p>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大。</p><h2 id="拥塞窗口"><a class="markdownIt-Anchor" href="#拥塞窗口"></a> 拥塞窗口</h2><p><code>拥塞窗口 cwnd</code> 是发送方维护的一个的状态变量，它会<strong>根据网络的拥塞程度动态变化</strong>的。</p><p>发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是 <code>swnd = min(cwnd, rwnd)</code>，也就是拥塞窗口和接收窗口中的最小值。</p><p>拥塞窗口 <code>cwnd</code> 变化的规则：</p><ul><li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li><li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li></ul><h2 id="拥塞控制算法"><a class="markdownIt-Anchor" href="#拥塞控制算法"></a> 拥塞控制算法</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201030180921.png" srcset="/img/loading.gif" alt="" /></p><h3 id="1-慢启动"><a class="markdownIt-Anchor" href="#1-慢启动"></a> 1. 慢启动</h3><blockquote><p>慢启动的算法规则：当发送方每收到一个 <code>ACK</code>，拥塞窗口 <code>cwnd</code> 的大小就会加 <code>1</code>。</p></blockquote><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量。</p><p>这里<strong>假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等</strong>，下面举个栗子：</p><ol><li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 MSS 大小的数据。</li><li>当收到一个 <code>ACK</code> 确认应答后，<code>cwnd</code> 增加 1，于是一次能够发送 2 个</li><li>当收到 2 个的 <code>ACK</code> 确认应答后， <code>cwnd</code> 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li><li>当这 4 个的 <code>ACK</code> 确认到来的时候，每个确认 <code>cwnd</code> 增加 1， 4 个确认 <code>cwnd</code> 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li></ol><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201030163027.png" srcset="/img/loading.gif" alt="" /></p><p>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p><p>为了防止拥塞窗口增长过大，还需要设置<code>慢启动门限 ssthresh</code> （<code>slow start threshold</code>）状态变量。</p><ul><li>当 <code>cwnd &lt; ssthresh</code> 时，使用<strong>慢启动</strong>算法。</li><li>当 <code>cwnd &gt;= ssthresh</code> 时，就会使用<strong>拥塞避免</strong>算法。</li></ul><h3 id="2-拥塞避免"><a class="markdownIt-Anchor" href="#2-拥塞避免"></a> 2. 拥塞避免</h3><blockquote><p>拥塞避免算法的规则：每经过一个往返时间 <code>RTT</code> 就把发送方的拥塞窗口加 1。</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201030163531.png" srcset="/img/loading.gif" alt="" /></p><p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了<strong>线性增长</strong>，还是增长阶段，但是增长速度缓慢了一些。</p><p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现<strong>丢包</strong>现象，这时就需要对丢失的数据包进行<strong>重传</strong>。</p><p>当触发了重传机制，也就进入了「拥塞发生算法」。</p><h3 id="3-超时重传和慢启动"><a class="markdownIt-Anchor" href="#3-超时重传和慢启动"></a> 3. 超时重传和慢启动</h3><ol><li>乘法减小：<code>ssthresh</code> 设为 <code>cwnd/2</code>；</li><li>慢启动：<code>cwnd</code> 重置为 <code>1</code>，开始慢启动。</li></ol><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201030163907.png" srcset="/img/loading.gif" alt="" /></p><p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</p><h3 id="4-快重传和快速恢复"><a class="markdownIt-Anchor" href="#4-快重传和快速恢复"></a> 4. 快重传和快速恢复</h3><p>当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p><ol><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快恢复算法</li></ol><p>快恢复流程：</p><ol><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 <code>ACK</code>，那么 <code>cwnd</code> 增加 1；</li><li>如果收到新数据的 <code>ACK</code> 后，把 <code>cwnd</code> 设置为第一步中的 <code>ssthresh</code> 的值，原因是该 <code>ACK</code> 确认了新的数据，说明从 <code>duplicated ACK</code> 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ol><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201030180102.png" srcset="/img/loading.gif" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 219. 存在重复元素 II</title>
    <link href="/2020/10/28/LeetCode-219-contains-duplicate-ii/"/>
    <url>/2020/10/28/LeetCode-219-contains-duplicate-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219. 存在重复元素 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (map.containsKey(nums[i])) &#123;            <span class="hljs-keyword">int</span> idx = map.get(nums[i]);            <span class="hljs-keyword">if</span> (Math.abs(idx - i) &lt;= k) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        map.put(nums[i], i);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 23. 合并K个升序链表</title>
    <link href="/2020/10/28/LeetCode-23-merge-k-sorted-lists/"/>
    <url>/2020/10/28/LeetCode-23-merge-k-sorted-lists/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个升序链表</a></p><h1 id="小顶堆"><a class="markdownIt-Anchor" href="#小顶堆"></a> 小顶堆</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;    PriorityQueue&lt;ListNode&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.val - o2.val);    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    ListNode head = dummy;    <span class="hljs-comment">// 放入小顶堆</span>    <span class="hljs-keyword">for</span> (ListNode node : lists) &#123;        ListNode cur = node;        ListNode next;        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 切断 cur 和 next 之间的联系，否则可能出现环</span>            next = cur.next;            cur.next = <span class="hljs-keyword">null</span>;            maxHeap.add(cur);            cur = next;        &#125;    &#125;    <span class="hljs-comment">// 依次出队链接</span>    <span class="hljs-keyword">while</span> (!maxHeap.isEmpty()) &#123;        head.next = maxHeap.poll();        head = head.next;    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre><h1 id="k-个指针后移"><a class="markdownIt-Anchor" href="#k-个指针后移"></a> K 个指针后移</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = lists.length;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    ListNode tail = dummy;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        <span class="hljs-comment">// 每次找到 lists 中最小的结点</span>        ListNode minNode = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 最小结点对应在 lists 中的位置</span>        <span class="hljs-keyword">int</span> minIdx = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (lists[i] == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 每次都比较头结点</span>            <span class="hljs-keyword">if</span> (minNode == <span class="hljs-keyword">null</span> || lists[i].val &lt; minNode.val) &#123;                minNode = lists[i];                minIdx = i;            &#125;        &#125;        <span class="hljs-keyword">if</span> (minIdx == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        tail.next = minNode;        tail = tail.next;        <span class="hljs-comment">// 移动头结点：把本次最小的那条链表后移</span>        lists[minIdx] = lists[minIdx].next;    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre><h1 id="两两合并"><a class="markdownIt-Anchor" href="#两两合并"></a> 两两合并</h1><p>大的合并小的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;    ListNode head = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">for</span> (ListNode node : lists) &#123;        head = merge2Lists(head, node);    &#125;    <span class="hljs-keyword">return</span> head;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">merge2Lists</span><span class="hljs-params">(ListNode node1, ListNode node2)</span> </span>&#123;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    ListNode tail = dummy;    <span class="hljs-keyword">while</span> (node1 != <span class="hljs-keyword">null</span> &amp;&amp; node2 != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (node1.val &lt; node2.val) &#123;            tail.next = node1;            node1 = node1.next;        &#125; <span class="hljs-keyword">else</span> &#123;            tail.next = node2;            node2 = node2.next;        &#125;        tail = tail.next;    &#125;    tail.next = node1 == <span class="hljs-keyword">null</span> ? node2 : node1;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre><p>两两合并，小的合成大的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = lists.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">// 合并完成后的链表数</span>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span> (i == len - <span class="hljs-number">1</span>) &#123;                lists[idx] = lists[i];            &#125; <span class="hljs-keyword">else</span> &#123;                lists[idx] = merge2Lists(lists[i], lists[i + <span class="hljs-number">1</span>]);            &#125;            idx++;        &#125;        <span class="hljs-comment">// 对合并完成后的 idx 条链表再合并，直到合成一条</span>        len = idx;    &#125;    <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>队列</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1306. 跳跃游戏 III</title>
    <link href="/2020/10/28/LeetCode-1306-jump-game-iii/"/>
    <url>/2020/10/28/LeetCode-1306-jump-game-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jump-game-iii/" target="_blank" rel="noopener">1306. 跳跃游戏 III</a></p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canReach</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(start);    visited[start] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-keyword">int</span> curPos = queue.poll();        <span class="hljs-keyword">if</span> (arr[curPos] == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 向前后搜索</span>        <span class="hljs-keyword">int</span> forward = curPos + arr[curPos];        <span class="hljs-keyword">int</span> backward = curPos - arr[curPos];        <span class="hljs-keyword">if</span> (forward &lt; len &amp;&amp; !visited[forward]) &#123;            visited[forward] = <span class="hljs-keyword">true</span>;            queue.add(forward);        &#125;        <span class="hljs-keyword">if</span> (backward &gt;= <span class="hljs-number">0</span> &amp;&amp; !visited[backward]) &#123;            visited[backward] = <span class="hljs-keyword">true</span>;            queue.add(backward);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canReach</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];    <span class="hljs-keyword">return</span> dfs(arr, len, start, visited);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">boolean</span>[] visited)</span> </span>&#123;    <span class="hljs-comment">// 越过边界 || 访问过</span>    <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span> || start &gt;= len || visited[start]) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// 终点</span>    <span class="hljs-keyword">if</span> (arr[start] == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 标记访问位</span>    visited[start] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// 向前</span>    <span class="hljs-keyword">int</span> forward = start + arr[start];    <span class="hljs-comment">// 向后</span>    <span class="hljs-keyword">int</span> backward = start - arr[start];    <span class="hljs-keyword">return</span> dfs(arr, len, forward, visited) || dfs(arr, len, backward, visited);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1207. 独一无二的出现次数</title>
    <link href="/2020/10/28/LeetCode-1207-unique-number-of-occurrences/"/>
    <url>/2020/10/28/LeetCode-1207-unique-number-of-occurrences/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/unique-number-of-occurrences/" target="_blank" rel="noopener">1207. 独一无二的出现次数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">uniqueOccurrences</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;        <span class="hljs-keyword">int</span> occur = map.getOrDefault(num, <span class="hljs-number">0</span>);        map.put(num, occur + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> occur : map.values()) &#123;        <span class="hljs-keyword">if</span> (counts[occur] &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        counts[occur]++;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 三次握手和四次挥手</title>
    <link href="/2020/10/28/network-TCP-three-way-handshake-four-way-wavehand/"/>
    <url>/2020/10/28/network-TCP-three-way-handshake-four-way-wavehand/</url>
    
    <content type="html"><![CDATA[<h1 id="tcp-基本认识"><a class="markdownIt-Anchor" href="#tcp-基本认识"></a> TCP 基本认识</h1><h2 id="tcp-基础"><a class="markdownIt-Anchor" href="#tcp-基础"></a> TCP 基础</h2><h3 id="tcp-头格式"><a class="markdownIt-Anchor" href="#tcp-头格式"></a> TCP 头格式</h3><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028143112.png" srcset="/img/loading.gif" alt="" /></p><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 <code>SYN</code> 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题</strong>。</p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决不丢包的问题</strong>。</p><p><strong>控制位</strong>：</p><ul><li><code>ACK</code>：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。</li><li><code>RST</code>：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><code>SYN</code>：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><code>FIN</code>：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</li></ul><h3 id="为什么需要-tcp-协议"><a class="markdownIt-Anchor" href="#为什么需要-tcp-协议"></a> 为什么需要 TCP 协议</h3><p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p><strong>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</strong><br />因为 <code>TCP</code> 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序</strong>的。</p><h3 id="什么是-tcp"><a class="markdownIt-Anchor" href="#什么是-tcp"></a> 什么是 TCP</h3><p><code>TCP</code> 是<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议。</p><ul><li><strong>面向连接</strong>：一定是「<strong>一对一</strong>」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：消息是「<strong>没有边界</strong>」的，所以无论我们消息有多大都可以进行传输。并且消息是「<strong>有序的</strong>」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</li></ul><h2 id="tcp-连接"><a class="markdownIt-Anchor" href="#tcp-连接"></a> TCP 连接</h2><h3 id="什么是-tcp-连接"><a class="markdownIt-Anchor" href="#什么是-tcp-连接"></a> 什么是 TCP 连接</h3><blockquote><p>用于保证可靠性和流量控制维护的某些<strong>状态信息</strong>，这些信息的组合，包括 <code>Socket</code>、<code>序列号</code>和<code>窗口大小</code>称为连接。</p></blockquote><ul><li><code>Socket</code>：由 IP 地址和端口号组成</li><li>序列号：用来解决乱序问题等</li><li>窗口大小：用来做流量控制</li></ul><h3 id="如何唯一确定一个-tcp-连接"><a class="markdownIt-Anchor" href="#如何唯一确定一个-tcp-连接"></a> 如何唯一确定一个 TCP 连接</h3><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ol><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ol><ul><li>源地址和目的地址的字段（32位）是在 <code>IP</code> 头部中，作用是通过 <code>IP</code> 协议发送报文给对方主机。</li><li>源端口和目的端口的字段（16位）是在 <code>TCP</code> 头部中，作用是告诉 <code>TCP</code> 协议应该把报文发给哪个进程。</li></ul><h3 id="tcp-的最大连接数"><a class="markdownIt-Anchor" href="#tcp-的最大连接数"></a> TCP 的最大连接数</h3><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。因此，客户端 IP 和 端口是可变的，其理论值计算公式如下：</p><pre><code class="hljs routeros">TCP 最大连接数 = 客户端的<span class="hljs-built_in"> IP </span>数 * 客户端的端口数</code></pre><p>对 <code>IPv4</code>，客户端的 <code>IP 数</code>最多为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，客户端的 <code>端口数</code> 最多为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>，也就是服务端单机最大 TCP 连接数，约为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。</p><ul><li>首先主要是<strong>文件描述符限制</strong>，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；</li><li>另一个是<strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的。</li></ul><h2 id="tcp-和-udp"><a class="markdownIt-Anchor" href="#tcp-和-udp"></a> TCP 和 UDP</h2><h3 id="udp-和-tcp-的区别-应用场景"><a class="markdownIt-Anchor" href="#udp-和-tcp-的区别-应用场景"></a> UDP 和 TCP 的区别、应用场景</h3><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。<br />UDP 协议头部只有 <code>8</code> 个字节，UDP 的头部格式如下：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028144852.png" srcset="/img/loading.gif" alt="" /></p><ul><li><strong>目标和源端口</strong>：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li><strong>包长度</strong>：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li><strong>校验和</strong>：校验和是为了提供可靠的 UDP 首部和数据而设计。</li></ul><p>TCP 和 UDP 区别：</p><ol><li>连接</li></ol><p>TCP 是面向连接的传输层协议，传输数据前先要建立连接。<br />UDP 是不需要连接，即刻传输数据。<br />2. 服务对象</p><p>TCP 是一对一的两点服务，即<strong>一条连接只有两个端点</strong>。<br />UDP 支持一对一、一对多、多对多的交互通信<br />3. 可靠性</p><p>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。<br />UDP 是尽最大努力交付，不保证可靠交付数据。<br />4. 拥塞控制、流量控制</p><p>TCP 有<strong>拥塞控制</strong>和<strong>流量控制</strong>机制，保证数据传输的安全性。<br />UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。<br />5. 首部开销</p><p>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。<br />UDP 首部只有 8 个字节，并且是固定不变的，开销较小。<br />6. 传输方式</p><p>TCP 是<strong>流式传输，没有边界，但保证顺序和可靠</strong>。<br />UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。<br />7. 分片不同</p><p>TCP 的数据大小如果大于 <code>MSS</code> 大小，则会在 <code>传输层</code> 进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。<br />UDP 的数据大小如果大于 <code>MTU</code> 大小，则会在 <code>IP 层</code> 进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输效率非常差，所以<strong>通常 <code>UDP</code> 的报文应该小于 <code>MTU</code></strong>。</p><p>TCP 和 UDP 应用场景：<br />由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输</li><li><code>HTTP</code> / <code>HTTPS</code></li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等</li><li>视频、音频等多媒体通信</li><li>广播通信</li></ul><h3 id="为什么-udp-头部没有首部长度字段"><a class="markdownIt-Anchor" href="#为什么-udp-头部没有首部长度字段"></a> 为什么 UDP 头部没有「首部长度」字段</h3><p>原因是 <code>TCP</code> 有<strong>可变长</strong>的「<code>选项</code>」字段，而 <code>UDP</code> <strong>头部长度则是不会变化</strong>的，无需多一个字段去记录 <code>UDP</code> 的首部长度。</p><h3 id="为什么-udp-头部有包长度字段"><a class="markdownIt-Anchor" href="#为什么-udp-头部有包长度字段"></a> 为什么 UDP 头部有「包长度」字段</h3><blockquote><p>TCP 数据长度 = <code>IP</code> 总长度 - <code>IP</code> 首部长度 - <code>TCP</code> 首部长度</p></blockquote><p>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p><p><strong>为了网络设备硬件设计和处理方便，首部长度需要是 <code>4字节</code> 的整数倍。</strong><br />如果去掉 UDP 「包长度」字段，那 UDP 首部长度就不是 4 字节的整数倍了，所以这可能是为了补全 UDP 首部长度是 4 字节的整数倍，才补充了「包长度」字段。</p><h1 id="tcp-连接建立"><a class="markdownIt-Anchor" href="#tcp-连接建立"></a> TCP 连接建立</h1><h2 id="tcp-三次握手过程和状态变迁"><a class="markdownIt-Anchor" href="#tcp-三次握手过程和状态变迁"></a> TCP 三次握手过程和状态变迁</h2><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而建立连接是通过三次握手来进行的。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028155915.png" srcset="/img/loading.gif" alt="" /></p><ul><li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li><li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li><li>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 1 ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，<strong>这次报文可以携带客户到服务器的数据</strong>，之后客户端处于 <code>ESTABLISHED</code> 状态。</li></ul><blockquote><p>可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的。</p></blockquote><p>一旦完成三次握手，双方都处于 <code>ESTABLISHED</code> 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。</p><h2 id="为什么是三次握手"><a class="markdownIt-Anchor" href="#为什么是三次握手"></a> 为什么是三次握手</h2><p>三次握手才能保证双方具有接收和发送的能力，可以初始化 <code>Socket</code>、<code>序列号</code>和<code>窗口大小</code>并建立 TCP 连接。</p><p>原因：</p><ol><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ol><h3 id="避免历史连接"><a class="markdownIt-Anchor" href="#避免历史连接"></a> 避免历史连接</h3><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028161453.png" srcset="/img/loading.gif" alt="" /></p><p><strong>客户端连续发送多次 SYN 建立连接的报文</strong>，在网络拥堵情况下：</p><ul><li>一个「<strong>旧 SYN 报文</strong>」比「<strong>最新的 SYN</strong>」 报文早到达了服务端；</li><li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li><li>客户端收到后可以根据自身的上下文，判断这是一个<strong>历史连接</strong>（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</li></ul><p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p><p>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接；<br />如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接；<br />所以，TCP 使用三次握手建立连接的最主要原因是<strong>防止历史连接初始化了连接</strong>。</p><h3 id="同步双方初始序列号"><a class="markdownIt-Anchor" href="#同步双方初始序列号"></a> 同步双方初始序列号</h3><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以去除重复的数据；</li><li>接收方可以根据数据包的序列号按序接收；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</li></ul><p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，<strong>表示客户端的 SYN 报文已被服务端成功接收</strong>，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能<strong>确保双方的初始序列号能被可靠的同步</strong>。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028162521.png" srcset="/img/loading.gif" alt="" /></p><p>四次握手其实也能够可靠的同步双方的初始化序号，但<strong>由于第二步和第三步可以优化成一步，所以就成了「三次握手」。</strong></p><p><strong>两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</strong></p><h3 id="避免资源浪费"><a class="markdownIt-Anchor" href="#避免资源浪费"></a> 避免资源浪费</h3><p>如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？</p><p>如果客户端的 <code>SYN</code> 阻塞了，重复发送多次 <code>SYN</code> 报文，那么<strong>服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028162315.jpeg" srcset="/img/loading.gif" alt="" /></p><p>即两次握手会造成消息滞留情况下，<strong>服务器重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</strong></p><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</p><p>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><h2 id="为什么客户端和服务端的初始序列号-isn-是不相同的"><a class="markdownIt-Anchor" href="#为什么客户端和服务端的初始序列号-isn-是不相同的"></a> 为什么客户端和服务端的初始序列号 ISN 是不相同的</h2><p>如果一个已经失效的连接被重用了，但是该旧连接的历史报文还残留在网络中，如果序列号相同，那么就无法分辨出该报文是不是历史报文，如果历史报文被新的连接接收了，则会产生数据错乱。</p><p>所以，每次建立连接前重新初始化一个序列号主要是为了<strong>通信双方能够根据序号将不属于本连接的报文段丢弃。</strong></p><p>另一方面是为了<strong>安全性</strong>，防止黑客伪造的相同序列号的 TCP 报文被对方接收。</p><h2 id="既然-ip-层会分片为什么-tcp-层还需要-mss"><a class="markdownIt-Anchor" href="#既然-ip-层会分片为什么-tcp-层还需要-mss"></a> 既然 IP 层会分片，为什么 TCP 层还需要 MSS</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023155957.png" srcset="/img/loading.gif" alt="" /></p><blockquote><p><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。<br /><code>MSS</code>：除去 <code>IP</code> 和 <code>TCP</code> 头部之后，一个网络包所能容纳的 <code>TCP</code> 数据的最大长度。</p></blockquote><p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？</p><p>当 IP 层有一个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 <strong>IP 层就要进行分片</strong>，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 <strong>IP 层来进行重新组装</strong>后，再交给上一层 TCP 传输层。</p><p>这看起来井然有序，但这存在隐患的，那么<strong>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。</strong><br />因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。<br />因为是在接收方的 IP 层进行分片重组，当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。<br />因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</p><p>所以，<strong>为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。<br />经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。</p><h2 id="什么是-syn-攻击如何避免-syn-攻击"><a class="markdownIt-Anchor" href="#什么是-syn-攻击如何避免-syn-攻击"></a> 什么是 SYN 攻击？如何避免 SYN 攻击？</h2><h3 id="syn-攻击"><a class="markdownIt-Anchor" href="#syn-攻击"></a> SYN 攻击</h3><p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入 <code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的 SYN 接收队列（未连接队列）</strong>，使得服务器不能为正常用户服务。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028164702.png" srcset="/img/loading.gif" alt="" /></p><h3 id="避免-syn-攻击方式一"><a class="markdownIt-Anchor" href="#避免-syn-攻击方式一"></a> 避免 SYN 攻击方式一</h3><p>其中一种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。</p><p>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。可以控制该队列的最大值，或限制 <code>SYN_RCVD</code> 状态连接的最大个数，当超出处理能力时，对新的 <code>SYN</code> 直接回报 <code>RST</code>，丢弃连接。</p><h3 id="避免-syn-攻击方式二"><a class="markdownIt-Anchor" href="#避免-syn-攻击方式二"></a> 避免 SYN 攻击方式二</h3><p>Linux 内核的 <code>SYN</code> （未完成连接建立）队列与 <code>Accpet</code> （已完成连接建立）队列的正常流程：</p><ol><li>当服务端接收到客户端的 <code>SYN</code> 报文时，会将其加入到内核的「<code>SYN 队列</code>」；</li><li>接着发送 <code>SYN + ACK</code> 给客户端，等待客户端回应 <code>ACK</code> 报文；</li><li>服务端接收到 <code>ACK</code> 报文后，从「<code>SYN 队列</code>」移除放入到「<code>Accept 队列</code>」；</li><li>应用通过调用 <code>accpet()</code> socket 接口，从「<code>Accept 队列</code>」取出连接。</li></ol><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028164936.png" srcset="/img/loading.gif" alt="" /></p><p>应用程序过慢：</p><p>如果应用程序过慢时，就会导致「Accept 队列」被占满。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028165619.jpeg" srcset="/img/loading.gif" alt="" /></p><p>受到 SYN 攻击：</p><p>如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028165601.jpeg" srcset="/img/loading.gif" alt="" /></p><ul><li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，<strong>不进入「SYN 队列」</strong>；</li><li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「<code>序列号</code>」返回客户端，</li><li>服务端接收到客户端的应答报文时，服务器会检查这个 <code>ACK</code> 包的合法性。如果合法，直接放入到「<code>Accept 队列</code>」。</li><li>最后应用通过调用 <code>accpet()</code> socket 接口，从「<code>Accept 队列</code>」取出的连接。</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028165544.jpeg" srcset="/img/loading.gif" alt="" /></p><h1 id="tcp-连接断开"><a class="markdownIt-Anchor" href="#tcp-连接断开"></a> TCP 连接断开</h1><h2 id="tcp-四次挥手过程和状态变迁"><a class="markdownIt-Anchor" href="#tcp-四次挥手过程和状态变迁"></a> TCP 四次挥手过程和状态变迁</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029124017.jpg" srcset="/img/loading.gif" alt="" /><br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029130218.png" srcset="/img/loading.gif" alt="" /></p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSED</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 后，自动进入 <code>CLOSED</code> 状态，至此客户端也完成连接的关闭。</li></ul><blockquote><p>可以看到，每个方向都需要一个 <code>FIN</code> 和一个 <code>ACK</code>，因此通常被称为四次挥手。<br />需要注意的是：<strong>主动关闭连接的，才有 <code>TIME_WAIT</code> 状态。</strong></p></blockquote><h2 id="为什么挥手需要四次"><a class="markdownIt-Anchor" href="#为什么挥手需要四次"></a> 为什么挥手需要四次</h2><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示<strong>客户端不再发送数据了但是还能接收数据。</strong></li><li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而<strong>服务端可能还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，<strong>服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会<code>分开发送</code></strong>，从而比三次握手导致多了一次。</p><h2 id="为什么-time_wait-等待的时间是-2-msl"><a class="markdownIt-Anchor" href="#为什么-time_wait-等待的时间是-2-msl"></a> 为什么 TIME_WAIT 等待的时间是 2 MSL</h2><blockquote><p><code>MSL</code> 是 <code>Maximum Segment Lifetime</code>，报文最大生存时间，它是<strong>任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。<strong>因为 <code>TCP</code> 报文基于是 <code>IP</code> 协议的，而 <code>IP</code> 头中有一个 <code>TTL</code> 字段，是 <code>IP</code> 数据报可以经过的</strong>最大路由数</strong>，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 <code>ICMP</code> 报文通知源主机。</p><p><code>MSL</code> 与 <code>TTL</code> 的区别： <code>MSL</code> 的单位是时间，而 <code>TTL</code> 是经过路由跳数。所以 <code>MSL</code> 应该要大于等于 <code>TTL</code> 消耗为 <code>0</code> 的时间，以确保报文已被自然消亡。</p></blockquote><p>2 MSL 是为了<strong>确保发送方最后发送的 <code>ACK</code> 已经被对端接收</strong>。<br />如果被动关闭方没有收到断开连接的最后的 <code>ACK</code> 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 <code>FIN</code> 后，会重发 <code>ACK</code> 给被动关闭方， 一来一去正好 <code>2</code> 个 <code>MSL</code>。</p><blockquote><p>当客户端 <code>TIME-WAIT</code> 时间超过了 <code>2MSL</code>，则客户端就直接进入关闭状态。若此时第四次挥手的 <code>ACK</code> 和重发的 <code>FIN</code> 都丢失，此时会看服务端超时重发 <code>FIN</code> 报文的次数如果超过 <code>tcp_orphan_retries</code> 大小后，服务端也会关闭 <code>TCP</code> 连接。</p></blockquote><p>2 MSL 的时间是<strong>从客户端接收到 <code>FIN</code> 后发送 <code>ACK</code> 开始计时的</strong>。如果在 <code>TIME-WAIT</code> 时间内，因为客户端的 <code>ACK</code> 没有传输到服务端，客户端又接收到了服务端重发的 <code>FIN</code> 报文，那么 2 MSL 时间将<strong>重新计时</strong>。</p><h2 id="为什么需要-time_wait-状态"><a class="markdownIt-Anchor" href="#为什么需要-time_wait-状态"></a> 为什么需要 TIME_WAIT 状态</h2><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p><p>需要 <code>TIME-WAIT</code> 状态，主要是两个原因：</p><ul><li>防止具有相同「四元组」的「旧」数据包被收到，使旧的数据包消亡在网络中；</li><li>保证「被动关闭连接」的一方能被正确的关闭，即<strong>保证最后的 <code>ACK</code> 能让被动关闭方接收，从而帮助其正常关闭；</strong></li></ul><h3 id="原因一防止旧连接的数据包"><a class="markdownIt-Anchor" href="#原因一防止旧连接的数据包"></a> 原因一：防止旧连接的数据包</h3><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029124033.png" srcset="/img/loading.gif" alt="" /></p><ul><li>如上图黄色框框服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li><li>这时有相同端口的 TCP 连接被复用后，被延迟的 <code>SEQ = 301</code> 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生<strong>数据错乱</strong>等严重的问题。</li></ul><p>所以，TCP 就设计出了这么一个机制，经过 2MSL 这个时间，足以<strong>让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><h3 id="原因二保证连接正确关闭"><a class="markdownIt-Anchor" href="#原因二保证连接正确关闭"></a> 原因二：保证连接正确关闭</h3><blockquote><p><code>TIME-WAIT</code> 作用是等待足够的时间以确保最后的 <code>ACK</code> 能让被动关闭方接收，从而帮助其正常关闭。<br />假设 <code>TIME-WAIT</code> 没有等待时间或时间过短，断开连接会造成什么问题呢？</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029124052.png" srcset="/img/loading.gif" alt="" /></p><ul><li>如上图红色框框客户端四次挥手的最后一个 <code>ACK</code> 报文如果在网络中被丢失了，此时如果客户端 <code>TIME-WAIT</code> 过短或没有，则就直接进入了 <code>CLOSED</code> 状态了，那么<strong>服务端则会一直处在 <code>LASE-ACK</code> 状态。</strong></li><li>当客户端发起建立连接的 <code>SYN</code> 请求报文后，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止。</li></ul><p>如果 <code>TIME-WAIT</code> 等待足够长的情况就会遇到两种情况：</p><ul><li>服务端正常收到四次挥手的最后一个 <code>ACK</code> 报文，则服务端正常关闭连接。</li><li>服务端没有收到四次挥手的最后一个 <code>ACK</code> 报文时，则会重发 <code>FIN</code> 关闭连接报文并等待新的 <code>ACK</code> 报文。</li></ul><p>所以客户端在 <code>TIME-WAIT</code> 状态等待 <code>2MSL</code> 时间后，就可以<strong>保证双方的连接都可以正常的关闭</strong>。</p><h2 id="time_wait-过多有什么危害"><a class="markdownIt-Anchor" href="#time_wait-过多有什么危害"></a> TIME_WAIT 过多有什么危害</h2><p>如果服务器有处于 <code>TIME-WAIT</code> 状态的 <code>TCP</code>，则说明是由<strong>服务器方主动发起的断开请求</strong>。</p><p>过多的 <code>TIME-WAIT</code> 状态主要的危害有两种：</p><ol><li><strong>内存</strong>资源占用；</li><li><strong>端口</strong>资源的占用，一个 TCP 连接至少消耗一个本地端口；</li></ol><p>如果发起连接一方的 <code>TIME_WAIT</code> 状态过多，占满了所有端口资源，则会导致无法创建新连接。</p><ul><li><p>客户端受端口资源限制：<br />客户端 <code>TIME_WAIT</code> 过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致<strong>无法创建新的连接。</strong></p></li><li><p>服务端受系统资源限制：<br />由于一个四元组表示 TCP 连接，理论上服务端可以建立很多连接，服务端确实只监听一个端口 但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听。但是线程池处理不了那么多一直不断的连接了。所以当服务端出现大量 <code>TIME_WAIT</code> 时，系统资源被占满时，会<strong>导致处理不过来新的连接。</strong></p></li></ul><h2 id="tcp-保活机制"><a class="markdownIt-Anchor" href="#tcp-保活机制"></a> TCP 保活机制</h2><blockquote><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 <code>TCP</code> 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p></blockquote><pre><code class="hljs stylus">保活时间：net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.tcp_keepalive_time</span> = <span class="hljs-number">7200</span>保活探测的间隔：net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.tcp_keepalive_intvl</span> = <span class="hljs-number">75</span>保活探测的次数：net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.tcp_keepalive_probes</span> = <span class="hljs-number">9</span></code></pre><ul><li><code>tcp_keepalive_time=7200</code>：表示保活时间是 <code>7200</code> 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li><li><code>tcp_keepalive_intvl=75</code>：表示每次检测间隔 <code>75</code> 秒；</li><li><code>tcp_keepalive_probes=9</code>：表示检测 <code>9</code> 次无响应，认为对方是不可达的，从而中断本次的连接。</li></ul><p>也就是说在 Linux 系统中，最少需要经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi>v</mi><mi>l</mi><mo>∗</mo><mi>p</mi><mi>r</mi><mi>o</mi><mi>b</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">time + (intvl * probes)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span> 即 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p><p>如果开启了 TCP 保活，需要考虑以下几种情况：</p><ol><li>对端程序是<strong>正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP <strong>保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li><li></li><li>对端程序<strong>崩溃并重启</strong>。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP <strong>连接已经被重置</strong>。</li><li></li><li>对端程序<strong>崩溃</strong>，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 <strong>TCP 连接已经死亡</strong>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 145. 二叉树的后序遍历</title>
    <link href="/2020/10/27/LeetCode-145-binary-tree-postorder-traversal/"/>
    <url>/2020/10/27/LeetCode-145-binary-tree-postorder-traversal/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    stack.add(root);    <span class="hljs-comment">// 前序：根左右 ——&gt; 后序：左右根</span>    <span class="hljs-comment">// 前序：根右左  reverse: 左右根</span>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        root = stack.pop();        res.add(root.val);        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;            stack.push(root.left);        &#125;        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;            stack.push(root.right);        &#125;    &#125;    Collections.reverse(res);    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 94. 二叉树的中序遍历</title>
    <link href="/2020/10/27/LeetCode-94-binary-tree-inorder-traversal/"/>
    <url>/2020/10/27/LeetCode-94-binary-tree-inorder-traversal/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;            stack.push(root);            root = root.left;        &#125;        root = stack.pop();        res.add(root.val);        root = root.right;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 144. 二叉树的前序遍历</title>
    <link href="/2020/10/27/LeetCode-144-binary-tree-preorder-traversal/"/>
    <url>/2020/10/27/LeetCode-144-binary-tree-preorder-traversal/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    stack.add(root);    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        root = stack.pop();        res.add(root.val);        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;            stack.push(root.right);        &#125;        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;            stack.push(root.left);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ping 和 traceroute 工作原理</title>
    <link href="/2020/10/26/network-ping-traceroute/"/>
    <url>/2020/10/26/network-ping-traceroute/</url>
    
    <content type="html"><![CDATA[<h1 id="icmp-协议"><a class="markdownIt-Anchor" href="#icmp-协议"></a> ICMP 协议</h1><h2 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h2><p><code>ping</code> 是基于 <code>ICMP</code> 协议工作的。<br /><code>ICMP</code> 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。ICMP 报文封装在 <code>IP</code> 包里面，它工作在<strong>网络层</strong>。</p><p><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将由 <code>ICMP</code> 负责通知。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201026190457.png" srcset="/img/loading.gif" alt="" /></p><p><code>ICMP</code> 包头的类型字段，大致可以分为两大类：</p><ol><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ol><h2 id="查询报文类型"><a class="markdownIt-Anchor" href="#查询报文类型"></a> 查询报文类型</h2><p>回送消息用于进行通信的<strong>主机</strong>或<strong>路由器</strong>之间，<strong>判断所发送的数据包是否已经成功到达对端</strong>的一种消息，ping 命令就是利用这个消息实现的。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201026190633.png" srcset="/img/loading.gif" alt="" /></p><p>可以向对端主机发送<code>回送请求</code>的消息（ICMP Echo Request Message，类型 8），也可以接收对端主机发回来的<code>回送应答</code>消息（ICMP Echo Reply Message，类型 0）。</p><h2 id="差错报文类型"><a class="markdownIt-Anchor" href="#差错报文类型"></a> 差错报文类型</h2><p><code>IP</code> 路由器无法将 <code>IP</code> 数据包发送给目标地址时，会给发送端主机返回一个<strong>目标不可达</strong>的 <code>ICMP</code> 消息，并在这个消息中显示不可达的具体原因，原因记录在 <code>ICMP</code> 包头的代码字段。</p><p>几个常用的 ICMP 差错报文的例子：</p><ol><li>目标不可达消息 —— 类型 为 <code>3</code></li><li>原点抑制消息 —— 类型 <code>4</code></li><li>重定向消息 —— 类型 <code>5</code></li><li>超时消息 —— 类型 <code>11</code></li></ol><h3 id="1-目标不可达消息"><a class="markdownIt-Anchor" href="#1-目标不可达消息"></a> 1. 目标不可达消息</h3><table><thead><tr><th>代码号</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td><code>0</code></td><td style="text-align:center">网络不可达</td></tr><tr><td><code>1</code></td><td style="text-align:center">主机不可达</td></tr><tr><td><code>2</code></td><td style="text-align:center">协议不可达</td></tr><tr><td><code>3</code></td><td style="text-align:center">端口不可达</td></tr><tr><td><code>4</code></td><td style="text-align:center">需要进行分片但设置了不分片位</td></tr></tbody></table><h3 id="2-原点抑制消息"><a class="markdownIt-Anchor" href="#2-原点抑制消息"></a> 2. 原点抑制消息</h3><p>在使用低速广域线路的情况下，连接 WAN 的路由器可能会遇到网络拥堵的问题。<br /><strong><code>ICMP</code> 原点抑制消息的目的就是为了缓和这种拥堵情况。</strong></p><p>当路由器向低速线路发送数据时，其发送队列的缓存变为零而无法发送出去时，可以向 <code>IP</code> 包的源地址发送一个 <code>ICMP</code> 原点抑制消息。<br />收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况，从而增大 <code>IP</code> 包的传输间隔，减少网络拥堵的情况。</p><p>然而，由于这种 <code>ICMP</code> 可能会引起不公平的网络通信，一般不被使用。</p><h3 id="3-重定向消息"><a class="markdownIt-Anchor" href="#3-重定向消息"></a> 3. 重定向消息</h3><p>如果路由器发现发送端主机使用了「<strong>不是最优</strong>」的路径发送数据，那么它会返回一个 ICMP 重定向消息给这个主机。</p><p><strong>在这个消息中包含了最合适的路由信息和源数据。</strong> 这主要发生在路由器持有<strong>更好的路由信息</strong>的情况下。路由器会通过这样的 <code>ICMP</code> 消息告知发送端，让它下次发给另外一个路由器。</p><h3 id="4-超时消息"><a class="markdownIt-Anchor" href="#4-超时消息"></a> 4. 超时消息</h3><p>IP 包中有一个字段叫做 <code>TTL （Time To Live，生存周期）</code>，它的值随着每经过一次路由器就会减 <code>1</code>，直到减到 <code>0</code> 时该 <code>IP</code> 包会被丢弃。</p><p>此时，路由器将会发送一个 <code>ICMP 超时消息</code>给发送端主机，并通知该包已被丢弃。</p><p>设置 <code>IP</code> 包生存周期的主要目的，是为了<strong>在路由控制遇到问题发生循环状况时，避免 <code>IP</code> 包无休止地在网络上被转发。</strong></p><h1 id="ping-查询报文类型的使用"><a class="markdownIt-Anchor" href="#ping-查询报文类型的使用"></a> ping: 查询报文类型的使用</h1><p><code>ping</code> 命令执行的时候，源主机首先会构建一个 <code>ICMP 回送请求消息数据包</code>。</p><p><code>ICMP</code> 数据包内包含多个字段，最重要的是两个：</p><ul><li>类型：对于回送请求消息而言该字段为 <code>8</code>；</li><li>序号：主要用于<strong>区分连续 <code>ping</code> 的时候发出的多个数据包</strong>。每发出一个请求数据包，序号会自动加 <code>1</code>。</li><li>发送时间：为了能够计算往返时间 <code>RTT</code>，它会在报文的数据部分插入发送时间。</li></ul><p>发送流程：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201026192125.png" srcset="/img/loading.gif" alt="" /></p><ol><li>源主机首先会构建一个 <code>ICMP 回送请求消息数据包</code>。由 <code>ICMP</code> 协议将这个数据包连同 <strong>目标地址</strong> 一起交给 <code>IP</code> 层。</li><li><code>IP</code> 层将以 <strong>上层传来的 IP 地址</strong> 作为<strong>目的地址</strong>，本机 <code>IP</code> 地址作为<strong>源地址</strong>，协议字段设置为 <code>1</code> 表示是 <code>ICMP</code> 协议，再加上一些其他控制信息，构建一个 <code>IP 数据包</code>。</li><li>加入 <code>MAC</code> 首部：如果在本地 <code>ARP</code> 映射表中查找出 目标地址 所对应的 <code>MAC</code> 地址，则可以直接使用；如果没有，则需要发送 <code>ARP</code> 协议查询 <code>MAC</code> 地址，获得 <code>MAC</code> 地址后，由数据链路层构建一个数据帧，目的地址是 <code>IP</code> 层传过来的 <code>MAC</code> 地址，源地址则是本机的 <code>MAC</code> 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</li><li>主机 <code>B</code> 收到这个数据帧后，先检查它的目的 <code>MAC</code> 地址，并和本机的 <code>MAC</code> 地址对比，如符合，则接收，否则就丢弃。</li><li>主机 <code>B</code> 会构建一个 <code>ICMP 回送响应消息数据包</code>，回送响应数据包的类型字段为 <code>0</code>，序号为接收到的请求数据包中的序号，然后再发送出去给主机 <code>A</code>。</li><li>在规定的时候间内，源主机如果没有接到 <code>ICMP</code> 的应答包，则说明目标<strong>主机不可达</strong>；如果接收到了 <code>ICMP</code> 回送响应消息，则说明目标主机可达。<br />此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 <code>ICMP</code> 数据包的时间延迟。</li></ol><h1 id="traceroute-差错报文类型的使用"><a class="markdownIt-Anchor" href="#traceroute-差错报文类型的使用"></a> traceroute: 差错报文类型的使用</h1><p>作用：</p><ol><li>故意设置特殊的 <code>TTL</code>，来<strong>追踪去往目的地时沿途经过的路由器</strong>。</li></ol><blockquote><p><strong>利用 IP 包的生存期限 从 1 开始按照顺序递增的同时发送 UDP 包，强制接收 ICMP 超时消息</strong>的一种方法。</p></blockquote><p>比如，将 <code>TTL</code> 设置为 <code>1</code>，则遇到第一个路由器，就牺牲了，接着返回 <code>ICMP</code> 差错报文网络包，类型是<strong>时间超时</strong>。<br />接下来将 <code>TTL</code> 设置为 <code>2</code>，也同时返回了 <code>ICMP</code> 差错报文数据包，如此往复，直到到达目的主机。<br />这样的过程，<code>traceroute</code> 就可以拿到了所有的路由器 <code>IP</code>。</p><ol start="2"><li>故意设置<strong>不分片</strong>，从而确定路径的 <code>MTU</code>。</li></ol><blockquote><p>有的时候我们并不知道路由器的 <code>MTU</code> 大小，以太网的数据链路上的 <code>MTU</code> 通常是 <code>1500</code> 字节，但是非以太网的 <code>MTU</code> 值就不一样了，所以我们要知道 <code>MTU</code> 的大小，从而控制发送的包大小。</p></blockquote><p>首先在发送端主机发送 <code>IP</code> 数据报时，将 <code>IP</code> 包首部的<strong>分片禁止标志位设置为 1</strong>。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。</p><p>随后，通过一个 <code>ICMP</code> 的不可达消息将数据链路上 <code>MTU</code> 的值一起给发送主机，不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」。</p><p>发送主机端每次收到 <code>ICMP</code> 差错报文时就减少包的大小，以此来定位一个合适的 <code>MTU</code> 值，以便能到达目标主机。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 641. 设计循环双端队列</title>
    <link href="/2020/10/26/LeetCode-641-design-circular-deque/"/>
    <url>/2020/10/26/LeetCode-641-design-circular-deque/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircularDeque</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 指向队头存储元素的位置</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> front;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 指向队尾存储元素的下一个位置</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rear;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] queue;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here. Set the size of the deque to be k.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCircularDeque</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.capacity = k + <span class="hljs-number">1</span>;        <span class="hljs-keyword">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[capacity];        <span class="hljs-comment">/**</span><span class="hljs-comment">         * insert: front-- , set value</span><span class="hljs-comment">         * delete: front++</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">this</span>.front = <span class="hljs-number">0</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * insert: set value, rear++</span><span class="hljs-comment">         * delete: rear--</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">this</span>.rear = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Adds an item at the front of Deque. Return true if the operation is successful.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertFront</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (isFull()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        front = (front - <span class="hljs-number">1</span> + capacity) % capacity;        queue[front] = value;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Adds an item at the rear of Deque. Return true if the operation is successful.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertLast</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (isFull()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        queue[rear] = value;        rear = (rear + <span class="hljs-number">1</span>) % capacity;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Deletes an item from the front of Deque. Return true if the operation is successful.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteFront</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        front = (front + <span class="hljs-number">1</span>) % capacity;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Deletes an item from the rear of Deque. Return true if the operation is successful.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteLast</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        rear = (rear - <span class="hljs-number">1</span> + capacity) % capacity;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get the front item from the deque.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFront</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> queue[front];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get the last item from the deque.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRear</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> queue[(rear - <span class="hljs-number">1</span> + capacity) % capacity];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Checks whether the circular deque is empty or not.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> front == rear;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Checks whether the circular deque is full or not.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (rear + <span class="hljs-number">1</span>) % capacity == front;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 622. 设计循环队列</title>
    <link href="/2020/10/26/LeetCode-622-design-circular-queue/"/>
    <url>/2020/10/26/LeetCode-622-design-circular-queue/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. 设计循环队列</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircularQueue</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 指向队头存储元素的位置</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> front;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 指向队尾存储元素的下一个位置</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rear;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] queue;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here. Set the size of the queue to be k.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCircularQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.capacity = k + <span class="hljs-number">1</span>;        <span class="hljs-keyword">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[capacity];        <span class="hljs-keyword">this</span>.front = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.rear = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Insert an element into the circular queue. Return true if the operation is successful.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (isFull()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        queue[rear] = value;        rear = (rear + <span class="hljs-number">1</span>) % capacity;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Delete an element from the circular queue. Return true if the operation is successful.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        front = (front + <span class="hljs-number">1</span>) % capacity;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get the front item from the queue.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> queue[front];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get the last item from the queue.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> queue[(rear - <span class="hljs-number">1</span> + capacity) % capacity];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Checks whether the circular queue is empty or not.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> front == rear;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Checks whether the circular queue is full or not.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (rear + <span class="hljs-number">1</span>) % capacity == front;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 621. 任务调度器</title>
    <link href="/2020/10/26/LeetCode-621-task-scheduler/"/>
    <url>/2020/10/26/LeetCode-621-task-scheduler/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">621. 任务调度器</a></p><h1 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tasks, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-comment">// 统计每个任务的数量</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> task : tasks) &#123;        counts[task - <span class="hljs-string">'A'</span>]++;    &#125;    <span class="hljs-comment">// 找到任务数最多的任务</span>    Arrays.sort(counts);    <span class="hljs-keyword">int</span> maxCount = counts[<span class="hljs-number">25</span>];    <span class="hljs-comment">// 需要几个任务队列取决于数量最多的那个任务</span>    <span class="hljs-keyword">int</span> time = (maxCount - <span class="hljs-number">1</span>) * (n + <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">25</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// 有其他任务和 max 一样，则多花一个时间</span>        <span class="hljs-keyword">if</span> (counts[i] == maxCount) &#123;            time++;        &#125;    &#125;    <span class="hljs-comment">// 若有空闲时间，res = time</span>    <span class="hljs-comment">// 若没有空闲时间，表示 n 个序列都已用完，需要扩充 n，res = len</span>    <span class="hljs-keyword">return</span> Math.max(time, tasks.length);&#125;</code></pre><h1 id="优先队列"><a class="markdownIt-Anchor" href="#优先队列"></a> 优先队列</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tasks, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-comment">// 统计每个任务的数量</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> task : tasks) &#123;        counts[task - <span class="hljs-string">'A'</span>]++;    &#125;    <span class="hljs-comment">// 大顶堆，优先安排数量多的任务</span>    Queue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-number">26</span>, (o1, o2) -&gt; o2 - o1);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : counts) &#123;        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;            maxHeap.add(num);        &#125;    &#125;    <span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (!maxHeap.isEmpty()) &#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        List&lt;Integer&gt; nextRound = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 每轮分配 n + 1 个任务</span>        <span class="hljs-keyword">while</span> (i &lt;= n) &#123;            time++;            <span class="hljs-keyword">if</span> (!maxHeap.isEmpty()) &#123;                <span class="hljs-comment">// 每次取最大任务数（堆顶）</span>                <span class="hljs-keyword">int</span> taskCount = maxHeap.poll();                <span class="hljs-keyword">if</span> (taskCount &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-comment">// 任务数 - 1 放入下一轮</span>                    nextRound.add(taskCount - <span class="hljs-number">1</span>);                &#125;            &#125;            <span class="hljs-keyword">if</span> (maxHeap.isEmpty() &amp;&amp; nextRound.isEmpty()) &#123;                <span class="hljs-keyword">break</span>;            &#125;            i++;        &#125;        maxHeap.addAll(nextRound);    &#125;    <span class="hljs-keyword">return</span> time;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1365. 有多少小于当前数字的数字</title>
    <link href="/2020/10/26/LeetCode-1365-how-many-numbers-are-smaller-than-the-current-number/"/>
    <url>/2020/10/26/LeetCode-1365-how-many-numbers-are-smaller-than-the-current-number/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/" target="_blank" rel="noopener">1365. 有多少小于当前数字的数字</a></p><h1 id="排序-哈希"><a class="markdownIt-Anchor" href="#排序-哈希"></a> 排序 + 哈希</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] smallerNumbersThanCurrent(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] origin = Arrays.copyOf(nums, len);    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">101</span>];    Arrays.sort(nums);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 去重</span>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] == nums[i]) &#123;            j--;        &#125;        counts[nums[i]] = j + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        res[i] = counts[origin[i]];    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="计数排序"><a class="markdownIt-Anchor" href="#计数排序"></a> 计数排序</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] smallerNumbersThanCurrent(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">101</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        counts[num]++;    &#125;    <span class="hljs-comment">// 统计出现频次</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; counts.length; i++) &#123;        counts[i] = counts[i - <span class="hljs-number">1</span>] + counts[i];    &#125;    <span class="hljs-comment">// 计算在 nums[i] 之前出现了几个数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;            res[i] = counts[nums[i] - <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 674. 最长连续递增序列</title>
    <link href="/2020/10/25/LeetCode-674-longest-continuous-increasing-subsequence/"/>
    <url>/2020/10/25/LeetCode-674-longest-continuous-increasing-subsequence/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">74. 最长连续递增序列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> curLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 递增则更新长度</span>        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] &lt; nums[i]) &#123;            curLen++;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 非连续递增，则重新开始计算长度</span>            curLen = <span class="hljs-number">1</span>;        &#125;        max = Math.max(max, curLen);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] rights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    Arrays.fill(rights, <span class="hljs-number">1</span>);    <span class="hljs-comment">// 从右边开始找最大递增数</span>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; len &amp;&amp; nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;            rights[i] = rights[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        &#125;        max = Math.max(max, rights[i]);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 845. 数组中的最长山脉</title>
    <link href="/2020/10/25/LeetCode-845-longest-mountain-in-array/"/>
    <url>/2020/10/25/LeetCode-845-longest-mountain-in-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/" target="_blank" rel="noopener">845. 数组中的最长山脉</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestMountain</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[] leftMin = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] rightMin = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-comment">// 找到左边比 A[i] 小的连续个数 </span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; A[i - <span class="hljs-number">1</span>] &lt; A[i]) &#123;            leftMin[i] = leftMin[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            leftMin[i] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-comment">// 找到右边比 A[i] 小的连续个数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; len &amp;&amp; A[i] &gt; A[i + <span class="hljs-number">1</span>]) &#123;            rightMin[i] = rightMin[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            rightMin[i] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (leftMin[i] != <span class="hljs-number">0</span> &amp;&amp; rightMin[i] != <span class="hljs-number">0</span>) &#123;            max = Math.max(max, leftMin[i] + rightMin[i] + <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1024. 视频拼接</title>
    <link href="/2020/10/24/LeetCode-1024-video-stitching/"/>
    <url>/2020/10/24/LeetCode-1024-video-stitching/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/video-stitching/" target="_blank" rel="noopener">1024. 视频拼接</a></p><p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">videoStitching</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] clips, <span class="hljs-keyword">int</span> T)</span> </span>&#123;    <span class="hljs-comment">/* dp[i]: 覆盖区间 [0, i] 所需要的最少子区间数量</span><span class="hljs-comment">    e.g.   0..|.....i|</span><span class="hljs-comment">              |a_j...|...b_j</span><span class="hljs-comment">      if i in [a_j, b_j]:</span><span class="hljs-comment">        [a_j, b_j] 可以覆盖 [0, i] 的后半部分</span><span class="hljs-comment">        后半部分：dp[i] = 1 (加上区间 [a_j, b_j])，前半部分：dp[a_j]</span><span class="hljs-comment">        整个区间：dp[i] = min(dp[a_j] + 1, dp[i])</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T + <span class="hljs-number">1</span>];    Arrays.fill(dp, Integer.MAX_VALUE - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= T; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] clip : clips) &#123;            <span class="hljs-keyword">if</span> (clip[<span class="hljs-number">0</span>] &lt;= i &amp;&amp; i &lt;= clip[<span class="hljs-number">1</span>]) &#123;                dp[i] = Math.min(dp[i], dp[clip[<span class="hljs-number">0</span>]] + <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[T] == Integer.MAX_VALUE - <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : dp[T];&#125;</code></pre><h1 id="贪心"><a class="markdownIt-Anchor" href="#贪心"></a> 贪心</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">videoStitching</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] clips, <span class="hljs-keyword">int</span> T)</span> </span>&#123;    <span class="hljs-comment">// dp[i]: 以 i 为起点能到达的最远位置</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">101</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] clip : clips) &#123;        <span class="hljs-comment">// 取 clip[0] 最远的位置，即取能覆盖最远的区间</span>        dp[clip[<span class="hljs-number">0</span>]] = Math.max(dp[clip[<span class="hljs-number">0</span>]], clip[<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-comment">// 所需要的片段数</span>    <span class="hljs-keyword">int</span> clipCount = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前的最远位置</span>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 上一次起跳的终点</span>    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) &#123;        <span class="hljs-comment">// 更新当前能到达的最远位置</span>        max = Math.max(max, dp[i]);        <span class="hljs-comment">// 当前最远只能到 i 位置，到不了下一个位置</span>        <span class="hljs-keyword">if</span> (max == i) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 到达上一次的终点，取一个新片段</span>        <span class="hljs-keyword">if</span> (i == pre) &#123;            clipCount++;            pre = max;        &#125;    &#125;    <span class="hljs-keyword">return</span> clipCount;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1267. 统计参与通信的服务器</title>
    <link href="/2020/10/23/LeetCode-1267-count-servers-that-communicate/"/>
    <url>/2020/10/23/LeetCode-1267-count-servers-that-communicate/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-servers-that-communicate/" target="_blank" rel="noopener">1267. 统计参与通信的服务器</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countServers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = grid.length;    <span class="hljs-keyword">int</span> cols = grid[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">int</span>[] rowCount = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows];    <span class="hljs-keyword">int</span>[] colCount = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[cols];    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            rowCount[i] += grid[i][j];            colCount[j] += grid[i][j];        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">if</span> (rowCount[i] &gt; <span class="hljs-number">1</span> || colCount[j] &gt; <span class="hljs-number">1</span>) &#123;                    res++;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1588. 所有奇数长度子数组的和</title>
    <link href="/2020/10/23/LeetCode-1588-sum-of-all-odd-length-subarrays/"/>
    <url>/2020/10/23/LeetCode-1588-sum-of-all-odd-length-subarrays/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/" target="_blank" rel="noopener">1588. 所有奇数长度子数组的和</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumOddLengthSubarrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] preSums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    preSums[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 1 4 2 5 3</span>    <span class="hljs-comment">// 0 1 5 7 12 15</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        preSums[i] = preSums[i - <span class="hljs-number">1</span>] + arr[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= len; j += <span class="hljs-number">2</span>) &#123;            <span class="hljs-comment">// preSums right index = i + &#123;0, 2, 4, ...&#125; + 1</span>            <span class="hljs-comment">// preSums left index = i</span>            <span class="hljs-keyword">int</span> right = i + j;            <span class="hljs-keyword">if</span> (right &lt;= len) &#123;                <span class="hljs-comment">// System.out.println(arr[i] + " sum = " + (preSums[right] - preSums[i]));</span>                res += preSums[right] - preSums[i];            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 234. 回文链表</title>
    <link href="/2020/10/23/LeetCode-234-palindrome-linked-list/"/>
    <url>/2020/10/23/LeetCode-234-palindrome-linked-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 1 0 1</span>    <span class="hljs-comment">// 翻转后的链表头部</span>    ListNode reversedHead = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 保存 需要翻转的 slow</span>    ListNode preSlow = head;    ListNode slow = head, fast = head;    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;        preSlow = slow;        <span class="hljs-comment">// 快慢指针移动</span>        slow = slow.next;        fast = fast.next.next;        <span class="hljs-comment">// 快慢指针移动完再翻转当前的 slow</span>        preSlow.next = reversedHead;        reversedHead = preSlow;    &#125;    <span class="hljs-comment">// 奇数个结点，slow 需要跳过中点进行回文判断</span>    <span class="hljs-keyword">if</span> (fast != <span class="hljs-keyword">null</span>) &#123;        slow = slow.next;    &#125;    <span class="hljs-keyword">while</span> (slow != <span class="hljs-keyword">null</span> &amp;&amp; reversedHead != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (slow.val != reversedHead.val) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        slow = slow.next;        reversedHead = reversedHead.next;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从键入网址到网页显示发生了什么</title>
    <link href="/2020/10/23/network-behind-type-url-and-press-enter/"/>
    <url>/2020/10/23/network-behind-type-url-and-press-enter/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023152504.png" srcset="/img/loading.gif" alt="" /></p><h1 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h1><ol><li>解析 URL：根据 URL 解析需要请求的文件。</li><li>产生 HTTP 请求信息。</li></ol><h1 id="dns-解析"><a class="markdownIt-Anchor" href="#dns-解析"></a> DNS 解析</h1><p>查询域名对应的 IP 地址。</p><blockquote><p><code>客户端</code> 采用<strong>递归查询</strong>向 <code>本地 DNS服务器</code> 查询。<br /><code>本地 DNS服务器</code> 采用<strong>递归查询</strong>向 <code>根域名服务器</code> 查询。</p><p>根域名服务器并不直接把待查询的域名直接转换成 IP 地址（根域名服务器也没有存放这种信息），而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。</p></blockquote><ol><li>客户端向 <code>本地 DNS服务器</code> 请求 <code>http://www.server.com</code> 的 <code>IP</code> 地址。</li><li><code>本地 DNS服务器</code> 收到客户端的请求后，<ul><li>如果缓存里能找到 <code>http://www.server.com</code>，则它直接返回 <code>IP</code> 地址。</li><li>如果没有，<code>本地 DNS</code> 会请求 <code>根域名服务器</code>。</li></ul></li><li><code>根域名服务器</code> 发现 <code>http://www.server.com</code> 的顶级域名是 <code>.com</code>，于是告诉 <code>本地 DNS服务器</code> 向 <code>.com</code> 顶级域名服务器查询。</li><li><code>本地 DNS</code> 会请求 <code>.com 顶级域名服务器</code>，<code>.com 顶级域名服务器</code> 告诉 <code>本地 DNS服务器</code> 向 <code>server.com 权限域名服务器</code> 查询。</li><li><code>本地 DNS</code> 会请求 <code>server.com 权限域名服务器</code>，<code>server.com 权限域名服务器</code> 将对应的 <code>IP 地址</code> 返回给 <code>本地 DNS</code>。</li><li><code>本地 DNS</code> 将 <code>IP 地址</code> 返回给客户端。</li></ol><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023153342.png" srcset="/img/loading.gif" alt="" /></p><h1 id="协议栈"><a class="markdownIt-Anchor" href="#协议栈"></a> 协议栈</h1><p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。</p><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023155010.png" srcset="/img/loading.gif" alt="" /></p><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，它们两会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据刽被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><p>此外 IP 中还包括 ICMP 协议和 ARP 协议。</p><ul><li>ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li>ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><h1 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> TCP</h1><h2 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h2><p>TCP 通过三次握手建立连接。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023155215.png" srcset="/img/loading.gif" alt="" /></p><ul><li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li><li>然后客户端主动发起连接 <code>SYN</code>，之后处于 <code>SYN-SENT</code> 状态。</li><li>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> 客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code> 之后，发送 <code>ACK</code> 的 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。</li><li>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</li></ul><blockquote><p>三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p></blockquote><h2 id="tcp-分割-http-数据"><a class="markdownIt-Anchor" href="#tcp-分割-http-数据"></a> TCP 分割 HTTP 数据</h2><blockquote><p><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。<br /><code>MSS</code>：除去 <code>IP</code> 和 <code>TCP</code> 头部之后，一个网络包所能容纳的 <code>TCP</code> 数据的最大长度。</p></blockquote><p>如果 <code>HTTP</code> 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 <code>TCP</code> 就需要把 <code>HTTP</code> 的数据拆解一块块的数据发送，而不是一次性发送所有数据。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023155957.png" srcset="/img/loading.gif" alt="" /></p><p>数据会被以 <code>MSS</code> 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 <code>TCP</code> 头信息，然后交给 <code>IP</code> 模块来发送数据。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023160020.png" srcset="/img/loading.gif" alt="" /></p><h2 id="tcp-报文生成"><a class="markdownIt-Anchor" href="#tcp-报文生成"></a> TCP 报文生成</h2><p>TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（80/443）。</p><p>在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。</p><p>至此，网络包的报文如下图。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023160222.png" srcset="/img/loading.gif" alt="" /></p><h1 id="ip"><a class="markdownIt-Anchor" href="#ip"></a> IP</h1><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。</p><h2 id="网卡选择"><a class="markdownIt-Anchor" href="#网卡选择"></a> 网卡选择</h2><ul><li>源地址IP，客户端输出的 IP 地址；</li><li>目标地址，通过 DNS 域名解析得到的 Web 服务器 IP。</li></ul><p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于<strong>在多块网卡中判断应该使用哪个一块网卡来发送包</strong>。</p><p>这个时候就需要根据路由表规则，来判断哪一个网卡作为源地址 IP。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023161006.png" srcset="/img/loading.gif" alt="" /></p><p>假设 Web 服务器的目标地址是 <code>192.168.10.200</code>。</p><ol><li>首先先和第一条目的子网掩码进行 <strong>与运算</strong>，得到结果为 <code>192.168.10.0</code>，但是第一个条目的 Destination 是 <code>192.168.3.0</code>，两者不一致所以匹配失败。</li><li>再与第二条目的子网掩码进行 <strong>与运算</strong>，得到的结果为 <code>192.168.10.0</code>，与第二条目的 Destination <code>192.168.10.0</code> 匹配成功，所以将使用 <code>eth1</code> 网卡的 IP 地址作为 IP 包头的源地址。</li></ol><h2 id="ip-报文生成"><a class="markdownIt-Anchor" href="#ip-报文生成"></a> IP 报文生成</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023160810.png" srcset="/img/loading.gif" alt="" /></p><h1 id="mac"><a class="markdownIt-Anchor" href="#mac"></a> MAC</h1><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。</p><p>在 <code>MAC</code> 包头里需要<code>发送方 MAC 地址</code>和<code>接收方目标 MAC 地址</code>，用于<strong>两点之间</strong>的传输。</p><p>一般在 TCP/IP 通信里，MAC 包头的协议类型只使用：</p><ul><li><code>0800</code> ： <code>IP</code> 协议</li><li><code>0806</code> ： <code>ARP</code> 协议</li></ul><p>地址获取：</p><ul><li>发送方的 MAC 地址：读取网卡的 <code>MAC</code> 地址。</li><li>接收方的 MAC 地址：使用 <code>ARP 协议</code> 以<strong>广播</strong>的形式获取。</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023161711.png" srcset="/img/loading.gif" alt="" /></p><h1 id="网卡"><a class="markdownIt-Anchor" href="#网卡"></a> 网卡</h1><p>IP 生成的网络包只是存放在内存中的一串<strong>二进制数字信息</strong>，没有办法直接发送给对方。因此，我们需要<strong>将数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p><p>负责执行这一操作的是网卡，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p><p>网卡驱动从 <code>IP</code> 模块获取到包之后，会将其复制到网卡内的缓存区中，接着会其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。</strong></p><ul><li>起始帧分界符是一个用来表示包起始位置的标记</li><li>末尾的 FCS（帧校验序列）用来检查包传输过程是否有损坏</li></ul><p>最后网卡会将包转为电信号，通过网线发送出去。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023161932.png" srcset="/img/loading.gif" alt="" /></p><h1 id="交换机"><a class="markdownIt-Anchor" href="#交换机"></a> 交换机</h1><p>交换机的设计是将网络包原样转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。<br />首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块<strong>将电信号转换为数字信号</strong>。<br />然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。</p><p>将包存入缓冲区后，接下来需要查询一下这个包的<code>接收方 MAC 地址</code>是否已经在 <code>MAC 地址表</code>中有记录了。</p><p>交换机的 MAC 地址表主要包含两个信息：</p><ul><li>一个是设备接收方的 <code>MAC 地址</code>，</li><li>另一个是该设备连接在交换机的哪个<code>端口</code>上。</li></ul><p><strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。</strong></p><blockquote><p>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能<strong>将包转发到除了源端口之外的所有端口上</strong>，无论该设备连接在哪个端口上都能收到这个包。</p></blockquote><h1 id="路由器"><a class="markdownIt-Anchor" href="#路由器"></a> 路由器</h1><h2 id="路由器与交换机的区别"><a class="markdownIt-Anchor" href="#路由器与交换机的区别"></a> 路由器与交换机的区别</h2><ul><li>路由器是基于 <code>IP</code> 设计的，俗称三层网络设备，路由器的各个端口都<strong>具有 MAC 地址和 IP 地址</strong>；</li><li>而交换机是基于<code>以太网</code>设计的，俗称二层网络设备，<strong>交换机的端口不具有 MAC 地址</strong>。</li></ul><h2 id="路由器的包接收操作"><a class="markdownIt-Anchor" href="#路由器的包接收操作"></a> 路由器的包接收操作</h2><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>如果没问题则检查 <code>MAC</code> 头部中的接收方 <code>MAC</code> 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>总的来说，路由器的端口都具有 <code>MAC</code> 地址，<strong>只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</strong></p><h2 id="路由器的包发送操作"><a class="markdownIt-Anchor" href="#路由器的包发送操作"></a> 路由器的包发送操作</h2><p>首先，我们需要<strong>根据路由表的网关列判断对方的地址</strong>。</p><ul><li>如果网关是一个 <code>IP</code> 地址，则这个 <code>IP</code> 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。</li><li>如果网关为空，则 <code>IP</code> 头部中的接收方 <code>IP</code> 地址就是要转发到的目标地址，也是就终于找到 <code>IP</code> 包头里的目标地址了，说明已抵达终点。</li></ul><p>知道对方的 <code>IP</code> 地址之后，接下来需要通过 <code>ARP</code> 协议根据 <code>IP</code> 地址查询 <code>MAC</code> 地址，并将查询的结果作为接收方 <code>MAC</code> 地址。</p><p>路由器也有 <code>ARP</code> 缓存，因此首先会在 <code>ARP</code> 缓存中查询，如果找不到则发送 <code>ARP</code> 查询请求。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。<br />发送出去的网络包会通过交换机到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><p>在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><h1 id="解析包"><a class="markdownIt-Anchor" href="#解析包"></a> 解析包</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023164232.png" srcset="/img/loading.gif" alt="" /></p><p>数据包抵达服务器后，服务器会先解析数据包的 <code>MAC 头部</code>，查看是否和服务器自己的 <code>MAC 地址</code>符合，符合就将包收起来。</p><p>接着继续解析数据包的 <code>IP 头</code>，发现 <code>IP</code> 地址符合，根据 <code>IP</code> 头中<code>协议项</code>，知道自己上层是 <code>TCP 协议</code>。</p><p>于是，解析 <code>TCP</code> 的头，里面有<code>序列号</code>，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 <code>ACK</code>，如果不是就丢弃。<code>TCP</code> 头部里面还有端口号， <code>HTTP</code> 的服务器正在监听这个端口号。</p><p>服务器的 <code>HTTP</code> 进程把客户端的请求数据封装在 <code>HTTP 响应报文</code>里。</p><p><code>HTTP 响应报文</code>也需要加上 <code>TCP</code>、<code>IP</code>、<code>MAC</code> 头部，不过这次是源地址是<code>服务器 IP 地址</code>，目的地址是<code>客户端 IP 地址</code>。之后通过相同的过程发送给客户端。最后通过<strong>四次挥手</strong>断开连接。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 763. 划分字母区间</title>
    <link href="/2020/10/22/LeetCode-763-partition-labels/"/>
    <url>/2020/10/22/LeetCode-763-partition-labels/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/partition-labels/" target="_blank" rel="noopener">763. 划分字母区间</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(String S)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = S.length();    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">char</span>[] str = S.toCharArray();    <span class="hljs-keyword">int</span>[] occur = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        occur[str[i] - <span class="hljs-string">'a'</span>] = i;    &#125;    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 每次遍历 [start, curWindowEnd]</span>    <span class="hljs-comment">// curWindowEnd 表示 start 对应字母的最后出现位置</span>    <span class="hljs-comment">// 取区间内每个字母最后出现位置的最大值</span>    <span class="hljs-keyword">while</span> (start &lt; len) &#123;        <span class="hljs-keyword">int</span> curWindowEnd = occur[str[start] - <span class="hljs-string">'a'</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; curWindowEnd; i++) &#123;            <span class="hljs-comment">// [start, curWindowEnd] 区间内取字母最后出现的位置</span>            curWindowEnd = Math.max(curWindowEnd, occur[str[i] - <span class="hljs-string">'a'</span>]);        &#125;        res.add(curWindowEnd - start + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 下一轮位置</span>        start = curWindowEnd + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 925. 长按键入</title>
    <link href="/2020/10/21/LeetCode-925-long-pressed-name/"/>
    <url>/2020/10/21/LeetCode-925-long-pressed-name/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/long-pressed-name/" target="_blank" rel="noopener">925. 长按键入</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLongPressedName</span><span class="hljs-params">(String name, String typed)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] names = name.toCharArray();    <span class="hljs-keyword">char</span>[] types = typed.toCharArray();    <span class="hljs-keyword">int</span> len1 = names.length;    <span class="hljs-keyword">int</span> len2 = types.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;        <span class="hljs-keyword">if</span> (names[i] == types[j]) &#123;            i++;            j++;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 第一个字符就不相等</span>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// types[j] 不是长按产生的</span>            <span class="hljs-keyword">boolean</span> jumped = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">while</span> (j &lt; len2 &amp;&amp; names[i - <span class="hljs-number">1</span>] == types[j]) &#123;                j++;                jumped = <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">if</span> (!jumped) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// types 后面还有重复</span>    <span class="hljs-keyword">while</span> (j &lt; len2) &#123;        <span class="hljs-keyword">if</span> (types[j] != names[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        j++;    &#125;    <span class="hljs-keyword">return</span> i == len1 &amp;&amp; j == len2;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 901. 股票价格跨度</title>
    <link href="/2020/10/20/LeetCode-901-online-stock-span/"/>
    <url>/2020/10/20/LeetCode-901-online-stock-span/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/online-stock-span/" target="_blank" rel="noopener">901. 股票价格跨度</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StockSpanner</span> </span>&#123;    ArrayDeque&lt;Integer&gt; stack;    ArrayDeque&lt;Integer&gt; weights;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StockSpanner</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 同步保存 price 之前有多少个比 price 小</span>        weights = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> price)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; price &gt;= stack.peek()) &#123;            <span class="hljs-comment">// 比 price 低的出栈</span>            stack.pop();            <span class="hljs-comment">// 加上对应的数目</span>            count += weights.pop();        &#125;        stack.push(price);        weights.push(count);        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 503. 下一个更大元素 II</title>
    <link href="/2020/10/20/LeetCode-503-next-greater-element-ii/"/>
    <url>/2020/10/20/LeetCode-503-next-greater-element-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. 下一个更大元素 II</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] nextGreaterElements(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    Arrays.fill(res, -<span class="hljs-number">1</span>);    ArrayDeque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-comment">// 两倍长度遍历</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len * <span class="hljs-number">2</span>; i++) &#123;        <span class="hljs-keyword">int</span> j = i % len;        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[j] &gt; nums[stack.peek()]) &#123;            res[stack.pop()] = nums[j];        &#125;        stack.push(j);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 143. 重排链表</title>
    <link href="/2020/10/20/LeetCode-143-reorder-list/"/>
    <url>/2020/10/20/LeetCode-143-reorder-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 1 2 3 4 5  1 2 3  5 4  1 5 2 4 3</span>    ListNode slow = head;    ListNode fast = head;    <span class="hljs-comment">// 快慢指针找中点</span>    <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>) &#123;        slow = slow.next;        fast = fast.next.next;    &#125;    ListNode newHead = slow.next;    slow.next = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 逆转链表</span>    newHead = reverseList(newHead);    <span class="hljs-comment">// 交替插入</span>    ListNode p = head;    ListNode q = newHead;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; q != <span class="hljs-keyword">null</span>) &#123;        ListNode t = p.next;        p.next = q;        ListNode t2 = q.next;        q.next = t;        p = t;        q = t2;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">// 1 2 3 4 5 6 7</span>    ListNode cur = head.next;    ListNode newHead = head;    newHead.next = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;        ListNode nextCur = cur.next;        cur.next = newHead;        newHead = cur;        cur = nextCur;    &#125;    <span class="hljs-keyword">return</span> newHead;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 496. 下一个更大元素 I</title>
    <link href="/2020/10/19/LeetCode-496-next-greater-element-i/"/>
    <url>/2020/10/19/LeetCode-496-next-greater-element-i/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] nextGreaterElement(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    ArrayDeque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums2) &#123;        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; num &gt; stack.peek()) &#123;            <span class="hljs-keyword">int</span> top = stack.pop();            map.put(top, num);        &#125;        stack.push(num);    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums1.length];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;        res[i] = map.getOrDefault(nums1[i], -<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 739. 每日温度</title>
    <link href="/2020/10/19/LeetCode-739-daily-temperatures/"/>
    <url>/2020/10/19/LeetCode-739-daily-temperatures/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></p><h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;    ArrayDeque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> len = T.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 单调递减栈</span>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;            <span class="hljs-keyword">int</span> top = stack.pop();            res[top] = i - top;        &#125;        stack.push(i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 844. 比较含退格的字符串</title>
    <link href="/2020/10/19/LeetCode-844-backspace-string-compare/"/>
    <url>/2020/10/19/LeetCode-844-backspace-string-compare/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">844. 比较含退格的字符串</a></p><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] s = S.toCharArray();    <span class="hljs-keyword">char</span>[] t = T.toCharArray();    <span class="hljs-keyword">return</span> getString(s).equals(getString(t));&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getString</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s)</span> </span>&#123;    ArrayDeque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s) &#123;        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'#'</span>) &#123;            <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;                stack.pop();            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            stack.push(c);        &#125;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        sb.append(stack.pop());    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] s = S.toCharArray();        <span class="hljs-keyword">char</span>[] t = T.toCharArray();        <span class="hljs-keyword">int</span> i = s.length - <span class="hljs-number">1</span>, j = t.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> skipS = <span class="hljs-number">0</span>, skipT = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 消除 s 中的 `#`</span>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">'#'</span>) &#123;                    skipS++;                    i--;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// s[i] 为字母</span>                    <span class="hljs-keyword">if</span> (skipS &gt; <span class="hljs-number">0</span>) &#123;                        skipS--;                        i--;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// 不需要跳过，比较此时的 s[i]</span>                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (t[j] == <span class="hljs-string">'#'</span>) &#123;                    skipT++;                    j--;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (skipT &gt; <span class="hljs-number">0</span>) &#123;                        skipT--;                        j--;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 比较 s[i] t[j]</span>            <span class="hljs-comment">// 只有一个遍历结束</span>            <span class="hljs-keyword">if</span> ((i &lt; <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) || (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; <span class="hljs-number">0</span>)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// s, t 都遍历结束</span>            <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">if</span> (s[i] != t[j]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            i--;            j--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1111. 有效括号的嵌套深度</title>
    <link href="/2020/10/18/LeetCode-1111-maximum-nesting-depth-of-two-valid-parentheses-strings/"/>
    <url>/2020/10/18/LeetCode-1111-maximum-nesting-depth-of-two-valid-parentheses-strings/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/" target="_blank" rel="noopener">1111. 有效括号的嵌套深度</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxDepthAfterSplit(String seq) &#123;    <span class="hljs-keyword">char</span>[] chars = seq.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 连续的 `((` 尽量不要分配在同一组</span>        <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">'('</span>) &#123;            <span class="hljs-comment">// 遇到 `(` 嵌套深度才增加</span>            depth++;            <span class="hljs-comment">// 按当前嵌套深度根据奇偶数分组</span>            res[i] = depth % <span class="hljs-number">2</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// `)` 与栈顶的 `(` 分配在同一组</span>            res[i] = depth % <span class="hljs-number">2</span>;            <span class="hljs-comment">// 减小嵌套深度</span>            depth--;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 19. 删除链表的倒数第N个节点</title>
    <link href="/2020/10/18/LeetCode-19-remove-nth-node-from-end-of-list/"/>
    <url>/2020/10/18/LeetCode-19-remove-nth-node-from-end-of-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>, head);    ListNode p = dummy, q = dummy;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (q.next != <span class="hljs-keyword">null</span>) &#123;        q = q.next;        <span class="hljs-keyword">if</span> (i == n) &#123;            p = p.next;        &#125; <span class="hljs-keyword">else</span> &#123;            i++;        &#125;    &#125;    <span class="hljs-keyword">if</span> (p.next != <span class="hljs-keyword">null</span>) &#123;        p.next = p.next.next;    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 946. 验证栈序列</title>
    <link href="/2020/10/17/LeetCode-946-validate-stack-sequences/"/>
    <url>/2020/10/17/LeetCode-946-validate-stack-sequences/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">946. 验证栈序列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pushed, <span class="hljs-keyword">int</span>[] popped)</span> </span>&#123;    ArrayDeque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : pushed) &#123;        stack.push(num);        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i]) &#123;            stack.pop();            i++;        &#125;    &#125;    <span class="hljs-keyword">return</span> stack.isEmpty();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 341. 扁平化嵌套列表迭代器</title>
    <link href="/2020/10/16/LeetCode-341-flatten-nested-list-iterator/"/>
    <url>/2020/10/16/LeetCode-341-flatten-nested-list-iterator/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/" target="_blank" rel="noopener">341. 扁平化嵌套列表迭代器</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NestedIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> ArrayDeque&lt;Integer&gt; deque;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NestedIterator</span><span class="hljs-params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;        deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        flatten(nestedList, deque);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> deque.pollFirst();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> !deque.isEmpty();    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(List&lt;NestedInteger&gt; nestedList, Deque&lt;Integer&gt; deque)</span> </span>&#123;        <span class="hljs-keyword">for</span> (NestedInteger ni : nestedList) &#123;            <span class="hljs-keyword">if</span> (ni.isInteger()) &#123;                deque.addLast(ni.getInteger());            &#125; <span class="hljs-keyword">else</span> &#123;                flatten(ni.getList(), deque);            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 316. 去除重复字母</title>
    <link href="/2020/10/16/LeetCode-316-remove-duplicate-letters/"/>
    <url>/2020/10/16/LeetCode-316-remove-duplicate-letters/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">316. 去除重复字母</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-comment">// 计算所有字符的出现次数</span>    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;        counts[c - <span class="hljs-string">'a'</span>]++;    &#125;    ArrayDeque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;        <span class="hljs-keyword">if</span> (!stack.contains(c)) &#123;            <span class="hljs-comment">// c &lt; 栈顶 &amp;&amp; 栈顶的剩余出现次数 &gt;= 1</span>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; c &lt; stack.peek() &amp;&amp; counts[stack.peek() - <span class="hljs-string">'a'</span>] &gt; <span class="hljs-number">0</span>) &#123;                stack.pop();            &#125;            stack.push(c);        &#125;        <span class="hljs-comment">// 更新剩余出现次数</span>        counts[c - <span class="hljs-string">'a'</span>]--;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        sb.append(stack.pollLast());    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 402. 移掉K位数字</title>
    <link href="/2020/10/16/LeetCode-402-remove-k-digits/"/>
    <url>/2020/10/16/LeetCode-402-remove-k-digits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeKdigits</span><span class="hljs-params">(String num, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    ArrayDeque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">char</span>[] nums = num.toCharArray();    <span class="hljs-keyword">int</span> dropCount = k;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> digit : nums) &#123;        <span class="hljs-comment">// 丢弃栈中比当前数字大的，可以使整个序列变小</span>        <span class="hljs-keyword">while</span> (dropCount &gt; <span class="hljs-number">0</span> &amp;&amp; !deque.isEmpty() &amp;&amp; deque.peekLast() &gt; digit) &#123;            deque.pollLast();            dropCount--;        &#125;        deque.addLast(digit);    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-comment">// 需要保留的数字个数</span>    <span class="hljs-keyword">int</span> len = nums.length - k;    <span class="hljs-keyword">int</span> zeroCount = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 去除起始的 0</span>    <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() == <span class="hljs-string">'0'</span>) &#123;        deque.pollFirst();        zeroCount++;    &#125;    <span class="hljs-comment">// 有效长度</span>    len -= zeroCount;    <span class="hljs-keyword">if</span> (deque.isEmpty() || len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"0"</span>;    &#125;    <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; len-- &gt; <span class="hljs-number">0</span>) &#123;        sb.append(deque.pollFirst());    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 284. 顶端迭代器</title>
    <link href="/2020/10/16/LeetCode-284-peeking-iterator/"/>
    <url>/2020/10/16/LeetCode-284-peeking-iterator/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/peeking-iterator/" target="_blank" rel="noopener">284. 顶端迭代器</a></p><h1 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeekingIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; queue;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PeekingIterator</span><span class="hljs-params">(Iterator&lt;Integer&gt; iterator)</span> </span>&#123;        <span class="hljs-comment">// initialize any member here.</span>        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-comment">// 把 iterator 中的所有元素放到队列中</span>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            queue.add(iterator.next());        &#125;    &#125;    <span class="hljs-comment">// Returns the next element in the iteration without advancing the iterator.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> queue.peek();    &#125;    <span class="hljs-comment">// hasNext() and next() should behave the same as in the Iterator interface.</span>    <span class="hljs-comment">// Override them if needed.</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> queue.poll();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> !queue.isEmpty();    &#125;&#125;</code></pre><h1 id="缓存-top"><a class="markdownIt-Anchor" href="#缓存-top"></a> 缓存 top</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeekingIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    Iterator&lt;Integer&gt; iter;    Integer top;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PeekingIterator</span><span class="hljs-params">(Iterator&lt;Integer&gt; iterator)</span> </span>&#123;        <span class="hljs-comment">// initialize any member here.</span>        iter = iterator;        <span class="hljs-comment">// top != null 表示已经调用过 peek()，top 就是 iterator 的顶部元素</span>        <span class="hljs-comment">// top == null 表示还没调用过 peek()，此时应该使 top = iterator 的顶部元素</span>        top = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">// Returns the next element in the iteration without advancing the iterator.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (top != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> top;        &#125;        <span class="hljs-comment">// top == null，表示调用过了 next()，使原来的 top 丢失了</span>        top = iter.next();        <span class="hljs-keyword">return</span> top;    &#125;    <span class="hljs-comment">// hasNext() and next() should behave the same as in the Iterator interface.</span>    <span class="hljs-comment">// Override them if needed.</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (top == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> iter.next();        &#125;        <span class="hljs-comment">// 原来的 top 已经在 peek() 的时候删除了</span>        <span class="hljs-comment">// 这时不能再调用 next()</span>        <span class="hljs-keyword">int</span> res = top;        <span class="hljs-comment">// 新的 top 此时还没更新，要由 peek() 赋值</span>        top = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> top != <span class="hljs-keyword">null</span> &amp;&amp; iter.hasNext();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 977. 有序数组的平方</title>
    <link href="/2020/10/16/LeetCode-977-squares-of-a-sorted-array/"/>
    <url>/2020/10/16/LeetCode-977-squares-of-a-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">977. 有序数组的平方</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortedSquares(<span class="hljs-keyword">int</span>[] A) &#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> i = right;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">int</span> l = A[left] * A[left];        <span class="hljs-keyword">int</span> r = A[right] * A[right];        <span class="hljs-keyword">if</span> (l &gt; r) &#123;            res[i] = l;            left++;        &#125; <span class="hljs-keyword">else</span> &#123;            res[i] = r;            right--;        &#125;        i--;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 116. 填充每个节点的下一个右侧节点指针</title>
    <link href="/2020/10/15/LeetCode-116-populating-next-right-pointers-in-each-node/"/>
    <url>/2020/10/15/LeetCode-116-populating-next-right-pointers-in-each-node/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">connect</span><span class="hljs-params">(Node root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    Node levelStart = root;    <span class="hljs-keyword">while</span> (levelStart.left != <span class="hljs-keyword">null</span>) &#123;        Node cur = levelStart;        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 子节点连接，只要 left 存在，right 一定存在</span>            cur.left.next = cur.right;            <span class="hljs-comment">// 向右连接</span>            <span class="hljs-keyword">if</span> (cur.next != <span class="hljs-keyword">null</span>) &#123;                cur.right.next = cur.next.left;            &#125;            <span class="hljs-comment">// 横向连接</span>            cur = cur.next;        &#125;        <span class="hljs-comment">// 进入下一层</span>        levelStart = levelStart.left;    &#125;    <span class="hljs-keyword">return</span> root;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 232. 用栈实现队列</title>
    <link href="/2020/10/15/LeetCode-232-implement-queue-using-stacks/"/>
    <url>/2020/10/15/LeetCode-232-implement-queue-using-stacks/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></p><p>一个栈用来入栈，一个栈用来出栈，<code>pop()</code> 或 <code>peek()</code> 时返回出栈的栈顶，若出栈为空，将入栈的所有元素压入出栈。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用于入栈</span><span class="hljs-comment">     */</span>    ArrayDeque&lt;Integer&gt; addStack;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用于出栈（出队）</span><span class="hljs-comment">     */</span>    ArrayDeque&lt;Integer&gt; popStack;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;        addStack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        popStack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Push element x to the back of queue.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        addStack.push(x);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Removes the element from in front of queue and returns that element.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 若 popStack 为空，则将 addStack 的所有元素压入 popStack</span>        <span class="hljs-keyword">if</span> (popStack.isEmpty()) &#123;            <span class="hljs-keyword">int</span> size = addStack.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">int</span> top = addStack.pop();                popStack.push(top);            &#125;        &#125;        <span class="hljs-comment">// 栈顶即为队头</span>        <span class="hljs-keyword">return</span> popStack.pop();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get the front element.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 若 popStack 为空，则将 addStack 的所有元素压入 popStack</span>        <span class="hljs-keyword">if</span> (popStack.isEmpty()) &#123;            <span class="hljs-keyword">int</span> size = addStack.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">int</span> top = addStack.pop();                popStack.push(top);            &#125;        &#125;        <span class="hljs-comment">// 栈顶即为队头</span>        <span class="hljs-keyword">return</span> popStack.peek();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns whether the queue is empty.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> addStack.isEmpty() &amp;&amp; popStack.isEmpty();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 225. 用队列实现栈</title>
    <link href="/2020/10/15/LeetCode-225-implement-stack-using-queues/"/>
    <url>/2020/10/15/LeetCode-225-implement-stack-using-queues/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></p><p><code>pop()</code> 和 <code>top()</code> 时将队头重新加入队尾</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> </span>&#123;    ArrayDeque&lt;Integer&gt; queue;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Push element x onto stack.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        queue.addLast(x);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Removes the element on top of the stack and returns that element.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// size - 1 个元素入队，队尾出栈</span>        <span class="hljs-keyword">int</span> size = queue.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> front = -<span class="hljs-number">1</span>;        <span class="hljs-comment">// 队头出队加入队尾，原来的队尾即为栈顶</span>        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            front = queue.pollFirst();            queue.addLast(front);        &#125;        <span class="hljs-comment">// 栈顶出栈</span>        <span class="hljs-keyword">return</span> queue.pollFirst();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get the top element.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 所有元素重新入队</span>        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-keyword">int</span> front = -<span class="hljs-number">1</span>;        <span class="hljs-comment">// 队头出队加入队尾，原来的队尾即为栈顶</span>        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            front = queue.pollFirst();            queue.addLast(front);        &#125;        <span class="hljs-keyword">return</span> front;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns whether the stack is empty.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> queue.isEmpty();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 155. 最小栈</title>
    <link href="/2020/10/15/LeetCode-155-min-stack/"/>
    <url>/2020/10/15/LeetCode-155-min-stack/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 存储实际的栈元素</span><span class="hljs-comment">     */</span>    ArrayDeque&lt;Integer&gt; dataStack;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 存储最小值</span><span class="hljs-comment">     */</span>    ArrayDeque&lt;Integer&gt; minStack;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        dataStack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        minStack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        dataStack.push(x);        <span class="hljs-comment">// 入栈元素 &lt;= min，则加入最小栈</span>        <span class="hljs-keyword">if</span> (!minStack.isEmpty()) &#123;            <span class="hljs-keyword">if</span> (x &lt;= getMin()) &#123;                minStack.push(x);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            minStack.push(x);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> top = dataStack.pop();        <span class="hljs-comment">// 出栈元素即为最小值，更新最小值</span>        <span class="hljs-keyword">if</span> (top == getMin()) &#123;            minStack.pop();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> dataStack.peek();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> minStack.peek();    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 71. 简化路径</title>
    <link href="/2020/10/15/LeetCode-71-simplify-path/"/>
    <url>/2020/10/15/LeetCode-71-simplify-path/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">simplifyPath</span><span class="hljs-params">(String path)</span> </span>&#123;    ArrayDeque&lt;String&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">int</span> len = path.length();    <span class="hljs-comment">// 多分配一个空间，处理不是以 '/' 结尾的情况</span>    <span class="hljs-keyword">char</span>[] str = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len + <span class="hljs-number">1</span>];    System.arraycopy(path.toCharArray(), <span class="hljs-number">0</span>, str, <span class="hljs-number">0</span>, len);    <span class="hljs-comment">// 尾部多分配 '/'</span>    str[len] = <span class="hljs-string">'/'</span>;    stack.push(<span class="hljs-string">""</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'/'</span>) &#123;            String folder = sb.toString();            sb.setLength(<span class="hljs-number">0</span>);            <span class="hljs-comment">// 0 或 1 个 '.' 还在当前目录</span>            <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(folder) || <span class="hljs-string">"."</span>.equals(folder)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 2 个点返回上一级目录</span>            <span class="hljs-keyword">if</span> (<span class="hljs-string">".."</span>.equals(folder)) &#123;                <span class="hljs-comment">// 当前目录不是根目录才可返回上一级</span>                <span class="hljs-keyword">if</span> (!<span class="hljs-string">""</span>.equals(stack.peek())) &#123;                    stack.pop();                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 进入下一级目录</span>                stack.push(folder);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            sb.append(str[i]);        &#125;    &#125;    List&lt;String&gt; folders = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        folders.add(stack.pop());    &#125;    <span class="hljs-comment">// 目录长度 == 1，此时只有根目录 = ''</span>    <span class="hljs-keyword">if</span> (folders.size() &gt; <span class="hljs-number">1</span>) &#123;        folders.remove(folders.size() - <span class="hljs-number">1</span>);    &#125;    Collections.reverse(folders);    sb.setLength(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (String folder : folders) &#123;        sb.append(<span class="hljs-string">"/"</span>);        sb.append(folder);    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP 基础</title>
    <link href="/2020/10/15/network-TCP-IP-basic/"/>
    <url>/2020/10/15/network-TCP-IP-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="网络基础知识"><a class="markdownIt-Anchor" href="#网络基础知识"></a> 网络基础知识</h1><h2 id="osi-参考模型"><a class="markdownIt-Anchor" href="#osi-参考模型"></a> OSI 参考模型</h2><ol><li>应用层：针对特定应用的协议，如电子邮件，远程登录，文件传输。</li><li>表示层：接收不同表现形式的信息，如文字，图像，声音。</li><li>会话层：通信管理，管理传输层以下的分层。</li><li>传输层：负责<strong>端到端的可靠性传输</strong>。</li><li>网络层：<strong>地址管理与路由选择</strong>。</li><li>数据链路层：互连设备之间传送数据帧。</li><li>物理层：比特流与电信号之间的转换。</li></ol><h2 id="传输方式"><a class="markdownIt-Anchor" href="#传输方式"></a> 传输方式</h2><h3 id="1-面向连接型与面向无连接型"><a class="markdownIt-Anchor" href="#1-面向连接型与面向无连接型"></a> 1. 面向连接型与面向无连接型</h3><ul><li>在面向有连接的方式下，必须在通信传输前后，专门进行建立和断开连接的处理。</li><li>在面向无连接的方式下，发送端可于任何时候自由发送数据。不需要确认对端是否存在，即使接收端不存在或无法接受数据，发送端也能将数据发送出去。</li></ul><h3 id="2-电路交换与分组交换"><a class="markdownIt-Anchor" href="#2-电路交换与分组交换"></a> 2. 电路交换与分组交换</h3><ul><li>电路交换中，两台计算机独占线路进行传输，其他计算机只能等线路空闲后才能使用这条电路进行通信。</li><li>分组交换中，把数据分成多个数据包，按照一定的顺序排列之后进行发送。每个分组的首部写入发送端和接收端的地址，所以即使同一条线路同时为多个用户提供服务，也可以明确每个分组数据的目的地。</li></ul><h3 id="3-根据接收端数量分类"><a class="markdownIt-Anchor" href="#3-根据接收端数量分类"></a> 3. 根据接收端数量分类</h3><ol><li>单播：一对一通信。</li><li>广播：将消息从一台主机发送给与之相连的<strong>所有其他主机</strong>。</li><li>多播：将消息从一台主机发送给<strong>某一组主机</strong>。</li><li>任播：在特定的多台主机中选出一台作为接收端进行通信。</li></ol><h2 id="各层网络设备"><a class="markdownIt-Anchor" href="#各层网络设备"></a> 各层网络设备</h2><ul><li>中继器（<code>Repeater</code>）：从物理层上延长网络。</li><li>网桥（<code>Bridge</code>）/ 2 层交换机：从数据链路层上延长网络。</li><li>路由器（<code>Router</code>）/ 3 层交换机：从网络层转发分组数据的设备。</li><li>4 ~ 7 层交换机：处理传输层以上各层网络传输的设备。</li><li>网关（<code>Gageway</code>）：转换协议的设备。</li></ul><h2 id="路由器和交换机的区别"><a class="markdownIt-Anchor" href="#路由器和交换机的区别"></a> 路由器和交换机的区别</h2><ul><li>交换机主要工作在<strong>数据链路层</strong>；<br />路由器工作在<strong>网络层</strong>。</li><li>交换机转发所依据的对象时：<code>MAC</code> 地址。（物理地址）；<br />路由转发所依据的对象是：<code>IP</code> 地址。（网络地址）。</li><li>交换机主要用于组建局域网；<br />路由器将局域网连接起来，或者接入互联网。</li><li>路由器实现了<strong>不同网络</strong>之间的数据<strong>转发</strong>；<br />交换机实现了<strong>特定网络</strong>内的数据<strong>交换</strong>。</li></ul><h1 id="tcpip-基础知识"><a class="markdownIt-Anchor" href="#tcpip-基础知识"></a> TCP/IP 基础知识</h1><h2 id="tcpip-具体含义"><a class="markdownIt-Anchor" href="#tcpip-具体含义"></a> TCP/IP 具体含义</h2><p>TCP/IP 是协议群的统称，有时也称为网际协议族。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201015144631.png" srcset="/img/loading.gif" alt="" /></p><h2 id="tcpip-与-osi-参考模型"><a class="markdownIt-Anchor" href="#tcpip-与-osi-参考模型"></a> TCP/IP 与 OSI 参考模型</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201015144926.png" srcset="/img/loading.gif" alt="" /></p><h2 id="数据包处理"><a class="markdownIt-Anchor" href="#数据包处理"></a> 数据包处理</h2><p>每一个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息。每个包首部中至少会包含两个信息：一个是发送端和接收端地址，另一个是上一层的协议类型。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201015145629.png" srcset="/img/loading.gif" alt="" /></p><h1 id="数据链路"><a class="markdownIt-Anchor" href="#数据链路"></a> 数据链路</h1><h2 id="mac-地址与-ip-地址"><a class="markdownIt-Anchor" href="#mac-地址与-ip-地址"></a> MAC 地址与 IP 地址</h2><ul><li><code>MAC</code> 地址（数据链路层）用于识别数据链路中互连的节点。</li><li><code>IP</code> 地址（网络层）用于在连接到网络中的所有主机中识别出进行通信的目标地址。</li></ul><p>MAC 地址格式：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201015151427.png" srcset="/img/loading.gif" alt="" /></p><p><strong>MAC 地址不一定是唯一的。</strong><br />即使 MAC 地址 相同，只要不是同属一个数据链路就没问题。如虚拟机分配的虚拟网卡，很难保证 MAC 地址的唯一性。</p><h2 id="共享介质型网络"><a class="markdownIt-Anchor" href="#共享介质型网络"></a> 共享介质型网络</h2><p>共享介质型网络指由多个设备共享一个通信介质的一种网络。</p><ul><li>设备之间使用<strong>同一个信道进行发送和接收。</strong></li><li>基本上采用<strong>半双工通信</strong>方式。</li><li>需要对介质进行<strong>访问控制</strong>。</li></ul><blockquote><p>半双工：共享介质，只发送或只接受的通信方式。<br />全双工：专用介质，可以同时发送数据和接收数据。</p></blockquote><p>介质访问控制方式：</p><ol><li>争用方式（<code>Contention</code>）：指的是争夺获取数据传输的方式。这种方法通常令网络中的各个站采用<strong>先到先得</strong>的方式占用信道发送数据。</li><li>令牌传递方式：只有获得令牌的站才能发送数据。特点是<strong>不会有冲突，每个站都有通过平等循环获得令牌的方式。</strong></li></ol><h2 id="非共享介质型网络"><a class="markdownIt-Anchor" href="#非共享介质型网络"></a> 非共享介质型网络</h2><p>非共享介质型网络是指不共享介质，是对介质采取<strong>专用</strong>的一种传输控制方式。每个站直连交换机，<strong>由交换机负责转发数据帧</strong>，采用<strong>全双工通信</strong>方式。</p><h1 id="ip-协议"><a class="markdownIt-Anchor" href="#ip-协议"></a> IP 协议</h1><h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h2><h3 id="网络层与数据链路层的关系"><a class="markdownIt-Anchor" href="#网络层与数据链路层的关系"></a> 网络层与数据链路层的关系</h3><ul><li><p>数据链路层提供两个设备之间的通信功能，在<strong>互连同一种数据链路的节点之间</strong>进行包传递。</p></li><li><p>网络层负责在<strong>没有直连的两个网络之间</strong>进行通信传输。网络层可以<strong>跨越不同的数据链路</strong>，在不同的数据链路上也能实现两端节点之间的数据包传输。</p></li></ul><h3 id="路由控制"><a class="markdownIt-Anchor" href="#路由控制"></a> 路由控制</h3><p>路由控制（<code>Routing</code>）是指将分组数据发送到最终目标地址的功能。</p><p>IP 路由也叫多跳路由，跳（<code>Hop</code>） 是指网络中的一个区间，在每一个区间内决定着 IP 包在下一跳被转发的路径。<br /><strong>多跳路由</strong> 是指路由器或主机在转发 IP 数据包时<strong>只指定下一个路由器或主机</strong>，而不是将到最终目标地址为止的所有通路全部指定出来。因为每一个区间（跳）在转发 IP 数据包时会分别指定下一跳的操作。</p><p>为了将数据包发给目标主机，所有主机都维护着一张路由控制表（<code>Routing Table</code>）。该表记录 IP 数据在下一步应该发给哪个路由器。IP 包将根据路由表在各个数据链路上传输。</p><h3 id="mtu"><a class="markdownIt-Anchor" href="#mtu"></a> MTU</h3><p>数据链路的地址可以被抽象为 IP 地址，对 IP 的上一层来说，不论底层数据链路使用以太网还是无线 LAN 亦或是 PPP，都将被一视同仁。</p><p>不同的数据链路的最大区别：它们各自的最大传输单位（<code>MTU</code>）不同。而我们需要传输比 MTU 更多字节的数据，就需要对 IP 数据包进行 <strong>分片处理（<code>IP Fragmentation</code>）</strong>，将较大的 IP 包分成多个较小的 IP 包。分片的包到了对端目标地址后会再被组合起来传给上一层。</p><h3 id="ip-属于面向无连接型"><a class="markdownIt-Anchor" href="#ip-属于面向无连接型"></a> IP 属于面向无连接型</h3><p>IP 在发包之前，不需要建立与对端目标地址之间的连接。上层如果遇到需要发给 IP 的数据，该数据会立即被压缩成 IP 包发送出去。</p><p>原因：</p><ol><li>简化：面向连接处理相对复杂，需要管理每个连接。</li><li>提速：每次通信之前都要先建立连接，会降低处理速度。</li></ol><blockquote><p>由于 IP 只负责将数据发给目标主机，为了保证通信的可靠性，上层的 TCP 采用面向连接型，负责保证对端主机确实收到数据。</p></blockquote><h2 id="ip-地址"><a class="markdownIt-Anchor" href="#ip-地址"></a> IP 地址</h2><h3 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h3><p>IP 地址（IPv4）由 <code>32</code> 位正整数表示，每 <code>8</code> 位一组，分成 4 组，每组以 <code>.</code> 隔开，再将每组数转换为十进制。</p><p>IP 地址由 <code>网络地址（网络号）</code> 和 <code>主机地址（主机号）</code> 组成，网络号在数据链路的每个段配置不同的值。网络号必须保证相互连接的每个段的地址不重复。而<strong>相同段内相连的主机必须有相同的网络地址。主机号则不允许在同一个网段内重复出现。</strong></p><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><p>根据 IP 地址中从第 <code>1</code> 位到第 <code>4</code> 位划分为 <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code> 类。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201016134533" srcset="/img/loading.gif" alt="" /></p><ul><li>A 类地址：第 1 字节为网络地址，其它 3 个字节为主机地址。它的第 1 个字节的<code>第一位</code>固定为 <code>0</code>。<ul><li>网络号范围：<code>0.0.0.0 ~ 127.0.0.0</code></li><li>私有地址：<code>10.0.0.0 ~ 10.255.255.255</code></li><li>保留地址：<code>127.x.x.x</code>，用于循环测试</li></ul></li><li>B 类地址：第 1 字节和第 2 字节为网络地址，后 2 个字节为主机地址。它的第 1 个字节的<code>前两位</code>固定为 <code>10</code>。<ul><li>网络号范围：<code>128.0.0.0 ~ 191.255.0.0</code></li><li>私有地址：<code>172.16.0.0 ~ 172.31.255.255</code></li><li>保留地址：<code>169.254.x.x</code>，如果是自动获取 IP 地址，而你在网络上又没有找到可用的 DHCP 服务器。就会得到其中一个 IP。</li><li>广播地址：<code>191.255.255.255</code>，不能分配。</li></ul></li><li>C 类地址：第 1 字节、第 2 字节和第 3 个字节为网络地址，第 4 个字节为主机地址。另外第 1 个字节的<code>前三位</code>固定为 <code>110</code>。<ul><li>网络号范围：<code>192.0.0.0 ~ 223.255.255.0</code></li><li>私有地址：<code>192.168.0.0 ~ 192.168.255.255</code></li></ul></li><li>D 类地址：没有主机地址，常用于多播，它的第 1 个字节的<code>前四位</code>固定为 <code>1110</code>。<ul><li>地址范围：<code>224.0.0.0 ~ 239.255.255.255</code></li></ul></li><li>E 类地址：不分网络地址和主机地址，它的第 1 个字节的<code>前四位</code>固定为 <code>1111</code>。<ul><li>地址范围：<code>240.0.0.0 ~ 255.255.255.254</code></li></ul></li></ul><h3 id="子网掩码"><a class="markdownIt-Anchor" href="#子网掩码"></a> 子网掩码</h3><blockquote><p>子网掩码的重要作用：就是将某个IP地址划分成网络地址和主机地址两部分。</p></blockquote><p>子网掩码实际上就是将原来 A/B/C 等分类中的<strong>主机地址部分用作子网地址</strong>，可以将原网络分为多个物理网络的一种机制。</p><p>表示方式：IP 地址网络号全部为 <code>1</code>，主机号全部为 <code>0</code>。<br />由此，一个 IP 地址不再受限自己的类别，而是可以使用子网掩码自由地定位自己的网络号部分。</p><p>如：<code>172.20.100.52/26</code> 表示前 <code>26</code> 位是网络号。<br />IP 地址：172. 20.  100. 52<br />子网掩码：255. 255. 255. 192</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019122155" srcset="/img/loading.gif" alt="" /></p><h2 id="路由控制-2"><a class="markdownIt-Anchor" href="#路由控制-2"></a> 路由控制</h2><p>IP 地址的网络部分用于进行路由控制。路由表中记录着<strong>网络地址</strong>与下一步应该发送至<strong>路由器的地址</strong>。如果路由表中存在多条相同网络地址的记录，就选择一个相同位数最多（<code>最长匹配</code>）的网络地址。</p><ul><li>默认路由：<code>0.0.0.0/0</code> 路由表中任何一个地址都能与之匹配。</li><li>主机路由：<code>IP 地址/32</code> 整个 IP 地址的所有位都将参与路由。</li><li>环回地址：<code>127.0.0.1、localhost</code> 同一台计算机上的程序之间进行网络通信。</li></ul><h2 id="相关协议"><a class="markdownIt-Anchor" href="#相关协议"></a> 相关协议</h2><h3 id="dns"><a class="markdownIt-Anchor" href="#dns"></a> DNS</h3><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019132145.png" srcset="/img/loading.gif" alt="" /></p><h3 id="arp-rarp"><a class="markdownIt-Anchor" href="#arp-rarp"></a> ARP、RARP</h3><p>ARP 将 IP 地址定位到对应的 MAC 地址。只适用于 IPv4。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019133552.png" srcset="/img/loading.gif" alt="" /></p><p>主机 A 为了获取主机 B 的 MAC 地址，要通过<strong>广播</strong>发送一个 ARP 请求包，这个包中包含了 主机 B 的 IP 地址。由于广播的包可以被同一个链路上所有的主机或路由器接收，<strong>如果请求包中的 IP 地址与自己的 IP 地址一致，那么这个节点就将自己的 MAC 地址放入 ARP 响应包返回给 主机 A。</strong></p><p>RARP 是从 MAC 地址定位 IP 地址的一种协议。例如将打印机等嵌入式设备接入到网络时就会用到。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019134340.png" srcset="/img/loading.gif" alt="" /></p><h3 id="icmp"><a class="markdownIt-Anchor" href="#icmp"></a> ICMP</h3><p>ICMP 的主要功能包括：确认 IP 包是否成功送达目标地址，通知在发送过程中 IP 包被废弃原因，改善网络设置，进行网络诊断。</p><p>ICMP 的消息大致可以分成两类：一类是通知出错原因的错误消息，另一类是用于诊断的查询信息。</p><h3 id="dhcp"><a class="markdownIt-Anchor" href="#dhcp"></a> DHCP</h3><p>DHCP 可实现自动设置 IP 地址，统一管理 IP 地址分配，让即插即用变得可能。在 IPv4，IPv6 中均可使用。</p><h3 id="nat"><a class="markdownIt-Anchor" href="#nat"></a> NAT</h3><p>NAT 用于在本地网络中使用私有地址，在连接互联网时使用全局 IP 地址。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019152539.png" srcset="/img/loading.gif" alt="" /></p><p>NAPT 将端口号一起转换。</p><blockquote><p>在使用 TCP 或 UDP 的通信当中，只有目标地址、源地址、目标端口、源端口以及协议种类都一致时才被认为是同一个连接。</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019153122.png" srcset="/img/loading.gif" alt="" /></p><h3 id="ip-隧道"><a class="markdownIt-Anchor" href="#ip-隧道"></a> IP 隧道</h3><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019153834.png" srcset="/img/loading.gif" alt="" /></p><p>IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。</p><h1 id="tcp-与-udp"><a class="markdownIt-Anchor" href="#tcp-与-udp"></a> TCP 与 UDP</h1><h2 id="传输层作用"><a class="markdownIt-Anchor" href="#传输层作用"></a> 传输层作用</h2><p>TCP 是<strong>面向连接的、可靠</strong>的流协议，为实现可靠传输，实行顺序控制或重发控制机制，还具备流量控制、拥塞空着、提高网络利用率等功能。</p><p>UDP 是<strong>面向无连接、不具有可靠性</strong>的数据报协议，主要用于那些对高速传输和实时性有较高要求的通信或广播通信。它不会进行重发处理。</p><h2 id="端口号"><a class="markdownIt-Anchor" href="#端口号"></a> 端口号</h2><p>端口号用来识别同一台计算机中进行通信的不同应用程序，它也被称为程序地址。传输层协议正是利用这些端口号识别本机中正在通信的应用程序，并准确地将数据传输。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020140053.png" srcset="/img/loading.gif" alt="" /></p><p>常见端口号：</p><table><thead><tr><th style="text-align:center">端口号</th><th style="text-align:center">服务名</th></tr></thead><tbody><tr><td style="text-align:center">20</td><td style="text-align:center">ftp-data</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">ftp</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">ssh</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">telnet</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">smtp</td></tr><tr><td style="text-align:center">80</td><td style="text-align:center">http</td></tr><tr><td style="text-align:center">443</td><td style="text-align:center">https</td></tr></tbody></table><h2 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h2><h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3><p>由于 UDP 面向无连接，它可以随时发送数据，加上 UDP 本身的处理既简单又高效，常用于以下几个方面：</p><ul><li>包总量较少的通信（DNS、SNMP 等）</li><li>视频、音频等多媒体通信</li><li>限定于 LAN 等特定网络中的应用通信</li><li>广播通信（广播、多播）</li></ul><h3 id="首部"><a class="markdownIt-Anchor" href="#首部"></a> 首部</h3><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020140728.png" srcset="/img/loading.gif" alt="" /></p><p>UDP 首部由源端口号，目标端口号，包长度和校验和组成。</p><ul><li>源端口号（<code>Source Port</code>）：发送端端口号，字段长 <code>16</code> 位，该字段是可选项，没有源端口号时设置为 <code>0</code>，可用于不需要返回的通信中。</li><li>目标端口号（<code>Destination Port</code>）：接收端端口号，字段长 <code>16</code> 位。</li><li>包长度（<code>Length</code>）：UDP 首部的长度和数据的长度之和。单位：字节。</li><li>校验和（<code>Checksum</code>）：校验和是为了提供可靠的 UDP 首部和数据而设计。</li></ul><h2 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> TCP</h2><p>TCP 通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p><h3 id="确认应答"><a class="markdownIt-Anchor" href="#确认应答"></a> 确认应答</h3><p>TCP 通过确认应答（<code>ACK</code>）实现可靠的数据传输。<br />当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端，反之，数据丢失的可能性很大。</p><p>确认丢失：当主机 A 在设定的超时重传时间内没有收到确认，但无法知道是自己发送的分组出错、丢失，或是主机 B 发送的确认丢失了。这时 A 会重传数据，假设 B 收到了重复数据，则它会丢弃这个重复数据，向 A 发送确认。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020142913.png" srcset="/img/loading.gif" alt="" /></p><p>确认迟到：传输过程中没有出现差错，但 B 对分组的确认迟到了，此时 A 会重传分组，B 收下重复分组后就丢弃，并向 A 发送确认。A 对于迟到的确认收下后就丢弃。</p><h3 id="超时重传"><a class="markdownIt-Anchor" href="#超时重传"></a> 超时重传</h3><p>超时重传时间是指在重发数据之前，等待确认应答到来的那个特定时间间隔。</p><p>超时时间随着数据包途径的网络环境的不同而有所变化，在同一个时段中，根据不同时段网络拥堵程度，时间长短也会发生变化。</p><p>在 UNIX 以及 Windows 中，超时都以 <code>0.5s</code> 为单位进行控制。数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以 <code>2</code> 倍、<code>4</code> 倍的指数函数延长。</p><p>数据不会被无限、反复地重发。达到一定重发次数后，如果仍没有任何确认应答返回，就会判断对方主机发生了异常，强制关闭连接，并且通知应用通信异常强行终止。</p><h3 id="mss"><a class="markdownIt-Anchor" href="#mss"></a> MSS</h3><p>TCP 以段为单位发送数据，以最大消息长度（<code>MSS：Maximum Segment Size</code>）的大小将数据进行分割发送。</p><p><strong><code>MSS</code> 是在三次握手时，在两端主机之间被计算得出。</strong> 两端主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己能够适应的 MSS 大小，然后会使用两者之间的较小值。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020144627.png" srcset="/img/loading.gif" alt="" /></p><h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h3><p>TCP 以 1 个段为单位，每发一个段进行一次确认应答的处理，但是如果包的往返时间越长，网络的吞吐量会越差，通信性能就越低。</p><p>所以 TCP 引入了滑动窗口，<strong>确认应答是以窗口大小进行确认的</strong>。发送端主机在发送了一个段之后不必要一直等待确认应答，而是继续发送。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020145712.png" srcset="/img/loading.gif" alt="" /></p><p>窗口内的数据即使没有收到确认也可以发送出去，在收到确认应答之前，必须在缓冲区中保留这部分数据。</p><p>在滑动窗口以外的部分包括已经确认收到应答的数据和尚未发送的数据，收到确认的数据此时可以从缓冲区清除。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020145753.png" srcset="/img/loading.gif" alt="" /></p><h4 id="确认丢失"><a class="markdownIt-Anchor" href="#确认丢失"></a> 确认丢失</h4><p>在没有使用滑动窗口时，没有收到确认应答的数据都会被重发。<br />而使用了滑动窗口时，窗口在一定程度上较大时，某些确认应答即便丢失也无需重发，可以通过<strong>下一个</strong>确认应答进行确认。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020150635.png" srcset="/img/loading.gif" alt="" /></p><h4 id="报文丢失"><a class="markdownIt-Anchor" href="#报文丢失"></a> 报文丢失</h4><p><code>高速重发控制</code>：在报文丢失的情况下，同一个序号的确认应答会被重复不断地返回。而发送端主机如果连续 <code>3</code> 次收到同一个确认应答，就会将其所对应的数据重发。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020150452.png" srcset="/img/loading.gif" alt="" /></p><h3 id="流量控制"><a class="markdownIt-Anchor" href="#流量控制"></a> 流量控制</h3><p>流量控制：TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。<br />滑动窗口大小：接收端主机向发送端主机通知自己可以接收数据的大小（首部字段中的<code>窗口大小</code>），于是发送端会发送不超过这个限度的数据。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020151743.png" srcset="/img/loading.gif" alt="" /></p><h3 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制"></a> 拥塞控制</h3><h4 id="慢开始和拥塞避免"><a class="markdownIt-Anchor" href="#慢开始和拥塞避免"></a> 慢开始和拥塞避免</h4><p>在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。<br />为了防止该问题的出现，在通信一开始时会通过<code>慢开始</code>算法对发送数据量进行控制。</p><p>在慢开始时，将<code>拥塞窗口</code>大小设置为 <code>1 MSS</code>，之后每收到一次确认应答，拥塞窗口的值就加 <code>1</code>。即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口。</p><blockquote><p>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化，<strong>发送方让自己的发送窗口等于拥塞窗口。</strong> 考虑到接收方的接收能力，那么发送窗口还可能小于拥塞窗口。</p></blockquote><p><strong>每经过一个传输轮次，拥塞窗口就加倍</strong>，以 1，2，4指数增长。为了防止拥塞窗口增长过大，还需要设置<code>慢开始阈值</code>：</p><ul><li>当 <code>cwnd &lt; ssthresh</code> 时，使用<strong>慢开始</strong>算法；</li><li>当 <code>cwnd &gt; ssthresh</code> 时，使用<strong>拥塞避免</strong>算法；</li><li>当 <code>cwnd = ssthresh</code> 时，可使用<strong>拥塞避免</strong>算法，也可使用<strong>慢开始</strong>算法。</li></ul><p><code>拥塞避免</code>的思路是让拥塞窗口缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口<code>加 1</code>，而不是加倍。这样，<strong>拥塞窗口按线性规律缓慢增长</strong>，比慢开始算法的增长速率慢得多。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020154633.png" srcset="/img/loading.gif" alt="" /></p><p>实际上，使用最广泛的是 <code>AIMD（加法增大乘法减小）</code>算法。</p><ul><li>加法增大：执行拥塞避免算法，使拥塞窗口缓慢增大。</li><li>乘法减小：不论是在慢开始还是在拥塞避免阶段，只要出现超时，就<strong>把窗口阈值 ssthresh 设置为当前的拥塞窗口的一半，与此同时，执行慢开始算法。</strong></li></ul><h4 id="快重传和快恢复"><a class="markdownIt-Anchor" href="#快重传和快恢复"></a> 快重传和快恢复</h4><p>快重传：发送方只要<strong>连续收到三个重复确认</strong>就应当立即重传对方尚未收到的报文，而不必继续等待为丢失报文设置的重传计时器到期（<strong>尽早重传未被确认的报文段</strong>）。</p><p>快恢复：</p><ul><li>当收到三个重复确认时，执行<strong>乘法减小</strong>算法，把慢开始门限 ssthresh 减半。</li><li>现在<strong>不执行慢开始</strong>算法（不把拥塞窗口设置为 1），而是<strong>把拥塞窗口设置为 ssthresh 减半后的数值，然后执行拥塞避免算法。</strong></li></ul><h3 id="tcp-首部"><a class="markdownIt-Anchor" href="#tcp-首部"></a> TCP 首部</h3><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020155556.png" srcset="/img/loading.gif" alt="" /></p><ul><li>源端口号（<code>Source Port</code>）：字段长 <code>16</code> 位。</li><li>目标端口号（<code>Destination Port</code>）：字段长 <code>16</code> 位。</li><li>序列号（<code>Sequence Number</code>）：字段长 <code>32</code> 位，指的是发送数据的位置，每发送一次数据，就累加一次该数据字节数的大小。</li><li>确认应答号（<code>Acknowledgement Number</code>）：字段长 <code>32</code> 位，指的是下一个应该收到的数据的序列号。实际上，它是指已收到 <code>确认应答号 - 1</code> 为止的数据。发送端收到这个确认应答号后可以认为在这个序号以前的数据都已经被正常接收。</li><li>数据偏移（<code>Data Offset</code>）：字段长 <code>4</code> 位。表示所传输的数据部分应该从 TCP 包的哪个位开始计算。可以看作是 <strong>TCP 首部的长度</strong>。</li><li>保留（<code>Reserved</code>）：字段长 <code>4</code> 位。一般设置为 <code>0</code>，主要是为了以后扩展时使用。</li><li>控制位（<code>Control Flag</code>）：字段长 <code>8</code> 位。从左至右分别为 <code>CWR</code>、<code>ECE</code>、<code>URG</code>、<code>ACK</code>、<code>PSH</code>、<code>RST</code>、<code>SYN</code>、<code>FIN</code>。</li><li>窗口大小（<code>Window Size</code>）：字段长 <code>16</code> 位。用于通知从确认应答号所指位置开始能接收的数据大小。TCP 不允许发送超过此处所示大小的数据。如果窗口为 <code>0</code>，表示可以发送窗口探测，以了解最新的窗口大小。</li><li>校验和（<code>Checksum</code>）：字段长 <code>16</code> 位。TCP 的校验和和 UDP 相似，区别在于 TCP 的校验和无法关闭。</li><li>紧急指针（<code>Urgent Pointer</code>）：字段长 <code>16</code> 位。一般在暂时中断通信时使用。从数据部分的首位到紧急指针所指示的位置为止为紧急数据。</li><li>选项（<code>Options</code>）：用于提高 TCP 的传输性能。</li></ul><h1 id="路由协议"><a class="markdownIt-Anchor" href="#路由协议"></a> 路由协议</h1><h2 id="静态路由与动态路由"><a class="markdownIt-Anchor" href="#静态路由与动态路由"></a> 静态路由与动态路由</h2><ul><li>静态路由是指事先设置好路由器和主机中并将路由信息固定的一种方法。<ul><li>静态路由通常由使用者手工操作完成。</li><li>一旦某个路由器发生故障，基本上无法自动绕过发生故障的节点。</li></ul></li><li>动态路由是指让路由协议在运行过程中自动地设置路由控制信息的一种方法。<ul><li>动态路由设定过程的复杂程度与具体要设置路由协议的类型有直接关系。</li><li>动态路由会给相邻路由器发送自己已知的网络连接信息，直至网络传递完成，路由控制表也制作完成。</li><li>一旦发生故障，只要有一个可绕的路径，数据包就会自动选择这个路径。</li></ul></li></ul><h2 id="路由算法"><a class="markdownIt-Anchor" href="#路由算法"></a> 路由算法</h2><h3 id="距离矢量算法"><a class="markdownIt-Anchor" href="#距离矢量算法"></a> 距离矢量算法</h3><p>距离矢量算法（<code>Distance-Vector</code>）算法是根据<strong>距离</strong>和<strong>方向</strong>决定目标网络或目标主机位置的一种方法。</p><p>路由器之间可以互换目标网络的方向及其距离的相关信息，并以这些信息为基础制作路由控制表。因此，<strong>每一个路由器的位置不同，它们的路由表也是不同的。</strong></p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201021142516.png" srcset="/img/loading.gif" alt="" /></p><h3 id="链路状态算法"><a class="markdownIt-Anchor" href="#链路状态算法"></a> 链路状态算法</h3><p>链路状态算法是路由器在了解<strong>网络整体状态</strong>的基础上生成路由控制表的一种方法。</p><p>在该方法中，<strong>每个路由器必须保持同样的信息</strong>才能进行正确的路由选择，这意味着可以使路由信息达到一个稳定的状态。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201021142452.png" srcset="/img/loading.gif" alt="" /></p><h3 id="主要路由协议"><a class="markdownIt-Anchor" href="#主要路由协议"></a> 主要路由协议</h3><table><thead><tr><th style="text-align:center">路由协议</th><th style="text-align:center">下一层协议</th><th style="text-align:center">方式</th><th style="text-align:center">适用范围</th><th style="text-align:center">循环检测</th></tr></thead><tbody><tr><td style="text-align:center">RIP</td><td style="text-align:center">UDP</td><td style="text-align:center">距离矢量</td><td style="text-align:center">自治系统内</td><td style="text-align:center">不可以</td></tr><tr><td style="text-align:center">OSPF</td><td style="text-align:center">UDP</td><td style="text-align:center">链路状态</td><td style="text-align:center">自治系统内</td><td style="text-align:center">可以</td></tr><tr><td style="text-align:center">EGP</td><td style="text-align:center">IP</td><td style="text-align:center">距离矢量</td><td style="text-align:center">对外连接</td><td style="text-align:center">不可以</td></tr><tr><td style="text-align:center">BGP</td><td style="text-align:center">IP</td><td style="text-align:center">路径矢量</td><td style="text-align:center">对外连接</td><td style="text-align:center">可以</td></tr></tbody></table><h2 id="rip"><a class="markdownIt-Anchor" href="#rip"></a> RIP</h2><p>特点：</p><ul><li>仅和<strong>相邻路由器</strong>交换信息。</li><li>交换的信息是当前本路由器所知道的全部信息，即自己的<strong>路由表</strong>。</li><li>按固定的时间间隔（<code>30s</code>）交换路由信息。</li></ul><p>路由表中的主要信息就是：到某个网络的距离（最短距离），以及经过的下一跳地址。路由表更新的原则就是<strong>找出到每个目的网络的最短距离</strong>。</p><p>RIP 存在的问题：由于采用距离矢量算法，当网络出现故障时，要经过较长时间才能将此信息传送到所有路由器。</p><h2 id="ospf"><a class="markdownIt-Anchor" href="#ospf"></a> OSPF</h2><p>OPPF 为链路状态型协议，所以能检测网络中的<strong>环路</strong>。</p><p>特点：</p><ul><li>向本自治系统中<strong>所有路由器</strong>发送信息，使用洪泛法（<code>flooding</code>）。</li><li>发送的信息是与本路由器相邻的所有路由器的<strong>链路状态</strong>。链路状态就是说明本路由器和哪些路由器相邻，以及该链路的<code>代价</code>，<strong>OSPF 总是选择一个总代价最小的一条路径</strong>，而 RIP 选择路由器个数最少的路径。</li><li>只有当<strong>链路状态变</strong>化时，路由器才发送信息。</li></ul><p>当网络的个数越多，每次交换的路由信息就越大，当链路状态变化较小时，这在一定程度上浪费了网络带宽。为了使 <strong>OSPF 能够用于规模很大的网络</strong>，OSPF 将一个自治系统再划分为若干个更小的<strong>区域</strong>，所有的其他区域都和<code>主干区域（Backbone Area）</code>相连接，每一个区域内部交换路由信息的通信量大大减小。</p><h2 id="bgp"><a class="markdownIt-Anchor" href="#bgp"></a> BGP</h2><p><code>BGP(Border Gateway Protocol)</code> 是连接不同自治系统的一种协议，它属于外部网关协议（<code>EGP</code>）。</p><p>在 <code>RIP</code> 和 <code>OSPF</code> 中利用 <code>IP</code> 地址的网络地址部分进行路由控制，然而 <code>BGP</code> 需要放眼整个互联网进行路由控制。<code>BGP</code> 的最终路由控制表由<strong>网络地址</strong>和<strong>下一站的路由器组</strong>来表示，它会根据所要经过的 <code>AS</code> 个数进行路由控制。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201021153257.png" srcset="/img/loading.gif" alt="" /></p><p>每个 <code>AS</code> 都有一个 <code>16 bit</code> 的 <code>AS 编号</code>，<code>BGP</code> 就是根据 <code>AS 编号</code>进行路由控制。<br />代表整个 AS 与其它 AS 交换路由控制信息的路由器叫做 BGP 发言人，一个 BGP 发言人与其它 AS 的 BGP 发言人要交换路由信息，就要先建立 TCP 连接。</p><p>BGP 中数据包送达目标网络时，会生成一个中途经过所有 AS 的编号列表（AS 路径信息访问列表<code>AS Path List</code>）。在做路由选择时，BGP 选择 AS 数最少的路径。</p><blockquote><p>路径向量（<code>Path Vector</code>）协议：可以检测环路，在 AS 路径信息访问列表中包含转发方向、距离和途径所有 AS 的编号。</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201021154457.png" srcset="/img/loading.gif" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 410. 分割数组的最大值</title>
    <link href="/2020/10/14/LeetCode-410-split-array-largest-sum/"/>
    <url>/2020/10/14/LeetCode-410-split-array-largest-sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> m)</span> </span>&#123;    <span class="hljs-comment">/* 子数组的最大值 maxOfSub in [max(nums), sum(nums)]</span><span class="hljs-comment">         当分成 nums.length 个子数组时，maxOfSub 最小 = max(nums)</span><span class="hljs-comment">         当分成 1 个子数组时，maxOfSub 最大 = sum(nums)</span><span class="hljs-comment">       分割方案越多，则 maxOfSub 越小，反之越大</span><span class="hljs-comment">       若 maxOfSub 对应的分割方案 &gt; m，说明 此时方案数应减少，maxOfSub 太小，则应增大 maxOfSub</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> left = nums[<span class="hljs-number">0</span>], right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        left = Math.max(left, num);        right += num;    &#125;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-comment">// 尝试以 mid 为子数组的最大和划分数组</span>        <span class="hljs-keyword">int</span> numOfSplit = splitBySubArraySum(mid, nums);        <span class="hljs-keyword">if</span> (numOfSplit &gt; m) &#123;            <span class="hljs-comment">// 子数组个数太多，则减少个数，增大子树数组和</span>            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据子数组的和获取划分的子数组个数</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> maxSum 子数组的最大和</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">splitBySubArraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSum, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-comment">// 至少可以划分成一个数组</span>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 当前子数组的和</span>    <span class="hljs-keyword">int</span> curSum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-comment">// 若当前数 + 子数组的和 &gt; 最大和，则划分一个新的子数组</span>        <span class="hljs-keyword">if</span> (curSum + num &gt; maxSum) &#123;            count++;            <span class="hljs-comment">// 重新开始划分子数组</span>            curSum = <span class="hljs-number">0</span>;        &#125;        curSum += num;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 875. 爱吃香蕉的珂珂</title>
    <link href="/2020/10/14/LeetCode-875-koko-eating-bananas/"/>
    <url>/2020/10/14/LeetCode-875-koko-eating-bananas/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a><br />可真能吃，不仅吃得多，还吃得久，还吃超时了。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles, <span class="hljs-keyword">int</span> H)</span> </span>&#123;    <span class="hljs-keyword">int</span> maxSpeed = piles[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : piles) &#123;        maxSpeed = Math.max(maxSpeed, num);    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = maxSpeed;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-comment">// 计算 speed = mid 时的耗时</span>        <span class="hljs-keyword">int</span> eatTime = eatInSpeed(mid, piles);        <span class="hljs-comment">// System.out.println("left=" + left + " mid = " + mid + " right=" + right + " time=" + eatTime);</span>        <span class="hljs-keyword">if</span> (eatTime &gt; H) &#123;            <span class="hljs-comment">// 吃太久了，加快速度 [mid + 1, right]</span>            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eatInSpeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> speed, <span class="hljs-keyword">int</span>[] piles)</span> </span>&#123;    <span class="hljs-comment">// 耗时</span>    <span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pile : piles) &#123;        <span class="hljs-comment">// 向上取整</span>        time += (pile + speed - <span class="hljs-number">1</span>) / speed;    &#125;    <span class="hljs-keyword">return</span> time;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1292. 元素和小于等于阈值的正方形的最大边长</title>
    <link href="/2020/10/13/LeetCode-1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/"/>
    <url>/2020/10/13/LeetCode-1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/" target="_blank" rel="noopener">1292. 元素和小于等于阈值的正方形的最大边长</a></p><h1 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSideLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] mat, <span class="hljs-keyword">int</span> threshold)</span> </span>&#123;    <span class="hljs-keyword">int</span> m = mat.length, n = mat[<span class="hljs-number">0</span>].length;    <span class="hljs-comment">// 计算前缀和</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;            dp[i][j] = mat[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>] - dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 最大的正方形边长</span>    <span class="hljs-keyword">int</span> maxSideLen = Math.min(m, n);    <span class="hljs-comment">// 遍历每个可能的边长所组成的正方形</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= maxSideLen; k++) &#123;        <span class="hljs-comment">// 以 dp[i][j]为右下角 计算正方形</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;                <span class="hljs-comment">// 无法组成正方形</span>                <span class="hljs-keyword">if</span> (k &gt; i || k &gt; j) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">int</span> rect = dp[i][j] - dp[i - k][j] - dp[i][j - k] + dp[i - k][j - k];                <span class="hljs-comment">// 更新最大边长</span>                <span class="hljs-keyword">if</span> (rect &lt;= threshold) &#123;                    res = Math.max(k, res);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="前缀和-二分"><a class="markdownIt-Anchor" href="#前缀和-二分"></a> 前缀和 + 二分</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSideLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] mat, <span class="hljs-keyword">int</span> threshold)</span> </span>&#123;    <span class="hljs-keyword">int</span> m = mat.length, n = mat[<span class="hljs-number">0</span>].length;    <span class="hljs-comment">// 计算前缀和</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;            dp[i][j] = mat[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>] - dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-comment">// 最大的正方形边长</span>    <span class="hljs-keyword">int</span> right = Math.min(m, n);    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">boolean</span> canIncrease = verifyRect(dp, threshold, mid, m, n);        <span class="hljs-keyword">if</span> (canIncrease) &#123;            <span class="hljs-comment">// mid 对应的正方形满足要求，可以增大</span>            left = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 判断以 len 为边长的正方形是否能满足 threshold</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dp</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> threshold</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> len</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> m</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> n</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyRect</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] dp, <span class="hljs-keyword">int</span> threshold, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">// 以 dp[i][j] 为右下角 计算正方形</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;            <span class="hljs-comment">// 无法组成正方形</span>            <span class="hljs-keyword">if</span> (len &gt; i || len &gt; j) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">int</span> sum = dp[i][j] - dp[i - len][j] - dp[i][j - len] + dp[i - len][j - len];            <span class="hljs-keyword">if</span> (sum &lt;= threshold) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1283. 使结果不超过阈值的最小除数</title>
    <link href="/2020/10/13/LeetCode-1283-find-the-smallest-divisor-given-a-threshold/"/>
    <url>/2020/10/13/LeetCode-1283-find-the-smallest-divisor-given-a-threshold/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/" target="_blank" rel="noopener">1283. 使结果不超过阈值的最小除数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">smallestDivisor</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> threshold)</span> </span>&#123;    <span class="hljs-keyword">int</span> right = Integer.MIN_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        right = Math.max(right, num);    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> sum = calcSum(nums, mid);        <span class="hljs-keyword">if</span> (sum &gt; threshold) &#123;            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calcSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> divider)</span> </span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-comment">// 向上取整技巧，快得很！</span>        sum += (num + divider - <span class="hljs-number">1</span>) / divider;    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 287. 寻找重复数</title>
    <link href="/2020/10/13/LeetCode-287-find-the-duplicate-number/"/>
    <url>/2020/10/13/LeetCode-287-find-the-duplicate-number/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></p><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// [2, 4, 5, 2, 3, 1, 6, 7]</span>    <span class="hljs-comment">// mid = 4, 若 [left, mid] 不存在重复元素</span>    <span class="hljs-comment">// 则 [left, mid] 中 &lt;= mid 的元素个数最多为 mid 个</span>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 计算 数组里小于等于 mid 的个数</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;            <span class="hljs-keyword">if</span> (num &lt;= mid) &#123;                count += <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-comment">// 若 count &gt; mid，则 [left, mid] 存在重复元素</span>        <span class="hljs-keyword">if</span> (count &gt; mid) &#123;            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><h1 id="快慢指针"><a class="markdownIt-Anchor" href="#快慢指针"></a> 快慢指针</h1><p>原地哈希和环形链表找入口的思路结合。<br /><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a><br /><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        fast = nums[nums[fast]];        slow = nums[slow];        <span class="hljs-comment">// fast = 2 * slow = slow + n * circle</span>        <span class="hljs-comment">// slow = n * circle</span>        <span class="hljs-keyword">if</span> (fast == slow) &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-comment">// 从起点同时走 a 步，在环的入口相遇</span>    <span class="hljs-comment">// n * circle + a &lt;=&gt; 0 + a</span>    fast = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (fast != slow) &#123;        fast = nums[fast];        slow = nums[slow];    &#125;    <span class="hljs-keyword">return</span> slow;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 协议</title>
    <link href="/2020/10/12/network-http/"/>
    <url>/2020/10/12/network-http/</url>
    
    <content type="html"><![CDATA[<h1 id="http-状态码"><a class="markdownIt-Anchor" href="#http-状态码"></a> HTTP 状态码</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201013133853.jpg" srcset="/img/loading.gif" alt="" /></p><h2 id="1xx"><a class="markdownIt-Anchor" href="#1xx"></a> 1xx</h2><p>1xx 类状态码属于<strong>提示信息</strong>，是协议处理中的一种<strong>中间状态</strong>，实际用到的比较少。</p><h2 id="2xx"><a class="markdownIt-Anchor" href="#2xx"></a> 2xx</h2><p>2xx 类状态码表示服务器<strong>成功处理</strong>了客户端的请求。</p><ul><li><p>「<code>200 OK</code>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 <code>body</code> 数据。</p></li><li><p>「<code>204 No Content</code>」也是常见的成功状态码，与 <code>200</code> 基本相同，但响应头没有 <code>body</code> 数据。</p></li><li><p>「<code>206 Partial Content</code>」是应用于<strong>分块下载或断点续传</strong>，表示响应返回的 <code>body</code> 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</p></li></ul><h2 id="3xx"><a class="markdownIt-Anchor" href="#3xx"></a> 3xx</h2><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 <code>URL</code> 重新发送请求获取资源，也就是重定向。</p><ul><li>「<code>301 Moved Permanently</code>」表示<strong>永久重定向</strong>，说明请求的资源已经不存在了，需改用新的 <code>URL</code> 再次访问。</li><li>「<code>302 Found</code>」表示<strong>临时重定向</strong>，说明请求的资源还在，但暂时需要用另一个 <code>URL</code> 来访问。<br /><code>301</code> 和 <code>302</code> 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 <code>URL</code>，浏览器会自动重定向新的 URL。</li><li>「<code>304 Not Modified</code>」不具有跳转的含义，表示<strong>资源未修改</strong>，重定向已存在的缓冲文件，也称<strong>缓存重定向</strong>，用于<strong>缓存控制</strong>。</li></ul><h2 id="4xx"><a class="markdownIt-Anchor" href="#4xx"></a> 4xx</h2><p>4xx 类状态码表示<strong>客户端发送的报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li><p>「<code>400 Bad Request</code>」表示客户端请求的报文有错误，但只是个<strong>笼统</strong>的错误。</p></li><li><p>「<code>401 Unauthorized</code>」表示客户端未授权，需登录后访问。</p></li><li><p>「<code>403 Forbidden</code>」表示服务器<strong>禁止访问</strong>资源，并不是客户端的请求出错。</p></li><li><p>「<code>404 Not Found</code>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p></li></ul><h2 id="5xx"><a class="markdownIt-Anchor" href="#5xx"></a> 5xx</h2><p>5xx 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li><p>「<code>500 Internal Server Error</code>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</p></li><li><p>「<code>501 Not Implemented</code>」表示客户端请求的<strong>功能还不支持</strong>。</p></li><li><p>「<code>502 Bad Gateway</code>」通常是服务器作为<strong>网关或代理</strong>时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p></li><li><p>「<code>503 Service Unavailable</code>」表示服务器当前很忙，暂时<strong>无法响应</strong>服务器。</p></li></ul><h1 id="http-首部"><a class="markdownIt-Anchor" href="#http-首部"></a> HTTP 首部</h1><h2 id="报文首部"><a class="markdownIt-Anchor" href="#报文首部"></a> 报文首部</h2><h3 id="1-请求报文"><a class="markdownIt-Anchor" href="#1-请求报文"></a> 1. 请求报文</h3><p>在请求中，<code>HTTP</code> 报文由 <code>方法</code>、<code>URI</code>、<code>HTTP 版本</code>、<code>HTTP 首部字段</code> 等部分构成。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201013140735.png" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs groovy">GET <span class="hljs-regexp">/ HTTP/</span><span class="hljs-number">1.1</span><span class="hljs-string">Host:</span> hackr.jpUser-<span class="hljs-string">Agent:</span> Mozilla<span class="hljs-regexp">/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/</span><span class="hljs-number">20100101</span> Firefox/<span class="hljs-number">13.0</span><span class="hljs-string">Accept:</span> text<span class="hljs-regexp">/html,application/</span>xhtml+xml,application<span class="hljs-regexp">/xml;q=0.9,*/</span>*; q=<span class="hljs-number">0.8</span>Accept-<span class="hljs-string">Language:</span> ja,en-us;q=<span class="hljs-number">0.7</span>,en;q=<span class="hljs-number">0.3</span>Accept-<span class="hljs-string">Encoding:</span> gzip, deflate <span class="hljs-string">DNT:</span> <span class="hljs-number">1</span><span class="hljs-string">Connection:</span> keep-aliveIf-Modified-<span class="hljs-string">Since:</span> Fri, <span class="hljs-number">31</span> Aug <span class="hljs-number">2007</span> <span class="hljs-number">02</span>:<span class="hljs-number">02</span>:<span class="hljs-number">20</span> GMTIf-None-<span class="hljs-string">Match:</span> <span class="hljs-string">"45bae1-16a-46d776ac"</span>Cache-<span class="hljs-string">Control:</span> max-age=<span class="hljs-number">0</span></code></pre><h3 id="2-响应报文"><a class="markdownIt-Anchor" href="#2-响应报文"></a> 2. 响应报文</h3><p>在响应中，<code>HTTP</code> 报文由 <code>状态码</code>、<code>HTTP 版本</code>、<code>HTTP 首部字段</code> 3 部分构成。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201013141307.png" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs yaml"><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">304</span> <span class="hljs-string">Not</span> <span class="hljs-string">Modified</span><span class="hljs-attr">Date:</span> <span class="hljs-string">Thu,</span> <span class="hljs-number">07</span> <span class="hljs-string">Jun</span> <span class="hljs-number">2012</span> <span class="hljs-number">07</span><span class="hljs-string">:21:36</span> <span class="hljs-string">GMT</span><span class="hljs-attr">Server:</span> <span class="hljs-string">Apache</span><span class="hljs-attr">Connection:</span> <span class="hljs-string">close</span><span class="hljs-attr">Etag:</span> <span class="hljs-string">"45bae1-16a-46d776ac"</span></code></pre><h2 id="首部字段"><a class="markdownIt-Anchor" href="#首部字段"></a> 首部字段</h2><p>HTTP 首部字段以键值对的形式构成，当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时，<strong>根据浏览器内部处理逻辑的不同，结果可能并不一致</strong>。有些浏览器会优先处理第一次出现的 首部字段，而有些则会优先处理最后出现的首部字段。</p><h3 id="首部字段类型"><a class="markdownIt-Anchor" href="#首部字段类型"></a> 首部字段类型</h3><ol><li>通用首部字段（<code>General Header Fields</code>）：请求报文和响应报文两方都会使用的首部。</li><li>请求首部字段（<code>Request Header Fields</code>）：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li><li>响应首部字段（<code>Response Header Fields</code>）：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加 内容，也会要求客户端附加额外的内容信息。</li><li>实体首部字段（<code>Entity Header Fields</code>）：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更 新时间等与实体有关的信息。</li></ol><h3 id="http11-首部字段"><a class="markdownIt-Anchor" href="#http11-首部字段"></a> HTTP/1.1 首部字段</h3><h4 id="1-通用首部字段"><a class="markdownIt-Anchor" href="#1-通用首部字段"></a> 1. 通用首部字段</h4><table><thead><tr><th style="text-align:left">首部字段名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Cache-Control</td><td style="text-align:left">控制缓存的行为</td></tr><tr><td style="text-align:left">Connection</td><td style="text-align:left">逐跳首部、连接的管理</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">创建报文的日期时间</td></tr><tr><td style="text-align:left">Pragma</td><td style="text-align:left">报文指令</td></tr><tr><td style="text-align:left">Trailer</td><td style="text-align:left">报文末端的首部一览</td></tr><tr><td style="text-align:left">Transfer-Encoding</td><td style="text-align:left">指定报文主体的传输编码方式</td></tr><tr><td style="text-align:left">Upgrade</td><td style="text-align:left">升级为其他协议</td></tr><tr><td style="text-align:left">Via</td><td style="text-align:left">代理服务器的相关信息</td></tr><tr><td style="text-align:left">Warning</td><td style="text-align:left">错误通知</td></tr></tbody></table><h4 id="2-请求首部字段"><a class="markdownIt-Anchor" href="#2-请求首部字段"></a> 2. 请求首部字段</h4><table><thead><tr><th style="text-align:left">首部字段名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Accept</td><td style="text-align:left">用户代理可处理的媒体类型</td></tr><tr><td style="text-align:left">Accept-Charset</td><td style="text-align:left">优先的字符集</td></tr><tr><td style="text-align:left">Accept-Encoding</td><td style="text-align:left">优先的内容编码</td></tr><tr><td style="text-align:left">Accept-Language</td><td style="text-align:left">优先的语言（自然语言）</td></tr><tr><td style="text-align:left">Authorization</td><td style="text-align:left">Web认证信息</td></tr><tr><td style="text-align:left">Expect</td><td style="text-align:left">期待服务器的特定行为</td></tr><tr><td style="text-align:left">From</td><td style="text-align:left">用户的电子邮箱地址</td></tr><tr><td style="text-align:left">Host</td><td style="text-align:left">请求资源所在服务器</td></tr><tr><td style="text-align:left">If-Match</td><td style="text-align:left">比较实体标记（ETag）</td></tr><tr><td style="text-align:left">If-Modified-Since</td><td style="text-align:left">比较资源的更新时间</td></tr><tr><td style="text-align:left">If-None-Match</td><td style="text-align:left">比较实体标记（与 If-Match 相反）</td></tr><tr><td style="text-align:left">If-Range</td><td style="text-align:left">资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td style="text-align:left">If-Unmodified-Since</td><td style="text-align:left">比较资源的更新时间（与If-Modified-Since相反）</td></tr><tr><td style="text-align:left">Max-Forwards</td><td style="text-align:left">最大传输逐跳数</td></tr><tr><td style="text-align:left">Proxy-Authorization</td><td style="text-align:left">代理服务器要求客户端的认证信息</td></tr><tr><td style="text-align:left">Range</td><td style="text-align:left">实体的字节范围请求</td></tr><tr><td style="text-align:left">Referer</td><td style="text-align:left">对请求中 URI 的原始获取方</td></tr><tr><td style="text-align:left">TE</td><td style="text-align:left">传输编码的优先级</td></tr><tr><td style="text-align:left">User-Agent</td><td style="text-align:left">HTTP 客户端程序的信息</td></tr></tbody></table><h4 id="3-响应首部字段"><a class="markdownIt-Anchor" href="#3-响应首部字段"></a> 3. 响应首部字段</h4><table><thead><tr><th style="text-align:left">首部字段名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Accept-Ranges</td><td style="text-align:left">是否接受字节范围请求</td></tr><tr><td style="text-align:left">Age</td><td style="text-align:left">推算资源创建经过时间</td></tr><tr><td style="text-align:left">ETag</td><td style="text-align:left">资源的匹配信息</td></tr><tr><td style="text-align:left">Location</td><td style="text-align:left">令客户端重定向至指定URI</td></tr><tr><td style="text-align:left">Proxy-Authenticate</td><td style="text-align:left">代理服务器对客户端的认证信息</td></tr><tr><td style="text-align:left">Retry-After</td><td style="text-align:left">对再次发起请求的时机要求</td></tr><tr><td style="text-align:left">Server</td><td style="text-align:left">HTTP服务器的安装信息</td></tr><tr><td style="text-align:left">Vary</td><td style="text-align:left">代理服务器缓存的管理信息</td></tr><tr><td style="text-align:left">WWW-Authenticate</td><td style="text-align:left">服务器对客户端的认证信息</td></tr></tbody></table><h4 id="4-实体首部字段"><a class="markdownIt-Anchor" href="#4-实体首部字段"></a> 4. 实体首部字段</h4><table><thead><tr><th style="text-align:left">首部字段名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Allow</td><td style="text-align:left">资源可支持的HTTP方法</td></tr><tr><td style="text-align:left">Content-Encoding</td><td style="text-align:left">实体主体适用的编码方式</td></tr><tr><td style="text-align:left">Content-Language</td><td style="text-align:left">实体主体的自然语言</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">实体主体的大小（单位：字节）</td></tr><tr><td style="text-align:left">Content-Location</td><td style="text-align:left">替代对应资源的URI</td></tr><tr><td style="text-align:left">Content-MD5</td><td style="text-align:left">实体主体的报文摘要</td></tr><tr><td style="text-align:left">Content-Range</td><td style="text-align:left">实体主体的位置范围</td></tr><tr><td style="text-align:left">Content-Type</td><td style="text-align:left">实体主体的媒体类型</td></tr><tr><td style="text-align:left">Expires</td><td style="text-align:left">实体主体过期的日期时间</td></tr><tr><td style="text-align:left">Last-Modified</td><td style="text-align:left">资源的最后修改日期时间</td></tr></tbody></table><h1 id="getpost"><a class="markdownIt-Anchor" href="#getpost"></a> GET/POST</h1><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">GET</th><th style="text-align:center">POST</th></tr></thead><tbody><tr><td style="text-align:center">功能</td><td style="text-align:center"><strong>获取/查询</strong> 资源信息</td><td style="text-align:center"><strong>更新</strong> 资源信息</td></tr><tr><td style="text-align:center">参数</td><td style="text-align:center">URL / <strong>Body</strong></td><td style="text-align:center">Body</td></tr><tr><td style="text-align:center">长度</td><td style="text-align:center">取决于 URL 长度，受浏览器和服务器限制</td><td style="text-align:center">大数据</td></tr><tr><td style="text-align:center">数据类型</td><td style="text-align:center">ASCII 字符</td><td style="text-align:center">无限制，允许二进制数据。</td></tr><tr><td style="text-align:center">缓存</td><td style="text-align:center">能被缓存，作为书签</td><td style="text-align:center">不能缓存</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">不安全，参数会明文暴露</td><td style="text-align:center">安全</td></tr><tr><td style="text-align:center">幂等性</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">TCP</td><td style="text-align:center">把请求报文一次性发出</td><td style="text-align:center">分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分</td></tr></tbody></table><h1 id="http-https"><a class="markdownIt-Anchor" href="#http-https"></a> HTTP / HTTPS</h1><h2 id="http-优缺点"><a class="markdownIt-Anchor" href="#http-优缺点"></a> HTTP 优缺点</h2><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><p>HTTP 最凸出的优点是「<strong>简单、灵活和易于扩展、应用广泛和跨平台</strong>」。</p><ol><li><p>简单<br />HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，易于理解，降低了学习和使用的门槛。</p></li><li><p>灵活和易于扩展<br />HTTP协议里的各类请求方法、<code>URI/URL</code>、状态码、头字段等每个组成都允许开发人员<strong>自定义和扩充</strong>。<br />同时 HTTP 由于是工作在应用层，则它下层可以随意变化。<br /><code>HTTPS</code> 也就是在 <code>HTTP</code> 与 <code>TCP</code> 层之间增加了 <code>SSL/TLS</code> 安全传输层，<code>HTTP/3</code> 甚至把 <code>TCP</code> 层换成了基于 <code>UDP</code> 的 <code>QUIC</code>。</p></li><li><p>应用广泛和跨平台</p></li></ol><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><ol><li><p>无状态<br /><code>HTTP</code> 是一个无状态协议，这意味着每个请求都是独立的，影响客户端与服务器的交互。<br />可通过在请求和响应报文中写入 <code>Cookie</code> 信息来控制客户端的状态。或者通过服务器设置 <code>Session</code> 将会话信息保存在服务器上。</p></li><li><p>明文传输<br />通信使用明文（不加密），内容可能会被窃听。可以用 <code>HTTPS</code> 的方式解决，也就是通过引入 <code>SSL/TLS</code> 层。</p></li></ol><h2 id="http-和-https-的区别"><a class="markdownIt-Anchor" href="#http-和-https-的区别"></a> HTTP 和 HTTPS 的区别</h2><ul><li><p>HTTP 使用 <code>80</code> 端口，HTTPS 使用 <code>443</code> 端口。</p></li><li><p>HTTPS 协议需要向 <code>CA（证书权威机构）</code>申请<strong>数字证书</strong>，来保证服务器的身份是可信的。</p></li><li><p>HTTP 是超文本传输协议，是<strong>明文传输</strong>；HTTPS 是经过 <strong><code>SSL</code> 加密</strong>的协议，传输更加安全。</p></li><li><p>HTTPS 比 HTTP 慢。</p><ul><li><strong>通信慢</strong>：HTTPS 和 HTTP 相比，除去 TCP 连接、发送 HTTP 请求-响应以外，还必须进行 SSL 通信。</li><li><strong>加密处理</strong>：加密和解密运算处理耗时。</li></ul></li></ul><h1 id="http1x-http2-http3"><a class="markdownIt-Anchor" href="#http1x-http2-http3"></a> HTTP/1.x, HTTP/2, HTTP/3</h1><h2 id="http1x-缺陷"><a class="markdownIt-Anchor" href="#http1x-缺陷"></a> HTTP/1.x 缺陷</h2><h3 id="1-连接无法复用"><a class="markdownIt-Anchor" href="#1-连接无法复用"></a> 1. 连接无法复用</h3><p>连接无法复用会导致<strong>每次请求都经历三次握手和慢启动</strong>。三次握手在高延迟的场景下影响较明显，慢启动则对大量小文件请求影响较大（没有达到最大窗口请求就被终止）。</p><ul><li><p><code>HTTP/1.0</code> 使用短连接，传输数据时，每次都需要重新建立连接，增加延迟。</p></li><li><p><code>HTTP/1.1</code> 使用长连接（<code>Connection: keep-alive</code>）可以复用一部分连接，但对于单个文件被不断请求的服务，<code>keep-alive</code> 可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</p></li></ul><h3 id="2-队头阻塞-head-of-line-blocking"><a class="markdownIt-Anchor" href="#2-队头阻塞-head-of-line-blocking"></a> 2. 队头阻塞 (<code>Head-Of-Line Blocking</code>)</h3><p>导致带宽无法被充分利用，以及后续请求被阻塞。<code>HOLB</code> 是指一系列包（<code>package</code>）因为第一个包被阻塞；当页面中需要请求很多资源的时候，会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p><ul><li><p><code>HTTP 1.0</code>：下个请求必须在前一个请求返回后才能发出，<code>request-response</code> 按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。</p></li><li><p><code>HTTP 1.1</code>：尝试使用 <code>管道网络传输（pipeling）</code> 来解决，即<strong>浏览器可以一次性发出多个请求</strong>（同个域名，同一条 <code>TCP</code> 链接）。但 <code>pipeling</code> 要求返回是按序的，那么前一个请求如果很耗时，那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，<code>pipeling</code> 只部分解决了 <code>HOLB</code>。</p></li></ul><h3 id="3-协议开销大"><a class="markdownIt-Anchor" href="#3-协议开销大"></a> 3. 协议开销大</h3><p><code>HTTP 1.x</code> 在使用时，<code>header</code> 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 <code>header</code> 基本不怎么变化，尤其在移动端增加用户流量。</p><h3 id="4-安全因素"><a class="markdownIt-Anchor" href="#4-安全因素"></a> 4. 安全因素</h3><p><code>HTTP 1.x</code> 在传输数据时，所有传输的内容都是<strong>明文</strong>，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</p><h2 id="http2-新特性"><a class="markdownIt-Anchor" href="#http2-新特性"></a> HTTP/2 新特性</h2><h3 id="1-二进制传输"><a class="markdownIt-Anchor" href="#1-二进制传输"></a> 1. 二进制传输</h3><p><code>HTTP/2</code> 采用二进制格式传输数据，而非 <code>HTTP 1.x</code> 的文本格式，二进制协议解析起来更高效。 <code>HTTP 1.x</code> 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。<strong><code>HTTP/2</code> 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</strong></p><h3 id="2-多路复用"><a class="markdownIt-Anchor" href="#2-多路复用"></a> 2. 多路复用</h3><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201013162824.png" srcset="/img/loading.gif" alt="" /></p><ul><li>同个域名只需要占用一个 <code>TCP</code> 连接，使用一个连接并行发送多个请求和响应,消除了因多个 <code>TCP</code> 连接而带来的延时和内存消耗。</li><li>并行交错地发送多个请求，请求之间互不影响。</li><li>并行交错地发送多个响应，响应之间互不干扰。</li></ul><h3 id="3-头部压缩"><a class="markdownIt-Anchor" href="#3-头部压缩"></a> 3. 头部压缩</h3><p>在 <code>HTTP/1</code> 中，我们使用文本的形式传输 <code>header</code>，在 <code>header</code> 携带 <code>cookie</code> 的情况下，可能每次都需要<strong>重复传输</strong>几百到几千的字节。</p><p>为了减少这块的资源消耗并提升性能， <code>HTTP/2</code> 对这些首部采取了压缩策略：</p><ul><li><code>HTTP/2</code> 在客户端和服务器端使用 <strong>首部表</strong> 来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</li><li>首部表在 <code>HTTP/2</code> 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li><li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201013163221.png" srcset="/img/loading.gif" alt="" /></p><h3 id="4-服务端推送"><a class="markdownIt-Anchor" href="#4-服务端推送"></a> 4. 服务端推送</h3><p>某些资源客户端是一定会请求的，这时就可以采取服务端推送的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。</p><p>例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。</p><p><strong>服务端可以主动推送</strong>，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。<strong>主动推送也遵守同源策略</strong>，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。</p><h2 id="http3-新特性"><a class="markdownIt-Anchor" href="#http3-新特性"></a> HTTP/3 新特性</h2><p><code>HTTP/2</code> 使用了多路复用，一般来说同一域名下只需要使用一个 <code>TCP</code> 连接。但当这个连接中出现了丢包的情况，那就会导致 <code>HTTP/2</code> 的表现情况反倒不如 <code>HTTP/1</code> 了。</p><p><strong>因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。</strong> 但是对于 <code>HTTP/1.1</code> 来说，可以开启多个 <code>TCP</code> 连接，出现这种情况反到只会影响其中一个连接，剩余的 <code>TCP</code> 连接还可以正常传输数据。<br />基于这个原因，Google 开发了一个基于 <code>UDP</code> 协议的 <code>QUIC</code> 协议，并且使用在了 <code>HTTP/3</code> 上。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201013164017.png" srcset="/img/loading.gif" alt="" /></p><h3 id="1-0-rtt"><a class="markdownIt-Anchor" href="#1-0-rtt"></a> 1. 0 RTT</h3><p><code>HTTP/1.x</code>，<code>HTTPS</code>，<code>HTTP2.0</code>，都使用了 <code>TCP</code> 进行传输。<code>HTTPS</code> 和 <code>HTTP2</code> 还需要使用 <code>TLS</code> 协议来进行安全传输。这就出现了两个握手延迟，而基于 <code>UDP</code> 协议的 <code>QUIC</code>，<strong>因为 UDP 本身没有连接的概念，连接建立时只需要一次交互，半个握手的时间。</strong></p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201013164452.png" srcset="/img/loading.gif" alt="" /></p><h3 id="2-多路复用-2"><a class="markdownIt-Anchor" href="#2-多路复用-2"></a> 2. 多路复用</h3><p>同 <code>HTTP2.0</code> 一样，同一条 <code>QUIC</code> 连接上可以创建多个 <code>stream</code>，来发送多个 <code>HTTP</code> 请求，但是，<code>QUIC</code> 是基于 <code>UDP</code> 的，<strong>一个连接上的多个 <code>stream</code> 之间没有依赖</strong>，所以当发生丢包时，只会影响当前的 <code>stream</code>，也就避免了线头阻塞问题。</p><p>比如下图中 <code>stream2</code> 丢了一个 <code>UDP</code> 包，不会影响后面跟着 <code>Stream3</code> 和 <code>Stream4</code>，不存在 <code>TCP</code> 队头阻塞。虽然 <code>stream2</code> 的那个包需要重新传，但是 <code>stream3</code>、<code>stream4</code> 的包无需等待，就可以发给用户。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201013164652.png" srcset="/img/loading.gif" alt="" /></p><p>另外 <code>QUIC</code> 在<strong>移动端</strong>的表现也会比 <code>TCP</code> 好。因为 <code>TCP</code> 是基于 <code>IP</code> 和<strong>端口</strong>去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 <code>QUIC</code> 是通过 <code>ID</code> 的方式去识别一个连接，不管你网络环境如何变化，只要 <code>ID</code> 不变，就能迅速重连上。</p><h3 id="3-报文加密"><a class="markdownIt-Anchor" href="#3-报文加密"></a> 3. 报文加密</h3><p><code>TCP</code> 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。</p><p>而 <code>QUIC</code> 所有<strong>报文头部</strong>都是经过认证的，报文 <code>Body</code> 都是经过加密的。这样只要对 <code>QUIC</code> 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 530. 二叉搜索树的最小绝对差</title>
    <link href="/2020/10/12/LeetCode-530-minimum-absolute-difference-in-bst/"/>
    <url>/2020/10/12/LeetCode-530-minimum-absolute-difference-in-bst/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. 二叉搜索树的最小绝对差</a></p><h1 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h1><p>中序遍历</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    ArrayDeque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    TreeNode curNode = root;    <span class="hljs-keyword">int</span> pre = Integer.MAX_VALUE, res = Integer.MAX_VALUE;    <span class="hljs-keyword">while</span> (!stack.isEmpty() || curNode != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">while</span> (curNode != <span class="hljs-keyword">null</span>) &#123;            stack.push(curNode);            curNode = curNode.left;        &#125;        TreeNode top = stack.pop();        <span class="hljs-comment">// 计算当前结点和上一个结点的差值</span>        res = Math.min(Math.abs(top.val - pre), res);        <span class="hljs-comment">// 当前值作为 pre</span>        pre = top.val;        <span class="hljs-comment">// 遍历右子树</span>        curNode = top.right;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span> res = Integer.MAX_VALUE;TreeNode prevNode;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    inOrder(root);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 遍历左子树</span>    inOrder(root.left);    <span class="hljs-comment">// 计算最小差值</span>    <span class="hljs-keyword">if</span> (prevNode != <span class="hljs-keyword">null</span>) &#123;        res = Math.min(res, root.val - prevNode.val);    &#125;    <span class="hljs-comment">// 更新前一个结点</span>    prevNode = root;    <span class="hljs-comment">// 遍历右子树</span>    inOrder(root.right);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 4. 寻找两个正序数组的中位数</title>
    <link href="/2020/10/12/LeetCode-4-median-of-two-sorted-arrays/"/>
    <url>/2020/10/12/LeetCode-4-median-of-two-sorted-arrays/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;    <span class="hljs-keyword">int</span> m = nums1.length, n = nums2.length;    <span class="hljs-keyword">int</span> len = m + n;    <span class="hljs-comment">// nums1, nums2 对应指针</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 上一次遍历到的数，当前遍历到的数</span>    <span class="hljs-keyword">int</span> prev = -<span class="hljs-number">1</span>, cur = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= len / <span class="hljs-number">2</span>; k++) &#123;        prev = cur;        <span class="hljs-comment">// 在两个数组中取小的数往后移</span>        <span class="hljs-keyword">if</span> (i == m) &#123;            <span class="hljs-comment">// nums1 遍历完成</span>            cur = nums2[j++];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n) &#123;            <span class="hljs-comment">// nums2 遍历完成</span>            cur = nums1[i++];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;            cur = nums1[i++];        &#125; <span class="hljs-keyword">else</span> &#123;            cur = nums2[j++];        &#125;    &#125;    <span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> (prev + cur) / <span class="hljs-number">2.0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> cur;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1300. 转变数组后最接近目标值的数组和</title>
    <link href="/2020/10/12/LeetCode-1300-sum-of-mutated-array-closest-to-target/"/>
    <url>/2020/10/12/LeetCode-1300-sum-of-mutated-array-closest-to-target/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">1300. 转变数组后最接近目标值的数组和</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findBestValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;        max = Math.max(max, num);    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = max;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> sum = getSum(arr, mid);        <span class="hljs-keyword">if</span> (sum == target) &#123;            <span class="hljs-keyword">return</span> mid;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 看 mid 和 mid - 1 哪个的和更接近 target</span>            <span class="hljs-keyword">int</span> prev = Math.abs(getSum(arr, mid - <span class="hljs-number">1</span>) - target);            <span class="hljs-keyword">int</span> midVal = Math.abs(sum - target);            <span class="hljs-keyword">if</span> (prev &lt;= midVal) &#123;                right = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> val)</span> </span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;        sum += Math.min(num, val);    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1237. 找出给定方程的正整数解</title>
    <link href="/2020/10/10/LeetCode-1237-find-positive-integer-solution-for-a-given-equation/"/>
    <url>/2020/10/10/LeetCode-1237-find-positive-integer-solution-for-a-given-equation/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/" target="_blank" rel="noopener">1237. 找出给定方程的正整数解</a></p><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSolution(CustomFunction customfunction, <span class="hljs-keyword">int</span> z) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// x: 1 -&gt; z</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= z; i++) &#123;        <span class="hljs-comment">// x: 1 -&gt; z 二分</span>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = z;        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (customfunction.f(i, mid) == z) &#123;                List&lt;Integer&gt; pair = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                pair.add(i);                pair.add(mid);                res.add(pair);                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (customfunction.f(i, mid) &gt; z) &#123;                right = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSolution(CustomFunction customfunction, <span class="hljs-keyword">int</span> z) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> low = <span class="hljs-number">1</span>, high = z;    <span class="hljs-keyword">while</span> (low &lt;= z &amp;&amp; high &gt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> r = customfunction.f(low, high);        <span class="hljs-keyword">if</span> (r &gt; z) &#123;            high--;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r &lt; z) &#123;            low++;        &#125; <span class="hljs-keyword">else</span> &#123;            List&lt;Integer&gt; pair = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            pair.add(low);            pair.add(high);            res.add(pair);            low++;            high--;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1095. 山脉数组中查找目标值</title>
    <link href="/2020/10/10/LeetCode-1095-find-in-mountain-array/"/>
    <url>/2020/10/10/LeetCode-1095-find-in-mountain-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findInMountainArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = mountainArr.length();        <span class="hljs-comment">// 获取山顶</span>        <span class="hljs-keyword">int</span> top = getTop(len, mountainArr);        <span class="hljs-comment">// 在左边查找</span>        <span class="hljs-keyword">int</span> ascPos = findInAsc(<span class="hljs-number">0</span>, top, target, mountainArr);        <span class="hljs-keyword">if</span> (ascPos != -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> ascPos;        &#125;        <span class="hljs-comment">// 在右边查找</span>        <span class="hljs-keyword">return</span> findInDesc(top, len - <span class="hljs-number">1</span>, target, mountainArr);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findInAsc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">int</span> midVal = mountainArr.get(mid);            <span class="hljs-keyword">if</span> (midVal == target) &#123;                <span class="hljs-keyword">return</span> mid;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midVal &gt; target) &#123;                right = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> mountainArr.get(left) == target ? left : -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findInDesc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">int</span> midVal = mountainArr.get(mid);            <span class="hljs-keyword">if</span> (midVal == target) &#123;                <span class="hljs-keyword">return</span> mid;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midVal &gt; target) &#123;                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                right = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> mountainArr.get(left) == target ? left : -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len, MountainArray mountainArr)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-comment">// 3, 4, 5, 2, 1</span>            <span class="hljs-keyword">if</span> (mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="hljs-number">1</span>)) &#123;                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                right = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 436. 寻找右区间</title>
    <link href="/2020/10/10/LeetCode-436-find-right-interval/"/>
    <url>/2020/10/10/LeetCode-436-find-right-interval/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-right-interval/" target="_blank" rel="noopener">436. 寻找右区间</a></p><ul><li>区间的终点总是大于它的起始点 =&gt; 只需要比较起点。</li><li>区间都不具有相同的起始点 =&gt; 可以保存排序前的<strong>起点</strong>和<strong>索引</strong>的关系。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findRightInterval(<span class="hljs-keyword">int</span>[][] intervals) &#123;    <span class="hljs-keyword">int</span> len = intervals.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] starts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 存储起点</span>        starts[i] = intervals[i][<span class="hljs-number">0</span>];        <span class="hljs-comment">// 存储每个起点的原始位置</span>        map.put(intervals[i][<span class="hljs-number">0</span>], i);    &#125;    Arrays.sort(starts);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 在起点数组中查找起点，该起点 &gt;= 区间 i 的终点</span>        <span class="hljs-keyword">int</span> index = binarySearch(starts, intervals[i][<span class="hljs-number">1</span>]);        res[i] = index == -<span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : map.get(starts[index]);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 查找第一个 &gt;= end 的区间起点</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> starts</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> end</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] starts, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = starts.length;    <span class="hljs-keyword">if</span> (starts[len - <span class="hljs-number">1</span>] &lt; end) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (starts[mid] &lt; end) &#123;            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 275. H 指数 II</title>
    <link href="/2020/10/09/LeetCode-275-h-index-ii/"/>
    <url>/2020/10/09/LeetCode-275-h-index-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/h-index-ii/" target="_blank" rel="noopener">275. H 指数 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] citations)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = citations.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span> || citations[len - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-comment">// 引用次数：citations[h]</span>        <span class="hljs-comment">// 论文数：len - h</span>        <span class="hljs-comment">// h index : (引用次数 &gt;= h 的论文数) &gt;= h 篇</span>        <span class="hljs-keyword">if</span> (citations[mid] &gt;= len - mid) &#123;            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> len - left;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 57 - II. 和为s的连续正数序列</title>
    <link href="/2020/10/09/LeetCode-offer-57-II-he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/"/>
    <url>/2020/10/09/LeetCode-offer-57-II-he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 57 - II. 和为s的连续正数序列</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;    List&lt;<span class="hljs-keyword">int</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = target / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (right &lt;= len) &#123;        sum += right;        right++;        <span class="hljs-keyword">while</span> (sum &gt; target) &#123;            sum -= left;            left++;        &#125;        <span class="hljs-keyword">if</span> (sum == target) &#123;            <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left, j = <span class="hljs-number">0</span>; i &lt; right; i++) &#123;                arr[j++] = i;            &#125;            list.add(arr);        &#125;    &#125;    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()][];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] arr : list) &#123;        res[i++] = arr;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
      <tag>剑指 Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 死锁</title>
    <link href="/2020/10/09/os-deadlock/"/>
    <url>/2020/10/09/os-deadlock/</url>
    
    <content type="html"><![CDATA[<h1 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h1><p>大部分的死锁都和资源有关，在进程对设备、文件具有<strong>独占性</strong>（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为 <code>资源(resource)</code>。</p><p>资源主要有可抢占资源和不可抢占资源。</p><ul><li><code>可抢占资源(preemptable resource)</code> 可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。</li><li><code>不可抢占资源(nonpreemtable resource)</code> 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。</li></ul><p>死锁与<strong>不可抢占</strong>资源有关，虽然抢占式资源也会造成死锁，不过这种情况的解决办法通常是在进程之间重新分配资源来化解。所以，我们的重点自然就会放在了不可抢占资源上。</p><p>如果在请求时资源不存在，请求进程就会强制等待。在某些操作系统中，当请求资源失败时进程会自动阻塞，当自资源可以获取时进程会自动唤醒。在另外一些操作系统中，请求资源失败并显示错误代码，然后等待进程等待一会儿再继续重试。</p><p>请求资源失败的进程会陷入一种<strong>请求资源、休眠、再请求资源</strong>的循环中。此类进程虽然没有阻塞，但是处于从目的和结果考虑，这类进程和阻塞差不多，因为这类进程并没有做任何有用的工作。</p><h1 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h1><p>在一组进程发生死锁的情况下，这组进程中的每一个进程，都在等待另一个进程所占有的资源。</p><p>死锁进程结合中的<strong>每个进程都在等待另一个死锁进程已经占有的资源</strong>。但是由于所有进程都不能运行，它们之中任何一个资源都无法释放资源，所以没有一个进程可以被唤醒。这种死锁也被称为 <code>资源死锁(resource deadlock)</code>。</p><h2 id="资源死锁的条件"><a class="markdownIt-Anchor" href="#资源死锁的条件"></a> 资源死锁的条件</h2><ol><li><strong>互斥条件</strong>：一段时间内，一个资源只能被一个进程占用。</li><li><strong>请求和保持条件</strong>：已经获取资源的进程提出了新的资源请求，但该资源已被其他进程占有，此时该进程被阻塞，但对已获取的资源保持不放。</li><li><strong>不可抢占条件</strong>：进程已获得的资源在未使用完之前不能被抢占，只能在使用完成时由自己释放。</li><li><strong>循环等待</strong>：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li></ol><p>发生死锁时，上面的情况必须<strong>同时</strong>会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过<strong>破坏其中任意一个条件来破坏死锁</strong>。</p><h2 id="死锁模型"><a class="markdownIt-Anchor" href="#死锁模型"></a> 死锁模型</h2><blockquote><p>圆形表示进程 (C, D)；方形表示资源 (T, U)。</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201010125812.png" srcset="/img/loading.gif" alt="" /></p><p>进程 C 等待资源 T 的释放，资源 T 却已经被进程 D 占用，进程 D 等待请求占用资源 U ，资源 U 却已经被线程 C 占用，从而形成环。</p><p>假设有三个进程 (A、B、C) 和三个资源(R、S、T) 。三个进程对资源的请求和释放序列如下图所示</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201010130805.png" srcset="/img/loading.gif" alt="" /></p><p>操作系统可以任意选择一个非阻塞的程序运行，所以它可以决定运行 A 直到 A 完成工作；它可以运行 B 直到 B 完成工作；最后运行 C。</p><p>这样的顺序不会导致死锁（因为不存在对资源的竞争），但是这种情况也完全没有并行性。进程除了在请求和释放资源外，还要做计算和输入/输出的工作。当进程按照顺序运行时，在等待一个 I/O 时，另一个进程不能使用 CPU。所以，严格按照串行的顺序执行并不是最优越的。另一方面，<strong>如果所有的进程都不执行 I/O 操作，那么短作业优先调度会优于轮转调度，所以在这种情况下串行可能是最优越的。</strong></p><p>假设进程会执行计算和 I/O 操作，所以轮询调度是一种合理的调度算法。资源请求可能会按照下面这个顺序进行：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201010131700.png" srcset="/img/loading.gif" alt="" /></p><p>这六个步骤的资源分配图：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201010131909.png" srcset="/img/loading.gif" alt="" /></p><p>在上面的第四个步骤，进程 A 正在等待资源 S；第五个步骤中，进程 B 在等待资源 T；第六个步骤中，进程 C 在等待资源 R，因此产生了<strong>环路</strong>并导致了死锁。</p><p>然而，操作系统并没有规定一定按照某种特定的顺序来执行这些进程。<strong>遇到一个可能会引起死锁的线程后，操作系统可以干脆不批准请求，并把进程挂起一直到安全状态为止。</strong> 比如上图中，如果操作系统认为有死锁的可能，它可以选择不把资源 S 分配给 B ，这样 B 被挂起。这样的话操作系统会只运行 A 和 C，那么资源的请求和释放就会是下面的步骤：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201010132457.png" srcset="/img/loading.gif" alt="" /></p><p>下图是针对上面这六个步骤的资源分配图：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201010132541.png" srcset="/img/loading.gif" alt="" /></p><p>在第六步执行完成后，可以发现并没有产生死锁，此时就可以把资源 S 分配给 B，因为 A 进程已经执行完毕，C 进程已经拿到了它想要的资源。进程 B 可以直接获得资源 S，也可以等待进程 C 释放资源 T 。</p><h2 id="处理死锁的策略"><a class="markdownIt-Anchor" href="#处理死锁的策略"></a> 处理死锁的策略</h2><ol><li><strong>鸵鸟算法</strong>：忽略死锁带来的影响；</li><li><strong>预防死锁</strong>：通过破坏死锁产生的四个条件之一，防止死锁产生；</li><li><strong>避免死锁</strong>：通过仔细分配资源来避免死锁；</li><li><strong>检测、解除死锁</strong>：检测死锁并恢复，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题；</li></ol><p>由上至下对死锁的防范程度逐渐减弱，但对应的是资源的利用率提高，以及进程因资源而阻塞的频度下降（并发程度提高）。</p><h1 id="鸵鸟算法"><a class="markdownIt-Anchor" href="#鸵鸟算法"></a> 鸵鸟算法</h1><p>最简单的解决办法就是使用 <code>鸵鸟算法(ostrich algorithm)</code>，把头埋在沙子里，假装问题根本没有发生。<br />每个人看待这个问题的反应都不同。数学家认为死锁是不可接受的，必须通过有效的策略来防止死锁的产生。工程师想要知道问题发生的频次，系统因为其他原因崩溃的次数和死锁带来的严重后果。如果死锁发生的频次很低，而经常会由于硬件故障、编译器错误等其他操作系统问题导致系统崩溃，那么大多数工程师不会修复死锁。</p><h1 id="预防死锁"><a class="markdownIt-Anchor" href="#预防死锁"></a> 预防死锁</h1><p>预防死锁是通过破坏产生死锁的四个必要条件中的一个或几个，以避免发生死锁。</p><blockquote><p>由于<strong>互斥条件是非共享设备所必须的</strong>，不仅不能改变，还应加以保证，因此主要是破坏产生死锁的后三个条件。</p></blockquote><h2 id="1-破坏互斥条件"><a class="markdownIt-Anchor" href="#1-破坏互斥条件"></a> 1. 破坏互斥条件</h2><p>如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 <code>假脱机打印机(spooling printer)</code> ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</p><p>后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</p><p>因此，避免分配那些不是绝对必须的资源，<strong>尽量做到尽可能少的进程可以请求资源</strong>。</p><h2 id="2-破坏请求和保持条件"><a class="markdownIt-Anchor" href="#2-破坏请求和保持条件"></a> 2. 破坏请求和保持条件</h2><p>系统必须做到：当一个进程在请求资源时，它不能持有不可抢占资源。<br />可以通过两个方式实现：</p><ul><li><p>让所有的进程<strong>开始执行前请求全部的资源</strong>。进程在整个运行期间，不会提出新的资源要求（破坏 <code>请求</code>）。只要有一种资源不能满足进程要求，让该进程等待，等待期间进程未占有任何资源（破坏 <code>保持</code>）。<br />很多进程<strong>无法在执行完成前就知道到底需要多少资源</strong>，如果知道的话，就可以使用<strong>银行家算法</strong>；还有一个问题是这样<strong>无法合理有效利用资源</strong>。</p></li><li><p>进程在请求其他资源时，<strong>先释放所占用的资源，然后再尝试一次获取全部的资源</strong>。</p></li></ul><h2 id="3-破坏不可抢占条件"><a class="markdownIt-Anchor" href="#3-破坏不可抢占条件"></a> 3. 破坏不可抢占条件</h2><p>当一个已经保持了某些不可抢占资源的进程，提出新的资源请求而不能被满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。</p><p>这种策略可能使进程前一段工作的失效，或者使进程前后两次运行的信息不连续。因为反复地申请和释放资源，导致进程的执行被无限地推迟，不仅延长了进程的周转时间，而且也增加了系统开销，降低了系统吞吐量。</p><h2 id="4-破坏循环等待条件"><a class="markdownIt-Anchor" href="#4-破坏循环等待条件"></a> 4. 破坏循环等待条件</h2><p>循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，<strong>一个进程在任何时候只能使用一种资源</strong>。如果需要另外一种资源，必须释放当前资源。对于需要将大文件从磁带复制到打印机的过程，此限制是不可接受的。</p><p>另一种方式是将所有的资源统一编号，如下图所示</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201010141050.png" srcset="/img/loading.gif" alt="" /></p><p>进程可以在任何时间提出请求，但是<strong>所有的请求都必须按照资源的顺序提出</strong>。如果按照此分配规则的话，那么资源分配之间不会出现环。</p><h1 id="避免死锁银行家算法"><a class="markdownIt-Anchor" href="#避免死锁银行家算法"></a> 避免死锁（银行家算法）</h1><p>银行家算法本身是一种死锁的调度算法。它的模型是基于一个城镇中的银行家，银行家向城镇中的客户承诺了一定数量的贷款额度。算法要做的就是判断请求是否会进入一种不安全的状态。如果是，就拒绝请求，如果请求后系统是安全的，就接受该请求。</p><p>假定系统中有五个进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>P</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>4</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P_0, P_1, P_2, P_3, P_4\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 和三类资源 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{A, B, C\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">}</span></span></span></span>，各种资源的数量分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mn>10</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>7</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{10, 5, 7\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mclose">}</span></span></span></span>，在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻的资源分配情况如下：</p><table><thead><tr><th style="text-align:center">进程</th><th style="text-align:center"><code>Max</code></th><th style="text-align:center"><code>Allocation</code></th><th style="text-align:center"><code>Need</code></th><th style="text-align:center"><code>Available</code></th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">7, 5, 3</td><td style="text-align:center">0, 1, 0</td><td style="text-align:center">7, 4, 3</td><td style="text-align:center">3, 3, 2</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">3, 2, 2</td><td style="text-align:center">2, 0, 0</td><td style="text-align:center">1, 2, 2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">9, 0, 2</td><td style="text-align:center">3, 0, 2</td><td style="text-align:center">6, 0, 0</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">2, 2, 2</td><td style="text-align:center">2, 1, 1</td><td style="text-align:center">0, 1, 1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">4, 3, 3</td><td style="text-align:center">0, 0, 2</td><td style="text-align:center">4, 3, 1</td><td style="text-align:center"></td></tr></tbody></table><p>在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻存在一个安全序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>0</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P_1, P_3, P_4, P_2, P_0\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>。</p><table><thead><tr><th style="text-align:center">进程</th><th style="text-align:center"><code>Available</code></th><th style="text-align:center"><code>Allocation</code></th><th style="text-align:center"><code>Need</code></th><th style="text-align:center"><code>Available + Allocation</code></th><th style="text-align:center"><code>Finish</code></th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">3, 3, 2</td><td style="text-align:center">2, 0, 0</td><td style="text-align:center">1, 2, 2</td><td style="text-align:center">5, 3, 2</td><td style="text-align:center"><code>TRUE</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">5, 3, 2</td><td style="text-align:center">2, 1, 1</td><td style="text-align:center">0, 1, 1</td><td style="text-align:center">7, 4, 3</td><td style="text-align:center"><code>TRUE</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">P_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">7, 4, 3</td><td style="text-align:center">0, 0, 2</td><td style="text-align:center">4, 3, 1</td><td style="text-align:center">7, 4, 5</td><td style="text-align:center"><code>TRUE</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">7, 4, 5</td><td style="text-align:center">3, 0, 2</td><td style="text-align:center">6, 0, 0</td><td style="text-align:center">10, 4, 7</td><td style="text-align:center"><code>TRUE</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">10, 4, 7</td><td style="text-align:center">0, 1, 0</td><td style="text-align:center">7, 4, 3</td><td style="text-align:center">10, 5, 7</td><td style="text-align:center"><code>TRUE</code></td></tr></tbody></table><h1 id="死锁的检测和恢复"><a class="markdownIt-Anchor" href="#死锁的检测和恢复"></a> 死锁的检测和恢复</h1><h2 id="死锁检测"><a class="markdownIt-Anchor" href="#死锁检测"></a> 死锁检测</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201010125812.png" srcset="/img/loading.gif" alt="" /></p><p>使用资源分配图来检测死锁，圆形表示一个进程，方形表示一类资源，当整个图存在环时说明系统存在死锁。</p><h2 id="死锁恢复"><a class="markdownIt-Anchor" href="#死锁恢复"></a> 死锁恢复</h2><h3 id="1-通过抢占资源"><a class="markdownIt-Anchor" href="#1-通过抢占资源"></a> 1. 通过抢占资源</h3><p>在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</p><h3 id="2-通过回滚"><a class="markdownIt-Anchor" href="#2-通过回滚"></a> 2. 通过回滚</h3><p>周期性地对进程进行 <code>检查点检查(checkpointed)</code>。 进程的检查点检查意味着进程的状态可以被写入到文件以便后面进行恢复。检查点不仅包含 <code>存储映像(memory image)</code>，还包含 <code>资源状态(resource state)</code>。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</p><p>为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</p><h3 id="3-终止进程"><a class="markdownIt-Anchor" href="#3-终止进程"></a> 3. 终止进程</h3><p>终止或撤销系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="/2020/10/07/LeetCode-34-find-first-and-last-position-of-element-in-sorted-array/"/>
    <url>/2020/10/07/LeetCode-34-find-first-and-last-position-of-element-in-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;        &#125;        <span class="hljs-keyword">int</span> first = findFirstPos(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>, target);        <span class="hljs-keyword">if</span> (first == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;        &#125;        <span class="hljs-keyword">int</span> last = findLastPos(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>, target);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;first, last&#125;;    &#125;    <span class="hljs-comment">// 1 2 3</span>    <span class="hljs-comment">// 0 1 2</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findFirstPos</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-comment">// 搜索开始位置：更新左边界</span>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;                <span class="hljs-comment">// [mid + 1, right]</span>                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// nums[mid] &gt;= target</span>                <span class="hljs-comment">// [left, mid]</span>                right = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 5 7 7 8 8 10</span>    <span class="hljs-comment">// 0 1 2 3 4  5</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLastPos</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;            <span class="hljs-comment">// 搜索结束位置：更新右边界</span>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;                <span class="hljs-comment">// [left, mid - 1]</span>                right = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// nums[mid] &lt;= target</span>                <span class="hljs-comment">// [mid, right]</span>                left = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 167. 两数之和 II - 输入有序数组</title>
    <link href="/2020/10/06/LeetCode-167-two-sum-ii-input-array-is-sorted/"/>
    <url>/2020/10/06/LeetCode-167-two-sum-ii-input-array-is-sorted/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></p><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> target) &#123;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = numbers.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> sum = numbers[left] + numbers[right];        <span class="hljs-keyword">if</span> (target &gt; sum) &#123;            left++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; sum) &#123;            right--;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];&#125;</code></pre><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> target) &#123;    <span class="hljs-keyword">int</span> len = numbers.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> right = binarySearch(numbers, i + <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>, target - numbers[i]);        <span class="hljs-keyword">if</span> (right != -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;            <span class="hljs-keyword">return</span> mid;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 18. 四数之和</title>
    <link href="/2020/10/05/LeetCode-18-4sum/"/>
    <url>/2020/10/05/LeetCode-18-4sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a><br />固定一个数进行三数之和的查找。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;    Arrays.sort(nums);    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">3</span>; i++) &#123;        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 查找 三数之和</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len - <span class="hljs-number">2</span>; j++) &#123;            <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">int</span> left = j + <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (left &lt; right) &#123;                <span class="hljs-keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];                <span class="hljs-keyword">if</span> (sum == target) &#123;                    res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));                    <span class="hljs-comment">// 跳过重复数字</span>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;                        left++;                    &#125;                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;                        right--;                    &#125;                    left++;                    right--;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;                    right--;                &#125; <span class="hljs-keyword">else</span> &#123;                    left++;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 42. 接雨水</title>
    <link href="/2020/10/05/LeetCode-42-trapping-rain-water/"/>
    <url>/2020/10/05/LeetCode-42-trapping-rain-water/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></p><h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;    ArrayDeque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; height.length; i++) &#123;        <span class="hljs-comment">// 当前高度 &gt; 栈顶时，计算栈顶元素上的积水</span>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;            <span class="hljs-comment">// 栈顶元素的高度</span>            <span class="hljs-keyword">int</span> top = height[stack.pop()];            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">// 可形成积水的宽度</span>            <span class="hljs-keyword">int</span> width = i - stack.peek() - <span class="hljs-number">1</span>;            <span class="hljs-comment">// 栈顶元素的两侧均 &gt; 栈顶高度，取最小值</span>            <span class="hljs-keyword">int</span> minHeight = Math.min(height[i], height[stack.peek()]);            res += width * (minHeight - top);        &#125;        stack.push(i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><p>分别找到当前列的左右最高点，计算积水。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = height.length;    <span class="hljs-comment">// 最左边和最右边无法保存水，可跳过</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// 找出左边最高的列</span>        <span class="hljs-keyword">int</span> leftMax = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;            leftMax = Math.max(leftMax, height[j]);        &#125;        <span class="hljs-comment">// 找出右边最高的列</span>        <span class="hljs-keyword">int</span> rightMax = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;            rightMax = Math.max(rightMax, height[j]);        &#125;        <span class="hljs-comment">// 当前列均小于 左边和右边时，当前列才能保存水</span>        <span class="hljs-keyword">int</span> minHeight = Math.min(leftMax, rightMax);        <span class="hljs-keyword">if</span> (minHeight &gt; height[i]) &#123;            res += minHeight - height[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = height.length;    <span class="hljs-keyword">int</span>[] leftMax = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-comment">// 计算左边最高</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        leftMax[i] = Math.max(leftMax[i - <span class="hljs-number">1</span>], height[i - <span class="hljs-number">1</span>]);    &#125;    <span class="hljs-comment">// 计算右边最高</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        rightMax[i] = Math.max(rightMax[i + <span class="hljs-number">1</span>], height[i + <span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">int</span> minHeight = Math.min(leftMax[i], rightMax[i]);        <span class="hljs-keyword">if</span> (minHeight &gt; height[i]) &#123;            res += minHeight - height[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>双指针</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 16. 最接近的三数之和</title>
    <link href="/2020/10/04/LeetCode-16-3sum-closest/"/>
    <url>/2020/10/04/LeetCode-16-3sum-closest/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    Arrays.sort(nums);    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> sum = nums[i] + nums[left] + nums[right];            <span class="hljs-keyword">if</span> (sum == target) &#123;                <span class="hljs-keyword">return</span> res;            &#125;            <span class="hljs-keyword">if</span> (Math.abs(target - sum) &lt; Math.abs(target - res)) &#123;                res = sum;            &#125;            <span class="hljs-keyword">if</span> (sum &gt; target) &#123;                right--;            &#125; <span class="hljs-keyword">else</span> &#123;                left++;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 15. 三数之和</title>
    <link href="/2020/10/03/LeetCode-15-3sum/"/>
    <url>/2020/10/03/LeetCode-15-3sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = nums.length;    Arrays.sort(nums);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 重复数字</span>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 当前为正数，则之后都为正数，和不可能为 0</span>        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> sum = nums[left] + nums[right] + nums[i];            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;                res.add(Arrays.asList(nums[i], nums[left], nums[right]));                <span class="hljs-comment">// 去重</span>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;                    left++;                &#125;                <span class="hljs-comment">// 去重</span>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;                    right--;                &#125;                <span class="hljs-comment">// 查找下一个可行解</span>                left++;                right--;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 右值偏大</span>                right--;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 左值偏小</span>                left++;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 11. 盛最多水的容器</title>
    <link href="/2020/10/02/LeetCode-11-container-with-most-water/"/>
    <url>/2020/10/02/LeetCode-11-container-with-most-water/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a><br />面积取决于最低的柱子高度，而每次向内移动宽度一定减小，因此要达到尽可能大的面积，新柱子的最低高度不能小于当前柱子的最低高度。</p><ul><li>若移动高的柱子，高度一定不会超过当前的最低点，面积反而可能减小。</li><li>若移动低的柱子，新的最低高度可能会超过当前最低点，面积才有可能增大。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> area = Math.min(height[left], height[right]) * (right - left);        max = Math.max(max, area);        <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;            left++;        &#125; <span class="hljs-keyword">else</span> &#123;            right--;        &#125;    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 48. 最长不含重复字符的子字符串</title>
    <link href="/2020/09/30/LeetCode-offer-48-zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/"/>
    <url>/2020/09/30/LeetCode-offer-48-zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 48. 最长不含重复字符的子字符串</a></p><h1 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h1><p>记录字符是否出现。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = chars.length;    Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">char</span> c = chars[right];        right++;        <span class="hljs-keyword">while</span> (set.contains(c)) &#123;            set.remove(chars[left]);            left++;        &#125;        set.add(c);        maxLen = Math.max(maxLen, right - left);    &#125;    <span class="hljs-keyword">return</span> maxLen;&#125;</code></pre><h1 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h1><p>记录字符的最后一次出现位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = chars.length;    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">char</span> c = chars[right];        <span class="hljs-keyword">if</span> (map.containsKey(c)) &#123;            left = Math.max(map.get(c) + <span class="hljs-number">1</span>, left);        &#125;        map.put(c, right);        maxLen = Math.max(maxLen, right - left + <span class="hljs-number">1</span>);        right++;    &#125;    <span class="hljs-keyword">return</span> maxLen;&#125;</code></pre><h1 id="数组哈希"><a class="markdownIt-Anchor" href="#数组哈希"></a> 数组哈希</h1><p>记录字符出现次数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];    <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">char</span> c = chars[right];        right++;        <span class="hljs-comment">// 收缩左边界，直到 right 对应字符未出现</span>        <span class="hljs-keyword">while</span> (freq[c] &gt; <span class="hljs-number">0</span>) &#123;            freq[chars[left]]--;            left++;        &#125;        freq[c]++;        maxLen = Math.max(maxLen, right - left);    &#125;    <span class="hljs-keyword">return</span> maxLen;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 995. K 连续位的最小翻转次数</title>
    <link href="/2020/09/30/LeetCode-995-minimum-number-of-k-consecutive-bit-flips/"/>
    <url>/2020/09/30/LeetCode-995-minimum-number-of-k-consecutive-bit-flips/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/" target="_blank" rel="noopener">995. K 连续位的最小翻转次数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (A[i] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// A[i] == 0，但后面没有 K 位，无法翻转</span>        <span class="hljs-keyword">if</span> (i + K &gt; len) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 遇到 0 就反转</span>        count++;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; i + K; j++) &#123;            A[j] ^= <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    ArrayDeque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// i 不在前几次的翻转子数组中</span>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekFirst() + K &lt;= i) &#123;            queue.poll();        &#125;        <span class="hljs-comment">// 在 [i - k + 1, i - 1] 翻转中</span>        <span class="hljs-comment">// 1 翻转奇数次后变为 0</span>        <span class="hljs-comment">// 0 翻转偶数次后变为 1，这两种情况需要再次翻转</span>        <span class="hljs-keyword">if</span> (queue.size() % <span class="hljs-number">2</span> == A[i]) &#123;            <span class="hljs-comment">// 剩下不足 K 位，无法翻转</span>            <span class="hljs-keyword">if</span> (i + K &gt; len) &#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;            count++;            queue.add(i);        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 输入输出</title>
    <link href="/2020/09/30/os-io/"/>
    <url>/2020/09/30/os-io/</url>
    
    <content type="html"><![CDATA[<h1 id="io-硬件原理"><a class="markdownIt-Anchor" href="#io-硬件原理"></a> I/O 硬件原理</h1><h2 id="io-设备"><a class="markdownIt-Anchor" href="#io-设备"></a> I/O 设备</h2><p><code>I/O 设备(I/O devices)</code> 可以分成两种：<code>块设备(block devices)</code> 和 <code>字符设备(character devices)</code>。</p><h3 id="块设备"><a class="markdownIt-Anchor" href="#块设备"></a> 块设备</h3><p>块设备是一个能存储<strong>固定大小</strong>块信息的设备，它支持以固定大小的块，扇区或群集读取和（可选）写入数据。每个块都有自己的物理地址。通常块的大小在 <code>512 - 65536</code> 之间。所有传输的信息都会以连续的块为单位。块设备的基本特征是<strong>每个块都较为对立，能够独立的进行读写</strong>。常见的块设备有 硬盘、蓝光光盘、USB 盘。</p><p>缺点：基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为<strong>必须在块的开头开始读取或写入</strong>。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。</p><h3 id="字符设备"><a class="markdownIt-Anchor" href="#字符设备"></a> 字符设备</h3><p>字符设备<strong>以字符为单位发送或接收一个字符流</strong>，而不考虑任何块结构。字符设备是<strong>不可寻址</strong>的，也没有任何寻道操作。常见的字符设备有 打印机、网络设备、鼠标、以及大多数与磁盘不同的设备。</p><h2 id="设备控制器"><a class="markdownIt-Anchor" href="#设备控制器"></a> 设备控制器</h2><p>设备控制器的主要功能是，<strong>控制一个或多个 <code>I/O</code> 设备，以实现 <code>I/O</code> 设备和计算机之间的数据交换</strong>。它是 <code>CPU</code> 与 <code>I/O</code> 设备之间的接口，接收从 <code>CPU</code> 发来的命令，去控制 <code>I/O</code> 设备工作。<br />设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些 <code>特殊目的寄存器(special purpose registers)</code> 也就是<code>本地缓冲区</code>中。</p><p>每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。</p><h2 id="内存映射-io"><a class="markdownIt-Anchor" href="#内存映射-io"></a> 内存映射 I/O</h2><p><code>CPU</code> 如何与设备寄存器和设备数据缓冲区进行通信呢？存在两个可选的方式。</p><h3 id="1-利用特定的-io-指令"><a class="markdownIt-Anchor" href="#1-利用特定的-io-指令"></a> 1. 利用特定的 I/O 指令</h3><p>第一种方法是，每个控制寄存器都被分配一个 <code>I/O 端口(I/O port)</code> 号，这是一个 8 位或 16 位的整数。所有 <code>I/O</code> 端口的集合形成了受保护的 <code>I/O</code> 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I/O 指令像是</p><pre><code class="hljs assembly">IN REG, PORT</code></pre><p>CPU 可以读取控制寄存器 PORT 的内容并将结果放在 <code>CPU</code> 寄存器 <code>REG</code> 中。类似的，使用</p><pre><code class="hljs assembly">OUT PORT, REG</code></pre><p><code>CPU</code> 可以将 <code>REG</code> 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型主机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。</p><p>在这一方案中，内存地址空间和 I/O 地址空间是不相同的，如下图所示：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200930162507.png" srcset="/img/loading.gif" alt="" /></p><p>指令</p><pre><code class="hljs assembly">IN R0,4</code></pre><p>和</p><pre><code class="hljs assembly">MOV R0,4</code></pre><p>这一设计中完全不同。前者读取 <code>I/O端口</code> 4 的内容并将其放入 R0，而后者读取<code>存储器</code>字 4 的内容并将其放入 R0。这些示例中的 <code>4</code> 代表<strong>不同且不相关的地址空间</strong>。</p><h3 id="2-内存映像-io"><a class="markdownIt-Anchor" href="#2-内存映像-io"></a> 2. 内存映像 I/O</h3><p>在这种方式中，不再区分内存单元地址和设备控制器中的寄存器地址，它将<strong>所有控制寄存器映射到内存空间中</strong>。</p><p><code>内存映射的 I/O</code> 是在 CPU 与其连接的外围设备之间交换数据和指令的一种方式，这种方式是处理器和 IO 设备<strong>共享同一内存位置的内存</strong>，即处理器和 <code>I/O</code> 设备使用内存地址进行映射。</p><p>当地址处于 <code>0 ~ n - 1</code> 范围时，被认为是内存地址，否则被认为是某个控制器的寄存器地址。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200930163143.png" srcset="/img/loading.gif" alt="" /></p><p>优点：</p><ol><li><p>如果需要特殊的 I/O 指令读写设备控制寄存器，那么访问这些寄存器需要使用汇编代码，因为在 C 或 C++ 中不存在执行 IN 和 OUT 指令的方法。调用这样的过程增加了 I/O 的开销。在内存映射中，<strong>控制寄存器只是内存中的变量，在 C 语言中可以和其他变量一样进行寻址</strong>。</p></li><li><p>对于内存映射 I/O ，<strong>不需要特殊的保护机制</strong>就能够阻止用户进程执行 I/O 操作。操作系统需要保证的是禁止把控制寄存器的地址空间放在用户的虚拟地址中就可以了。</p></li><li><p>对于内存映射 I/O，可以引用内存的每一条指令也可以引用控制寄存器，便于引用。</p></li></ol><h2 id="直接内存访问dma"><a class="markdownIt-Anchor" href="#直接内存访问dma"></a> 直接内存访问（DMA）</h2><p>无论一个 <code>CPU</code> 是否具有内存映射 <code>I/O</code>，它都需要寻址设备控制器以便与它们交换数据。<code>CPU</code> 可以从 <code>I/O</code> 控制器通过<strong>中断</strong>每次请求一个字节的数据，但是这么做会浪费 <code>CPU</code> 时间，所以经常会用到一种称为 <code>直接内存访问(Direct Memory Access)</code> 的方案，如下图所示</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200930163602.png" srcset="/img/loading.gif" alt="" /></p><p><strong><code>DMA</code> 控制器能够独立于 CPU 从而访问系统总线</strong>，如上图所示。它包含几个可由 CPU 读写的寄存器，其中包括一个<code>内存地址寄存器</code>，<code>字节计数寄存器</code>和一个或多个<code>控制寄存器</code>。控制寄存器指定要使用的 <code>I/O</code> 端口、传送方向（从 <code>I/O</code> 设备读或写到 <code>I/O</code> 设备）、传送单位（每次一个字节或者每次一个字）以及在一次突发传送中要传送的字节数。</p><h3 id="dma-工作原理"><a class="markdownIt-Anchor" href="#dma-工作原理"></a> DMA 工作原理</h3><ol><li>首先 <code>CPU</code> 通过设置 <code>DMA</code> 控制器的寄存器对它进行编程，所以 <code>DMA</code> 控制器知道将什么数据传送到什么地方。<code>DMA</code> 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区并检验校验和。当有效数据位于磁盘控制器的缓冲区中时，<code>DMA</code> 就可以开始了。</li><li><code>DMA</code> 控制器通过在总线上发出一个读请求到磁盘控制器而发起 <code>DMA</code> 传送。这个读请求就像其他读请求一样，<strong>磁盘控制器并不知道或者并不关心它是来自 <code>CPU</code> 还是来自 <code>DMA</code> 控制器。</strong> 通常情况下，要写的内存地址在总线的地址线上，所以当磁盘控制器去匹配下一个字时，它知道将该字写到什么地方。</li><li>通过总线进行数据交换。</li><li>当写操作完成时，磁盘控制器在总线上发出一个应答信号到 <code>DMA</code> 控制器。</li></ol><h2 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200930174048.png" srcset="/img/loading.gif" alt="" /></p><p>当一个 I/O 设备完成它的工作后，它就会产生一个中断，它通过在总线上声明已分配的信号来实现此目的。主板上的中断控制器芯片会检测到这个信号，然后执行中断操作。</p><ul><li>如果在中断前没有其他中断操作阻塞的话，中断控制器将立刻对中断进行处理。</li><li>如果在中断前还有其他中断操作正在执行，或者有其他设备发出<strong>优先级更高</strong>的中断信号的话，那么这个设备将暂时不会处理。在这种情况下，该设备会继续在总线上置起中断信号，直到得到 <code>CPU</code> 服务。</li></ul><p>硬件通常在服务程序开始前保存当前信息。对于不同的 <code>CPU</code> 来说，哪些信息需要保存以及保存在哪里差别很大。不管其他的信息是否保存，<strong>程序计数器必须要被保存，这对所有的 CPU 来说都是相同的，以此来恢复中断的进程。</strong> 所有可见寄存器和大量内部寄存器也应该被保存。</p><p>上面说到硬件应该保存当前信息，那么保存在哪里是个问题，一种选择是将其放入到<strong>内部寄存器</strong>中，在需要时操作系统可以读出这些内部寄存器。这种方法会造成的问题是：一段时间内设备无法响应，直到所有的内部寄存器中存储的信息被读出后，才能恢复运行，以免第二个内部寄存器重写内部寄存器的状态。</p><p>第二种方式是在<strong>堆栈</strong>中保存信息，这也是大部分 <code>CPU</code> 所使用的方式。但是，这种方法也存在问题，因为使用的堆栈不确定，如果使用的是当前堆栈，则它很可能是用户进程的堆栈。堆栈指针甚至不合法，这样当硬件试图在它所指的地址处写入时，将会导致致命错误。如果使用的是内核堆栈，堆栈指针是合法的并且指向一个固定的页面，这样的机会可能会更大。然而，切换到内核态需要切换 <code>MMU</code> 上下文，并且可能使高速缓存或者 <code>TLB</code> 失效。静态或动态重新装载这些东西将增加中断处理的时间，浪费 <code>CPU</code> 时间。</p><h1 id="io-软件原理"><a class="markdownIt-Anchor" href="#io-软件原理"></a> IO 软件原理</h1><h2 id="io-软件目标"><a class="markdownIt-Anchor" href="#io-软件目标"></a> I/O 软件目标</h2><h3 id="1-设备独立性"><a class="markdownIt-Anchor" href="#1-设备独立性"></a> 1. 设备独立性</h3><p><code>设备独立性(device independence)</code> 意味着我们<strong>能够编写访问任何设备的应用程序</strong>，而不用事先指定特定的设备。比如你编写了一个能够从设备读入文件的应用程序，那么这个应用程序可以从硬盘、DVD 或者 USB 进行读入，不必再为每个设备定制应用程序。这其实就体现了设备独立性的概念。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201007134014.png" srcset="/img/loading.gif" alt="" /></p><p>再比如说你可以输入一条下面的指令</p><pre><code class="hljs gradle"><span class="hljs-keyword">sort</span> 输入 输出</code></pre><p>那么上面这个 <code>输入</code> 就可以接收来自任意类型的磁盘或者键盘，并且 <code>输出</code> 可以写入到任意类型的磁盘或者屏幕。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201007134238.png" srcset="/img/loading.gif" alt="" /></p><p>计算机操作系统是这些硬件的媒介，因为不同硬件它们的指令序列不同，所以需要操作系统来做指令间的转换。</p><p>与设备独立性密切相关的一个指标就是 <code>统一命名(uniform naming)</code>。设备的代号应该是一个整数或者是字符串，它们不应该依赖于具体的设备。在 <code>UNIX</code> 中，所有的磁盘都能够被集成到文件系统中，所以用户不用记住每个设备的具体名称，直接记住对应的路径即可，如果路径记不住，也可以通过 <code>ls</code> 等指令找到具体的集成位置。举个例子来说，比如一个 USB 磁盘被挂载到了 <code>/usr/likai/backup</code> 下，那么你把文件复制到 <code>/usr/likai/backup/device</code> 下，就相当于是把文件复制到了磁盘中，通过这种方式，实现了向任何磁盘写入文件都相当于是向指定的路径输出文件。</p><h3 id="2-错误处理"><a class="markdownIt-Anchor" href="#2-错误处理"></a> 2. 错误处理</h3><p><code>I/O</code> 软件实现的第二个重要的目标就是 <code>错误处理(error handling)</code>。通常情况下来说，错误应该交给硬件层面去处理。如果设备控制器发现了读错误的话，它会尽可能的去修复这个错误。如果设备控制器处理不了这个问题，那么设备驱动程序应该进行处理，设备驱动程序会再次尝试读取操作，很多错误都是偶然性的，如果设备驱动程序无法处理这个错误，才会把错误向上抛到硬件层面（上层）进行处理，很多时候，<strong>上层并不需要知道下层是如何解决错误的</strong>。这就很像项目经理不用把每个决定都告诉老板；程序员不用把每行代码如何写告诉项目经理。这种处理方式不够透明。</p><h3 id="3-同步和异步传输"><a class="markdownIt-Anchor" href="#3-同步和异步传输"></a> 3. 同步和异步传输</h3><p><code>I/O</code> 软件实现的第三个目标就是 <code>同步(synchronous)</code> 和 <code>异步(asynchronous，即中断驱动)</code> 传输。</p><ul><li>同步传输中数据通常以<strong>块或帧</strong>的形式发送。发送方和接收方在数据传输之前应该具有<strong>同步时钟</strong>。</li><li>异步传输中，数据通常以<strong>字节</strong>或者<strong>字符</strong>的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加<strong>奇偶校验位</strong>。</li></ul><p>大部分 <code>物理 IO(physical I/O)</code> 是异步的。物理 I/O 中的 <code>CPU</code> 是很聪明的，CPU 传输完成后会转而做其他事情，它和中断心灵相通，等到中断发生后，<code>CPU</code> 才会回到传输这件事情上来。</p><blockquote><p><code>I/O</code> 分为两种：<code>物理 I/O</code> 和 <code>逻辑 I/O(Logical I/O)</code>。</p><p><code>物理 I/O</code> 通常是从磁盘等<strong>存储设备</strong>实际获取数据。<code>逻辑 I/O</code> 是对<strong>存储器</strong>（块，缓冲区）获取数据。</p></blockquote><h3 id="4-缓冲"><a class="markdownIt-Anchor" href="#4-缓冲"></a> 4. 缓冲</h3><p><code>I/O</code> 软件的最后一个问题是 <code>缓冲(buffering)</code>。通常情况下，从一个设备发出的数据不会直接到达最后的设备。其间会经过一系列的校验、检查、缓冲等操作才能到达。举个例子来说，从网络上发送一个数据包，会经过一系列检查之后首先到达缓冲区，从而消除缓冲区填满速率和缓冲区过载。</p><h3 id="5-共享和独占"><a class="markdownIt-Anchor" href="#5-共享和独占"></a> 5. 共享和独占</h3><p>有些 I/O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用。</p><h2 id="控制-io-设备的方法"><a class="markdownIt-Anchor" href="#控制-io-设备的方法"></a> 控制 I/O 设备的方法</h2><h3 id="1-使用程序控制-io"><a class="markdownIt-Anchor" href="#1-使用程序控制-io"></a> 1. 使用程序控制 I/O</h3><p>使用程序控制 <code>I/O</code> 又被称为 <code>可编程I/O</code>，它是指由 <code>CPU</code> 在驱动程序软件控制下启动的数据传输，来访问设备上的寄存器或者其他存储器。<code>CPU</code> 会发出命令，然后等待 <code>I/O</code> 操作的完成。由于 <code>CPU</code> 的速度比 <code>I/O</code> 模块的速度快很多，因此可编程 <code>I/O</code> 的问题在于，<code>CPU</code> 必须等待很长时间才能等到处理结果。<code>CPU</code> 在等待时会采用 <code>轮询(polling)</code> 或者 <code>忙等(busy waiting)</code> 的方式，结果，整个系统的性能被严重拉低。可编程 <code>I/O</code> 十分简单，如果需要等待的时间非常短的话，可编程 <code>I/O</code> 倒是一个很好的方式。一个可编程的 <code>I/O</code> 会经历如下操作：</p><ul><li><code>CPU</code> 请求 I/O 操作</li><li><code>I/O</code> 模块执行响应</li><li><code>I/O</code> 模块设置状态位</li><li><code>CPU</code> 会定期检查状态位</li><li><code>I/O</code> <strong>不会直接通知</strong> <code>CPU</code> 操作完成，<code>I/O</code> 也不会中断 <code>CPU</code></li><li><code>CPU</code> 可能会等待或在随后的过程中返回</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201007135543.png" srcset="/img/loading.gif" alt="" /></p><h3 id="2-使用中断驱动-io"><a class="markdownIt-Anchor" href="#2-使用中断驱动-io"></a> 2. 使用中断驱动 I/O</h3><p>在 <code>CPU</code> 等待 <code>I/O</code> 设备的同时，能够做其他事情，等到 <code>I/O</code> 设备完成后，它就会产生一个中断，这个中断会停止当前进程并保存当前的状态。一个可能的示意图如下：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201007135557.png" srcset="/img/loading.gif" alt="" /></p><p>尽管中断减轻了 <code>CPU</code> 和 <code>I/O</code> 设备的等待时间的负担，但是由于还需要在 <code>CPU</code> 和 <code>I/O</code> 模块之前进行大量的逐字传输，因此在大量数据传输中效率仍然很低。下面是中断的基本操作</p><ul><li><code>CPU</code> 进行读取操作</li><li><code>I/O</code> 设备从外围设备获取数据，同时 <code>CPU</code> 执行其他操作</li><li><code>I/O</code> 设备<strong>中断通知</strong> <code>CPU</code></li><li><code>CPU</code> 请求数据</li><li><code>I/O</code> 模块传输数据</li></ul><h3 id="3-使用-dma-驱动-io"><a class="markdownIt-Anchor" href="#3-使用-dma-驱动-io"></a> 3. 使用 DMA 驱动 I/O</h3><p><code>DMA</code> 的中文名称是直接内存访问，它意味着 <strong><code>CPU</code> 授予 <code>I/O</code> 模块权限在不涉及 <code>CPU</code> 的情况下读取或写入内存。</strong> 也就是 <code>DMA</code> 可以不需要 <code>CPU</code> 的参与。这个过程由称为 <code>DMA 控制器（DMAC）</code> 的芯片管理。由于 <code>DMA</code> 设备可以直接在内存之间传输数据，而不是使用 <code>CPU</code> 作为中介，因此可以缓解总线上的拥塞。<code>DMA</code> 通过允许 <code>CPU</code> 执行任务，同时 <code>DMA</code> 系统通过系统和内存总线传输数据来提高系统并发性。</p><h1 id="io-层次结构"><a class="markdownIt-Anchor" href="#io-层次结构"></a> I/O 层次结构</h1><p>I/O 软件通常组织成四个层次，它们的大致结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201009130854.png" srcset="/img/loading.gif" alt="" /></p><h2 id="中断处理程序"><a class="markdownIt-Anchor" href="#中断处理程序"></a> 中断处理程序</h2><p>中断处理程序又被称为 <code>中断服务程序</code> 或者是 <code>ISR(Interrupt Service Routines)</code>，它是最靠近硬件的一层。中断处理程序由硬件中断、软件中断或者是软件异常启动产生的中断，用于实现设备驱动程序或受保护的操作模式（例如系统调用）之间的转换。</p><p>中断处理程序负责处理中断发生时的所有操作，操作完成后阻塞，然后启动中断驱动程序来解决阻塞。通常会有三种通知方式，依赖于不同的具体实现：</p><ol><li>信号量实现中：在信号量上使用 <code>up</code> 进行通知；</li><li>管程实现：对管程中的条件变量执行 <code>signal</code> 操作；</li><li>还有一些情况是发送一些消息。</li></ol><p>下面是一些通用的中断处理程序的步骤，不同的操作系统实现细节不一样</p><ol><li>保存所有没有被中断硬件保存的寄存器</li><li>为中断服务程序设置<strong>上下文环境</strong>，可能包括设置 TLB、MMU 和页表</li><li>为中断服务程序设置栈</li><li>对中断控制器作出响应，如果不存在集中的中断控制器，则继续响应中断</li><li>把寄存器从保存它的地方拷贝到进程表中</li><li>运行中断服务程序，它会从发出中断的设备控制器的寄存器中提取信息</li><li>操作系统会选择一个合适的进程来运行。如果中断造成了一些优先级更高的进程变为就绪态，则选择运行这些优先级高的进程</li><li>为进程设置 MMU 上下文，可能也会需要 TLB，根据实际情况决定</li><li>加载进程的寄存器，包括 PSW 寄存器</li><li>开始运行新的进程</li></ol><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201009132314.png" srcset="/img/loading.gif" alt="" /></p><h2 id="设备驱动程序"><a class="markdownIt-Anchor" href="#设备驱动程序"></a> 设备驱动程序</h2><p>每个设备控制器内部都会有寄存器用来和设备进行沟通，发送指令，读取设备的状态等。因此，每个连接到计算机的 I/O 设备都需要有某些特定设备的代码对其进行控制，例如鼠标控制器需要从鼠标接受指令，告诉下一步应该移动到哪里，键盘控制器需要知道哪个按键被按下等。这些<strong>提供 I/O 设备到设备控制器转换的过程的代码称为 <code>设备驱动程序(Device driver)</code>。</strong></p><p>为了能够访问设备的硬件，<strong>设备驱动程序通常是操作系统内核的一部分。</strong><br />但是也可以构造用户空间的设备驱动程序，通过系统调用来完成读写操作。这样就避免了一个问题，有问题的驱动程序会干扰内核，从而造成崩溃。所以，<strong>在用户空间实现设备驱动程序可以保证系统稳定性。</strong></p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201009134753.png" srcset="/img/loading.gif" alt="" /></p><p>在 <code>UNIX</code> 系统中，操作系统是一个二进制程序，包含需要编译到其内部的所有驱动程序，如果你要对 <code>UNIX</code> 添加一个新设备，需要<strong>重新编译内核</strong>，将新的驱动程序装到二进制程序中。</p><p>然而随着大多数个人计算机的出现，由于 <code>I/O</code> 设备的广泛应用，上面这种静态编译的方式不再有效，因此，从 <code>MS-DOS</code> 开始，操作系统转向驱动程序在执行期间<strong>动态装载</strong>到系统中。</p><p>设备驱动程序接受到读写请求后，会检查当前设备是否在使用，如果设备在使用，请求被排入队列中，等待后续的处理。如果此时设备是空闲的，驱动程序会检查硬件以了解请求是否能够被处理。在传输开始前，会启动设备。等待设备就绪完成，再进行实际的控制。<strong>控制设备就是对设备发出指令。</strong></p><p>发出命令后，设备控制器便开始将它们写入控制器的<code>设备寄存器</code>。在将每个命令写入控制器后，会检查控制器是否接受了这条命令并准备接受下一个命令。一般控制设备会发出一系列的指令，这称为 <code>指令序列</code>，设备控制器会依次检查每个命令是否被接受，下一条指令是否能够被接收，直到所有的序列发出为止。</p><p>发出指令后，一般会有两种可能出现的情况。</p><ul><li>在大多数情况下，设备驱动程序会进行等待直到控制器完成它的事情。设备控制器会阻塞，直到中断来解除阻塞状态。</li><li>还有一种情况是操作是可以无延迟的完成，所以驱动程序不需要阻塞。</li></ul><p>设备驱动程序必须是<strong>可重入</strong>的，因为设备驱动程序会阻塞和唤醒然后再次阻塞。<strong>驱动程序不允许进行系统调用</strong>，但是它们通常需要与内核的其余部分进行交互。</p><h2 id="与设备无关的-io-软件"><a class="markdownIt-Anchor" href="#与设备无关的-io-软件"></a> 与设备无关的 I/O 软件</h2><p><code>设备无关性</code> 也就是不需要特定的设备。设备驱动程序与设备无关的软件之间的界限取决于具体的系统。</p><p>与设备无关的 I/O 软件的基本功能是<strong>执行对所有设备公共的 <code>I/O</code> 功能，并且向用户层软件提供一个统一的接口。</strong></p><h3 id="缓冲"><a class="markdownIt-Anchor" href="#缓冲"></a> 缓冲</h3><p>无论是对于块设备还是字符设备来说，缓冲都是一个非常重要的考量标准。下面是从 <code>ADSL(调制解调器)</code> 读取数据的过程。</p><p>用户程序调用 <code>read</code> 系统调用<strong>阻塞用户进程</strong>，等待字符的到来，这是对到来的字符进行处理的一种方式。每一个到来的字符都会造成中断。中断服务程序会给用户进程提供字符，并解除阻塞。将字符提供给用户程序后，进程会去读取其他字符并继续阻塞，这种模型如下：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201009142221.png" srcset="/img/loading.gif" alt="" /></p><p>这一种方案是没有缓冲区的存在，因为用户进程如果读不到数据会阻塞，直到读到数据为止，这种情况效率比较低，而且阻塞式的方式，会直接阻止用户进程做其他事情，这对用户来说是不能接受的。还有一种情况就是每次用户进程都会重启，对于每个字符的到来都会重启用户进程，这种效率会严重降低，所以无缓冲区的软件不是一个很好的设计。</p><p>作为一个改良点，我们可以尝试在<strong>用户空间中使用一个能读取 n 个字节缓冲区</strong>来读取 n 个字符。这样的话，中断服务程序会把字符放到缓冲区中直到缓冲区变满为止，然后再去唤醒用户进程。这种方案要比上面的方案改良很多。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201009142840.png" srcset="/img/loading.gif" alt="" /></p><p>但是这种方案也存在问题，当字符到来时，如果缓冲区被分页，会被调出内存。解决方案是把缓冲区锁定在内存中，但是这种方案也会出现问题，如果少量的缓冲区被锁定还好，如果大量的缓冲区被锁定在内存中，那么可以换进换出的页面就会收缩，造成系统性能的下降。</p><p>一种解决方案是在<strong>内核中内部创建一块缓冲区</strong>，让中断服务程序将字符放在内核内部的缓冲区中。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201009143125.png" srcset="/img/loading.gif" alt="" /></p><p>当内核中的缓冲区要满的时候，会将用户空间中的页面调入内存，然后将内核空间的缓冲区复制到用户空间的缓冲区中，这种方案也面临一个问题就是假如用户空间的页面被换入内存，此时内核空间的缓冲区已满，这时候仍有新的字符到来，这个时候会怎么办？因为缓冲区满了，没有空间来存储新的字符了。</p><p>一种非常简单的方式就是<strong>再设置一个缓冲区</strong>就行了，在第一个缓冲区填满后，在缓冲区清空前，使用第二个缓冲区，这种解决方式如下：</p><p>当第二个缓冲区也满了的时候，它也会把数据复制到用户空间中，然后第一个缓冲区用于接受新的字符。这种具有两个缓冲区的设计被称为 <code>双缓冲(double buffering)</code>。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201009143518.png" srcset="/img/loading.gif" alt="" /></p><p>还有一种缓冲形式是 <code>循环缓冲(circular buffer)</code>。它由一个内存区域和两个指针组成。一个指针指向下一个空闲字，新的数据可以放在此处。另外一个指针指向缓冲区中尚未删除数据的第一个字。在许多情况下，硬件会在添加新的数据时，移动第一个指针；而操作系统会在删除和处理无用数据时会移动第二个指针。两个指针到达顶部时就回到底部重新开始。</p><p>缓冲技术应用广泛，但它也有缺点。如果数据被缓冲次数太多，会影响性能。考虑例如如下这种情况，</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201009143601.png" srcset="/img/loading.gif" alt="" /></p><p>数据经过用户进程 -&gt; 内核空间 -&gt; 网络控制器，这里的网络控制器应该就相当于是 缓冲区，然后发送到网络上，再到接收方的网络控制器 -&gt; 接收方的内核缓冲 -&gt; 接收方的用户缓冲，一条数据包被缓存了太多次，很容易降低性能。</p><h3 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h3><p>I/O 错误的一类是程序员<strong>编程错误</strong>，比如还没有打开文件前就读流，或者不关闭流导致内存溢出等等。这类问题由程序员处理；</p><p>另外一类是<strong>实际的 <code>I/O</code> 错误</strong>，例如向一个磁盘坏块写入数据，无论怎么写都写入不了。这类问题由驱动程序处理，驱动程序处理不了交给硬件处理。</p><h3 id="分配和释放"><a class="markdownIt-Anchor" href="#分配和释放"></a> 分配和释放</h3><p>一些设备例如打印机，它只能由一个进程来使用，这就需要操作系统根据实际情况判断是否能够对设备的请求进行检查，判断是否能够接受其他请求，一种比较简单直接的方式是在特殊文件上执行 <code>open</code> 操作。如果设备不可用，那么直接 <code>open</code> 会导致失败。还有一种方式是不直接导致失败，而是让其阻塞，等到另外一个进程释放资源后，在进行 <code>open</code> 打开操作。这种方式就把选择权交给了用户，由用户判断是否应该等待。</p><h2 id="用户空间的-io-软件"><a class="markdownIt-Anchor" href="#用户空间的-io-软件"></a> 用户空间的 I/O 软件</h2><p>虽然大部分 I/O 软件都在内核结构中，但是还有一些在用户空间实现的 I/O 软件。一些 I/O 软件和库过程在用户空间存在，然后以提供系统调用的方式实现。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1208. 尽可能使字符串相等</title>
    <link href="/2020/09/29/LeetCode-1208-get-equal-substrings-within-budget/"/>
    <url>/2020/09/29/LeetCode-1208-get-equal-substrings-within-budget/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/" target="_blank" rel="noopener">1208. 尽可能使字符串相等</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">equalSubstring</span><span class="hljs-params">(String s, String t, <span class="hljs-keyword">int</span> maxCost)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] sChar = s.toCharArray();    <span class="hljs-keyword">char</span>[] tChar = t.toCharArray();    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> windowCost = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-comment">// 计算窗口内字符代价</span>        windowCost += Math.abs(sChar[right] - tChar[right]);        right++;        <span class="hljs-comment">// 收缩左边界</span>        <span class="hljs-keyword">if</span> (windowCost &gt; maxCost) &#123;            windowCost -= Math.abs(sChar[left] - tChar[left]);            left++;        &#125;        <span class="hljs-comment">// 计算最大长度</span>        maxLen = Math.max(maxLen, right - left);    &#125;    <span class="hljs-keyword">return</span> maxLen;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1052. 爱生气的书店老板</title>
    <link href="/2020/09/29/LeetCode-1052-grumpy-bookstore-owner/"/>
    <url>/2020/09/29/LeetCode-1052-grumpy-bookstore-owner/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/" target="_blank" rel="noopener">1052. 爱生气的书店老板</a></p><p>计算可补偿的最大值。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSatisfied</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] customers, <span class="hljs-keyword">int</span>[] grumpy, <span class="hljs-keyword">int</span> X)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = customers.length;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> windowComplement = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxComp = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">if</span> (grumpy[right] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 可补充的值</span>            windowComplement += customers[right];        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 原始值</span>            sum += customers[right];        &#125;        right++;        <span class="hljs-comment">// 窗口大小 = X</span>        <span class="hljs-keyword">if</span> (right - left &gt;= X) &#123;            maxComp = Math.max(maxComp, windowComplement);            <span class="hljs-keyword">if</span> (grumpy[left] == <span class="hljs-number">1</span>) &#123;                windowComplement -= customers[left];            &#125;            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> sum + maxComp;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSatisfied</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] customers, <span class="hljs-keyword">int</span>[] grumpy, <span class="hljs-keyword">int</span> X)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = customers.length;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> windowComplement = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxComp = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (grumpy[i] == <span class="hljs-number">0</span>) &#123;            sum += customers[i];            customers[i] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        windowComplement += customers[right];        right++;        <span class="hljs-comment">// 窗口大小 = X</span>        <span class="hljs-keyword">if</span> (right - left &gt;= X) &#123;            maxComp = Math.max(maxComp, windowComplement);            windowComplement -= customers[left];            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> sum + maxComp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1423. 可获得的最大点数</title>
    <link href="/2020/09/29/LeetCode-1423-maximum-points-you-can-obtain-from-cards/"/>
    <url>/2020/09/29/LeetCode-1423-maximum-points-you-can-obtain-from-cards/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">1423. 可获得的最大点数</a></p><p>左边取 <code>i</code> 个，则右边取 <code>k - i</code> 个，依次比较最大值。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cardPoints, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = cardPoints.length;    <span class="hljs-keyword">int</span> leftSum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> rightSum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 右边 k 个之和</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= len - k; i--) &#123;        rightSum += cardPoints[i];    &#125;    <span class="hljs-comment">// 左边取 0 个</span>    <span class="hljs-keyword">int</span> max = rightSum;    <span class="hljs-comment">// 从左边开始取 1 ~ k 个</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;        leftSum += cardPoints[i];        <span class="hljs-comment">// 减去右边多的部分: 1 -&gt; k - 1, 2 -&gt; k - 2......</span>        rightSum -= cardPoints[len - k + i];        max = Math.max(max, leftSum + rightSum);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 59 - II. 队列的最大值</title>
    <link href="/2020/09/29/LeetCode-offer-59-II-dui-lie-de-zui-da-zhi-lcof/"/>
    <url>/2020/09/29/LeetCode-offer-59-II-dui-lie-de-zui-da-zhi-lcof/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - II. 队列的最大值</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> </span>&#123;    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; queue;    <span class="hljs-keyword">private</span> ArrayDeque&lt;Integer&gt; deque;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 保存入队元素</span>        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-comment">// 最大值队列</span>        deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> deque.isEmpty() ? -<span class="hljs-number">1</span> : deque.peekFirst();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        queue.addLast(value);        <span class="hljs-comment">// 更新最大值</span>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value) &#123;            deque.pollLast();        &#125;        deque.addLast(value);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> front = queue.isEmpty() ? -<span class="hljs-number">1</span> : queue.pollFirst();        <span class="hljs-comment">// 出队元素为最大值，则从最大值队列中出队</span>        <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst().equals(front)) &#123;            deque.pollFirst();        &#125;        <span class="hljs-keyword">return</span> front;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
      <tag>队列</tag>
      
      <tag>剑指 Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1004. 最大连续1的个数 III</title>
    <link href="/2020/09/28/LeetCode-1004-max-consecutive-ones-iii/"/>
    <url>/2020/09/28/LeetCode-1004-max-consecutive-ones-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener">1004. 最大连续1的个数 III</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestOnes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> windowCount = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">if</span> (A[right] == <span class="hljs-number">1</span>) &#123;            windowCount++;        &#125;        right++;        <span class="hljs-comment">// 可替换的 0 个数 &gt; K, 收缩左边界</span>        <span class="hljs-keyword">while</span> (right - left - windowCount &gt; K) &#123;            <span class="hljs-keyword">if</span> (A[left] == <span class="hljs-number">1</span>) &#123;                windowCount--;            &#125;            left++;        &#125;        max = Math.max(max, right - left);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 485. 最大连续1的个数</title>
    <link href="/2020/09/28/LeetCode-485-max-consecutive-ones/"/>
    <url>/2020/09/28/LeetCode-485-max-consecutive-ones/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">485. 最大连续1的个数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxConsecutiveOnes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;            count++;        &#125; <span class="hljs-keyword">else</span> &#123;            max = Math.max(max, count);            count = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> Math.max(max, count);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxConsecutiveOnes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">if</span> (nums[right] == <span class="hljs-number">0</span>) &#123;            max = Math.max(right - left, max);            left = right + <span class="hljs-number">1</span>;        &#125;        right++;    &#125;    <span class="hljs-keyword">return</span> Math.max(right - left, max);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1456. 定长子串中元音的最大数目</title>
    <link href="/2020/09/28/LeetCode-1456-maximum-number-of-vowels-in-a-substring-of-given-length/"/>
    <url>/2020/09/28/LeetCode-1456-maximum-number-of-vowels-in-a-substring-of-given-length/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">1456. 定长子串中元音的最大数目</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxVowels</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span> validLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">char</span>[] vowels = &#123;<span class="hljs-string">'a'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'u'</span>&#125;;    <span class="hljs-keyword">int</span>[] needs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : vowels) &#123;        needs[c - <span class="hljs-string">'a'</span>]++;    &#125;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">int</span> cur = chars[right] - <span class="hljs-string">'a'</span>;        <span class="hljs-comment">// 当前字符为元音</span>        <span class="hljs-keyword">if</span> (needs[cur] &gt; <span class="hljs-number">0</span>) &#123;            validLen++;        &#125;        right++;        <span class="hljs-comment">// 长度满足要求，寻找最优解，收缩左边界</span>        <span class="hljs-keyword">if</span> (right - left == k) &#123;            max = Math.max(max, validLen);            <span class="hljs-keyword">int</span> leftPos = chars[left] - <span class="hljs-string">'a'</span>;            <span class="hljs-comment">// 当前字符为元音</span>            <span class="hljs-keyword">if</span> (needs[leftPos] &gt; <span class="hljs-number">0</span>) &#123;                validLen--;            &#125;            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
    <link href="/2020/09/28/LeetCode-offer-59-I-hua-dong-chuang-kou-de-zui-da-zhi-lcof/"/>
    <url>/2020/09/28/LeetCode-offer-59-I-hua-dong-chuang-kou-de-zui-da-zhi-lcof/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;&#125;;    &#125;    ArrayDeque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len - k + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt; nums[i]) &#123;            queue.removeLast();        &#125;        queue.addLast(i);        <span class="hljs-keyword">if</span> (queue.peekFirst() &lt;= i - k) &#123;            queue.removeFirst();        &#125;        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;            res[j++] = nums[queue.peekFirst()];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
      <tag>队列</tag>
      
      <tag>剑指 Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 文件系统</title>
    <link href="/2020/09/28/os-file-system/"/>
    <url>/2020/09/28/os-file-system/</url>
    
    <content type="html"><![CDATA[<h1 id="文件"><a class="markdownIt-Anchor" href="#文件"></a> 文件</h1><h2 id="文件命名"><a class="markdownIt-Anchor" href="#文件命名"></a> 文件命名</h2><p>文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用名称访问该文件。</p><p>文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。</p><p>某些文件区分大小写字母，而大多数则不区分。<code>UNIX</code> 属于第一类；历史悠久的 <code>MS-DOS</code> 属于第二类；因此，<code>UNIX</code> 系统会有三种不同的命名文件：<code>maria</code>、<code>Maria</code>、<code>MARIA</code> 。在 <code>MS-DOS</code>，所有这些命名都属于相同的文件。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928152723.png" srcset="/img/loading.gif" alt="" /></p><ul><li><p>在 <code>UNIX</code> 系统中，文件扩展名只是一种约定，操作系统并不强制采用。</p></li><li><p>与 <code>UNIX</code> 相反，<code>Windows</code> 就会关注扩展名并对扩展名赋予了新的含义。用户(或进程) 可以在操作系统中注册扩展名，并且规定哪个程序能够拥有扩展名。当用户双击某个文件名时，拥有该文件名的程序就启动并运行文件。</p></li></ul><h2 id="文件结构"><a class="markdownIt-Anchor" href="#文件结构"></a> 文件结构</h2><p>文件的构造有多种方式。下图列出了常用的三种构造方式：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928153020.png" srcset="/img/loading.gif" alt="" /></p><p>上图中的 a 是一种<strong>无结构的字节序列</strong>，操作系统不关心序列的内容是什么，操作系统能看到的就是字节(bytes)。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。</p><p>把文件看成字节序列提供了最大的灵活性。用户程序可以向文件中写任何内容，并且可以通过任何方便的形式命名。操作系统不会为为用户写入内容提供帮助，当然也不会干扰阻塞你。对于想做特殊操作的用户来说，后者是十分重要的。所有的 UNIX 版本（包括 Linux 和 OS X）和 Windows 都使用这种文件模型。</p><p>图 b 表示在文件结构上的第一步改进。在这个模型中，文件是具有固定长度记录的序列，每个记录都有其内部结构。 把文件作为记录序列的核心思想是：读操作返回一个记录，而写操作重写或者追加一个记录。</p><p>第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗记录树构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个key 字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。</p><p>在记录树的结构中，可以取出下一个记录，但是最关键的还是根据 key 搜索指定的记录。如上图 c 所示，用户可以读出指定的 pony 记录，而不必关心记录在文件中的确切位置。用户也可以在文件中添加新的记录。但是用户不能决定添加到何处位置，添加到何处位置是由操作系统决定的。</p><h2 id="文件类型"><a class="markdownIt-Anchor" href="#文件类型"></a> 文件类型</h2><p>很多操作系统支持多种文件类型。例如，<code>UNIX</code>（同样包括 <code>OS X</code>）和 <code>Windows</code> 都具有常规的文件和目录。除此之外，<code>UNIX</code> 还具有 <code>字符特殊文件(character special file)</code> 和 <code>块特殊文件(block special file)</code>。</p><ul><li><code>常规文件(Regular files)</code> 是包含有用户信息的文件。用户一般使用的文件大都是常规文件，常规文件一般包括 可执行文件、文本文件、图像文件，从常规文件读取数据或将数据写入时，内核会根据文件系统的规则执行操作，是写入可能被延迟，记录日志或者接受其他操作。</li><li>字符特殊文件和输入/输出有关，用于串行 <code>I/O</code> 类设备，如终端、打印机、网络等。</li><li>块特殊文件用于磁盘类设备。</li></ul><p>常规文件一般分为 <code>ASCII</code> 码文件或者<code>二进制文件</code>。<code>ASCII</code> 码文件由文本组成。在一些系统中，每行都会用回车符结束（ASCII码是13，控制字符 CR，转义字符\r。），另外一些则会使用换行符（ASCII码是10，控制字符LF，转义字符\n）。一些系统（比如 Windows）两者都会使用。</p><p><code>ASCII</code> 文件的优点在于<strong>显示</strong> 和 <strong>打印</strong>，还可以用任何文本编辑器进行编辑。进一步来说，如果许多应用程序使用 <code>ASCII</code> 码作为输入和输出，那么很容易就能够把多个程序连接起来，一个程序的输出可能是另一个程序的输入，就像管道一样。</p><p>其他与 <code>ASCII</code> 不同的是二进制文件。打印出来的二进制文件是无法理解的。下面是一个二进制文件的格式，它取自早期的 UNIX 。尽管从技术上来看这个文件只是字节序列，但是操作系统只有在文件格式正确的情况下才会执行。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928155756.png" srcset="/img/loading.gif" alt="" /></p><p>这个文件有五个段：文件头、正文、数据、重定位和符号表。文件头以 <code>魔数(magic number)</code> 为开始，表明这个文件是一个可执行文件。然后是文件各个部分的大小，开始执行的标志以及一些标志位。程序本身的正文和数据在文件头后面，他们被加载到内存中或者重定位会根据重定位位进行判断。符号表则用于调试。</p><p>二进制文件的另外一种形式是存档文件，它由已编译但没有链接的库过程（模块）组合而成。每个文件都以模块头开始，其中记录了名称、创建日期、所有者、保护码和文件大小。和可执行文件一样，模块头也都是二进制数，将它们复制到打印机将会产生乱码。</p><p>当程序从文件中读写数据时，请求会转到 <code>内核处理程序(kernel driver)</code>。如果文件是常规文件，则数据由文件系统驱动程序处理，并且通常存储在磁盘或其他存储介质上的某块区域中，从文件中读取的数据就是之前在该位置写入的数据。</p><p>当数据读取或写入到设备文件时，请求会被设备驱动程序处理。每个设备文件都有一个关联的编号，该编号标示要使用的设备驱动程序。设备处理数据的工作是它自己的事。</p><ul><li><code>块设备</code> 也叫做块特殊文件，它的行为通常与普通文件相似：它们是字节数组，并且在给定位置读取的值是最后写入该位置的值。来自块设备的数据可以缓存在内存中，并从缓存中读取；写入可以被缓冲。块设备通常是可搜索的，块设备的概念是，相应的硬件可以一次读取或者写入整个块，例如磁盘上的一个扇区</li><li><code>字符设备</code> 也称为字符特殊文件，它的行为类似于管道、串行端口。将字节写入字符设备可能会导致它在屏幕上显示，在串行端口上输出，转换为声音。</li><li><code>目录(Directories)</code> 是管理文件系统结构的系统文件。它是用于在计算机上存储文件的位置。目录位于分层文件系统中，例如 Linux，MS-DOS 和 UNIX。</li></ul><h2 id="文件访问"><a class="markdownIt-Anchor" href="#文件访问"></a> 文件访问</h2><p>早期的操作系统只有一种访问方式：<code>序列访问(sequential access)</code>。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。</p><p>在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为<code>随机访问文件(random access file)</code>。许多应用程序都需要这种方式。</p><p>随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。</p><h1 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h1><p>文件系统通常提供 <code>目录(directories)</code> 或者 <code>文件夹(folders)</code> 用于记录文件的位置，在很多系统中目录本身也是文件。</p><h2 id="一级目录系统"><a class="markdownIt-Anchor" href="#一级目录系统"></a> 一级目录系统</h2><p>目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为 <code>根目录(root directory)</code>，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928161552.png" srcset="/img/loading.gif" alt="" /></p><p>该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。</p><h2 id="层次目录系统"><a class="markdownIt-Anchor" href="#层次目录系统"></a> 层次目录系统</h2><p>对于简单的应用而言，一般都用单层目录方式，但是这种组织形式并不适合于现代计算机，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了 <code>层次目录系统(Hierarchical Directory Systems)</code>，也称为<code>目录树</code>。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928161630.png" srcset="/img/loading.gif" alt="" /></p><p>根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户各自创建了子目录。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的。</p><h2 id="路径名"><a class="markdownIt-Anchor" href="#路径名"></a> 路径名</h2><p>当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个 <code>绝对路径名(absolute path name)</code>，它由根目录到文件的路径组成。在 <code>UNIX</code> 中，路径的组件由 <code>/</code> 分隔。在 <code>Windows</code> 中，分隔符为 <code>\</code>。 在 <code>MULTICS</code> 中，它是 <code>&gt;</code>。 因此，在这三个系统中，相同的路径名将被编写如下</p><pre><code class="hljs properties"><span class="hljs-attr">Windows</span> <span class="hljs-string">\usr\ast\mailbox </span><span class="hljs-attr">UNIX</span> <span class="hljs-string">/usr/ast/mailbox </span><span class="hljs-attr">MULTICS</span> <span class="hljs-string">&gt;usr&gt;ast&gt;mailbox</span></code></pre><p>不论使用哪种方式，如果路径名的第一个字符是分隔符，那就是绝对路径。</p><p>另外一种指定文件名的方法是 <code>相对路径名(relative path name)</code>。它常常和 <code>工作目录(working directory)</code> （也称作 <code>当前目录(current directory)</code>）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 /usr/ast，那么绝对路径 /usr/ast/mailbox可以直接使用 mailbox 来引用。也就是说，如果工作目录是 /usr/ast，则 UNIX 命令</p><pre><code class="hljs awk">cp <span class="hljs-regexp">/usr/</span>ast<span class="hljs-regexp">/mailbox  /u</span>sr<span class="hljs-regexp">/ast/m</span>ailbox.bak</code></pre><p>和命令</p><pre><code class="hljs avrasm"><span class="hljs-keyword">cp</span> mailbox mailbox.bak</code></pre><p>具有相同的含义。相对路径通常情况下更加方便和简洁。而它实现的功能和绝对路径安全相同。<br />一些程序需要访问某个特定的文件而不必关心当前的工作目录是什么。在这种情况下，应该使用绝对路径名。</p><p>支持层次目录结构的大多数操作系统在每个目录中有两个特殊的目录项 <code>.</code> 和 <code>..</code>，分别读作 <code>dot</code> 和 <code>dotdot</code>。<code>dot</code> 指的是当前目录，<code>dotdot</code> 指的是其父目录（在根目录中例外，在根目录中指向自己）。可以参考下面的进程树来查看如何使用。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928162121.png" srcset="/img/loading.gif" alt="" /><br />一个进程的工作目录是 <code>/usr/ast</code>。</p><pre><code class="hljs crystal">cp ../<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">dictionary</span> .</span>cp /usr/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">dictionary</span> .</span>cp /usr/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">dictionary</span> <span class="hljs-title">dictionary</span></span>cp /usr/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">dictionary</span> /<span class="hljs-title">usr</span>/<span class="hljs-title">lib</span>/<span class="hljs-title">dictionary</span></span></code></pre><h1 id="文件系统的实现"><a class="markdownIt-Anchor" href="#文件系统的实现"></a> 文件系统的实现</h1><h2 id="文件系统布局"><a class="markdownIt-Anchor" href="#文件系统布局"></a> 文件系统布局</h2><p>文件系统存储在磁盘中。大部分的磁盘能够划分出一到多个分区，叫做 <code>磁盘分区(disk partitioning)</code> 或者是 <code>磁盘分片(disk slicing)</code>。<strong>每个分区都有独立的文件系统</strong>，每块分区的文件系统可以不同。磁盘的 <code>0</code> 号分区称为 <code>主引导记录(Master Boot Record, MBR)</code>，用来 <code>引导(boot)</code> 计算机。在 <code>MBR</code> 的结尾是 <code>分区表(partition table)</code>。每个分区表给出每个分区由开始到结束的地址。系统管理员使用一个称为分区编辑器的程序来创建，调整大小，删除和操作分区。这种方式的一个缺点是<strong>很难适当调整分区的大小</strong>，导致一个分区具有很多可用空间，而另一个分区几乎完全被分配。</p><p><code>MBR</code> 可以用在 <code>DOS</code> 、<code>Microsoft Windows</code> 和 <code>Linux</code> 操作系统中。从 2010 年代中期开始，大多数新计算机都改用 <code>GUID 分区表（GPT）</code>分区方案。</p><p>当计算机开始引 <code>boot</code> 时，<code>BIOS</code> 读入并执行 <code>MBR</code>。</p><h3 id="引导块"><a class="markdownIt-Anchor" href="#引导块"></a> 引导块</h3><p><code>MBR</code> 做的第一件事就是<strong>确定活动分区</strong>，读入它的第一个块，称为 <code>引导块(boot block)</code> 并执行。引导块中的程序将加载分区中的操作系统。为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统。引导块占据文件系统的前 <code>4096</code> 个字节，从磁盘上的字节偏移量 <code>0</code> 开始。引导块可用于启动操作系统。</p><blockquote><p>在计算机中，引导就是启动计算机的过程，它可以通过硬件（例如按下电源按钮）或者软件命令的方式来启动。开机后，电脑的 <code>CPU</code> 还不能执行指令，因为此时没有软件在主存中，所以一些软件必须先被加载到内存中，然后才能让 <code>CPU</code> 开始执行。也就是计算机开机后，首先会进行软件的装载过程。</p><p>重启电脑的过程称为 <code>重新引导(rebooting)</code>，从休眠或睡眠状态返回计算机的过程不涉及启动。</p></blockquote><p>除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。通常文件系统会包含一些属性，如下：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928163718.png" srcset="/img/loading.gif" alt="" /></p><h3 id="超级块"><a class="markdownIt-Anchor" href="#超级块"></a> 超级块</h3><p><code>超级块(Superblock)</code> 的大小为 <code>4096</code> 字节，从磁盘上的字节偏移 <code>4096</code> 开始。超级块包含文件系统的所有关键参数</p><ul><li><p>文件系统的大小</p></li><li><p>文件系统中的数据块数</p></li><li><p>指示文件系统状态的标志</p></li><li><p>分配组大小</p></li></ul><p>在计算机启动或者文件系统首次使用时，超级块会被读入内存。</p><h3 id="空闲空间块"><a class="markdownIt-Anchor" href="#空闲空间块"></a> 空闲空间块</h3><p>接着是文件系统中空闲块的信息，例如，可以用位图或者指针列表的形式给出。</p><ul><li><code>BitMap</code> 位图或者 <code>Bit vector</code> 位向量</li></ul><p>位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：<code>0</code>和 <code>1</code>，<code>0</code> 表示已分配该块，而 <code>1</code> 表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用 <code>16位</code> 的位图表示为：<code>0000111000000110</code>。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928164045.png" srcset="/img/loading.gif" alt="" /></p><ul><li>使用链表进行管理</li></ul><p>在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928164130.png" srcset="/img/loading.gif" alt="" /></p><h3 id="碎片"><a class="markdownIt-Anchor" href="#碎片"></a> 碎片</h3><p><code>碎片(fragment)</code> 也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。如果你不理解这个概念就给你举个例子。比如你用 Windows 电脑创建了一个文件，你会发现这个文件可以存储在任何地方，比如存在桌面上，存在磁盘中的文件夹中或者其他地方。你可以打开文件，编辑文件，删除文件等等。你可能以为这些都在一个地方发生，但是实际上并不是，你的硬盘驱动器可能会将文件中的一部分存储在一个区域内，另一部分存储在另外一个区域，在你打开文件时，硬盘驱动器会迅速的将文件的所有部分汇总在一起，以便其他计算机系统可以使用它。</p><h3 id="inode"><a class="markdownIt-Anchor" href="#inode"></a> inode</h3><p><code>inode(index node)</code> 也称作索引节点。它是一个数组的结构，每个文件有一个 <code>inode</code>，<code>inode</code> 非常重要，它说明了文件的方方面面。每个索引节点都存储对象数据的属性和磁盘块位置。</p><p><code>inode</code> 节点主要包括了以下信息</p><ul><li><p>模式/权限（保护）</p></li><li><p>所有者 ID</p></li><li><p>组 ID</p></li><li><p>文件大小</p></li><li><p>文件的硬链接数</p></li><li><p>上次访问时间</p></li><li><p>最后修改时间</p></li><li><p><code>inode</code> 上次修改时间</p></li></ul><p>文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 <code>inode</code> 的数量，也不能增加磁盘块的数量。</p><p>紧跟在 <code>inode</code> 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。</p><h2 id="文件的实现"><a class="markdownIt-Anchor" href="#文件的实现"></a> 文件的实现</h2><p>最重要的问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用了不同的方法。下面我们会探讨一下这些方式。分配背后的主要思想是<strong>有效利用文件空间和快速访问文件</strong>，主要有三种分配方案</p><ul><li>连续分配</li><li>链表分配</li><li>索引分配</li></ul><h3 id="1-连续分配"><a class="markdownIt-Anchor" href="#1-连续分配"></a> 1. 连续分配</h3><blockquote><p><code>CD-ROM</code>, <code>DVD</code>, 蓝光光盘使用了连续分配方式。</p></blockquote><p>最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929143042.png" srcset="/img/loading.gif" alt="" /></p><p>连续的磁盘空间分配有两个优点。</p><ul><li><p>第一，连续文件存储<strong>实现起来比较简单</strong>，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。</p></li><li><p>第二点是<strong>读取性能比较强</strong>，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。</p></li></ul><p>因此，连续的空间分配具有<strong>实现简单、高性能</strong>的特点。</p><p>但是随着时间的推移，磁盘会变得很零碎。下图解释了这种现象：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929143412.png" srcset="/img/loading.gif" alt="" /></p><p>这里有两个文件 <code>D</code> 和 <code>F</code> 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。</p><p>刚开始的时候，这个碎片不是问题，因为每个新文件都会在之前文件的结尾处进行写入。然而，磁盘最终会被填满，<strong>因此要么压缩磁盘、要么重新使用空闲块的空间</strong>。</p><ul><li>压缩磁盘的开销太大，因此不可行；</li><li>重新使用空闲块的空间会维护一个<strong>空闲列表</strong>，这个是可行的。但是这种情况又存在一个问题，为空闲块匹配合适大小的文件，需要知道该文件的最终大小。</li></ul><h3 id="2-链表分配"><a class="markdownIt-Anchor" href="#2-链表分配"></a> 2. 链表分配</h3><p>第二种存储文件的方式是为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929144116.png" srcset="/img/loading.gif" alt="" /></p><p>每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。整个的链表分配方案：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929144259.png" srcset="/img/loading.gif" alt="" /></p><p>与连续分配方案不同，这一方法<strong>可以充分利用每个磁盘块</strong>。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。</p><ul><li><p>在链表的分配方案中，尽管顺序读取非常方便，但是随机访问却很困难。</p></li><li><p>由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 <code>2</code> 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 <code>2</code> 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以<strong>要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销</strong>。</p></li></ul><h3 id="3-使用内存表进行链表分配"><a class="markdownIt-Anchor" href="#3-使用内存表进行链表分配"></a> 3. 使用内存表进行链表分配</h3><p>由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足之处。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929144918.png" srcset="/img/loading.gif" alt="" /></p><p>上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 <code>A</code> 依次使用了磁盘块地址 <strong>4</strong>、<strong>7</strong>、 <strong>2</strong>、 <strong>10</strong>、 <strong>12</strong>，文件 B 使用了<strong>6</strong>、<strong>3</strong>、<strong>11</strong> 和 <strong>14</strong>。也就是说，文件 <code>A</code> 从地址 <code>4</code> 处开始，顺着链表走就能找到文件 <code>A</code> 的全部磁盘块。同样，从第 <code>6</code> 块开始，顺着链走到最后，也能够找到文件 <code>B</code> 的全部磁盘块。这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为 <code>文件分配表(File Application Table, FAT)</code>。</p><p>使用这种组织方式，整个块都可以存放数据。进而，随机访问也容易很多。虽然仍要顺着链在内存中查找给定的偏移量，但是整个链都存放在内存中，所以不需要任何磁盘引用。与前面的方法相同，不管文件有多大，在目录项中只需记录一个整数（起始块号），按照它就可以找到文件的全部块。</p><p>这种方式存在缺点，那就是<strong>必须要把整个链表放在内存中</strong>。对于 1TB 的磁盘和 1KB 的大小的块，那么这张表需要有 10 亿项。每一项对应于这 10 亿个磁盘块中的一块。每项至少 3 个字节，为了提高查找速度，有时需要 4 个字节。根据系统对空间或时间的优化方案，这张表要占用 3GB 或 2.4GB 的内存。FAT 的管理方式不能较好地扩展并应用于大型磁盘中。而这正是最初 MS-DOS 文件比较实用，并仍被各个 Windows 版本所完全支持。</p><h3 id="4-inode"><a class="markdownIt-Anchor" href="#4-inode"></a> 4. inode</h3><p>最后一个记录各个文件分别包含哪些磁盘块的方法是给每个文件赋予一个称为 <code>inode(索引节点)</code> 的数据结构，每个文件都与一个 <code>inode</code> 进行关联，<code>inode</code> 由整数进行标识。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929150217.png" srcset="/img/loading.gif" alt="" /></p><p>给出 <code>inode</code> 的长度，就能够找到文件中的所有块。</p><p>相对于在内存中使用表的方式而言，这种机制具有很大的优势。即<strong>只有在文件打开时，其 <code>inode</code> 才会在内存中</strong>。如果每个 <code>inode</code> 需要 <code>n</code> 个字节，最多 <code>k</code> 个文件同时打开，那么 <code>inode</code> 占有总共打开的文件是 <code>kn</code> 字节。仅需预留这么多空间。</p><p>这个数组要比我们上面描述的 <code>FAT(文件分配表)</code> 占用的空间小的多。原因是<strong>用于保存所有磁盘块的链接列表的表的大小与磁盘本身成正比</strong>。如果磁盘有 <code>n</code> 个块，那么这个表也需要 <code>n</code> 项。随着磁盘空间的变大，那么该表也随之线性增长。相反，<code>inode</code> 需要在内存中有数组，其大小和可能需要打开的最大文件个数成正比。它与磁盘是 <code>100GB</code>、<code>4000GB</code> 还是 <code>10000GB</code> 无关。</p><p><code>inode</code> 的一个问题是如果每个节点都会有固定大小的磁盘地址，那么文件增长到所能允许的最大容量外会发生什么？一个解决方案是<strong>最后一个磁盘地址不指向数据块</strong>，而是指向一个包含额外磁盘块地址的地址，如上图所示。一个更高级的解决方案是：<strong>有两个或者更多包含磁盘地址的块，或者指向其他存放地址的磁盘块的磁盘块。</strong> <code>Windows</code> 的 <code>NTFS</code> 文件系统采用了相似的方法，所不同的仅仅是大的 <code>inode</code> 也可以表示小的文件。</p><blockquote><p><code>NTFS</code> 的全称是 <code>New Technology File System</code>，是微软公司开发的专用系统文件，<code>NTFS</code> 取代 <code>FAT(文件分配表)</code> 和 <code>HPFS(高性能文件系统)</code>，并在此基础上进一步改进。例如增强对元数据的支持，使用更高级的数据结构以提升性能、可靠性和磁盘空间利用率等。</p></blockquote><h2 id="目录的实现"><a class="markdownIt-Anchor" href="#目录的实现"></a> 目录的实现</h2><p>文件只有打开后才能够被读取。在文件打开后，操作系统会使用用户提供的路径名来定位磁盘中的目录。目录项提供了查找文件磁盘块所需要的信息。根据系统的不同，提供的信息也不同，可能提供的信息是整个文件的磁盘地址，或者是第一个块的数量（两个链表方案）或 inode 的数量。不过不管用哪种情况，目录系统的主要功能就是 <strong>将文件的 <code>ASCII</code> 码的名称映射到定位数据所需的信息上。</strong></p><p>与此关系密切的问题是属性应该存放在哪里。每个文件系统包含不同的文件属性，例如文件的所有者和创建时间，需要存储的位置。一种显而易见的方法是直接把文件属性存放在目录中。有一些系统恰好是这么做的，如下：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929151603.png" srcset="/img/loading.gif" alt="" /></p><p>在这种简单的设计中，目录有一个固定大小的目录项列表，每个文件对应一项，其中包含一个固定长度的文件名，文件属性的结构体以及用以说明磁盘块位置的一个或多个磁盘地址。</p><p>对于采用 <code>inode</code> 的系统，会把 <code>inode</code> 存储在属性中而不是目录项中。在这种情况下，目录项会更短：仅仅只有文件名称和 <code>inode</code> 数量。这种方式如下所示：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929151753.png" srcset="/img/loading.gif" alt="" /></p><h3 id="可变长度扩展名"><a class="markdownIt-Anchor" href="#可变长度扩展名"></a> 可变长度扩展名</h3><p>到目前为止，我们已经假设文件具有较短的、固定长度的名字。在 <code>MS-DOS</code> 中，具有 1 - 8 个字符的基本名称和 1 - 3 个字符的可拓展名称。在 <code>UNIX</code> 版本 7 中，文件有 1 - 14 个字符，包括任何拓展。然而，几乎所有的现代操作系统都支持可变长度的扩展名。这是如何实现的呢？</p><p>最简单的方式是给予文件名一个长度限制，比如 255 个字符，然后使用上图中的设计，并为每个文件名保留 255 个字符空间。这种处理很简单，但是浪费了大量的目录空间，因为只有很少的文件会有那么长的文件名称。所以，需要一种其他的结构来处理。</p><p>一种可选择的方式是放弃所有目录项大小相同的想法。在这种方法中，每个目录项都包含一个固定部分，这个固定部分通常以目录项的长度开始，后面是固定格式的数据，通常包括所有者、创建时间、保护信息和其他属性。这个固定长度的头的后面是一个任意长度的实际文件名，如下图所示：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929151951.png" srcset="/img/loading.gif" alt="" /></p><p>这个例子中，有三个文件，分别是 <code>project-budget</code>、<code>personnel</code> 和 <code>foo</code>。每个文件名以一个特殊字符（通常是 0 ）结束，用矩形中的叉进行表示。为了使每个目录项从字的边界开始，每个文件名被填充成整数个字，如下图所示</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929152139.png" srcset="/img/loading.gif" alt="" /></p><p>这个方法的缺点是当文件被移除后，就会留下一块固定长度的空间，而新添加进来的文件大小不一定和空闲空间大小一致。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929152203.png" srcset="/img/loading.gif" alt="" /></p><p>这个问题与我们上面探讨的连续磁盘文件的问题是一样的，由于整个目录在内存中，所以只有对目录进行<strong>紧凑拼接</strong>操作才可节省空间。另一个问题是，一个目录项可能会分布在多个页上，在读取文件名时可能发生<strong>缺页中断</strong>。</p><p>处理可变长度文件名字的另外一种方法是，<strong>使目录项自身具有固定长度，而将文件名放在目录末尾的堆栈中。</strong> 如上图所示的这种方式。这种方法的优点是当目录项被移除后，下一个文件将能够正常匹配移除文件的空间。当然，必须要对堆进行管理，因为在处理文件名的时候也会发生缺页异常。</p><h3 id="加快文件查找"><a class="markdownIt-Anchor" href="#加快文件查找"></a> 加快文件查找</h3><p>到目前为止的所有设计中，在需要查找文件名时，所有的方案都是线性的从头到尾对目录进行搜索。对于特别长的目录，线性搜索的效率很低。提高文件检索效率的一种方式是在每个目录上使用 <code>哈希表(hash table)</code>。</p><ul><li><p>添加：无论采用哪种方式，<strong>在添加一个文件时都要对与散列值相对 应的散列表进行检查。</strong> 如果没有使用过，就会将一个指向目录项的指针指向这里。文件目录项紧跟着哈希表后面。如果已经使用过，就会构造一个链表，链表的表头指针存放在表项中，并通过哈希值将所有的表项相连。</p></li><li><p>查找：查找文件的过程和添加类似，首先对文件名进行哈希处理，在哈希表中查找是否有这个哈希值，如果有的话，就检查这条链上所有的哈希项，查看文件名是否存在。如果哈希不在链上，那么文件就不在目录中。</p></li></ul><p>使用哈希表的优势是查找非常迅速，缺点是管理起来非常复杂。只有在系统中会有成千上万个目录项存在时，才会考虑使用散列表作为解决方案。</p><p>另外一种在大量目录中加快查找指令目录的方法是使用<code>缓存</code>，缓存查找的结果。在开始查找之前，会首先检查文件名是否在缓存中。如果在缓存中，那么文件就能立刻定位。当然，只有在较少的文件下进行多次查找，缓存才会发挥最大功效。</p><h2 id="共享文件"><a class="markdownIt-Anchor" href="#共享文件"></a> 共享文件</h2><p>当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图我们在上面提到过，但是有一个更改的地方，就是 <code>C</code> 的一个文件也出现在了 <code>B</code> 的目录下。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929153128.png" srcset="/img/loading.gif" alt="" /></p><p>如果按照如上图的这种组织方式而言，那么 <code>B</code> 的目录与该共享文件的联系称为 <code>链接(link)</code>。那么文件系统现在就是一个 <code>有向无环图(Directed Acyclic Graph, 简称 DAG)</code>，而不是一棵树了。</p><p>将文件系统组织成为有向无环图会使得维护复杂化，但也是必须要付出的代价。</p><p>共享文件很方便，但这也会带来一些问题。<strong>如果目录中包含磁盘地址，则当链接文件时，必须把 <code>C</code> 目录中的磁盘地址复制到 <code>B</code> 目录中。</strong> 如果 <code>B</code> 或者 <code>C</code> 随后又向文件中添加内容，则仅在执行追加的用户的目录中显示新写入的数据块。这种变更将会对其他用户不可见，从而破坏了共享的目的。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929153402.png" srcset="/img/loading.gif" alt="" /></p><p>有两种方案可以解决这种问题。</p><ul><li><p>第一种解决方案，<strong>磁盘块不列入目录中</strong>，而是会把磁盘块放在与文件本身相关联的 <code>inode</code> 中。目录将指向这个 <code>inode</code>。这是 <code>UNIX</code> 中使用的方式。</p></li><li><p>在第二种解决方案中，通过让系统建立一个类型为 <code>LINK</code> 的新文件，并把该文件放在 <code>B</code> 的目录下，使得 <code>B</code> 与 <code>C</code> 建立链接。新的文件中只包含了它所链接的文件的路径名。当 <code>B</code> 想要读取文件时，操作系统会检查 <code>B</code> 的目录下存在一个类型为 <code>LINK</code> 的文件，进而找到该链接的文件和路径名，然后再去读文件，这种方式称为 <code>符号链接(symbolic linking)</code>。</p></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929153627.png" srcset="/img/loading.gif" alt="" /></p><h2 id="日志结构文件系统"><a class="markdownIt-Anchor" href="#日志结构文件系统"></a> 日志结构文件系统</h2><p><code>日志结构文件系统(Log-structured File System, LFS)</code> 旨在解决以下问题：</p><ul><li><p>不断增长的系统内存</p></li><li><p>顺序 <code>I/O</code> 性能胜过随机 <code>I/O</code> 性能</p></li><li><p>现有低效率的文件系统</p></li><li><p>文件系统不支持 <code>RAID（虚拟化）</code></p></li></ul><p>不论是 <code>UNIX</code> 还是 <code>FFS</code>，都有大量的随机读写，因此成为整个系统的性能瓶颈。同时因为 <code>Page cache</code> 的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 <code>cache</code>，因此 <code>LFS</code> 主要要解决的是<strong>减少对硬盘的随机写操作</strong>。</p><p>在这种设计中，<code>inode</code> 甚至具有与 <code>UNIX</code> 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，<code>inode</code> 很难定位。为了能够找到 <code>inode</code> ，维护了一个由 <code>inode</code> 索引的 <code>inode map</code>。表项 <code>i</code> 指向磁盘中的第 <code>i</code> 个 <code>inode</code>。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。</p><blockquote><p>日志结构文件系统主要使用四种数据结构：<code>Inode</code>、<code>Inode Map</code>、<code>Segment</code>、<code>Segment Usage Table</code>。</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929160054.png" srcset="/img/loading.gif" alt="" /></p><p>到目前为止，所有写入最初都缓存在内存中，并且追加在日志末尾，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。</p><p>真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 <code>inode</code> 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。</p><p>为了处理这个问题，LFS 有一个 <code>清理（clean）线程</code>，<strong>它会循环扫描日志并对日志进行压缩</strong>。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 <code>inode</code> 的映射来查看 <code>inode</code> 否在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 <code>inode</code> 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的环形缓冲区，写线程将新的段写在前面，而清理线程则清理后面的段。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929160520.png" srcset="/img/loading.gif" alt="" /></p><h2 id="日志文件系统"><a class="markdownIt-Anchor" href="#日志文件系统"></a> 日志文件系统</h2><p>虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做日志文件系统，它会保存一个系统下一步将要做什么的日志。微软的 <code>NTFS</code> 文件系统、<code>Linux</code> 的 <code>ext3</code> 就使用了日志。 <code>OS X</code> 将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如 <code>移除文件</code>，这个操作在 <code>UNIX</code> 中需要三个步骤完成：</p><ol><li>在目录中删除文件</li><li>释放 <code>inode</code> 到空闲 <code>inode</code> 池</li><li>将所有磁盘块归还给空闲磁盘池。</li></ol><p>为了让日志能够正确工作，被写入的日志操作必须是 <code>幂等的(idempotent)</code>，它意味着只要有必要，它们就可以重复执行很多次，并不会带来破坏。像操作 <code>更新位表并标记 inode k 或者块 n 是空闲的</code> 可以重复执行任意次。同样地，查找一个目录并且删除所有叫 foobar 的项也是幂等的。相反，把从 inode k 新释放的块加入空闲表的末端不是幂等的，因为它们可能已经被释放并存放在那里了。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929161137.png" srcset="/img/loading.gif" alt="" /></p><p>为了增加可靠性，一个文件系统可以引入数据库中 <code>原子事务(atomic transaction)</code> 的概念。使用这个概念，一组动作可以被界定在开始事务和结束事务操作之间。这样，文件系统就会知道它必须完成所有的动作，要么就一个不做。</p><h2 id="虚拟文件系统"><a class="markdownIt-Anchor" href="#虚拟文件系统"></a> 虚拟文件系统</h2><p>即使在同一台计算机上或者在同一个操作系统下，都会使用很多不同的文件系统。Windows 中的主要文件系统是 NTFS 文件系统，但不是说 Windows 只有 NTFS 操作系统，它还有一些其他的例如旧的 FAT -32 或 FAT -16 驱动器或分区，其中包含仍需要的数据，闪存驱动器，旧的 CD-ROM 或 DVD（每个都有自己的独特文件系统）。<strong>Windows 通过指定不同的盘符来处理这些不同的文件系统</strong>，比如 <code>C:</code>，<code>D:</code> 等。盘符可以显示存在也可以隐式存在，如果你想找指定位置的文件，那么盘符是显示存在；如果当一个进程打开一个文件时，此时盘符是隐式存在，所以 Windows 知道向哪个文件系统传递请求。</p><p><code>UNIX</code> 采用了一种不同的方式，即 <strong><code>UNIX</code> 把多种文件系统整合到一个统一的结构中</strong>。一个 <code>Linux</code> 系统可以使用 ext2 作为根文件系统，ext3 分区装载在 /usr 下，另一块采用 Reiser FS 文件系统的硬盘装载到 /home下，以及一个 ISO 9660 的 CD - ROM 临时装载到 /mnt 下。从用户的观点来看，只有一个文件系统层级，但是事实上它们是由多个文件系统组合而成，<strong>对于用户和进程是不可见的</strong>。</p><p><code>UNIX</code> 操作系统使用一种 <code>虚拟文件系统(Virtual File System, VFS)</code> 来尝试将多种文件系统构成一个有序的结构。关键的思想是<strong>抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。</strong> 下面是一个 <code>VFS</code> 的系统结构：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929161745.png" srcset="/img/loading.gif" alt="" /></p><p>所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的 <code>POSIX</code> 系统调用，比如 <code>open</code>、<code>read</code>、<code>write</code> 和 <code>seek</code> 等。VFS 对用户进程有一个 <code>上层</code> 接口，这个接口就是著名的 <code>POSIX</code> 接口。</p><p><code>VFS</code> 也有一个对于实际文件的 <code>下层</code> 接口，就是上图中标记为 <code>VFS</code> 的接口。这个接口包含许多<strong>功能调用</strong>，这样 <code>VFS</code> 可以使每一个文件系统完成任务。因此，要创建一个可以与 <code>VFS</code> 一起使用的新文件系统，新文件系统的设计者必须确保它提供了 <code>VFS</code> 要求的功能。一个明显的例子是从磁盘读取特定的块，然后将其放入文件系统的缓冲区高速缓存中，然后返回指向该块的指针的函数。 因此，<code>VFS</code> 具有两个不同的接口：<strong>上一个到用户进程，下一个到具体文件系统</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 978. 最长湍流子数组</title>
    <link href="/2020/09/27/LeetCode-978-longest-turbulent-subarray/"/>
    <url>/2020/09/27/LeetCode-978-longest-turbulent-subarray/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/" target="_blank" rel="noopener">978. 最长湍流子数组</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxTurbulenceSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;    <span class="hljs-comment">// [9,4,2,10,7,8,8,1,9]</span>    <span class="hljs-comment">// dp[i]: 以第 i 个元素结尾的最大子数组长度</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">      if A[i] == A[i - 1]</span><span class="hljs-comment">        dp[i] = 1</span><span class="hljs-comment">      if A[i - 2], A[i - 1] 上升（下降）</span><span class="hljs-comment">        if A[i - 1], A[i] 下降（上升）</span><span class="hljs-comment">           dp[i] = dp[i - 1] + 1</span><span class="hljs-comment">        else if A[i - 1], A[i] 上升（下降）</span><span class="hljs-comment">           dp[i] = 2</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    Arrays.fill(dp, <span class="hljs-number">1</span>);    dp[<span class="hljs-number">1</span>] = A[<span class="hljs-number">1</span>] == A[<span class="hljs-number">0</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> max = dp[<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 上升</span>        <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">2</span>] &lt; A[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// 下降</span>            <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] &gt; A[i]) &#123;                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] &lt; A[i]) &#123;                dp[i] = <span class="hljs-number">2</span>;            &#125;        &#125;        <span class="hljs-comment">// 下降</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">2</span>] &gt; A[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// 上升</span>            <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] &lt; A[i]) &#123;                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>] &gt; dp[i]) &#123;                dp[i] = <span class="hljs-number">2</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// A[i - 2] == A[i - 1]</span>            dp[i] = (A[i] == A[i - <span class="hljs-number">1</span>]) ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;        &#125;        max = Math.max(max, dp[i]);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><h1 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxTurbulenceSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> maxLen = A[<span class="hljs-number">0</span>] == A[<span class="hljs-number">1</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">if</span> (A[right] == A[right - <span class="hljs-number">1</span>]) &#123;            left = right;            right++;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// up</span>        <span class="hljs-keyword">if</span> (A[right - <span class="hljs-number">2</span>] &lt; A[right - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// up</span>            <span class="hljs-keyword">if</span> (A[right - <span class="hljs-number">1</span>] &lt; A[right]) &#123;                left = right - <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-comment">// down</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[right - <span class="hljs-number">2</span>] &gt; A[right - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// down</span>            <span class="hljs-keyword">if</span> (A[right - <span class="hljs-number">1</span>] &gt; A[right]) &#123;                left = right - <span class="hljs-number">1</span>;            &#125;        &#125;        right++;        maxLen = Math.max(maxLen, right - left);    &#125;    <span class="hljs-keyword">return</span> maxLen;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 643. 子数组最大平均数 I</title>
    <link href="/2020/09/25/LeetCode-643-maximum-average-subarray-i/"/>
    <url>/2020/09/25/LeetCode-643-maximum-average-subarray-i/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener">643. 子数组最大平均数 I</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMaxAverage</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 计算前 k 个子数组和</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;        sum += nums[i];    &#125;    <span class="hljs-keyword">double</span> res = sum;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; nums.length; i++) &#123;        <span class="hljs-comment">// [i, i + 1, ... , i + k, i + k + 1]</span>        <span class="hljs-comment">// 0, 1, 2, 3, 4</span>        sum = sum - nums[i - k] + nums[i];        res = Math.max(res, sum);    &#125;    <span class="hljs-keyword">return</span> res / k;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 567. 字符串的排列</title>
    <link href="/2020/09/25/LeetCode-567-permutation-in-string/"/>
    <url>/2020/09/25/LeetCode-567-permutation-in-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars1 = s1.toCharArray();    <span class="hljs-keyword">char</span>[] chars2 = s2.toCharArray();    <span class="hljs-keyword">int</span>[] window = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">int</span>[] needs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars1) &#123;        needs[c - <span class="hljs-string">'a'</span>]++;    &#125;    <span class="hljs-keyword">int</span> s1Len = chars1.length;    <span class="hljs-keyword">int</span> s2Len = chars2.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> validLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; s2Len) &#123;        <span class="hljs-keyword">int</span> curPos = chars2[right] - <span class="hljs-string">'a'</span>;        <span class="hljs-keyword">if</span> (needs[curPos] == <span class="hljs-number">0</span>) &#123;            right++;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span> (window[curPos] &lt; needs[curPos]) &#123;            validLen++;        &#125;        window[curPos]++;        right++;        <span class="hljs-keyword">while</span> (validLen == s1Len) &#123;            <span class="hljs-comment">// 只有当前窗口长度 == s1 时，才算有效的排列</span>            <span class="hljs-keyword">if</span> (right - left == s1Len) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">int</span> leftPos = chars2[left] - <span class="hljs-string">'a'</span>;            <span class="hljs-comment">// 左边字符不在排列中</span>            <span class="hljs-keyword">if</span> (needs[leftPos] == <span class="hljs-number">0</span>) &#123;                left++;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 左边字符在排列中，减小有效长度</span>            <span class="hljs-keyword">if</span> (window[leftPos] == needs[leftPos]) &#123;                validLen--;            &#125;            window[leftPos]--;            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 424. 替换后的最长重复字符</title>
    <link href="/2020/09/24/LeetCode-424-longest-repeating-character-replacement/"/>
    <url>/2020/09/24/LeetCode-424-longest-repeating-character-replacement/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">424. 替换后的最长重复字符</a></p><p>实际上，窗口始终增大，因为要求最长子串，窗口内的字符出现次数在窗口收缩一位后，没有必要进行更新。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-comment">// 窗口内字符的出现次数</span>    <span class="hljs-keyword">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxCount = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxLen = Integer.MIN_VALUE;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">int</span> cur = chars[right] - <span class="hljs-string">'A'</span>;        freq[cur]++;        right++;        maxCount = Math.max(maxCount, freq[cur]);        <span class="hljs-comment">// 窗口大小 - 重复字符长度 &lt;= k 个替换长度时</span>        <span class="hljs-comment">// 表示可以替换的字符还达不到 k 个，此时可以扩大窗口</span>        <span class="hljs-comment">// 收缩 left 之后，窗口内正好可替换 k 个字符</span>        <span class="hljs-comment">// while (right - left - maxCount &gt; k) &#123;</span>        <span class="hljs-keyword">if</span> (right - left - maxCount &gt; k) &#123;            freq[chars[left] - <span class="hljs-string">'A'</span>]--;            left++;        &#125;        maxLen = Math.max(maxLen, right - left);    &#125;    <span class="hljs-keyword">return</span> maxLen;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 239. 滑动窗口最大值</title>
    <link href="/2020/09/24/LeetCode-239-sliding-window-maximum/"/>
    <url>/2020/09/24/LeetCode-239-sliding-window-maximum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len - k + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 单调递减队列：队首 &gt; 队尾</span>    <span class="hljs-comment">// 维护窗口内的最大值，当队首不在窗口内时则移除</span>    ArrayDeque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 移除队列中比当前值小的元素</span>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt; nums[i]) &#123;            queue.removeLast();        &#125;        <span class="hljs-comment">// 添加当前元素</span>        queue.add(i);        <span class="hljs-comment">// 判断队首值是否在窗口内，若不在则移除</span>        <span class="hljs-keyword">if</span> (queue.getFirst() &lt;= i - k) &#123;            queue.removeFirst();        &#125;        <span class="hljs-comment">// 形成有效窗口大小</span>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;            res[j++] = nums[queue.getFirst()];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 209. 长度最小的子数组</title>
    <link href="/2020/09/24/LeetCode-209-minimum-size-subarray-sum/"/>
    <url>/2020/09/24/LeetCode-209-minimum-size-subarray-sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></p><h1 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> minLen = Integer.MAX_VALUE;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-comment">// 计算前缀和</span>        sum += nums[right];        right++;        <span class="hljs-comment">// 当前缀和 &gt; target，尝试右移 left</span>        <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;            <span class="hljs-comment">// 更新最小长度</span>            <span class="hljs-keyword">if</span> (right - left &lt; minLen) &#123;                minLen = right - left;            &#125;            <span class="hljs-comment">// 右移 left 之前要减去 left 对应的值</span>            sum -= nums[left];            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : minLen;&#125;</code></pre><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 计算前缀和数组</span>    <span class="hljs-keyword">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    preSum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        preSum[i] = nums[i] + preSum[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">int</span> minLen = Integer.MAX_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> s1 = s - nums[i];        <span class="hljs-comment">// preSum[i.....j]</span>        <span class="hljs-comment">// 找到一个 preSum[j]，使得 preSum[j] - preSum[i] &gt;= s</span>        <span class="hljs-keyword">int</span> j = binarySearch(preSum, i, len - <span class="hljs-number">1</span>, s1 + preSum[i]);        <span class="hljs-keyword">if</span> (j != -<span class="hljs-number">1</span>) &#123;            minLen = Math.min(minLen, j - i + <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : minLen;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preSum, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">int</span> mid = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;        mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (preSum[mid] == target) &#123;            <span class="hljs-keyword">return</span> mid;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (preSum[mid] &gt; target) &#123;            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">// 找不到 == target 的 preSum[j]，则返回第一个 &gt; target 的元素</span>    <span class="hljs-keyword">return</span> preSum[mid] &gt; target ? mid : -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 内存管理</title>
    <link href="/2020/09/24/os-ram-manage/"/>
    <url>/2020/09/24/os-ram-manage/</url>
    
    <content type="html"><![CDATA[<p><code>分层存储器体系(memory hierarchy)</code>：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200924163759.png" srcset="/img/loading.gif" alt="" /></p><p>位于顶层的存储器速度最快，但是相对容量最小，成本非常高。层级结构向下，其访问速度会变慢，但是容量会变大，相对造价也就越便宜。（所以个人感觉相对存储容量来说，访问速度是更重要的）</p><p>操作系统中管理内存层次结构的部分称为 <code>内存管理器(memory manager)</code>，它的主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。所有现代操作系统都提供内存管理。</p><h1 id="无存储器抽象"><a class="markdownIt-Anchor" href="#无存储器抽象"></a> 无存储器抽象</h1><p>最简单的存储器抽象是无存储器。早期大型计算机（20 世纪 60 年代之前），小型计算机（20 世纪 70 年代之前）和个人计算机（20 世纪 80 年代之前）都没有存储器抽象。每一个程序都直接访问物理内存。当一个程序执行如下命令：</p><pre><code class="hljs angelscript">MOV REGISTER1, <span class="hljs-number">1000</span></code></pre><p>计算机会把位置为 1000 的物理内存中的内容移到 <code>REGISTER1</code> 中。因此呈现给程序员的内存模型就是物理内存，内存地址从 0 开始到内存地址的最大值中，每个地址中都会包含一个 <code>8 位</code> 位数的内存单元。</p><p>所以这种情况下的计算机<strong>不可能会有两个应用程序同时在内存中</strong>。如果第一个程序向内存地址 2000 的这个位置写入了一个值，那么此值将会替换第二个程序 2000 位置上的值，所以，同时运行两个应用程序是行不通的，两个程序会立刻崩溃。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200924165101.png" srcset="/img/loading.gif" alt="" /></p><p>不过即使存储器模型就是物理内存，还是存在一些可变体的。下面展示了三种变体：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200924165747.png" srcset="/img/loading.gif" alt="" /></p><p>在上图 <code>a</code> 中，操作系统位于 <code>RAM(Random Access Memory)</code> 的底部，或像是图 <code>b</code> 一样位于 <code>ROM(Read-Only Memory)</code> 顶部；而在图 <code>c</code> 中，<strong>设备驱动程序</strong>位于顶端的 <code>ROM</code> 中，而操作系统位于底部的 <code>RAM</code> 中。</p><ul><li>图 a 的模型以前用在大型机和小型机上，但现在已经很少使用了；</li><li>图 b 中的模型一般用于掌上电脑或者是嵌入式系统中。</li><li>第三种模型就应用在早期个人计算机中了。ROM 系统中的一部分成为 <code>BIOS (Basic Input Output System)</code>。模型 a 和 c 的缺点是<strong>用户程序中的错误可能会破坏操作系统</strong>，可能会导致灾难性的后果。</li></ul><p>按照这种方式组织系统时，通常<strong>同一个时刻只能有一个进程正在运行</strong>。一旦用户键入了一个命令，操作系统就把需要的程序从磁盘复制到内存中并执行；当进程运行结束后，操作系统在用户终端显示提示符并等待新的命令。收到新的命令后，它把新的程序装入内存，覆盖前一个程序。</p><p>在没有存储器抽象的系统中实现并行性一种方式是使用多线程来编程。由于同一进程中的多线程内部共享同一内存映像，那么实现并行也就不是问题了。但是这种方式却并没有被广泛采纳，因为人们通常希望能够在同一时间内运行没有关联的程序，而这正是线程抽象所不能提供的。</p><h1 id="存储器抽象地址空间"><a class="markdownIt-Anchor" href="#存储器抽象地址空间"></a> 存储器抽象：地址空间</h1><p>把物理内存暴露给进程会有几个主要的缺点：</p><ul><li><p>第一个问题是，如果用户程序可以寻址内存的每个字节，它们就可以很容易的<strong>破坏操作系统</strong>，从而使系统停止运行。即使在只有一个用户进程运行的情况下，这个问题也存在。</p></li><li><p>第二点是，<strong>难以运行多个程序</strong>。在个人计算机上，一般会打开很多应用程序，这些进程在不同时刻会有一个进程正在运行，其他应用程序可以通过鼠标来唤醒。在系统中没有物理内存的情况下很难实现。</p></li></ul><h2 id="地址空间概念"><a class="markdownIt-Anchor" href="#地址空间概念"></a> 地址空间概念</h2><p><code>地址空间(the address space)</code> 创建了一种抽象内存供程序使用。<strong>地址空间是进程可以用来寻址内存的地址集。每个进程都有它自己的地址空间，独立于其他进程的地址空间，但是某些进程会希望可以共享地址空间。</strong></p><h3 id="基址寄存器和变址寄存器"><a class="markdownIt-Anchor" href="#基址寄存器和变址寄存器"></a> 基址寄存器和变址寄存器</h3><p>最简单的办法是使用 <code>动态重定位(dynamic relocation)</code> 技术，它就是通过一种简单的方式<strong>将每个进程的地址空间映射到物理内存的不同区域</strong>。<br />经典办法是给每个 <code>CPU</code> 配置两个特殊硬件寄存器，通常叫做 <code>基址寄存器(basic register)</code> 和 <code>变址寄存器(limit register)</code>。当使用基址寄存器和变址寄存器时，程序会装载到内存中的连续位置并且在装载期间无需重定位。</p><ul><li>基址寄存器：存储数据内存的起始位置</li><li>变址寄存器：存储应用程序的长度。</li></ul><p>每当进程引用内存以获取指令或读取、写入数据时，<code>CPU</code> 都会自动将基址值添加到进程生成的地址中，然后再将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于变址寄存器中的值。如果程序提供的地址要超过变址寄存器的范围，那么会产生错误并中止访问。</p><p>执行 <code>JMP 28</code> 这条指令后，硬件会把它解释为 <code>JMP 16412</code>，所以程序能够跳到 <code>CMP</code> 指令，过程如下：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925132116.png" srcset="/img/loading.gif" alt="" /></p><p>使用基址寄存器和变址寄存器是给每个进程提供私有地址空间的一种非常好的方法，因为每个内存地址在送到内存之前，都会先加上基址寄存器的内容。在很多实际系统中，对基址寄存器和变址寄存器都会以一定的方式加以保护，使得只有操作系统可以修改它们。</p><p>缺点：在每次访问内存时，都会进行 <code>ADD</code> 和 <code>CMP</code> 运算。<code>CMP</code> 指令可以执行的很快，但是加法就会相对慢一些，除非使用特殊的加法电路，否则加法因进位传播时间而变慢。</p><h2 id="交换技术"><a class="markdownIt-Anchor" href="#交换技术"></a> 交换技术</h2><p>实际上，所有<strong>进程需要的 <code>RAM</code> 总容量要远远高于内存的容量</strong>。针对<strong>内存不足</strong>的问题，提出了两种处理方式：</p><ul><li><code>交换(swapping)</code> 技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。</li><li><code>虚拟内存(virtual memory)</code>，虚拟内存技术能够允许应用程序部分的运行在内存中。</li></ul><h3 id="交换过程"><a class="markdownIt-Anchor" href="#交换过程"></a> 交换过程</h3><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925132623.png" srcset="/img/loading.gif" alt="" /></p><p>刚开始的时候，只有进程 A 在内存中，然后从创建进程 B 和进程 C 或者从磁盘中把它们换入内存，然后在图 d 中，A 被换出内存到磁盘中，最后 A 重新进来。因为图 g 中的进程 A 现在到了不同的位置，所以在装载过程中需要被重新定位，或者在交换程序时通过软件来执行；或者在程序执行期间通过硬件来重定位。基址寄存器和变址寄存器就适用于这种情况。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925132932.png" srcset="/img/loading.gif" alt="" /></p><p>交换在内存创建了多个 <code>空闲区(hole)</code>，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这项技术称为 <code>内存紧缩(memory compaction)</code>。但是这项技术通常不会使用，因为这项技术会消耗很多 <code>CPU</code> 时间。例如，在一个 16GB 内存的机器上每 8ns 复制 8 字节，它紧缩全部的内存大约要花费 16s。</p><h3 id="动态内存分配"><a class="markdownIt-Anchor" href="#动态内存分配"></a> 动态内存分配</h3><p>如果进程被创建后它的大小是固定的并且不再改变，那么分配策略就比较简单：操作系统会准确的按其需要的大小进行分配。</p><p>进程的 <code>data segment</code> 能够自动增长，会有三种处理方式：</p><ul><li><p>如果一个进程与空闲区相邻，那么可把该空闲区分配给进程以供其增大。</p></li><li><p>如果进程相邻的是另一个进程，就会有两种处理方式：要么把需要增长的进程移动到一个内存中空闲区足够大的区域，要么把一个或多个进程交换出去，已变成生成一个大的空闲区。</p></li><li><p>如果一个进程在内存中不能增长，而且磁盘上的交换区也满了，那么这个进程只有挂起一些空闲空间（或者可以结束该进程）。</p></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925133850.png" srcset="/img/loading.gif" alt="" /></p><p>上面只针对单个或者一小部分需要增长的进程采用的方式，如果大部分进程都要在运行时增长，为了减少因内存区域不够而引起的进程交换和移动所产生的开销，一种可用的方法是，<strong>在换入或移动进程时为它分配一些额外的内存</strong>。然而，<strong>当进程被换出到磁盘上时，应该只交换实际上使用的内存</strong>，将额外的内存交换也是一种浪费，下面是一种为两个进程分配了增长空间的内存配置。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925134003.png" srcset="/img/loading.gif" alt="" /></p><p>如果进程有两个可增长的段，例如，供变量动态分配和释放的作为堆(全局变量)使用的一个 <code>数据段(data segment)</code>，以及存放局部变量与返回地址的一个 <code>堆栈段(stack segment)</code>，就如图 b 所示。在图中可以看到所示进程的<strong>堆栈段在进程所占内存的顶端向下增长</strong>，紧接着在程序段后的<strong>数据段向上增长</strong>。当增长预留的内存区域不够了，处理方式就如上面的流程图(<code>data segment</code> 自动增长的三种处理方式)一样了。</p><h2 id="空闲内存管理"><a class="markdownIt-Anchor" href="#空闲内存管理"></a> 空闲内存管理</h2><p>在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式</p><ul><li>位图(<code>bitmap</code>)</li><li>空闲列表(<code>free lists</code>)</li></ul><h3 id="1-使用位图的存储管理"><a class="markdownIt-Anchor" href="#1-使用位图的存储管理"></a> 1. 使用位图的存储管理</h3><p>使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925161159.png" srcset="/img/loading.gif" alt="" /></p><p>图 <code>a</code> 表示一段有 5 个进程和 3 个空闲区的内存，刻度为内存分配单元，阴影区表示空闲（在位图中用 0 表示）；图 <code>b</code> 表示对应的位图；图 <code>c</code> 表示用链表表示同样的信息。</p><p>分配单元的大小是一个重要的设计因素，<strong>分配单位越小，位图越大</strong>。然而，即使只有 <code>4</code> 字节的分配单元，<code>32</code> 位的内存也仅仅只需要位图中的 <code>1</code> 位。<code>32n</code> 位的内存需要 <code>n</code> 位的位图，所以 <code>1</code> 个位图只占用了 <code>1/32</code> 的内存。如果选择更大的内存单元，位图应该要更小。如果进程的大小不是分配单元的整数倍，那么在最后一个分配单元中会有大量的内存被浪费。</p><p>位图提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为<strong>位图的大小取决于内存和分配单元的大小</strong>。这种方法有一个问题是，当决定为把具有 <code>k</code> 个分配单元的进程放入内存时，<code>内容管理器(memory manager)</code> 必须搜索位图，在位图中找出能够运行 <code>k</code> 个连续 <code>0</code> 位的串。<strong>在位图中找出制定长度的连续 <code>0</code> 串是一个很耗时的操作，这是位图的缺点。</strong></p><h3 id="2-使用链表进行管理"><a class="markdownIt-Anchor" href="#2-使用链表进行管理"></a> 2. 使用链表进行管理</h3><p>另一种记录内存使用情况的方法是，维护一个记录<strong>已分配内存段和空闲内存段的链表</strong>，段会包含进程或者是两个进程的空闲区域。可用上面的 <code>图 c</code> 来表示内存的使用情况。链表中的每一项都可以代表一个 <code>空闲区(H)</code> 或者是 <code>进程(P)</code> 的起始标志，长度和下一个链表项的位置。</p><p>在这个例子中，<code>段链表(segment list)</code> 是按照地址排序的。这种方式的优点是，当进程终止或被交换时，更新列表很简单。一个终止进程通常有两个邻居（除了内存的顶部和底部外）。相邻的可能是进程也可能是空闲区，它们有四种组合方式。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925163044.png" srcset="/img/loading.gif" alt="" /></p><h3 id="3-顺序搜索的动态内存分配"><a class="markdownIt-Anchor" href="#3-顺序搜索的动态内存分配"></a> 3. 顺序搜索的动态内存分配</h3><p>当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。</p><h4 id="31-首次适配first-fit"><a class="markdownIt-Anchor" href="#31-首次适配first-fit"></a> 3.1 <code>首次适配(first fit)</code></h4><p><strong>内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止</strong>。除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。</p><h4 id="32-下次适配next-fit"><a class="markdownIt-Anchor" href="#32-下次适配next-fit"></a> 3.2 <code>下次适配(next fit)</code></h4><p>它和首次匹配的工作方式相同，只有一个不同之处那就是<strong>下次适配在每次找到合适的空闲区时就会记录当时的位置</strong>，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。</p><h4 id="33-最佳适配best-fit"><a class="markdownIt-Anchor" href="#33-最佳适配best-fit"></a> 3.3 <code>最佳适配(best fit)</code></h4><p>最佳适配会从头到尾寻找整个链表，找出能够容纳进程的<strong>最小空闲区</strong>。最佳适配算法会试图<strong>找出最接近实际需要的空闲区</strong>，以最好的匹配请求和可用空闲区，而不是先一次拆分一个以后可能会用到的大的空闲区。比如现在我们需要一个大小为 2 的块，那么首次匹配算法会把这个块分配在位置 5 的空闲区，而最佳适配算法会把该块分配在位置为 18 的空闲区，如下：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925162851.png" srcset="/img/loading.gif" alt="" /></p><p>最佳适配会遍历整个链表，所以最佳适配算法的性能要比首次匹配算法差。但最佳适配算法要比首次匹配和下次匹配算法浪费更多的内存，因为它会产生大量无用的小缓冲区，首次匹配算法生成的空闲区会更大一些。</p><h4 id="34-最差适配worst-fit"><a class="markdownIt-Anchor" href="#34-最差适配worst-fit"></a> 3.4 <code>最差适配(worst fit)</code></h4><p><strong>总是分配最大的内存区域</strong>，使新分配的空闲区比较大从而可以继续使用。仿真程序表明最差适配算法也不是一个好主意。</p><h4 id="35-快速适配quick-fit"><a class="markdownIt-Anchor" href="#35-快速适配quick-fit"></a> 3.5 <code>快速适配(quick fit)</code></h4><p><strong>为那些常用大小的空闲区维护单独的链表</strong>。例如，有一个 <code>n</code> 项的表，该表的第一项是指向大小为 <code>4 KB</code> 的空闲区链表表头指针，第二项是指向大小为 <code>8 KB</code> 的空闲区链表表头指针，第三项是指向大小为 <code>12 KB</code> 的空闲区链表表头指针，以此类推。比如 <code>21 KB</code> 这样的空闲区既可以放在 <code>20 KB</code> 的链表中，也可以放在一个专门存放大小比较特别的空闲区链表中。</p><p>快速匹配算法寻找一个指定代销的空闲区也是十分快速的，但它和所有将空闲区按大小排序的方案一样，都有一个共同的缺点，<strong>即在一个进程终止或被换出时，寻找它的相邻块并查看是否可以合并的过程都是非常耗时的。</strong> 如果不进行合并，内存将会很快分裂出大量进程无法利用的小空闲区。</p><h1 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h1><p>在一些中小应用程序可使用交换技术，<strong>如果应用程序过大，交换技术并不是一个很有效的方案。</strong><br />一个典型的 <code>SATA</code> 磁盘的峰值传输速度高达几百兆/秒，这意味着需要好几秒才能换出或者换入一个 <code>1 GB</code> 的程序。</p><p><code>虚拟内存(virtual memory)</code> 的基本思想是，<strong>每个程序都有自己的地址空间，这个地址空间被划分为多个称为 <code>页面(page)</code> 的块。</strong> 每一页都是连续的地址范围。<strong>这些页被映射到物理内存</strong>，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p><p>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中，当一个程序等待它的一部分读入内存时，可以把 <code>CPU</code> 交给另一个进程使用。</p><h2 id="分页"><a class="markdownIt-Anchor" href="#分页"></a> 分页</h2><p>大部分使用虚拟内存的系统中都会使用一种 <code>分页(paging)</code> 技术。在任何一台计算机上，程序会引用使用一组内存地址。当程序执行</p><pre><code class="hljs assembly">MOV REG, 1000</code></pre><p>这条指令时，它会把内存地址为 <code>1000</code> 的内存单元的内容复制到 <code>REG</code> 中（或者相反，这取决于计算机）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</p><p>这些程序生成的地址被称为 <code>虚拟地址(virtual addresses)</code> 并形成 <code>虚拟地址空间(virtual address space)</code>.</p><ul><li>在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作都使用同样地址的物理内存。</li><li>在使用虚拟内存时，虚拟地址不会直接发送到内存总线上。相反，会使用 <code>MMU(Memory Management Unit)</code> 内存管理单元<strong>把虚拟地址映射为物理内存地址</strong>，像下图这样：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927155103.png" srcset="/img/loading.gif" alt="" /></li></ul><p>下面这幅图展示了这种映射是如何工作的：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927155203.png" srcset="/img/loading.gif" alt="" /></p><h3 id="1-存在映射的页如何映射"><a class="markdownIt-Anchor" href="#1-存在映射的页如何映射"></a> 1. 存在映射的页如何映射</h3><p>虚拟地址空间由固定大小的单元组成，这种固定大小的单元称为 <code>页(pages)</code>。而相对的，物理内存中也有固定大小的物理单元，称为 <code>页框(page frames)</code>。页和页框的大小一样。在上面这个例子中，页的大小为 <code>4KB</code> ，但是实际的使用过程中页的大小范围可能是 <code>512</code> 字节 - <code>1G</code> 字节的大小。对应于 <code>64 KB</code> 的虚拟地址空间和 <code>32 KB</code> 的物理内存，可得到 <code>16</code> 个虚拟页面和 <code>8</code> 个页框。 <strong><code>RAM</code> 和磁盘之间的交换总是以整个页为单元进行交换的。</strong></p><p>程序试图访问地址时，例如执行下面这条指令：</p><pre><code class="hljs assembly">MOV REG, 0</code></pre><p>会将虚拟地址 <code>0</code> 送到 <code>MMU</code>。<code>MMU</code> 看到虚拟地址落在<code>页面 0</code> （<code>0 - 4095</code>），根据其映射结果，这一页面对应的<code>页框 2</code> （<code>8192 - 12287</code>），因此 <code>MMU</code> 把地址变换为 <code>8192</code> ，并把地址 <code>8192</code> 送到总线上。内存对 <code>MMU</code> 一无所知，它只看到一个对 <code>8192</code> 地址的读写请求并执行它。<code>MMU</code> 从而有效的把所有虚拟地址 <code>0 - 4095</code> 映射到了 <code>8192 - 12287</code> 的物理地址。同样的，指令</p><pre><code class="hljs assembly">MOV REG, 8192</code></pre><p>也被有效的转换为</p><pre><code class="hljs assembly">MOV REG, 24576</code></pre><p>虚拟地址 <code>8192</code>（在<code>虚拟页 2</code> 中）被映射到物理地址 <code>24576</code>（在物理<code>页框 6</code> 中）上。</p><p>通过恰当的设置 <code>MMU</code>，可以把 <code>16</code> 个虚拟页面映射到 <code>8</code> 个页框中的任何一个。但是这并没有解决虚拟地址空间比物理内存大的问题。</p><p>上图中有 <code>8</code> 个物理页框，于是只有 <code>8</code> 个虚拟页被映射到了物理内存中，在上图中用 <code>X</code> 号表示的其他页面没有被映射。在实际的硬件中，会使用一个 <code>在/不在(Present/absent bit)位</code> 记录页面在内存中的实际存在情况。</p><h3 id="2-未映射的页如何映射"><a class="markdownIt-Anchor" href="#2-未映射的页如何映射"></a> 2. 未映射的页如何映射</h3><p>当程序访问一个未映射的页面，如执行指令：</p><pre><code class="hljs assembly">MOV REG, 32780</code></pre><p>将会发生什么情况呢？<code>虚拟页面 8</code> （从 <code>32768</code> 开始）的第 <code>12</code> 个字节所对应的物理地址是什么？<code>MMU</code> 注意到该页面没有被映射（在图中用 <code>X</code> 号表示），于是 <code>CPU</code> 会陷入(<code>trap</code>)到操作系统中。这个陷入称为 <code>缺页中断(page fault)</code> 或者是 <code>缺页错误</code>。操作系统会选择一个很少使用的页并把它的内容写入磁盘（如果它不在磁盘上）。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷入的指令。有点不太好理解，举个例子来看一下。</p><p>例如，如果操作系统决定放弃 <code>页框 1</code>，那么它将把 <code>虚拟页面 8</code> 装入物理地址 <code>4096</code>，并对 <code>MMU</code> 映射做两处修改。</p><ul><li>首先，它要将虚拟页中的 <code>1</code> 表项标记为<code>未映射</code>，使以后任何对虚拟地址 <code>4096 - 8191</code> 的访问都将导致陷入。</li><li>随后把虚拟页面 <code>8</code> 的表项的叉号改为 <code>1</code>，因此在引起陷阱的指令重新启动时，它将把虚拟地址 <code>32780</code> 映射为物理地址（<code>4096 + 12</code>）。</li></ul><p>下面查看一下 <code>MMU</code> 的内部构造以便了解它们是如何工作的，以及了解为什么我们选用的页大小都是 2 的整数次幂。下图我们可以看到一个虚拟地址的例子：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927163045.png" srcset="/img/loading.gif" alt="" /></p><blockquote><p>虚拟地址 = 虚拟页号 + 页内偏移量<br />物理地址 = (虚拟地址页号 -&gt; 物理地址页号) + 页内偏移量</p></blockquote><p>虚拟地址 <code>8196</code> （<code>0010000000000100</code>）用上面的页表映射图所示的 <code>MMU</code> 映射机制进行映射，输入的 <code>16</code> 位虚拟地址被分为 <code>4</code> 位的<strong>页号</strong>和 <code>12</code> 位的<strong>偏移量</strong>。<code>4</code> 位的页号可以表示 <code>16</code> 个页面，<code>12</code> 位的偏移可以为一页内的全部 <code>4096</code> 个字节。</p><p>可用页号作为 <code>页表(page table)</code> 的索引，以得出对应于该虚拟页面的<strong>页框号</strong>。如果在/不在位是 <code>0</code> ，则引起一个操作系统陷入。如果该位是 <code>1</code>，则将在页表中查到的页框号复制到输出寄存器的<code>高 3 位</code>中，再加上输入虚拟地址中的<code>低 12 位偏移量</code>。如此就构成了 <code>15</code> 位的物理地址。输出寄存器的内容随即被作为物理地址送到总线。</p><h2 id="页表"><a class="markdownIt-Anchor" href="#页表"></a> 页表</h2><p>在上面这个简单的例子中，虚拟地址到物理地址的映射可以总结如下：虚拟地址被分为<strong>虚拟页号</strong>（高位部分）和<strong>偏移量</strong>（低位部分）。例如，对于 <code>16</code> 位地址和 <code>4 KB</code> 的页面大小，<strong>高 4 位</strong>可以指定 <code>16</code> 个虚拟页面中的一页，而<strong>低 12 位</strong>接着确定了所选页面中的偏移量（<code>0-4095</code>）。</p><p>虚拟页号可作为页表的索引用来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927164705.png" srcset="/img/loading.gif" alt="" /></p><p>因此，<strong>页表的目的是把虚拟页映射到页框中</strong>。从数学上说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。</p><h3 id="页表项的结构"><a class="markdownIt-Anchor" href="#页表项的结构"></a> 页表项的结构</h3><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927164835.png" srcset="/img/loading.gif" alt="" /></p><p>页表项的结构是与机器相关的，但是不同机器上的页表项大致相同。上面是一个页表项的构成，不同计算机的页表项可能不同，但是一般来说都是 <code>32</code> 位的。</p><ul><li><p><code>页框号(Page frame number)</code>: 页表项中最重要的字段，毕竟，页表到页框最重要的一步操作就是要把此值映射过去。</p></li><li><p><code>在/不在(Present/absent bit)位</code>: 如果此位上的值是 1，那么页表项是有效的并且能够被使用。如果此值是 0 的话，则表示该页表项对应的虚拟页面不在内存中，访问该页面会引起一个 <code>缺页中断(page fault)</code>。</p></li><li><p><code>保护位(Protection)</code>: 指出一个页允许什么类型的访问。最简单的表示形式是这个域只有一位，0 表示可读可写，1 表示的是只读。</p></li><li><p><code>修改位(Modified)</code> 和 <code>访问位(Referenced)</code> 会跟踪页面的使用情况。当一个页面被写入时，硬件会自动的设置修改位。修改位在页面重新分配页框时很有用。如果一个页面已经被修改过（即它是 <code>脏</code> 的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是 <code>干净</code> 的），那么重新分配时这个页框会被直接丢弃，因为磁盘上的副本仍然是有效的。这个位有时也叫做 <code>脏位(dirty bit)</code>，因为它反映了页面的状态。</p></li><li><p><code>访问位(Referenced)</code>: 在页面被访问时被设置，不管是读还是写。这个值能够帮助操作系统在发生缺页中断时选择要淘汰的页。不再使用的页要比正在使用的页更适合被淘汰。这个位在后面要讨论的页面置换算法中作用很大。</p></li><li><p><code>高速缓存禁止位</code>: 用于禁止该页面被高速缓存，这个功能对于映射到设备寄存器还是内存中起到了关键作用。通过这一位可以禁用高速缓存。具有独立的 <code>I/O</code> 空间而不是用内存映射 <code>I/O</code> 的机器来说，并不需要这一位。</p></li></ul><p>需要强调一下：<strong>虚拟内存本质上是用来创造一个地址空间的抽象，类似于进程是对 <code>CPU</code> 的抽象。虚拟内存的实现，本质是将虚拟地址空间分解成页，并将每一项映射到物理内存的某个页框。</strong> 因此我们的重点是如何管理这个虚拟内存的抽象。</p><h2 id="快表"><a class="markdownIt-Anchor" href="#快表"></a> 快表</h2><p>大多数程序总是对少量页面进行多次访问，而不是对大量页面进行少量访问。因此，只有很少的页面能够被再次访问，而其他的页表项很少被访问。</p><blockquote><p>页表项一般也被称为 <code>Page Table Entry(PTE)</code>。</p></blockquote><p>基于这种设想，提出了一种方案，即从硬件方面来解决这个问题，为计算机设置一个小型的硬件设备，能够将虚拟地址直接映射到物理地址，而不必再访问内存中的页表。这种设备被称为 <code>转换检测缓冲区(Translation Lookaside Buffer, TLB)</code>，有时又被称为 <code>相联存储器(associate memory)</code>。</p><p><code>TLB</code> 通常位于 <code>MMU</code> 中，包含少量的表项，每个表项都记录了页面的相关信息，除了虚拟页号外，其他表项都和页表是一一对应的。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927172214.png" srcset="/img/loading.gif" alt="" /></p><p><code>TLB</code> 其实就是一种<strong>内存缓存，用于减少访问内存所需要的时间</strong>，它就是 <code>MMU</code> 的一部分，<code>TLB</code> 会将虚拟地址到物理地址的转换存储起来，通常可以称为 <code>地址翻译缓存(address-translation cache)</code>。<code>TLB</code> 通常位于 <code>CPU</code> 和 <code>CPU</code> 缓存之间，它与 <code>CPU</code> 缓存是不同的缓存级别。下面我们来看一下 <code>TLB</code> 是如何工作的。</p><p>当一个 <code>MMU</code> 中的虚拟地址需要进行转换时，硬件首先检查虚拟页号与 <code>TLB</code> 中所有表项进行并行匹配，判断虚拟页是否在 <code>TLB</code> 中。如果找到了有效匹配项，并且要进行的访问操作没有违反保护位的话，则将页框号直接从 <code>TLB</code> 中取出而<strong>不用再直接访问页表</strong>。如果虚拟页在 <code>TLB</code> 中但是违反了保护位的权限的话（比如只允许读但是是一个写指令），则会生成一个 <code>保护错误(protection fault)</code> 返回。</p><p>上面探讨的是虚拟地址在 <code>TLB</code> 中的情况，那么如果虚拟地址不再 <code>TLB</code> 中该怎么办？如果 <code>MMU</code> 检测到没有有效的匹配项，就会进行正常的页表查找，然后从 <code>TLB</code> 中逐出一个表项然后把从页表中找到的项放在 <code>TLB</code> 中。当一个表项被从 <code>TLB</code> 中清除出，将修改位复制到内存中页表项，除了访问位之外，其他位保持不变。当页表项从页表装入 <code>TLB</code> 中时，所有的值都来自于内存。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927172423.png" srcset="/img/loading.gif" alt="" /></p><h1 id="页面置换算法"><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h1><p>当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。<br />如果要换出的页面在内存驻留期间已经被修改过，就必须把它写回磁盘以更新该页面在磁盘上的副本；如果该页面没有被修改过，那么磁盘副本已经是最新的，不需要回写，直接用调入的页面覆盖被淘汰的页面就可以了。</p><p>当发生缺页中断时，虽然可以随机的选择一个页面进行置换，但是如果每次都选择一个不常用的页面会提升系统的性能。</p><blockquote><p><code>抖动（Thrashing）</code>: 如果一个经常使用的页面被换出，那么这个页面在短时间内又可能被重复使用，那么就可能会造成额外的性能开销。</p></blockquote><h2 id="1-最优页面置换算法"><a class="markdownIt-Anchor" href="#1-最优页面置换算法"></a> 1. 最优页面置换算法</h2><p>最优 <code>(Optimal)</code> 页面置换算法是一种理论上的算法，<strong>其所选择的被淘汰页将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面。</strong> 采用最优置换算法通常可保证获得最低的缺页率。但由于目前人们还无法预知，一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的，但可以利用该算法取评价其他算法。</p><p>最优化的页面算法表明应该标记最大的页面。如果一个页面在 800 万条指令内不会被使用，另外一个页面在 600 万条指令内不会被使用，则置换前一个页面，从而把需要调入这个页面而发生的缺页中断推迟。计算机也像人类一样，会把不愿意做的事情尽可能的往后拖。</p><p>这个算法最大的问题时<strong>无法实现</strong>。当缺页中断发生时，操作系统无法知道各个页面的下一次将在什么时候被访问。这种算法在实际过程中根本不会使用。</p><h2 id="2-最近未使用页面置换算法-nru"><a class="markdownIt-Anchor" href="#2-最近未使用页面置换算法-nru"></a> 2. 最近未使用页面置换算法 (NRU)</h2><p>为了能够让操作系统收集页面使用信息，大部分使用虚拟地址的计算机都有两个状态位，<code>R</code> 和 <code>M</code>，来和每个页面进行关联。每当<strong>访问</strong>页面时都设置 <code>R</code>，<strong>写入</strong>页面时设置 <code>M</code>，这些位包含在每个页表项中，就像下面所示：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928123701.png" srcset="/img/loading.gif" alt="" /><br />因为每次访问时都会更新这些位，因此由硬件来设置它们非常重要。一旦某个位被设置为 <code>1</code>，就会一直保持 <code>1</code> 直到操作系统下次来修改此位。</p><p>如果硬件没有这些位，那么可以使用操作系统的<code>缺页中断</code>和<code>时钟中断</code>机制来进行模拟。当启动一个进程时，将其所有的页面都标记为不在内存；一旦访问任何一个页面就会引发一次缺页中断，此时操作系统就可以设置 <code>R 位(在它的内部表中)</code>，修改页表项使其指向正确的页面，并设置为 <code>READ ONLY</code> 模式，然后重新启动引起缺页中断的指令。如果页面随后被修改，就会发生另一个缺页异常。从而允许操作系统设置 <code>M</code> 位并把页面的模式设置为 <code>READ/WRITE</code>。</p><p>可以用 <code>R</code> 位和 <code>M</code> 位来构造一个简单的页面置换算法：当启动一个进程时，操作系统将其所有页面的两个位都设置为 <code>0</code>。<code>R</code> 位定期的被清零（在每个时钟中断）。用来将最近未引用的页面和已引用的页面分开。</p><p>当出现缺页中断后，操作系统会检查所有的页面，并根据它们的 <code>R</code> 位和 <code>M</code> 位将当前值分为四类：</p><ul><li>第 0 类：没有引用 R，没有修改 M</li><li>第 1 类：没有引用 R，已修改 M</li><li>第 2 类：引用 R ，没有修改 M</li><li>第 3 类：已被访问 R，已被修改 M</li></ul><p>尽管看起来好像无法实现第一类页面，但是当第三类页面的 <code>R</code> 位被时钟中断清除时，它们就会发生。时钟中断不会清除 <code>M</code> 位，因为需要这个信息才能知道是否写回磁盘中。清除 <code>R</code> 但不清除 <code>M</code> 会导致出现一类页面。</p><p><code>NRU(Not Recently Used)</code> 算法从编号最小的非空类中随机删除一个页面。此算法隐含的思想是，在一个时钟内（约 20 ms）<strong>淘汰一个已修改但是没有被访问的页面</strong>要比一个大量引用的未修改页面好，NRU 的主要优点是<strong>易于理解并且能够有效的实现</strong>。</p><h2 id="3-先进先出页面置换算法-fifo"><a class="markdownIt-Anchor" href="#3-先进先出页面置换算法-fifo"></a> 3. 先进先出页面置换算法 (FIFO)</h2><p>操作系统维护一个所有在当前内存中的页面的链表，最早进入的放在表头，最新进入的页面放在表尾。在发生缺页异常时，会把头部的页移除并且把新的页添加到表尾。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928125343.png" srcset="/img/loading.gif" alt="" /></p><h2 id="4-第二次机会页面置换算法"><a class="markdownIt-Anchor" href="#4-第二次机会页面置换算法"></a> 4. 第二次机会页面置换算法</h2><p>FIFO 可能会把经常使用的页面置换出去，为了避免这一问题，我们对该算法做一个简单的修改：我们检查最老页面的 <code>R</code> 位，</p><ul><li>如果是 <code>0</code> ，那么这个页面就是<strong>最老的而且没有被使用</strong>，那么这个页面就会被立刻换出。</li><li>如果 <code>R</code> 位是 <code>1</code>，那么就清除此位，此页面会被放在链表的尾部，修改它的装入时间就像刚放进来的一样。然后继续搜索。</li></ul><p>这种算法叫做 <code>第二次机会(second chance)</code> 算法，就像下面这样，我们看到页面 <code>A</code> 到 <code>H</code> 保留在链表中，并按到达内存的时间排序。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928131405.png" srcset="/img/loading.gif" alt="" /></p><p>假设缺页异常发生在时刻 <code>20</code> 处，这时最老的页面是 <code>A</code> ，它是在 <code>0</code> 时刻到达的。</p><ul><li>如果 <code>A</code> 的 <code>R</code> 位是 <code>0</code>，那么它将被淘汰出内存，或者把它写回磁盘（如果它已经被修改过），或者只是简单的放弃（如果它是未被修改过）。</li><li>如果它的 <code>R</code> 位已经设置了，则将 <code>A</code> 放到链表的尾部并且重新设置装入时间为当前时刻（20 处），然后清除 <code>R</code> 位。然后从 <code>B</code> 页面开始继续搜索合适的页面。</li></ul><p>寻找第二次机会的是在<strong>最近的时钟间隔中未被访问过的页面</strong>。如果所有的页面都被访问过，该算法就会被简化为单纯的 <code>FIFO</code> 算法。<br />具体来说，假设图 <code>a</code> 中所有页面都设置了 <code>R</code> 位。操作系统将页面依次移到链表末尾，每次都在添加到末尾时清除 <code>R</code> 位。最后，算法又会回到页面 <code>A</code>，此时的 <code>R</code> 位已经被清除，那么页面 <code>A</code> 就会被执行出链处理，因此算法能够正常结束。</p><h2 id="5-时钟页面置换算法-clock"><a class="markdownIt-Anchor" href="#5-时钟页面置换算法-clock"></a> 5. 时钟页面置换算法 (Clock)</h2><p>第二次页面置换算法经常要在链表中移动页面，既降低了效率，而且这种算法也不是必须的。一种比较好的方式是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。如下图所示：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928131906.png" srcset="/img/loading.gif" alt="" /><br />当缺页错误出现时，算法首先检查表针指向的页面，</p><ul><li>如果它的 <code>R</code> 位是 <code>0</code> 就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；</li><li>如果 <code>R</code> 位是 <code>1</code> 就清除 R 位并把表针前移一个位置。</li></ul><p>重复这个过程直到找到了一个 <code>R</code> 位为 <code>0</code> 的页面位置。</p><h2 id="6-最近最少使用页面置换算法-lru"><a class="markdownIt-Anchor" href="#6-最近最少使用页面置换算法-lru"></a> 6. 最近最少使用页面置换算法 (LRU)</h2><p>在前面几条指令中频繁使用的页面很可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面有可能在未来一段时间内仍不会被使用。这个思想揭示了一个可以实现的算法：在缺页中断时，置换未使用时间最长的页面。这个策略称为 <code>LRU(Least Recently Used)</code>，最近最少使用页面置换算法。</p><p>虽然 <code>LRU</code> 在理论上是可以实现的，但是从长远看来代价比较高。为了完全实现 <code>LRU</code>，会在内存中维护一个所有页面的链表，<strong>最频繁使用的页位于表头，最近最少使用的页位于表尾</strong>。困难的是在<strong>每次内存引用时更新整个链表</strong>。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作，即使使用硬件来实现也是一样的费时。</p><p>然而，还有其他方法可以通过硬件实现 <code>LRU</code>。这个方法要求硬件有一个 <code>64</code> 位的计数器，它在每条指令执行完成后自动加 <code>1</code>，每个页表必须有一个足够容纳这个计数器值的域。在每次访问内存后，将当前的值保存到被访问页面的页表项中。一旦发生缺页异常，操作系统就检查所有页表项中计数器的值，找到值最小的一个页面，这个页面就是最少使用的页面。</p><h2 id="7-nfu-老化算法"><a class="markdownIt-Anchor" href="#7-nfu-老化算法"></a> 7. NFU, 老化算法</h2><p>尽管上面的 <code>LRU</code> 算法在原则上是可以实现的，但是很少有机器能够拥有那些特殊的硬件。上面是硬件的实现方式，那么现在考虑要用软件来实现 <code>LRU</code> 。一种可以实现的方案是 <code>NFU(Not Frequently Used，最不常用)</code> 算法。它需要一个软件计数器来和每个页面关联，初始化的时候是 <code>0</code>。在每个时钟中断时，操作系统会浏览内存中的所有页，会将每个页面的 <code>R</code> 位（<code>0</code> 或 <code>1</code>）加到它的计数器上。这个计数器大体上跟踪了各个页面访问的频繁程度。当缺页异常出现时，则置换计数器值最小的页面。</p><p>只需要对 <code>NFU</code> 做一个简单的修改就可以让它模拟 <code>LRU</code>，这个修改有两个步骤</p><ol><li>在 <code>R</code> 位被添加进来之前先把<strong>计数器右移一位</strong>；</li><li><code>R</code> 位被添加到<strong>最左边</strong>的位而不是最右边的位。<br />修改以后的算法称为 <code>老化(aging)</code> 算法，下图解释了老化算法是如何工作的。</li></ol><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928135317.png" srcset="/img/loading.gif" alt="" /></p><p>我们假设在第一个时钟周期内页面 <code>0 - 5</code> 的 <code>R</code> 位依次是 <code>1，0，1，0，1，1</code>。也就是说，在 <code>0</code> 个时钟周期到 <code>1</code> 个时钟周期之间，<code>0，2，4，5</code> 都被引用了，从而把它们的 <code>R</code> 位设置为 <code>1</code>，剩下的设置为 <code>0</code>。在相关的六个计数器被右移之后 <code>R</code> 位被添加到 左侧 ，就像上图中的 <code>a</code>。剩下的四列显示了接下来的四个时钟周期内的六个计数器变化。</p><blockquote><p>CPU正在以某个频率前进，该频率的周期称为时钟滴答或时钟周期。一个 100Mhz 的处理器每秒将接收100,000,000个时钟滴答。</p></blockquote><p>当缺页异常出现时，<strong>将置换计数器值最小的页面</strong>。如果一个页面在前面 <code>4</code> 个时钟周期内都没有被访问过，那么它的计数器应该会有四个连续的 <code>0</code>，因此它的值肯定要比前面 <code>3</code> 个时钟周期内都没有被访问过的页面的计数器小。</p><p>这个算法与 <code>LRU</code> 算法有两个重要的区别：看一下上图中的 <code>e</code>，第三列和第五列：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928135342.png" srcset="/img/loading.gif" alt="" /></p><p>它们在两个时钟周期内都没有被访问过，在此之前的时钟周期内都引用了两个页面。根据 <code>LRU</code> 算法，如果需要置换的话，那么应该在这两个页面中选择一个。那么问题来了，我们应该选择哪个？现在的问题是我们不知道时钟周期 1 到时钟周期 2 内它们中哪个页面是后被访问到的。<strong>因为在每个时钟周期内只记录了一位，所以无法区分在一个时钟周期内哪个页面最早被引用，哪个页面是最后被引用的。</strong> 因此，我们能做的就是置换 <code>页面3</code>，因为页面 <code>3</code> 在周期 <code>0 - 1</code> 内都没有被访问过，而页面 <code>5</code> 却被引用过。</p><p><code>LRU</code> 与老化之前的第 2 个区别是，在老化期间，<strong>计数器具有有限数量的位</strong>（这个例子中是 8 位），这就限制了以往的访问记录。如果两个页面的计数器都是 <code>0</code> ，那么我们可以随便选择一个进行置换。实际上，有可能其中一个页面的访问次数实在 <code>9</code> 个时钟周期以前，而另外一个页面是在 <code>1000</code> 个时钟周期之前，但是我们却无法看到这些。在实际过程中，如果时钟周期是 20 ms，8 位一般是够用的。所以我们经常拿 20 ms 来举例。</p><h2 id="8-工作集页面置换算法"><a class="markdownIt-Anchor" href="#8-工作集页面置换算法"></a> 8. 工作集页面置换算法</h2><p>在最单纯的分页系统中，刚启动进程时，在内存中并没有页面。此时如果 <code>CPU</code> 尝试匹配第一条指令，就会得到一个缺页异常，使操作系统装入含有第一条指令的页面。其他的错误比如 <code>全局变量和 堆栈</code> 引起的缺页异常通常会紧接着发生。一段时间以后，进程需要的大部分页面都在内存中了，此时进程开始在较少的缺页异常环境中运行。这个策略称为 <code>请求调页(demand paging)</code>，因为页面是根据需要被调入的，而不是预先调入的。</p><p>在一个大的地址空间中系统的读所有的页面，将会造成很多缺页异常，因此会导致没有足够的内存来容纳这些页面。不过幸运的是，大部分进程不是这样工作的，它们都会以 <code>局部性方式(locality of reference)</code> 来访问，这意味着在执行的任何阶段，程序只引用其中的一小部分。</p><p>一个进程当前正在使用的页面的集合称为它的 <code>工作集(working set)</code>，如果整个工作集都在内存中，那么进程在运行到下一运行阶段之前，不会产生很多缺页中断。如果内存太小从而无法容纳整个工作集，那么进程的运行过程中会产生大量的缺页中断，会导致运行速度也会变得缓慢。因为通常只需要几纳秒就能执行一条指令，而通常需要十毫秒才能从磁盘上读入一个页面。如果一个程序每 10 ms 只能执行一到两条指令，那么它将需要很长时间才能运行完。如果只是执行几条指令就会产生中断，那么就称作这个程序产生了 颠簸(thrashing)。</p><p>在多道程序的系统中，通常会把进程移到磁盘上，这样可以让其他进程有机会占用 <code>CPU</code>。有一个问题是，当进程想要再次把之前调回磁盘的页面调回内存怎么办？从技术的角度上来讲，并不需要做什么，此进程会一直产生缺页中断直到它的工作集被调回内存。然后，每次装入一个进程需要 20、100 甚至 1000 次缺页中断，速度显然太慢了，并且由于 <code>CPU</code> 需要几毫秒时间处理一个缺页中断，因此由相当多的 <code>CPU</code> 时间也被浪费了。</p><p>因此，不少分页系统中都会设法跟踪进程的工作集，确保这些工作集在进程运行时被调入内存。这个方法叫做 <code>工作集模式(working set model)</code>。它被设计用来<strong>减少缺页中断的次数</strong>。在进程运行前首先装入工作集页面的这一个过程被称为 <code>预先调页(prepaging)</code>，工作集是随着时间来变化的。</p><p>根据研究表明，大多数程序并不是均匀的访问地址空间的，而访问往往是集中于一小部分页面。一次内存访问可能会取出一条指令，也可能会取出数据，或者是存储数据。<br />在任一时刻 <code>t</code>，都存在一个集合，它包含所有最近 <code>k</code> 次内存访问所访问过的页面。这个集合 <code>w(k,t)</code> 就是工作集。因为最近 <code>k = 1</code> 次访问肯定会访问最近 <code>k &gt; 1</code> 次访问所访问过的页面，所以 <code>w(k,t)</code> 是 k 的单调递减函数。随着 <code>k</code> 的增大，<code>w(k,t)</code> 是不会无限变大的，因为程序不可能访问比所能容纳页面数量上限还多的页面。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928141451.png" srcset="/img/loading.gif" alt="" /></p><p><strong>事实上大多数应用程序只会任意访问一小部分页面集合，但是这个集合会随着时间而缓慢变化</strong>，所以一开始曲线会快速上升而 <code>k</code> 较大时上升缓慢。为了实现工作集模型，操作系统必须跟踪哪些页面在工作集中。一个进程从它开始执行到当前所实际使用的 <code>CPU</code> 时间总数通常称作 <code>当前实际运行时间</code>。<strong>进程的工作集可以被称为在过去的 <code>t</code> 秒实际运行时间中它所访问过的页面集合。</strong></p><p>下面来简单描述一下工作集的页面置换算法，基本思路就是<strong>找出一个不在工作集中的页面并淘汰它</strong>。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928141619.png" srcset="/img/loading.gif" alt="" /></p><h2 id="9-工作集时钟页面置换算法"><a class="markdownIt-Anchor" href="#9-工作集时钟页面置换算法"></a> 9. 工作集时钟页面置换算法</h2><p>当缺页异常发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法还是比较浪费时间的。一个对基本工作集算法的提升是<strong>基于时钟算法但是却使用工作集的信息</strong>，这种算法称为<code>WSClock(工作集时钟)</code>。由于它的实现简单并且具有高性能，因此在实践中被广泛应用。</p><p>与时钟算法一样，所需的数据结构是一个以页框为元素的循环列表，就像下面这样：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928142410.png" srcset="/img/loading.gif" alt="" /></p><p>最初的时候，该表是空的。当装入第一个页面后，把它加载到该表中。随着更多的页面的加入，它们形成一个环形结构。每个表项包含来自基本工作集算法的上次使用时间，以及 <code>R</code> 位（已标明）和 <code>M</code> 位（未标明）。</p><p>与时钟算法一样，在每个缺页异常时，首先检查指针指向的页面。</p><ul><li><code>R = 1</code>，该页面在当前时钟周期内就被使用过，那么该页面就不适合被淘汰。然后把该页面的 <code>R</code> 设置为 <code>0</code>，指针指向下一个页面，并重复该算法。该事件序列化后的状态参见图 <code>b</code>。</li><li><code>R = 0</code><ul><li>如果页面的使用期限大于 <code>t</code> 并且页面为<code>未访问过</code>，那么这个页面就不会在工作集中，并且在磁盘上会有一个此页面的副本。申请重新调入一个新的页面，并把新的页面放在其中，如图 <code>d</code> 所示。</li><li>如果页面<code>被修改过</code>，就不能重新申请页面，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。毕竟，有可能存在一个老的，没有被修改过的页面可以立即使用。</li></ul></li></ul><h2 id="页面置换算法小结"><a class="markdownIt-Anchor" href="#页面置换算法小结"></a> 页面置换算法小结</h2><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">最优算法</td><td style="text-align:center">不可实现，但可以用作基准</td></tr><tr><td style="text-align:center">NRU(最近未使用) 算法</td><td style="text-align:center">和 LRU 算法很相似</td></tr><tr><td style="text-align:center">FIFO(先进先出) 算法</td><td style="text-align:center">有可能会抛弃重要的页面</td></tr><tr><td style="text-align:center">第二次机会算法</td><td style="text-align:center">比 FIFO 有较大的改善</td></tr><tr><td style="text-align:center">时钟算法</td><td style="text-align:center">实际使用</td></tr><tr><td style="text-align:center">LRU(最近最少)算法</td><td style="text-align:center">比较优秀，但是很难实现</td></tr><tr><td style="text-align:center">NFU(最不经常使用)算法</td><td style="text-align:center">和 LRU 很类似</td></tr><tr><td style="text-align:center">老化算法</td><td style="text-align:center">近似 LRU 的高效算法</td></tr><tr><td style="text-align:center">工作集算法</td><td style="text-align:center">实施起来开销很大</td></tr><tr><td style="text-align:center">工作集时钟算法</td><td style="text-align:center">比较有效的算法</td></tr></tbody></table><ul><li><p>最优算法在当前页面中<strong>置换最后要访问</strong>的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，因此实际上该算法不能使用。然而，它可以作为衡量其他算法的标准。</p></li><li><p><code>NRU</code> 算法根据 <code>R</code> 位和 <code>M</code> 位的状态将页面分为四类。从编号最小的类别中随机选择一个页面。<code>NRU</code> 算法易于实现，但是性能不是很好。存在更好的算法。</p></li><li><p><code>FIFO</code> 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。</p></li><li><p>第二次机会算法是对 <code>FIFO</code> 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。</p></li><li><p><code>时钟</code> 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。</p></li><li><p><code>LRU</code> 算法是一个非常优秀的算法，但是没有特殊的硬件(TLB)很难实现。</p></li><li><p><code>NFU</code> 算法是一种近似于 <code>LRU</code> 的算法，它的性能不是非常好。</p></li><li><p><code>老化</code> 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择</p></li><li><p>最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。<code>WSClock</code> 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 76. 最小覆盖子串</title>
    <link href="/2020/09/23/LeetCode-76-minimum-window-substring/"/>
    <url>/2020/09/23/LeetCode-76-minimum-window-substring/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></p><p>使用一个计数器统计窗口内目标字符的出现次数，当满足要求时，移动 left，并更新最小长度，若移除的字符为目标字符，则计数器也要减小。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] sChar = s.toCharArray();    <span class="hljs-keyword">char</span>[] tChar = t.toCharArray();    <span class="hljs-keyword">int</span> sLen = s.length();    <span class="hljs-keyword">int</span> tLen = t.length();    <span class="hljs-comment">// 只统计窗口内目标字符的出现次数</span>    <span class="hljs-keyword">int</span>[] window = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];    <span class="hljs-keyword">int</span>[] needs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : tChar) &#123;        needs[c]++;    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, begin = <span class="hljs-number">0</span>, minLen = sLen + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 滑动窗口内包含 t 中字符的个数</span>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; sLen) &#123;        <span class="hljs-keyword">char</span> c = sChar[right];        <span class="hljs-comment">// 当前字符不在 t 中，right 向右移动</span>        <span class="hljs-keyword">if</span> (needs[c] == <span class="hljs-number">0</span>) &#123;            right++;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 统计窗口中目标字符的长度</span>        <span class="hljs-keyword">if</span> (window[c] &lt; needs[c]) &#123;            count++;        &#125;        <span class="hljs-comment">// 更新窗口中目标字符出现次数</span>        window[c]++;        right++;        <span class="hljs-comment">// 有效字符个数满足要求</span>        <span class="hljs-comment">// [left, right)</span>        <span class="hljs-keyword">while</span> (count == tLen) &#123;            <span class="hljs-comment">// 更新最小长度</span>            <span class="hljs-keyword">if</span> (right - left &lt; minLen) &#123;                minLen = right - left;                begin = left;            &#125;            <span class="hljs-comment">// 左边需要移除的字符</span>            <span class="hljs-keyword">char</span> leftChar = sChar[left];            <span class="hljs-comment">// 移除的字符不在目标字符中，则直接移动 left</span>            <span class="hljs-keyword">if</span> (needs[leftChar] == <span class="hljs-number">0</span>) &#123;                left++;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 移除的字符出现的目标字符中，则减少有效字符长度</span>            <span class="hljs-keyword">if</span> (window[leftChar] == needs[leftChar]) &#123;                count--;            &#125;            window[leftChar]--;            left++;        &#125;    &#125;    <span class="hljs-keyword">if</span> (minLen == sLen + <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    <span class="hljs-keyword">return</span> s.substring(begin, begin + minLen);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 283. 移动零</title>
    <link href="/2020/09/22/LeetCode-283-move-zeroes/"/>
    <url>/2020/09/22/LeetCode-283-move-zeroes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a><br />统计非 0 元素的个数，若 <code>nums[i] != 0</code> 则进行交换。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">// 非 0 元素的个数，nums[0:j) != 0</span>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">int</span> t = nums[i];                nums[i] = nums[j];                nums[j] = t;                j++;            &#125;        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 75. 颜色分类</title>
    <link href="/2020/09/22/LeetCode-75-sort-colors/"/>
    <url>/2020/09/22/LeetCode-75-sort-colors/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 0,0,0,.zero.1,1,1,1,1.two.2,2,2,2,2,len</span>    <span class="hljs-comment">// [0, zero) 0</span>    <span class="hljs-comment">// [zero, i) 1</span>    <span class="hljs-comment">// [two, len) 2</span>    <span class="hljs-comment">// `0` 的边界从 0 开始</span>    <span class="hljs-keyword">int</span> zero = <span class="hljs-number">0</span>;    <span class="hljs-comment">// `2` 的边界从最后一个元素开始</span>    <span class="hljs-keyword">int</span> two = len - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 遍历起点</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当 i == two 时，还差一个元素未访问</span>    <span class="hljs-keyword">while</span> (i &lt;= two) &#123;        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;            swap(nums, i, zero);            zero++;            i++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;            i++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">2</span>) &#123;            <span class="hljs-comment">// 此时不需要 i++，否则交换过来的 nums[i] 未判断</span>            swap(nums, i, two);            two--;        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 451. 根据字符出现频率排序</title>
    <link href="/2020/09/21/LeetCode-451-sort-characters-by-frequency/"/>
    <url>/2020/09/21/LeetCode-451-sort-characters-by-frequency/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">451. 根据字符出现频率排序</a></p><h1 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">frequencySort</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    List&lt;Character&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        <span class="hljs-keyword">if</span> (!list.contains(c)) &#123;            list.add(c);        &#125;        map.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);    &#125;    list.sort((o1, o2) -&gt; map.get(o2) - map.get(o1));    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : list) &#123;        <span class="hljs-keyword">int</span> count = map.get(c);        <span class="hljs-keyword">while</span> (count-- &gt; <span class="hljs-number">0</span>) &#123;            sb.append(c);        &#125;    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre><h1 id="大顶堆"><a class="markdownIt-Anchor" href="#大顶堆"></a> 大顶堆</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">frequencySort</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        map.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);    &#125;    PriorityQueue&lt;Character&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; map.get(o2) - map.get(o1));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        <span class="hljs-keyword">if</span> (!maxHeap.contains(c)) &#123;            maxHeap.add(c);        &#125;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">while</span> (!maxHeap.isEmpty()) &#123;        <span class="hljs-keyword">char</span> key = maxHeap.poll();        <span class="hljs-keyword">int</span> count = map.get(key);        <span class="hljs-keyword">while</span> (count-- &gt; <span class="hljs-number">0</span>) &#123;            sb.append(key);        &#125;    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 189. 旋转数组</title>
    <link href="/2020/09/21/LeetCode-189-rotate-array/"/>
    <url>/2020/09/21/LeetCode-189-rotate-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. 旋转数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 每次反转都有 k % n 个 数字被移动到前部</span>    k = k % len;    <span class="hljs-comment">// 全部反转</span>    reverse(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 反转前 k 个</span>    reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 反转 len - k 个</span>    reverse(nums, k, len - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">while</span> (start &lt; end) &#123;        <span class="hljs-keyword">int</span> t = nums[start];        nums[start] = nums[end];        nums[end] = t;        start++;        end--;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 进程与线程</title>
    <link href="/2020/09/21/os-process-thread/"/>
    <url>/2020/09/21/os-process-thread/</url>
    
    <content type="html"><![CDATA[<h1 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h1><p><strong>进程是操作系统对正在运行中的程序的一个抽象</strong>，操作系统的其他所有内容都是通过进程展开的。无论是在单核还是多核 <code>CPU</code> 中，一个 <code>CPU</code> 都像是在<strong>并发</strong>地执行多个进程，这是通过处理器在进程间切换来实现的，即<strong>伪并行</strong>。</p><blockquote><p><code>伪并行</code>是指单核或多核处理器同时执行多个进程，从而使程序更快。 通过以<strong>非常有限的时间间隔在程序之间快速切换 <code>CPU</code></strong>，因此会产生并行感。 缺点是 <code>CPU</code> 时间可能分配给下一个进程，也可能不分配给下一个进程。</p></blockquote><h2 id="进程模型"><a class="markdownIt-Anchor" href="#进程模型"></a> 进程模型</h2><p>在进程模型中，所有计算机上运行的软件，通常也包括操作系统，被组织为若干<strong>顺序进程</strong>(<code>sequential processes</code>)，简称为 <strong>进程</strong>(<code>process</code>) 。一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 <code>CPU</code>，但是实际情况是 <code>CPU</code> 会在各个进程之间进行来回切换。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200918135528.png" srcset="/img/loading.gif" alt="" /><br />如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200918135549.png" srcset="/img/loading.gif" alt="" /><br />在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。<br />当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。<br />当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p><p>从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，但<strong>在任何一个给定的瞬间仅有一个进程真正运行。</strong><br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200918135606.png" srcset="/img/loading.gif" alt="" /></p><p>因此，当我们说一个 <code>CPU</code> 只能真正一次运行一个进程的时候，即使有 <code>2</code> 个核（或 <code>CPU</code>），<strong>每一个核也只能一次运行一个线程</strong>。</p><p>这里的关键思想是认识到一个进程所需的条件，<strong>进程是某一类特定活动的总和，它有程序、输入输出以及状态。</strong> 单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务。<br />另外需要注意的是，如果一个进程运行了两遍，则被认为是两个进程，操作系统能够使它们共享代码，因此只有一个副本放在内存中。</p><h2 id="进程的创建"><a class="markdownIt-Anchor" href="#进程的创建"></a> 进程的创建</h2><p>创建进程的方式:</p><ol><li>系统初始化（<code>init</code>）</li><li>正在运行的程序执行了创建进程的系统调用（比如 fork）</li><li>用户请求创建一个新进程</li><li>初始化一个批处理工作</li></ol><p>在 <code>UNIX</code> 和 <code>Windows</code> 中，进程创建之后，<strong>父进程和子进程有各自不同的地址空间</strong>。如果其中某个进程在其地址空间中修改了一个字，这个修改将对另一个进程不可见。</p><ul><li><p>在 <code>UNIX</code> 中，子进程的地址空间是父进程的一个副本，但是这里涉及两个不同的地址空间；<strong>不可写的内存区域是共享的</strong>，<strong>可写的内存是不能被共享的</strong>。<br />某些 <code>UNIX</code> 实现使子进程共享父进程的所有内存，但是这种情况下通过 <code>写时复制 (copy-on-write)</code> 共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。但是，对于一个新创建的进程来说，确实有可能共享创建者的资源，比如可以共享打开的文件。</p></li><li><p>在 <code>Windows</code> 中，从一开始父进程的地址空间和子进程的地址空间就是不同的。</p></li></ul><h3 id="1-系统初始化"><a class="markdownIt-Anchor" href="#1-系统初始化"></a> 1. 系统初始化</h3><p>启动操作系统时，通常会创建若干个进程。</p><ul><li><code>前台进程 (numerous processes</code>) 同用户进行交互并替他们完成工作的进程。</li><li><code>守护进程 (daemons)</code> 运行在后台，并不与特定的用户进行交互。</li></ul><h3 id="2-系统调用创建"><a class="markdownIt-Anchor" href="#2-系统调用创建"></a> 2. 系统调用创建</h3><p>一个正在运行的进程会发出<code>系统调用</code>用来创建一个或多个新进程来帮助其完成工作。</p><p>例如，如果有大量的数据需要经过网络调取并进行顺序处理，那么创建一个进程读数据，并把数据放到共享缓冲区中，而让第二个进程取走并正确处理会比较容易些。在多处理器中，让每个进程运行在不同的 CPU 上也可以使工作做的更快。</p><h3 id="3-用户请求创建"><a class="markdownIt-Anchor" href="#3-用户请求创建"></a> 3. 用户请求创建</h3><p>在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。在 Windows 中启动进程时，它一般没有窗口，但是它可以创建一个或多个窗口。每个窗口都可以运行进程。通过鼠标或者命令就可以切换窗口并与进程进行交互。</p><h3 id="4-批处理创建"><a class="markdownIt-Anchor" href="#4-批处理创建"></a> 4. 批处理创建</h3><p>批处理创建会在大型机的<code>批处理系统</code>中应用。用户在这种系统中提交批处理作业。当操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业。</p><h2 id="进程的终止"><a class="markdownIt-Anchor" href="#进程的终止"></a> 进程的终止</h2><p>进程在创建之后，它就开始运行并做完成任务。然而，进程早晚会发生终止，通常是由于以下情况触发的</p><ol><li>正常退出(自愿的)</li><li>错误退出(自愿的)</li><li>严重错误(非自愿的)</li><li>被其他进程杀死(非自愿的)</li></ol><h3 id="1-正常退出自愿的"><a class="markdownIt-Anchor" href="#1-正常退出自愿的"></a> 1. 正常退出(自愿的)</h3><p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。<br />这个调用在 <code>UNIX</code> 中是 <code>exit</code> ，在 <code>Windows</code> 中是 <code>ExitProcess</code>。</p><h3 id="2-错误退出自愿的"><a class="markdownIt-Anchor" href="#2-错误退出自愿的"></a> 2. 错误退出(自愿的)</h3><p>进程发生终止的第二个原因是发现错误。<br />例如，如果用户执行如下命令</p><pre><code class="hljs bash">cc foo.c</code></pre><p>要编译 <code>foo.c</code> 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p><h3 id="3-严重错误非自愿的"><a class="markdownIt-Anchor" href="#3-严重错误非自愿的"></a> 3. 严重错误(非自愿的)</h3><p>严重错误通常是由于程序中的错误所导致的。<br />例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 <code>UNIX</code> 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p><h3 id="4-被其他进程杀死非自愿的"><a class="markdownIt-Anchor" href="#4-被其他进程杀死非自愿的"></a> 4. 被其他进程杀死(非自愿的)</h3><p>某个进程执行<strong>系统调用</strong>告诉操作系统杀死某个进程。在 <code>UNIX</code> 中，这个系统调用是 <code>kill</code>。在 <code>Win32</code> 中对应的函数是 <code>TerminateProcess</code>。</p><h2 id="进程的层次结构"><a class="markdownIt-Anchor" href="#进程的层次结构"></a> 进程的层次结构</h2><p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p><h3 id="unix-进程体系"><a class="markdownIt-Anchor" href="#unix-进程体系"></a> <code>UNIX</code> 进程体系</h3><p>在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 <code>kill</code> 掉。</p><p><code>UNIX</code> 在启动时会运行 <code>init</code> 进程，它会初始化多个子进程，因此，整个操作系统中的所有进程都属于一个以 <code>init</code> 为根的进程树。</p><h3 id="windows-进程体系"><a class="markdownIt-Anchor" href="#windows-进程体系"></a> <code>Windows</code> 进程体系</h3><p><code>Windows</code> 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为<code>句柄</code>），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 <code>UNIX</code> 中，进程不能剥夺其子进程的 <strong>进程权</strong>。</p><h2 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h2><p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。例如，一个进程的结果可以作为另一个进程的输入，在 <code>shell</code> 命令中</p><pre><code class="hljs shell">cat chapter1 chapter2 chapter3 | grep tree</code></pre><p>第一个进程是 <code>cat</code>，将三个文件级联并输出。第二个进程是 <code>grep</code>，它从输入中选择具有包含关键字 <code>tree</code> 的内容，根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的 <code>CPU</code> 时间片），可能会发生下面这种情况，<code>grep</code> 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞 <code>grep</code> 进程，直到输入完毕。</p><p>当一个进程开始运行时，它可能会经历下面这几种状态</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921150701.png" srcset="/img/loading.gif" alt="" /></p><p>图中会涉及三种状态：</p><ol><li><strong>运行态</strong>，该时刻进程实际占用 <code>CPU</code>。</li><li><strong>就绪态</strong>，可运行，但因为其他进程正在运行而处于就绪状态。</li><li><strong>阻塞态</strong>，除非某种外部事件发生，否则进程不能运行。</li></ol><ul><li>逻辑上来说，运行态和就绪态是很相似的。都表示进程可运行，但是<strong>就绪态</strong>没有获得 <code>CPU</code> 时间分片。</li><li>阻塞态与前两种状态不同的原因是<strong>这个进程不能运行，<code>CPU</code> 空闲时也不能运行</strong>。</li></ul><p>三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生 <code>状态 1</code> 的轮转。<br /><code>转换 2</code> 和<code>转换 3</code> 都是由进程调度程序引起的，进程本身不知道调度程序的存在。<br /><code>转换 2</code> 的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行 <code>CPU</code> 时间片了。<br />当所有其他进程都运行过后，这时候该是让第一个进程重新获得 <code>CPU</code> 时间片的时候了，就会发生<code>转换 3</code>。</p><blockquote><p>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p></blockquote><p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生<code>转换 4</code>。如果此时没有其他进程在运行，则立刻触发<code>转换 3</code>，该进程便开始运行，否则该进程会处于就绪阶段，等待 <code>CPU</code> 空闲后再轮到它运行。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921152100.png" srcset="/img/loading.gif" alt="" /></p><p><strong>操作系统最底层的就是调度程序</strong>，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。事实上，调度程序只是一段非常小的程序。</p><h2 id="进程的实现"><a class="markdownIt-Anchor" href="#进程的实现"></a> 进程的实现</h2><p>操作系统为了执行进程间的切换，会维护着一张表格，这张表就是 <code>进程表(process table)</code>。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括<strong>程序计数器</strong>、<strong>堆栈指针</strong>、<strong>内存分配状况</strong>、<strong>所打开文件的状态</strong>、<strong>账号和调度信息</strong>，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921152615.webp" srcset="/img/loading.gif" alt="" /></p><p>第一列内容与 <strong>进程管理</strong> 有关，第二列内容与 <strong>存储管理</strong> 有关，第三列内容与 <strong>文件管理</strong> 有关。</p><h1 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h1><h2 id="线程的使用"><a class="markdownIt-Anchor" href="#线程的使用"></a> 线程的使用</h2><p>为什么要在进程的基础上再创建一个线程的概念：</p><ul><li>多线程之间会<strong>共享同一块地址空间和所有可用数据</strong>的能力，这是进程所不具备的。</li><li>线程要比进程更<strong>轻量级</strong>，它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 <code>10 - 100</code> 倍。</li><li>性能方面：如果多个线程都是 <code>CPU</code> 密集型的，那么并不能获得性能上的增强，但是如果存在着<strong>大量的计算和大量的 <code>I/O</code> 处理</strong>，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度。</li></ul><h3 id="1-多线程解决方案"><a class="markdownIt-Anchor" href="#1-多线程解决方案"></a> 1. 多线程解决方案</h3><p>一个 WEB 服务器，对页面的请求发送给服务器，而所请求的页面发送回客户端。在多数 WEB 站点上，某些页面较其他页面相比有更多的访问。Web 服务器可以把获得大量访问的页面集合保存在内存中，避免到磁盘去调入这些页面，从而改善性能。这种页面的集合称为 <code>高速缓存(cache)</code>，高速缓存也应用在许多场合中，比如说 <code>CPU</code> 缓存。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921153549.png" srcset="/img/loading.gif" alt="" /></p><p>上面是一个 web 服务器的组织方式，一个叫做 <code>调度线程(dispatcher thread)</code> 的线程从网络中读入工作请求，在调度线程检查完请求后，它会选择一个空闲的（阻塞的）工作线程来处理请求，通常是将消息的指针写入到每个线程关联的特殊字中。然后调度线程会唤醒正在睡眠中的工作线程，把工作线程的状态从阻塞态变为就绪态。</p><p>当<code>工作线程</code>启动后，它会检查请求是否在 web 页面的高速缓存中存在，这个高速缓存是所有线程都可以访问的。如果高速缓存不存在这个 web 页面的话，它会调用一个 read 操作从磁盘中获取页面并且阻塞线程直到磁盘操作完成。当线程阻塞在硬盘操作的期间，为了完成更多的工作，调度线程可能挑选另一个线程运行，也可能把另一个当前就绪的工作线程投入运行。</p><p>这种模型允许<strong>将服务器编写为顺序线程</strong>的集合，在分派线程的程序中包含一个死循环，该循环用来获得工作请求并且把请求派给工作线程。每个工作线程的代码包含一个从调度线程接收的请求，并且检查 web 高速缓存中是否存在所需页面，如果有，直接把该页面返回给客户，接着工作线程阻塞，等待一个新请求的到达。如果没有，工作线程就从磁盘调入该页面，将该页面返回给客户机，然后工作线程阻塞，等待一个新请求。</p><h3 id="2-单线程解决方案"><a class="markdownIt-Anchor" href="#2-单线程解决方案"></a> 2. 单线程解决方案</h3><p>Web 服务器的主循环获取请求并检查请求，并争取在下一个请求之前完成工作。在等待磁盘操作时，服务器空转，并且不处理任何到来的其他请求。结果会导致每秒中只有很少的请求被处理，所以这个例子能够说明多线程提高了程序的并行性并提高了程序的性能。</p><h3 id="3-状态机解决方案"><a class="markdownIt-Anchor" href="#3-状态机解决方案"></a> 3. 状态机解决方案</h3><p>如果目前只有一个非阻塞版本的 read 系统调用可以使用，那么当请求到达服务器时，这个唯一的 read 调用的线程会进行检查，如果能够从高速缓存中得到响应，那么直接返回，如果不能，则启动一个非阻塞的磁盘操作。</p><p>服务器在表中记录当前请求的状态，然后进入并获取下一个事件，紧接着下一个事件可能就是一个新工作的请求或是磁盘对先前操作的回答。如果是新工作的请求，那么就开始处理请求。如果是磁盘的响应，就从表中取出对应的状态信息进行处理。对于非阻塞式磁盘 I/O 而言，这种响应一般都是信号中断响应。</p><p>每次服务器从某个请求工作的状态切换到另一个状态时，都必须显示的保存或者重新装入相应的计算状态。这里，每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为 <code>有限状态机(finite-state machine)</code>。</p><ul><li>多线程使得顺序进程的思想得以保留下来，并且实现了<strong>并行性</strong>，但是顺序进程会<strong>阻塞系统调用</strong>；</li><li>单线程服务器保留了阻塞系统的简易性，但是却放弃了性能。</li><li>有限状态机的处理方法运用了<strong>非阻塞调用</strong>和中断，通过<strong>并行</strong>实现了高性能，但是给编程增加了困难。</li></ul><h2 id="经典的线程模型"><a class="markdownIt-Anchor" href="#经典的线程模型"></a> 经典的线程模型</h2><p>组成：</p><ul><li><strong>程序计数器</strong>，记录接着要执行哪一条指令；</li><li><strong>寄存器</strong>，保存线程当前正在使用的变量；</li><li><strong>堆栈</strong>，记录程序的执行路径。</li></ul><p>在同一个进程中，允许彼此之间有较大的独立性且互不干扰。在一个进程中并行运行多个线程类似于在一台计算机上运行多个进程。<br />在多个线程中，各个线程共享同一地址空间和其他资源。<br />在多个进程中，进程共享物理内存、磁盘、打印机和其他资源。因为线程会包含有一些进程的属性，所以线程被称为轻量的进程(<code>lightweight processes</code>)。</p><p>三个进程，每个进程有自己的地址空间和单个控制线程，每个线程都在不同的地址空间中运行。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155110.png" srcset="/img/loading.gif" alt="" /></p><p>一个进程三个线程的情况。每个线程都在相同的地址空间中运行。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155327.png" srcset="/img/loading.gif" alt="" /></p><p>线程不像是进程那样具备较强的独立性。<strong>同一个进程中的所有线程都会有完全一样的地址空间</strong>，这意味着它们也<strong>共享同样的全局变量</strong>。由于每个线程都可以访问进程地址空间内每个内存地址，因此一个线程可以读取、写入甚至擦除另一个线程的堆栈。线程之间除了共享同一内存空间外，还具有如下不同的内容：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155439.png" srcset="/img/loading.gif" alt="" /></p><p>和进程一样，线程可以处于下面这几种状态：<strong>运行</strong>、<strong>阻塞</strong>、<strong>就绪</strong>和<strong>终止</strong>。<br />正在运行的线程拥有 <code>CPU</code> 时间片并且状态是运行中。<br />一个被阻塞的线程会等待某个释放它的事件。<br />例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞直到有输入为止。线程通常会被阻塞，直到它等待某个外部事件的发生或者有其他线程来释放它。线程之间的状态转换和进程之间的状态转换是一样的。</p><p>每个线程都会有自己的堆栈，如下图所示<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155658.png" srcset="/img/loading.gif" alt="" /></p><h2 id="线程实现"><a class="markdownIt-Anchor" href="#线程实现"></a> 线程实现</h2><h3 id="1-在用户空间中实现线程"><a class="markdownIt-Anchor" href="#1-在用户空间中实现线程"></a> 1. 在用户空间中实现线程</h3><p>第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921160042.png" srcset="/img/loading.gif" alt="" /><br />线程在运行时系统之上运行，运行时系统是管理线程过程的集合。</p><blockquote><p><code>运行时系统(Runtime System)</code> 也叫做运行时环境，<strong>该运行时系统提供了程序在其中运行的环境</strong>。此环境可能会解决许多问题，包括应用程序内存的布局，程序如何访问变量，在过程之间传递参数的机制，与操作系统的接口等等。编译器根据特定的运行时系统进行假设以生成正确的代码。通常，运行时系统将负责设置和管理堆栈，并且会包含诸如垃圾收集，线程或语言内置的其他动态的功能。</p></blockquote><p>在用户空间管理线程时，每个进程需要有其专用的 <code>线程表(thread table)</code>，<strong>用来跟踪该进程中的线程</strong>。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器和状态。<strong>该线程标由运行时系统统一管理</strong>。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程的所有信息，与内核在进程表中存放的信息完全一样。</p><p>优势：</p><ul><li><p>保存线程的状态和调度程序都是<code>本地过程</code>，所以启动他们比进行内核调用效率更高。因而<strong>不需要切换到内核，也就不需要上下文切换，也不需要对内存高速缓存进行刷新，因为线程调度非常便捷，因此效率比较高。</strong></p></li><li><p>允许每个进程有自己定制的调度算法。</p></li></ul><h3 id="2-在内核空间中实现线程"><a class="markdownIt-Anchor" href="#2-在内核空间中实现线程"></a> 2. 在内核空间中实现线程</h3><p>使用内核来实现线程的情况，<strong>不再需要运行时环境</strong>，<strong>每个进程中也没有线程表</strong>。相反，在内核中会有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921161156.png" srcset="/img/loading.gif" alt="" /></p><p>所有能够阻塞的调用都会通过<strong>系统调用</strong>的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 <code>CPU</code> 时间片（或者没有可运行的线程存在了）为止。</p><p>由于在内核中创建或者销毁线程的开销比较大，所以某些系统会采用<strong>可循环利用</strong>的方式来回收线程。<br />当某个线程被销毁时，就把它标志为不可运行的状态，但是其内部结构没有受到影响。稍后，在必须创建一个新线程时，就会重新启用旧线程，把它标志为可用状态。</p><h3 id="3-在用户和内核空间中混合实现线程"><a class="markdownIt-Anchor" href="#3-在用户和内核空间中混合实现线程"></a> 3. 在用户和内核空间中混合实现线程</h3><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921161507.png" srcset="/img/loading.gif" alt="" /></p><p>在这种模型中，<strong>编程人员可以自由控制用户线程和内核线程的数量</strong>，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程<strong>多路复用</strong>。</p><h1 id="进程间通信"><a class="markdownIt-Anchor" href="#进程间通信"></a> 进程间通信</h1><h2 id="竞态条件"><a class="markdownIt-Anchor" href="#竞态条件"></a> 竞态条件</h2><p>在一些操作系统中，协作的进程可能共享一些彼此都能读写的公共资源。公共资源可能在内存中也可能在一个共享文件。<br />为了讲清楚进程间是如何通信的，这里我们举一个例子：一个后台打印程序。当一个进程需要打印某个文件时，它会将文件名放在一个特殊的 <code>后台目录(spooler directory)</code> 中。另一个进程 <code>打印后台进程(printer daemon)</code> 会定期的检查是否需要文件被打印，如果有的话，就打印并将该文件名从目录下删除。</p><p>假设我们的后台目录有非常多的 <code>槽位(slot)</code>，编号依次为 0，1，2，…，每个槽位存放一个文件名。同时假设有两个共享变量：<code>out</code>，指向下一个需要打印的文件；<code>in</code>，指向目录中下个空闲的槽位。可以把这两个文件保存在一个所有进程都能访问的文件中，该文件的长度为两个字。在某一时刻，0 至 3 号槽位空，4 号至 6 号槽位被占用。在同一时刻，进程 A 和 进程 B 都决定将一个文件排队打印，情况如下：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921163828.webp" srcset="/img/loading.gif" alt="" /></p><p>在某一时刻两个进程都认为下一个可用槽位是 7。<br />进程 B 会将打印文件名写入到 slot 7 中，然后把 in 的指针更改为 8 ，然后进程 B 离开去做其他的事情。<br />进程 A 也发现 slot 7 的槽位是空的，于是将打印文件名存入 slot 7 中，然后把 in 的值更新为 8，由于 slot 7 这个槽位中已经有进程 B 写入的值，所以进程 A 的打印文件名会把进程 B 的文件覆盖，由于打印机内部是无法发现是哪个进程更新的，它的功能比较局限，所以这时候进程 B 永远无法打印输出，类似这种情况，即<strong>两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时</strong>，这种就被称为 <code>竞态条件(race condition)</code>。</p><h2 id="临界区"><a class="markdownIt-Anchor" href="#临界区"></a> 临界区</h2><p>不仅共享资源会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：<strong>禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写</strong>。<br />换句话说，我们需要一种 <code>互斥(mutual exclusion)</code> 条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。</p><p>避免竞争问题的条件可以用一种抽象的方式去描述。大部分时间，进程都会忙于内部计算和其他不会导致竞争条件的计算。然而，有时候进程会访问共享内存或文件，或者做一些能够导致竞态条件的操作。我们把<strong>对共享内存进行访问的程序片段</strong>称作 <code>临界区域(critical region)</code> 或 <code>临界区(critical section)</code>。如果我们能够正确的操作，使两个不同进程不可能同时处于临界区，就能避免竞争条件，这也是从操作系统设计角度来进行的。</p><p>尽管上面这种设计避免了竞争条件，但是不能确保并发线程同时访问共享数据的正确性和高效性。一个好的解决方案，应该包含下面四种条件</p><ol><li>任何时候两个进程不能同时处于临界区</li><li>不应对 CPU 的速度和数量做任何假设</li><li>位于临界区外的进程不得阻塞其他进程</li><li>不能使任何进程无限等待进入临界区</li></ol><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200922124159.png" srcset="/img/loading.gif" alt="" /></p><p>从抽象的角度来看，我们通常希望进程的行为如上图所示，在 t1 时刻，进程 A 进入临界区，在 t2 的时刻，进程 B 尝试进入临界区，因为此时进程 A 正在处于临界区中，所以进程 B 会阻塞直到 t3 时刻进程 A 离开临界区，此时进程 B 能够允许进入临界区。最后，在 t4 时刻，进程 B 离开临界区，系统恢复到没有进程的原始状态。</p><h2 id="忙等互斥"><a class="markdownIt-Anchor" href="#忙等互斥"></a> 忙等互斥</h2><p>在实现互斥的各种方案中，当一个进程正忙于更新其临界区的共享内存时，没有其他进程会进入其临界区，也不会造成影响。</p><h3 id="1-屏蔽中断"><a class="markdownIt-Anchor" href="#1-屏蔽中断"></a> 1. 屏蔽中断</h3><p>在<code>单处理器</code>系统上，最简单的解决方案是<strong>让每个进程在进入临界区后立即屏蔽所有中断</strong>，并<strong>在离开临界区之前重新启用它们</strong>。屏蔽中断后，时钟中断也会被屏蔽。<code>CPU</code> 只有发生时钟中断或其他中断时才会进行进程切换。这样，在屏蔽中断后 <code>CPU</code> 不会切换到其他进程。<br />所以，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不用担心其他进程介入访问共享数据。</p><p>缺点：</p><ul><li>如果经过一段较长时间后进程没有离开，中断一直无法启用，可能会造成整个系统的终止。</li><li>如果是<code>多处理器</code>系统，<strong>屏蔽中断仅仅对执行 <code>disable</code> 指令的 <code>CPU</code> 有效</strong>。其他 <code>CPU</code> 仍将继续运行，并可以访问共享内存。</li></ul><h3 id="2-锁变量"><a class="markdownIt-Anchor" href="#2-锁变量"></a> 2. 锁变量</h3><p>考虑有单个共享的（锁）变量，初始为值为 0 。当一个线程想要进入临界区时，它首先会查看锁的值是否为 0 ，如果锁的值是 0 ，进程会把它设置为 1 并让进程进入临界区。如果锁的状态是 1，进程会等待直到锁变量的值变为 0。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200922130139.png" srcset="/img/loading.gif" alt="" /><br />此时假设一个进程读出锁变量的值并发现它为 0 ，而恰好在它将其设置为 1 之前，另一个进程调度运行，读出锁的变量为0 ，并将锁的变量设置为 1 。然后第一个线程运行，把锁变量的值再次设置为 1，此时，临界区域就会有两个进程在同时运行。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200922130639.png" srcset="/img/loading.gif" alt="" /></p><h3 id="3-严格轮询法"><a class="markdownIt-Anchor" href="#3-严格轮询法"></a> 3. 严格轮询法</h3><p>进程 0：当 <code>turn == 0</code> 进入临界区</p><pre><code class="hljs c"><span class="hljs-keyword">while</span>(TRUE)&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">turn</span> == <span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">/* 进入临界区 */</span>    critical_region();    <span class="hljs-built_in">turn</span> = <span class="hljs-number">1</span>;    <span class="hljs-comment">/* 离开临界区 */</span>    noncritical_region();  &#125;&#125;</code></pre><p>进程 1：当 <code>turn == 1</code> 进入临界区</p><pre><code class="hljs c"><span class="hljs-keyword">while</span>(TRUE)&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">turn</span> == <span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">/* 进入临界区 */</span>    critical_region();    <span class="hljs-built_in">turn</span> = <span class="hljs-number">0</span>;    <span class="hljs-comment">/* 离开临界区 */</span>    noncritical_region();  &#125;&#125;</code></pre><p>在上面代码中，变量 <code>turn</code>，初始值为 <code>0</code> ，用于记录轮到那个进程进入临界区，并检查或更新共享内存。开始时，<code>进程 0</code> 检查 <code>turn</code>，发现其值为 <code>0</code>，于是进入临界区。<code>进程 1</code> 也发现其值为 <code>0</code> ，所以在一个等待循环中不停的测试 <code>turn</code>，看其值何时变为 <code>1</code>。</p><blockquote><p>连续检查一个变量直到某个值出现为止，这种方法称为 <code>忙等待(busywaiting)</code>。用于忙等待的锁，称为 <code>自旋锁(spinlock)</code>。<br />由于这种方式<strong>浪费 <code>CPU</code> 时间</strong>，所以这种方式通常应该要避免。只有在有理由认为<strong>等待时间是非常短的情况下，才能够使用忙等待</strong>。</p></blockquote><p>当 <code>进程 0</code> 和 <code>进程 1</code> 都在非临界区时，此时 <code>进程 0</code> 结束了非临界区的操作并返回到循环的开始。但是，这时它不能进入临界区，因为 <code>turn == 1</code>，此时 <code>进程 1</code> 还忙于非临界区的操作，<code>进程 0</code> 只能继续阻塞，直到<code>进程 1</code> 把 <code>turn</code> 的值改为 <code>0</code>。这说明，在<strong>一个进程比另一个进程执行速度慢了很多的情况下，轮流进入临界区并不是一个好的方法。</strong></p><p>这种情况违反了前面的叙述 3 ，即 <strong>位于临界区外的进程不得阻塞其他进程</strong>，<code>进程 0</code> 被临界区外的 <code>进程 1</code> 阻塞。由于违反了第三条，所以也不能作为一个好的方案。</p><h3 id="4-peterson-解法"><a class="markdownIt-Anchor" href="#4-peterson-解法"></a> 4. Peterson 解法</h3><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE  1</span><span class="hljs-comment">/* 进程数量 */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N     2</span><span class="hljs-comment">/* 现在轮到谁 */</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">turn</span>;<span class="hljs-comment">/* 所有值初始化为 0 (FALSE) */</span><span class="hljs-keyword">int</span> interested[N];<span class="hljs-comment">/* 进程是 0 或 1 */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enter_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">process</span>)</span></span>&#123;    <span class="hljs-comment">/* 另一个进程号 */</span>  <span class="hljs-keyword">int</span> other;    <span class="hljs-comment">/* 另一个进程 */</span>  other = <span class="hljs-number">1</span> - <span class="hljs-built_in">process</span>;    <span class="hljs-comment">/* 表示愿意进入临界区 */</span>  interested[<span class="hljs-built_in">process</span>] = TRUE;  <span class="hljs-built_in">turn</span> = <span class="hljs-built_in">process</span>;    <span class="hljs-comment">/* 阻塞 */</span>  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">turn</span> == <span class="hljs-built_in">process</span>         &amp;&amp; interested[other] == <span class="hljs-literal">true</span>)&#123;&#125;   &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">leave_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">process</span>)</span></span>&#123;    <span class="hljs-comment">/* 表示离开临界区 */</span>  interested[<span class="hljs-built_in">process</span>] == FALSE; &#125;</code></pre><p>在使用共享变量时（即进入其临界区）之前，各个进程使用各自的进程号 <code>0</code> 或 <code>1</code> 作为参数来调用 <code>enter_region</code>，这个函数调用在需要时将使进程等待，直到能够安全的临界区。在完成对共享变量的操作之后，进程将调用 <code>leave_region</code> 表示操作完成，并且允许其他进程进入。</p><p>考虑一种两个进程同时调用 <code>enter_region</code> 的情况。它们都将自己的进程存入 <code>turn</code>，但只有最后保存进去的进程号才有效，前一个进程的进程号因为重写而丢失。假如 <code>进程 1</code> 是最后存入的，则 <code>turn = 1</code> 。当两个进程都运行到 <code>while</code> 的时候，<code>进程 0</code> 将不会循环并进入临界区，而 <code>进程 1</code> 将会无限循环且不会进入临界区，直到 <code>进程 0</code> 退出临界区为止。</p><h3 id="5-tsl-指令"><a class="markdownIt-Anchor" href="#5-tsl-指令"></a> 5. <code>TSL</code> 指令</h3><p>一些计算机，特别是那些设计为多处理器的计算机，都会有下面这条指令</p><pre><code class="hljs cos">TSL RX,<span class="hljs-keyword">LOCK</span></code></pre><p>称为 <code>测试并加锁(test and set lock)</code>，它将一个内存字 <code>lock</code> 读到寄存器 <code>RX</code> 中，然后在该内存地址上存储一个非零值。其执行过程是一条原语。在这个指令结束之前其他处理器均不允许访问内存。执行 <code>TSL</code> 指令的 <code>CPU</code> 将会锁住内存总线，用来禁止其他 <code>CPU</code> 在这个指令结束之前访问内存。</p><p>很重要的一点是锁住内存总线和禁用中断不一样。禁用中断并不能保证一个处理器在读写操作之间另一个处理器对内存的读写。也就是说，在 <code>处理器 1</code> 上屏蔽中断对 <code>处理器 2</code> 没有影响。让 <code>处理器 2</code> 远离内存直到 <code>处理器 1</code> 完成读写的最好的方式就是<strong>锁住总线</strong>。这需要一个特殊的硬件（基本上，一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能使用）。</p><h3 id="6-xchg-指令"><a class="markdownIt-Anchor" href="#6-xchg-指令"></a> 6. <code>XCHG</code> 指令</h3><p><code>XCHG</code> 指令可以替换 <code>TSL</code> 的指令，它原子性的交换了两个位置的内容，例如，一个寄存器与一个内存字。</p><p><code>XCHG</code> 的本质上与 <code>TSL</code> 的解决办法一样。所有的 <code>Intel x86</code> <code>CPU</code> 在底层同步中使用 <code>XCHG</code> 指令。</p><h2 id="睡眠与唤醒"><a class="markdownIt-Anchor" href="#睡眠与唤醒"></a> 睡眠与唤醒</h2><p><code>Peterson</code> 、<code>TSL</code> 和 <code>XCHG</code> 解法都是正确的，但是它们都有<strong>忙等待</strong>的缺点。这些解法的本质上都是一样的，先检查是否能够进入临界区，若不允许，则该进程将原地等待，直到允许为止。</p><p>这种方式不但浪费了 <code>CPU</code> 时间，而且还可能引起意想不到的结果。考虑一台计算机上有两个进程，这两个进程具有不同的优先级，<code>H</code> 是属于优先级比较高的进程，<code>L</code> 是属于优先级比较低的进程。进程调度的规则是<strong>不论何时只要 <code>H 进程</code> 处于就绪态 <code>H</code> 就开始运行</strong>。<br />在某一时刻，<strong><code>L</code> 处于临界区中</strong>，此时 <code>H</code> 变为就绪态，准备运行（例如，一条 I/O 操作结束）。现在 <code>H</code> 要开始忙等，但由于当 <code>H</code> 就绪时 <code>L</code> 就不会被调度，<code>L</code> 从来不会有机会离开临界区，所以 <code>H</code> 会变成<strong>死循环</strong>，有时将这种情况称为 <code>优先级反转问题(priority inversion problem)</code>。</p><p>进程间的通信原语<strong>在不允许它们进入临界区之前会阻塞</strong>而不是浪费 <code>CPU</code> 时间，最简单的是 <code>sleep</code> 和 <code>wakeup</code>。</p><ul><li><code>Sleep</code> 是一个能够造成调用者阻塞的系统调用，也就是说，这个系统调用会暂停直到其他进程唤醒它。</li><li><code>wakeup</code> 调用有一个参数，即要唤醒的进程。</li></ul><p>还有一种方式是 <code>wakeup</code> 和 <code>sleep</code> 都有一个参数，即 <code>sleep</code> 和 <code>wakeup</code> 需要匹配的内存地址。</p><h3 id="生产者-消费者问题"><a class="markdownIt-Anchor" href="#生产者-消费者问题"></a> 生产者-消费者问题</h3><p><code>生产者-消费者(producer-consumer)</code> 问题，也称作 <code>有界缓冲区(bounded-buffer)</code> 问题。两个进程共享一个公共的固定大小的缓冲区。其中一个是<code>生产者(producer)</code>，将信息放入缓冲区， 另一个是<code>消费者(consumer)</code>，会从缓冲区中取出。</p><p>如果缓冲队列已满，那么当生产者仍想要将数据写入缓冲区的时候，会出现问题。它的解决办法是让生产者睡眠，也就是阻塞生产者。等到消费者从缓冲区中取出一个或多个数据项时再唤醒它。同样的，当消费者试图从缓冲区中取数据，但是发现缓冲区为空时，消费者也会睡眠，阻塞。直到生产者向其中放入一个新的数据。</p><pre><code class="hljs c"><span class="hljs-comment">/* 缓冲区 slot 槽的数量 */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span><span class="hljs-comment">/* 缓冲区数据的数量 */</span><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>  <span class="hljs-comment">// 生产者</span><span class="hljs-keyword">void</span> producer(<span class="hljs-keyword">void</span>)&#123;  <span class="hljs-keyword">int</span> item;    <span class="hljs-comment">/* 无限循环 */</span>  <span class="hljs-keyword">while</span>(TRUE)&#123;    <span class="hljs-comment">/* 生成下一项数据 */</span>    item = produce_item()    <span class="hljs-comment">/* 如果缓存区是满的，就会阻塞 */</span>    <span class="hljs-keyword">if</span>(count == N)&#123;      sleep();    &#125;        <span class="hljs-comment">/* 把当前数据放在缓冲区中 */</span>    insert_item(item);    <span class="hljs-comment">/* 增加缓冲区 count 的数量 */</span>    count = count + <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>)&#123;      <span class="hljs-comment">/* 缓冲区是否为空？ */</span>      wakeup(consumer);    &#125;  &#125;&#125;<span class="hljs-comment">// 消费者</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> item;    <span class="hljs-comment">/* 无限循环 */</span>  <span class="hljs-keyword">while</span>(TRUE)&#123;    <span class="hljs-comment">/* 如果缓冲区是空的，就会进行阻塞 */</span>    <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;      sleep();    &#125;    <span class="hljs-comment">/* 从缓冲区中取出一个数据 */</span>    item = remove_item();    <span class="hljs-comment">/* 将缓冲区的 count 数量减一 */</span>    count = count - <span class="hljs-number">1</span>    <span class="hljs-comment">/* 缓冲区满？ */</span>    <span class="hljs-keyword">if</span>(count == N - <span class="hljs-number">1</span>)&#123;      wakeup(producer);    &#125;    <span class="hljs-comment">/* 打印数据项 */</span>    consumer_item(item);  &#125;  &#125;</code></pre><p>上面代码中会产生竞争条件。有可能出现下面这种情况：缓冲区为空，此时消费者刚好读取 <code>count</code> 的值发现它为 <code>0</code>。此时<strong>调度程序决定暂停消费者</strong>并启动运行生产者。生产者生产了一条数据并把它放在缓冲区中，然后增加 <code>count</code> 的值，<code>count = 1</code> 。由于 <code>count</code> 初始为 <code>0</code>，消费者必须处于睡眠状态，因此生产者调用 <code>wakeup</code> 来唤醒消费者。但是，消费者此时在逻辑上并没有睡眠，所以 <code>wakeup</code> 信号会<strong>丢失</strong>。当消费者下次启动后，它会查看之前读取的 <code>count</code> 值，发现它的值是 <code>0</code>，然后在此进行睡眠。不久之后生产者会填满整个缓冲区，在这之后会阻塞，这样一来两个进程将永远睡眠下去。</p><p>引起上面问题的本质是 <strong>唤醒尚未进行睡眠状态的进程会导致唤醒丢失</strong>。如果它没有丢失，则一切都很正常。一种快速解决上面问题的方式是增加一个 <code>唤醒等待位(wakeup waiting bit)</code>。当一个 <code>wakeup</code> 信号发送给仍在清醒的进程后，该位置为 <code>1</code>。之后，当进程尝试睡眠的时候，如果唤醒等待位为 <code>1</code>，则该位清除，而进程仍然保持清醒。</p><p>然而，当进程数量有许多的时候，这时可以通过增加唤醒等待位的数量来唤醒等待位，于是就有了 2、4、6、8 个唤醒等待位，但是并没有从根本上解决问题。</p><h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2><p>一个信号量的取值可以是 <code>0</code> ，或任意正数。<code>0</code> 表示的是不需要任何唤醒，任意的正数表示的就是资源数目（唤醒次数）。</p><p>Dijkstra 提出了信号量有两个操作，现在通常使用 <code>down (P)</code> 和 <code>up (V)</code>（分别可以用 <code>sleep</code> 和 <code>wakeup</code> 来表示）。</p><ul><li><code>down</code> 操作会检查值是否大于 <code>0</code> 。如果大于 <code>0</code> ，则将其值 <code>- 1</code> ；若该值为 <code>0</code>，则进程将睡眠，而且此时 <code>down</code> 操作将会继续执行。</li></ul><p><strong>检查数值</strong>、<strong>修改变量值</strong>以及可能发生的<strong>睡眠操作</strong>均为一个单一的、不可分割的 <code>原子操作(atomic action)</code> 完成。这会保证一旦信号量操作开始，没有其他的进程能够访问信号量，直到操作完成或者阻塞。这种原子性对于解决同步问题和避免竞争绝对必不可少。</p><ul><li><code>up</code> 操作会使信号量的值 <code>+ 1</code>。如果一个或者多个进程在信号量上睡眠，无法完成一个先前的 <code>down</code> 操作，则由系统选择（<strong>随机挑选</strong>）其中的一个并允许该程完成 <code>down</code> 操作。</li></ul><p>因此，对一个进程在其上睡眠的信号量执行一次 <code>up</code> 操作之后，该信号量的值仍然是 <code>0</code> ，但在其上睡眠的进程却少了一个。信号量的值增 <code>1</code> 和唤醒一个进程同样也是不可分割的。不会有某个进程因执行 <code>up</code> 而阻塞，正如在前面的模型中不会有进程因执行 <code>wakeup</code> 而阻塞是一样的道理。</p><h3 id="用信号量解决生产者-消费者问题"><a class="markdownIt-Anchor" href="#用信号量解决生产者-消费者问题"></a> 用信号量解决生产者 - 消费者问题</h3><p>用信号量解决丢失的 <code>wakeup</code> 问题，代码如下：</p><pre><code class="hljs c"><span class="hljs-comment">/* 定义缓冲区槽的数量 */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span><span class="hljs-comment">/* 信号量是一种特殊的 int */</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;<span class="hljs-comment">/* 控制临界区的访问 */</span>semaphore mutex = <span class="hljs-number">1</span>;<span class="hljs-comment">/* 统计 buffer 空槽的数量 */</span>semaphore empty = N;<span class="hljs-comment">/* 统计 buffer 满槽的数量 */</span>semaphore full = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;     <span class="hljs-keyword">int</span> item;      <span class="hljs-keyword">while</span>(TRUE)&#123;    <span class="hljs-comment">/* 产生放在缓冲区的一些数据 */</span>    item = producer_item();    <span class="hljs-comment">/* 将空槽数量减 1  */</span>    <span class="hljs-comment">// 若空槽数量不够，则阻塞</span>    down(&amp;empty);        <span class="hljs-comment">/* 进入临界区  */</span>    down(&amp;mutex);    <span class="hljs-comment">/* 把数据放入缓冲区中 */</span>    insert_item(item);    <span class="hljs-comment">/* 离开临界区 */</span>    up(&amp;mutex);        <span class="hljs-comment">/* 将 buffer 满槽数量 + 1 */</span>    up(&amp;full);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> item;    <span class="hljs-keyword">while</span>(TRUE)&#123;    <span class="hljs-comment">/* 缓存区满槽数量 - 1 */</span>    <span class="hljs-comment">// 若满槽数量不足，无法消费，则阻塞</span>    down(&amp;full);        <span class="hljs-comment">/* 进入缓冲区 */</span>    down(&amp;mutex);    <span class="hljs-comment">/* 从缓冲区取出数据 */</span>    item = remove_item();    <span class="hljs-comment">/* 离开临界区 */</span>    up(&amp;mutex);        <span class="hljs-comment">/* 将空槽数目 + 1 */</span>    <span class="hljs-comment">// 消费数据和不需要同步，所以先处理空槽数再消费取出的数据</span>    up(&amp;empty);        <span class="hljs-comment">/* 消费数据 */</span>    consume_item(item);  &#125;&#125;</code></pre><p>为了确保信号量能正确工作，最重要的是要采用一种不可分割的方式来实现它。通常是将 <code>up</code> 和 <code>down</code> 作为系统调用来实现。而且操作系统只需在执行以下操作时暂时屏蔽全部中断：<strong>检查信号量</strong>、<strong>更新</strong>、<strong>必要时使进程睡眠</strong>。由于这些操作仅需要非常少的指令，因此中断不会造成影响。如果使用多个 <code>CPU</code>，那么信号量应该被<strong>锁</strong>进行保护。使用 <code>TSL</code> 或者 <code>XCHG</code> 指令用来确保同一时刻只有一个 <code>CPU</code> 对信号量进行操作。</p><p>使用 <code>TSL</code> 或者 <code>XCHG</code> 来防止几个 <code>CPU</code> 同时访问一个信号量，与生产者或消费者使用<strong>忙等待</strong>来等待其他腾出或填充缓冲区是完全不一样的。前者的操作仅需要几个毫秒，而生产者或消费者可能需要任意长的时间。</p><p>上面这个解决方案使用了三种信号量：一个称为 <code>full</code>，用来记录充满的缓冲槽数目；一个称为 <code>empty</code>，记录空的缓冲槽数目；一个称为 <code>mutex</code>，<strong>用来确保生产者和消费者不会同时进入缓冲区</strong>。<code>full</code> 被初始化为 <code>0</code>，<code>empty</code> 初始化为缓冲区中插槽数，<code>mutex</code> 初始化为 <code>1</code>。</p><blockquote><p>供两个或多个进程使用的信号量，初始化为 <code>1</code>，保证它们中同时只有一个可以进入临界区的信号被称为 <code>二进制信号量(binary semaphores)</code>。如果每个进程都在进入临界区之前执行 <code>down</code> 操作，而在离开临界区之后执行 <code>up</code> 操作，则可以确保相互互斥。</p></blockquote><p>信号量的另一用途是实现 <code>同步（synchronizeation）</code>。信号量 <code>full</code> 和 <code>empty</code> 用来保证某种事件的顺序发生或不发生。</p><h2 id="互斥量"><a class="markdownIt-Anchor" href="#互斥量"></a> 互斥量</h2><p>如果不需要信号量的计数能力时，可以使用信号量的一个简单版本，称为 <code>mutex (互斥量)</code>。互斥量的优势就在于在一些共享资源和一段代码中保持互斥。由于互斥的实现既简单又有效，这使得互斥量在实现用户空间线程包时非常有用。</p><p>互斥量是一个处于<strong>两种状态</strong>之一的共享变量：<code>解锁(unlocked)</code> 和 <code>加锁(locked)</code>。这样，只需要<strong>一个二进制位</strong>来表示它，不过一般情况下，通常会用一个 <code>整形(integer)</code> 来表示。<code>0</code> 表示解锁，其他所有的值表示加锁，比 <code>1</code> 大的值表示加锁的次数。</p><p>当一个线程（或者进程）需要访问临界区时，会调用 <code>mutex_lock</code> 进行加锁。</p><ul><li>如果互斥锁当前处于<strong>未锁定</strong>状态（表示临界区可用），则调用成功，并且调用线程可以自由进入临界区。</li><li>如果 <code>mutex</code> 互斥量<strong>已经锁定</strong>，调用线程会<strong>阻塞直到临界区内的线程执行完毕并且调用了 <code>mutex_unlock</code>。</strong> 如果多个线程在 <code>mutex</code> 互斥量上阻塞，将随机选择一个线程并允许它获得锁。</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200922155103.png" srcset="/img/loading.gif" alt="" /></p><p>随着并行的增加，有效的 <code>同步(synchronization)</code> 和 <code>锁定(locking)</code> 对于性能来说是非常重要的。</p><ul><li>如果进程等待时间很短，那么 <code>自旋锁(Spin lock)</code> 是非常有效；但是如果等待时间比较长，那么这会浪费 CPU 周期。</li><li>如果进程很多，那么阻塞此进程，并仅当锁被释放的时候让内核解除阻塞是更有效的方式。<br />不幸的是：它可以在进程竞争频繁的时候运行良好，但是在竞争不是很激烈的情况下内核切换的消耗会非常大，而且更困难的是，预测锁的竞争数量更不容易。</li></ul><h2 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h2><p>管程是程序、变量和数据结构等组成的一个集合，它们组成一个特殊的模块或者包。进程可以在任何需要的时候调用管程中的程序，但是它们不能从管程外部访问数据结构和程序。</p><p><strong>在任何时候管程中只能有一个活跃的进程</strong>，这一特性使管程能够很方便的实现互斥操作。通常情况下，当进程调用管程中的程序时，该程序的前几条指令会检查管程中是否有其他活跃的进程。如果有的话，调用进程将被挂起，直到另一个进程离开管程才将其唤醒。如果没有活跃进程在使用管程，那么该调用进程才可以进入。</p><p>即使管程提供了一种简单的方式来实现互斥，但在我们看来，这还不够。因为我们还需要一种<strong>使得进程在无法执行时被阻塞</strong>。在生产者-消费者问题中，很容易将针对缓冲区满和缓冲区空的测试放在管程程序中，但是生产者在发现缓冲区满的时候该如何阻塞呢？</p><p>解决的办法是引入 <code>条件变量(condition variables)</code> 以及相关的两个操作 <code>wait</code> 和 <code>signal</code>。当一个管程程序发现它不能运行时（例如，生产者发现缓冲区已满），它会在某个条件变量（如 <code>full</code>）上执行 <code>wait</code> 操作。这个操作造成调用进程阻塞，并且还将另一个以前等在管程之外的进程调入管程。另一个进程，比如消费者可以通过执行 <code>signal</code> 来唤醒阻塞的调用进程。</p><p>如果在一个条件变量上有若干进程都在等待，则在对该条件执行 <code>signal</code> 操作后，系统调度程序只能选择其中一个进程恢复运行。</p><blockquote><p>条件变量不是计数器。条件变量也不能像信号量那样积累信号以便以后使用。所以，如果向一个条件变量发送信号，但是该条件变量上没有等待进程，那么信号将会丢失。也就是说，<strong><code>wait</code> 操作必须在 <code>signal</code> 之前执行</strong>。</p></blockquote><p>通过临界区自动的互斥，<strong>管程比信号量更容易保证并行编程的正确性</strong>。但是管程也有缺点，我们前面说到过管程是一个编程语言的概念，编译器必须要识别管程并用某种方式对其互斥作出保证。C、Pascal 以及大多数其他编程语言都没有管程，所以不能依靠编译器来遵守互斥规则。</p><p>与管程和信号量有关的另一个问题是，<strong>这些机制都是设计用来解决访问共享内存的一个或多个 <code>CPU</code> 上的互斥问题的</strong>。</p><ul><li>通过将信号量放在共享内存中并用 <code>TSL</code> 或 <code>XCHG</code> 指令来保护它们，可以避免竞争。</li><li>但是如果是在分布式系统中，可能同时具有多个 <code>CPU</code> 的情况，并且每个 <code>CPU</code> 都有自己的私有内存呢，它们通过网络相连，那么这些原语将会失效。因为信号量太低级了，而管程在少数几种编程语言之外无法使用，所以还需要其他方法。</li></ul><h2 id="消息传递"><a class="markdownIt-Anchor" href="#消息传递"></a> 消息传递</h2><p><code>消息传递(messaage passing)</code> 使用两个原语 <code>send</code> 和 <code>receive</code>，它们像信号量而不像管程，是系统调用而不是语言级别。示例如下</p><pre><code class="hljs c">send(destination, &amp;message);receive(source, &amp;message);</code></pre><p><code>send</code> 方法用于向一个给定的目标发送一条消息，<code>receive</code> 从一个给定的源接受一条消息。如果没有消息，接受者可能被阻塞，直到接受一条消息或者带着错误码返回。</p><h3 id="设计要点"><a class="markdownIt-Anchor" href="#设计要点"></a> 设计要点</h3><p>消息传递系统现在面临着许多信号量和管程所未涉及的问题和设计难点，尤其对那些在网络中不同机器上的通信状况。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923130422.png" srcset="/img/loading.gif" alt="" /></p><ul><li><p><strong>消息丢失</strong> - 为了防止消息丢失，发送方和接收方可以达成一致：一旦接受到消息后，接收方马上回送一条特殊的 <code>确认(acknowledgement)</code> 消息。如果发送方在一段时间间隔内未收到确认，则重发消息。</p></li><li><p><strong>确认消息丢失</strong> - 发送者将重发消息，这样接受者将收到两次相同的消息。对于接收者来说，如何区分新的消息和一条重发的老消息是非常重要的。通常采用<strong>在每条原始消息中嵌入一个连续的序号</strong>来解决此问题。如果接受者收到一条消息，它具有与前面某一条消息一样的序号，就知道这条消息是重复的，可以忽略。</p></li></ul><h3 id="用消息传递解决生产者-消费者问题"><a class="markdownIt-Anchor" href="#用消息传递解决生产者-消费者问题"></a> 用消息传递解决生产者-消费者问题</h3><pre><code class="hljs c"><span class="hljs-comment">/* buffer 中槽的数量 */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> item;  <span class="hljs-comment">/* buffer 中槽的数量 */</span>  message m;    <span class="hljs-keyword">while</span>(TRUE)&#123;    <span class="hljs-comment">/* 生成放入缓冲区的数据 */</span>    item = produce_item();    <span class="hljs-comment">/* 等待消费者发送空缓冲区 */</span>    receive(consumer,&amp;m);    <span class="hljs-comment">/* 建立一个待发送的消息 */</span>    build_message(&amp;m,item);    <span class="hljs-comment">/* 发送给消费者 */</span>    send(consumer,&amp;m);  &#125;  &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> item,i;  message m;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++)&#123;    <span class="hljs-comment">/* 发送 N 个缓冲区 */</span>    send(producer,&amp;m);  &#125;  <span class="hljs-keyword">while</span>(TRUE)&#123;    <span class="hljs-comment">/* 接受包含数据的消息 */</span>    receive(producer,&amp;m);    <span class="hljs-comment">/* 将数据从消息中提取出来 */</span>    item = extract_item(&amp;m);    <span class="hljs-comment">/* 将空缓冲区发送回生产者 */</span>    send(producer,&amp;m);    <span class="hljs-comment">/* 处理数据 */</span>    consume_item(item);  &#125;  &#125;</code></pre><p>在该解决方案中共使用 <code>N</code> 条消息，这就类似于一块共享内存缓冲区的 <code>N</code> 个槽。消费者首先将 <code>N</code> 条空消息发送给生产者。当生产者向消费者传递一个数据项时，它取走一条空消息并返回一条填充了内容的消息。通过这种方式，系统中总的消息数量保持不变，所以消息都可以存放在事先确定数量的内存中。</p><h2 id="屏障"><a class="markdownIt-Anchor" href="#屏障"></a> 屏障</h2><p>屏障是用于<strong>进程组</strong>而不是进程间的生产者-消费者情况的。在某些应用中划分了若干阶段，并且规定，除非<strong>所有的进程都就绪</strong>准备进入下一个阶段，否则任何进程都不能进入下一个阶段，可以通过在每个阶段的结尾安装一个 <code>屏障(barrier)</code> 来实现这种行为。当一个进程到达屏障时，它会被屏障所拦截，直到所有的屏障都到达为止。屏障可用于一组进程同步，如下图所示：</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923131256.png" srcset="/img/loading.gif" alt="" /></p><h1 id="调度"><a class="markdownIt-Anchor" href="#调度"></a> 调度</h1><p>在多道程序系统中，<strong>调度的实质是一种资源分配</strong>，多个进程或者线程同时竞争 <code>CPU</code> 和<code>时间片</code>，通过调度算法来选择需要运行的进程/线程。</p><h2 id="调度介绍"><a class="markdownIt-Anchor" href="#调度介绍"></a> 调度介绍</h2><p>批处理系统的时代：依次运行磁带上的每一个作业。<br />对于多道程序设计系统，会复杂一些，因为通常会有多个用户在等待服务。一些大型机仍然将 <code>批处理</code> 和 <code>分时服务</code> 结合使用，需要调度程序决定下一个运行的是一个批处理作业还是终端上的用户。由于在这些机器中 <code>CPU</code> 是稀缺资源，所以好的调度程序可以在提高性能和用户的满意度方面取得很大的成果。</p><h3 id="进程行为"><a class="markdownIt-Anchor" href="#进程行为"></a> 进程行为</h3><p><strong>几乎所有的进程（磁盘或网络）I/O 请求和计算都是交替运行的。</strong><br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923134601.png" srcset="/img/loading.gif" alt="" /><br />上面 <code>a</code> 是 <code>CPU 密集型</code> 进程；<code>b</code> 是 <code>I/O 密集型</code> 进程，<code>a</code> 因为在计算的时间上花费时间更长，因此称为 <code>计算密集型(compute-bound)</code> 或者 <code>CPU 密集型(CPU-bound)</code>，<code>b</code> 因为 <code>I/O</code> 发生频率比较快因此称为 <code>I/O 密集型(I/O-bound)</code>。</p><ul><li>计算密集型进程有较长的 <code>CPU</code> 集中使用和较小频度的 <code>I/O</code> 等待。</li><li><code>I/O</code> 密集型进程有较短的 <code>CPU</code> 使用时间和较频繁的 <code>I/O</code> 等待。</li></ul><p>注意到上面两种进程的区分关键在于 <strong><code>CPU</code> 的时间占用</strong>而不是 <code>I/O</code> 的时间占用。<br /><code>I/O 密集型</code> 的原因是因为<strong>它们没有在 <code>I/O</code> 之间花费更多的计算、而不是 <code>I/O</code> 请求时间特别长</strong>。无论数据到达后需要花费多少时间，它们都需要花费相同的时间来发出读取磁盘块的硬件请求。</p><p>值得注意的是，随着 <code>CPU</code> 的速度越来越快，更多的进程倾向于 <code>I/O 密集型</code>。这种情况出现的原因是 <code>CPU</code> 速度的提升要远远高于硬盘。这种情况导致的结果是，未来对 <code>I/O</code> 密集型进程的调度处理似乎更为重要。这里的基本思想是，如果需要运行 <code>I/O</code> 密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌。</p><h3 id="何时调度"><a class="markdownIt-Anchor" href="#何时调度"></a> 何时调度</h3><p>第一个和调度有关的问题是<strong>何时进行调度决策</strong>。存在着需要调度处理的各种情形。</p><ul><li><p>首先，在创建一个新进程后，需要决定是运行父进程还是子进程。因为二者的进程都处于就绪态下，这是正常的调度决策，可以任意选择，也就是说，调度程序可以任意的选择子进程或父进程开始运行。</p></li><li><p>第二，在进程退出时需要作出调度决定。因为此进程不再运行（因为它将不再存在），因此必须从就绪进程中选择其他进程运行。如果没有进程处于就绪态，系统提供的空闲进程通常会运行。</p></li></ul><h3 id="调度算法的分类"><a class="markdownIt-Anchor" href="#调度算法的分类"></a> 调度算法的分类</h3><p>不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，<strong>在不同的系统中，调度程序的优化也是不同的</strong>。这里有必要划分出三种环境：</p><ol><li><p><code>批处理(Batch)</code>：<br />批处理系统广泛应用于商业领域，比如用来处理工资单、存货清单、账目收入、账目支出、利息计算、索赔处理和其他周期性作业。在批处理系统中，<strong>一般会选择使用<code>非抢占式算法</code>或者<code>周期性比较长的抢占式算法</code></strong>。这种方法可以<code>减少线程切换</code>因此能够提升性能。</p></li><li><p><code>交互式(Interactive)</code>：<br />在交互式用户环境中，为了避免一个进程霸占 <code>CPU</code> 拒绝为其他进程服务，所以需要<code>抢占式算法</code>。即使没有进程有意要一直运行下去，但是，由于某个进程出现错误也有可能无限期的排斥其他所有进程。为了避免这种情况，抢占式也是必须的。服务器也属于此类别，因为它们通常为多个（远程）用户提供服务，而这些用户都非常着急，计算机用户总是很忙。</p></li><li><p><code>实时(Real time)</code>：<br />在实时系统中，抢占有时是不需要的，因为进程知道自己可能运行不了很长时间，通常很快的做完自己的工作并阻塞。</p></li></ol><p>实时系统与交互式系统的差别是，实时系统只运行那些用来推进现有应用的程序，而交互式系统是通用的，它可以运行任意的非协作甚至是有恶意的程序。</p><h3 id="调度算法的目标"><a class="markdownIt-Anchor" href="#调度算法的目标"></a> 调度算法的目标</h3><p>所有系统:</p><ul><li>公平：给每个进程公平的 <code>CPU</code> 份额。</li><li>策略强制执行：保证规定的策略被执行。</li><li>平衡：保持系统的所有部分都忙碌。</li></ul><p>批处理系统：</p><ul><li>吞吐量：系统每小时完成的作业数量。</li><li>周转时间：一个批处理提交开始直到作业完成时刻为止平均时间。该数据度量了用户要得到输出所需的平均等待时间。周转时间越小越好。</li><li><code>CPU</code> 利用率：保持 <code>CPU</code> 时钟忙碌。</li></ul><p>交互式系统：</p><ul><li>减少响应时间。</li><li>均衡性：满足用户期望。</li></ul><p>实时系统</p><ul><li>必须满足最后的截止时间：避免数据丢失。</li><li>可预测性：多媒体系统中避免品质降低。</li></ul><h2 id="一-批处理中的调度"><a class="markdownIt-Anchor" href="#一-批处理中的调度"></a> 一. 批处理中的调度</h2><h3 id="1-先来先服务"><a class="markdownIt-Anchor" href="#1-先来先服务"></a> 1. 先来先服务</h3><p><code>先来先服务(first-come,first-serverd)</code> <strong>将按照请求顺序为进程分配 <code>CPU</code>。</strong> 最基本的，会有一个就绪进程的等待队列。</p><ul><li>当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。</li><li>当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。</li><li>当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923142129.png" srcset="/img/loading.gif" alt="" /></li></ul><p>缺点：<strong>没有优先级的关系</strong>，试想一下，如果有 100 个 I/O 进程正在排队，第 101 个是一个 CPU 密集型进程，那岂不是需要等 100 个 I/O 进程运行完毕才会等到一个 CPU 密集型进程运行，这在实际情况下根本不可能，所以需要 <code>优先级</code> 或者 <code>抢占式</code> 进程的出现来优先选择重要的进程运行。</p><h3 id="2-最短作业优先"><a class="markdownIt-Anchor" href="#2-最短作业优先"></a> 2. 最短作业优先</h3><p><code>最短作业优先(Shortest Job First)</code> 以作业的长短来计算优先级，作业越短，其优先级越高。</p><blockquote><p>需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923142638.png" srcset="/img/loading.gif" alt="" /></p><h3 id="3-最短剩余时间优先"><a class="markdownIt-Anchor" href="#3-最短剩余时间优先"></a> 3. 最短剩余时间优先</h3><p>最短作业优先的<code>抢占式</code>版本被称作为 <code>最短剩余时间优先(Shortest Remaining Time Next)</code> 算法。使用这个算法，调度程序总是选择<strong>剩余运行时间最短</strong>的那个进程运行。当一个新作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式能够使短期作业获得良好的服务。</p><h2 id="二-交互式系统中的调度"><a class="markdownIt-Anchor" href="#二-交互式系统中的调度"></a> 二. 交互式系统中的调度</h2><h3 id="1-轮询调度"><a class="markdownIt-Anchor" href="#1-轮询调度"></a> 1. 轮询调度</h3><p>一种最古老、最简单、最公平并且最广泛使用的算法就是 <code>轮询算法(round-robin)</code>。每个进程都会被分配一个时间段，称为 <code>时间片(quantum)</code>，在这个时间片内允许进程运行。</p><p>切换时机：</p><ul><li>如果时间片结束时进程还在运行的话，则抢占一个 <code>CPU</code> 并将其分配给另一个进程。</li><li>如果进程在时间片结束前阻塞或结束，则 <code>CPU</code> 立即进行切换。</li></ul><p>时间片大小：</p><ul><li>小时间片有利于短作业，但会频繁执行进程调度和上下文切换。</li><li>长时间片，为了使每个进程在一个时间片内完成，RR 算法便退化为 FCFS 算法，无法满足短作业和交互用户的需求。</li><li>一个较为可取的时间片大小是略大于一次典型的交互所需要的时间，使大多数交互式进程能在一个时间片内完成，从而可以获得很小的响应时间。</li></ul><p>轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 <code>a</code>，当一个进程用完时间片后就被移到队列的末尾，就像下图的 <code>b</code>。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923143142.png" srcset="/img/loading.gif" alt="" /></p><h3 id="2-优先级调度"><a class="markdownIt-Anchor" href="#2-优先级调度"></a> 2. 优先级调度</h3><p><code>优先级调度(priority scheduling)</code> 是把处理机分配给就绪队列中优先级最高的进程。</p><p>但是也不意味着高优先级的进程能够永远一直运行下去，调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果此操作导致其优先级降低到下一个最高进程的优先级以下，则会发生进程切换。或者，可以为每个进程分配允许运行的最大时间间隔。当时间间隔用完后，下一个高优先级的进程会得到运行的机会。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923144447.png" srcset="/img/loading.gif" alt="" /><br />算法类型：</p><ul><li>非抢占式：一旦 CPU 分配给就绪队列中优先级最高的进程后，该进程便一直执行下去直至完成。</li><li>抢占式：在优先级最高的进程执行期间，只要出现另一个优先级更高的进程，就将 CPU 分配给新的最高优先级进程。</li></ul><p>优先级类型：</p><ul><li>静态优先级：在创建进程时确定优先级，在进程的整个运行期间保持不变。</li><li>动态优先级：在创建进程之初，先赋予一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。</li></ul><h3 id="3-多级队列"><a class="markdownIt-Anchor" href="#3-多级队列"></a> 3. 多级队列</h3><p>将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，就绪队列本身也可以设置不同的优先级。</p><h3 id="4-最短进程优先"><a class="markdownIt-Anchor" href="#4-最短进程优先"></a> 4. 最短进程优先</h3><p>根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。<br />假设每个终端上每条命令的预估运行时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，现在假设测量到其下一次运行时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，可以用两个值的加权来改进估计时间，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><msub><mi>T</mi><mn>0</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">aT_0 + (1 - a)T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。通过选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">a = \frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 时，可以得到下面这个序列：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msub><mi>T</mi><mn>0</mn></msub><mn>2</mn></mfrac><mo>+</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{T_0}{2} + \frac{T_1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msub><mi>T</mi><mn>0</mn></msub><mn>4</mn></mfrac><mo>+</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mn>4</mn></mfrac><mo>+</mo><mfrac><msub><mi>T</mi><mn>2</mn></msub><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{T_0}{4} + \frac{T_1}{4} + \frac{T_2}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msub><mi>T</mi><mn>0</mn></msub><mn>8</mn></mfrac><mo>+</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mn>8</mn></mfrac><mo>+</mo><mfrac><msub><mi>T</mi><mn>2</mn></msub><mn>4</mn></mfrac><mo>+</mo><mfrac><msub><mi>T</mi><mn>3</mn></msub><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{T_0}{8} + \frac{T_1}{8} + \frac{T_2}{4} + \frac{T_3}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>可以看到，在三轮过后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在新的估计值中所占比重下降至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">1/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">8</span></span></span></span>。</p><p>有时把这种通过当前测量值和先前估计值进行加权平均从而得到下一个估计值的技术称作 <code>老化(aging)</code>。这种方法会使用很多预测值基于当前值的情况。</p><h3 id="5-保证调度"><a class="markdownIt-Anchor" href="#5-保证调度"></a> 5. 保证调度</h3><p>对用户做出明确的性能保证。一种实际而且容易实现的保证是：在一个有 <code>n</code> 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 <code>1/n</code> 的 <code>CPU</code> 时间。</p><h3 id="6-彩票调度"><a class="markdownIt-Anchor" href="#6-彩票调度"></a> 6. 彩票调度</h3><p><code>彩票调度(lottery scheduling)算法</code> 为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。</p><ul><li><p><strong>所有的进程是平等的，但是某些进程能够更平等一些。</strong> 一些重要的进程可以给它们额外的彩票，以便增加他们赢得的机会。<br />如果出售了 100 张彩票，而且有一个进程持有了它们中的 20 张，它就会有 20% 的机会去赢得彩票中奖。在长时间的运行中，它就会获得 20% 的CPU。相反，对于优先级调度程序，很难说明拥有优先级 40 究竟是什么意思，这里的规则很清楚，拥有彩票 f 份额的进程大约得到系统资源的 f 份额。</p></li><li><p><strong>如果希望进程之间协作的话可以交换它们之间的票据。</strong> 例如，客户端进程给服务器进程发送了一条消息后阻塞，客户端进程可能会把自己所有的票据都交给服务器，来增加下一次服务器运行的机会。当服务完成后，它会把彩票还给客户端让其有机会再次运行。事实上，如果没有客户机，服务器也根本不需要彩票。</p></li></ul><h3 id="7-公平分享调度"><a class="markdownIt-Anchor" href="#7-公平分享调度"></a> 7. 公平分享调度</h3><p>一些系统在调度前会把<strong>进程的拥有者</strong>考虑在内。在这种模型下，<strong>每个用户都会分配一些 <code>CPU</code> 时间，而调度程序会选择进程并强制执行。</strong> 因此如果两个用户每个都会有 <code>50%</code> 的 <code>CPU</code> 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 <code>CPU</code> 份额。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923151340.png" srcset="/img/loading.gif" alt="" /></p><h2 id="三-实时系统中的调度"><a class="markdownIt-Anchor" href="#三-实时系统中的调度"></a> 三. 实时系统中的调度</h2><p><code>实时系统(real-time)</code> 是一个时间扮演了重要作用的系统。典型的，一种或多种外部物理设备发给计算机一个服务请求，而计算机<strong>必须在一个确定的时间范围内恰当的做出反应</strong>。</p><p>例如，在 CD 播放器中的计算机会获得从驱动器过来的位流，然后必须在非常短的时间内将位流转换为音乐播放出来。如果计算时间过长，那么音乐就会听起来有异常。<br />再比如说医院特别护理部门的病人监护装置、飞机中的自动驾驶系统、列车中的烟雾警告装置等，在这些例子中，正确但是却缓慢的响应要比没有响应甚至还糟糕。</p><p>实时系统可以分为两类，<code>硬实时(hard real time)</code> 和 <code>软实时(soft real time)</code> 系统，前者意味着必须要<strong>满足绝对的截止时间</strong>；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。在这两种情形中，实时都是通过把程序划分为一组进程而实现的，其中每个进程的行为是可预测和提前可知的。这些进程一般寿命较短，并且极快的运行完成。在检测到一个外部信号时，调度程序的任务就是按照满足所有截止时间的要求调度进程。</p><p>实时系统中的事件可以按照响应方式进一步分类为 <code>周期性(以规则的时间间隔发生)</code> 事件或 <code>非周期性(发生时间不可预知)</code> 事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个周期事件，事件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 以周期 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 发生，并需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 秒 <code>CPU</code> 时间处理一个事件，那么可以处理负载的条件是</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>P</mi><mi>i</mi></msub></mfrac><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{m} \frac{C_i}{P_i} \leq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>只有满足这个条件的实时系统称为 <code>可调度</code> 的，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 <code>CPU</code> 时间总和大于 <code>CPU</code> 能提供的时间。</p><h2 id="线程调度"><a class="markdownIt-Anchor" href="#线程调度"></a> 线程调度</h2><p>当若干进程都有多个线程时，就存在两个层次的并行：进程和线程。在这样的系统中调度处理有本质的差别，这取决于所支持的是用户级线程还是内核级线程（或两者都支持）。</p><p>首先考虑 <code>用户级线程</code>，由于内核并不知道有线程存在，所以内核还是和以前一样地操作，选取一个进程，假设为 A，并给予 A 以时间片控制。<strong>进程 A 中的线程调度程序决定哪个线程运行。</strong> 假设为 A1。由于多道线程并不存在时钟中断，所以这个线程可以按其意愿任意运行多长时间。如果该线程用完了进程的全部时间片，内核就会选择另一个进程继续运行。</p><p>在进程 A 终于又一次运行时，线程 A1 会接着运行。该线程会继续耗费 A 进程的所有时间，直到它完成工作。不过，线程运行不会影响到其他进程。其他进程会得到调度程序所分配的合适份额，不会考虑进程 A 内部发生的事情。</p><p>现在考虑 A 线程每次 CPU 计算的工作比较少的情况，例如：在 50 ms 的时间片中有 5 ms 的计算工作。于是，每个线程运行一会儿，然后把 CPU 交回给线程调度程序。这样在内核切换到进程 B 之前，就会有序列 A1, A2, A3, A1, A2, A3, A1, A2, A3, A1。 如下所示</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923154350.png" srcset="/img/loading.gif" alt="" /></p><p>运行时系统使用的调度算法可以是上面介绍算法的任意一种。从实用方面考虑，<strong>轮转调度和优先级调度更为常用</strong>。唯一的局限是，缺乏一个时钟中断运行过长的线程。但由于线程之间的合作关系，这通常也不是问题。</p><p>现在考虑使用<code>内核线程</code> 的情况，<strong>内核选择一个特定的线程运行</strong>。<strong>它不用考虑线程属于哪个进程</strong>，不过如果有必要的话，也可以这么做。对被选择的线程赋予一个时间片，而且如果超过了时间片，就会强制挂起该线程。一个线程在 50 ms 的时间片内，5 ms 之后被阻塞，在 30 ms 的时间片中，线程的顺序会是 A1, B1, A2, B2, A3, B3。如下图所示<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923154416.png" srcset="/img/loading.gif" alt="" /></p><p>用户级线程和内核级线程之间的主要差别在于<code>性能</code>。<strong>用户级线程的切换需要少量的机器指令，而内核线程需要完整的上下文切换</strong>，修改内存映像，使高速缓存失效，这会导致了若干数量级的延迟。另一方面，在使用内核级线程时，一旦线程阻塞在 <code>I/O</code> 上就不需要在用户级线程中那样将整个进程挂起。</p><p>从进程 A 的一个线程切换到进程 B 的一个线程，其消耗要远高于运行进程 A 的两个线程（涉及修改内存映像，修改高速缓存），内核对这种切换的消耗是了解到，可以通过这些信息作出决定。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 88. 合并两个有序数组</title>
    <link href="/2020/09/20/LeetCode-88-merge-sorted-array/"/>
    <url>/2020/09/20/LeetCode-88-merge-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> k = m + n - <span class="hljs-number">1</span>;    m--;    n--;    <span class="hljs-keyword">while</span> (m &gt;= <span class="hljs-number">0</span> &amp;&amp; n &gt;= <span class="hljs-number">0</span>) &#123;        nums1[k--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];    &#125;    <span class="hljs-keyword">while</span> (n &gt;= <span class="hljs-number">0</span>) &#123;        nums1[k--] = nums2[n--];    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            nums1[m++] = nums2[i];        &#125;        Arrays.sort(nums1);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 66. 加一</title>
    <link href="/2020/09/19/LeetCode-66-plus-one/"/>
    <url>/2020/09/19/LeetCode-66-plus-one/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. 加一</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] plusOne(<span class="hljs-keyword">int</span>[] digits) &#123;    <span class="hljs-keyword">int</span> len = digits.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        digits[i]++;        <span class="hljs-comment">// 超过 10，则对 10 取余，下一位进位</span>        <span class="hljs-keyword">if</span> (digits[i] &gt;= <span class="hljs-number">10</span>) &#123;            digits[i] = digits[i] % <span class="hljs-number">10</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 不超过 10，返回结果</span>            <span class="hljs-keyword">return</span> digits;        &#125;    &#125;    <span class="hljs-comment">// 第一位也超过 10，则长度 + 1，如 999</span>    <span class="hljs-keyword">int</span>[] newDigits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    newDigits[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> newDigits;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 27. 移除元素</title>
    <link href="/2020/09/18/LeetCode-27-remove-element/"/>
    <url>/2020/09/18/LeetCode-27-remove-element/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; len) &#123;        <span class="hljs-keyword">if</span> (nums[i] != val) &#123;            nums[j++] = nums[i];        &#125;        i++;    &#125;    <span class="hljs-keyword">return</span> j;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 26. 删除排序数组中的重复项</title>
    <link href="/2020/09/18/LeetCode-26-remove-duplicates-from-sorted-array/"/>
    <url>/2020/09/18/LeetCode-26-remove-duplicates-from-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (i &lt; len) &#123;        <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;            i++;        &#125; <span class="hljs-keyword">else</span> &#123;            nums[j++] = nums[i++];        &#125;    &#125;    <span class="hljs-keyword">return</span> j;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 315. 计算右侧小于当前元素的个数</title>
    <link href="/2020/09/17/LeetCode-315-count-of-smaller-numbers-after-self/"/>
    <url>/2020/09/17/LeetCode-315-count-of-smaller-numbers-after-self/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></p><p>利用索引数组，对索引数组排序，就可根据索引保存对应位置的逆序数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">countSmaller</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-comment">// 索引数组</span>    <span class="hljs-keyword">int</span>[] indexes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-comment">// 保存每个位置的逆序数</span>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        indexes[i] = i;    &#125;    mergeSort(indexes, nums, res, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> count : res) &#123;        list.add(count);    &#125;    <span class="hljs-keyword">return</span> list;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] indexes, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span>[] res, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;    mergeSort(indexes, nums, res, left, mid);    mergeSort(indexes, nums, res, mid + <span class="hljs-number">1</span>, right);    <span class="hljs-keyword">if</span> (nums[indexes[mid]] &lt;= nums[indexes[mid + <span class="hljs-number">1</span>]]) &#123;        <span class="hljs-keyword">return</span>;    &#125;    mergeAndCountSmaller(indexes, nums, res, left, mid, right);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeAndCountSmaller</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] indexes, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span>[] res, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = right - left + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        <span class="hljs-comment">// 比较索引对应位置上的数</span>        <span class="hljs-keyword">if</span> (nums[indexes[i]] &lt;= nums[indexes[j]]) &#123;            <span class="hljs-comment">// 更新比 nums[idx[i]] 小的数</span>            res[indexes[i]] += j - mid - <span class="hljs-number">1</span>;            tmp[k++] = indexes[i++];        &#125; <span class="hljs-keyword">else</span> &#123;            tmp[k++] = indexes[j++];        &#125;    &#125;    <span class="hljs-comment">// 合并剩下的数</span>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        <span class="hljs-comment">// 左边还有剩余，说明右边比它小的都已经归并回去了</span>        res[indexes[i]] += j - mid - <span class="hljs-number">1</span>;        tmp[k++] = indexes[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= right) &#123;        tmp[k++] = indexes[j++];    &#125;    System.arraycopy(tmp, <span class="hljs-number">0</span>, indexes, left, len);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 442. 数组中重复的数据</title>
    <link href="/2020/09/16/LeetCode-442-find-all-duplicates-in-an-array/"/>
    <url>/2020/09/16/LeetCode-442-find-all-duplicates-in-an-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">442. 数组中重复的数据</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">while</span> (nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) &#123;            swap(nums, i, nums[i] - <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;            res.add(nums[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = nums[i];    nums[i] = nums[j];    nums[j] = t;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 448. 找到所有数组中消失的数字</title>
    <link href="/2020/09/16/LeetCode-448-find-all-numbers-disappeared-in-an-array/"/>
    <url>/2020/09/16/LeetCode-448-find-all-numbers-disappeared-in-an-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span> &lt;= nums[i] &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) &#123;            swap(nums, i, nums[i] - <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;            res.add(i + <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = nums[i];    nums[i] = nums[j];    nums[j] = t;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 41. 缺失的第一个正数</title>
    <link href="/2020/09/16/LeetCode-41-first-missing-positive/"/>
    <url>/2020/09/16/LeetCode-41-first-missing-positive/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a></p><h1 id="哈希"><a class="markdownIt-Anchor" href="#哈希"></a> 哈希</h1><p>空间不符合</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        map.put(num, <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len + <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">if</span> (!map.containsKey(i)) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><p>时间不符合</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    quickSort(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        <span class="hljs-keyword">int</span> pos = binarySearch(i, nums);        <span class="hljs-keyword">if</span> (pos == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;&#125;</code></pre><h1 id="原地哈希"><a class="markdownIt-Anchor" href="#原地哈希"></a> 原地哈希</h1><p>第 i 个位置存放的数 = i + 1</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// nums[i] = i + 1</span>        <span class="hljs-comment">// 未出现的数一定在 [1, len + 1]</span>        <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) &#123;            swap(nums, i, nums[i] - <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-comment">// 当 第 i 个位置上的数不是 i + 1 时，说明 i + 1 没有出现过</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = nums[i];    nums[i] = nums[j];    nums[j] = t;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统总览</title>
    <link href="/2020/09/16/os-overview/"/>
    <url>/2020/09/16/os-overview/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h1><h2 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h2><p>现代计算机系统由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成。</p><p>然而，程序员不会直接和这些硬件打交道，在硬件的基础之上，计算机安装了一层软件，这层软件能够通过响应用户输入的指令达到控制硬件的效果，从而满足用户需求，这种软件称之为 <code>操作系统</code>，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200916142646.png" srcset="/img/loading.gif" alt="" /></p><h2 id="用户态和内核态"><a class="markdownIt-Anchor" href="#用户态和内核态"></a> 用户态和内核态</h2><p>大部分计算机有两种运行模式：<code>内核态</code> 和 <code>用户态</code>，</p><ul><li>软件中最基础的部分是操作系统，它运行在 <code>内核态</code> 中，内核态也称为 <code>管态</code> 和 <code>核心态</code>，它们都是操作系统的运行状态，只不过是不同的叫法而已。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 <code>用户态</code> 下。</li><li>用户接口程序(<code>shell</code> 或者 <code>GUI</code>)处于<code>用户态</code>中，并且它们位于用户态的最低层，允许用户运行其他程序，例如 Web 浏览器、电子邮件阅读器、音乐播放器等。而且，越靠近用户态的应用程序越容易编写。</li></ul><h1 id="计算机硬件简介"><a class="markdownIt-Anchor" href="#计算机硬件简介"></a> 计算机硬件简介</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200916143656.png" srcset="/img/loading.gif" alt="" /></p><p>从概念上来看，一台简单的个人电脑可以被抽象为上面这种相似的模型，CPU、内存、I/O 设备都和总线串联起来并通过总线与其他设备进行通信。</p><h2 id="cpu"><a class="markdownIt-Anchor" href="#cpu"></a> CPU</h2><p>CPU 主要和内存进行交互，从内存中提取指令并执行它。一个 CPU 的执行周期是从内存中提取第一条指令、解码并决定它的类型和操作数，执行，然后再提取、解码执行后续的指令。重复该循环直到程序运行完毕。</p><ul><li>程序计数器 (<code>Program Counter</code>): 是 CPU 的核心，在任何时刻，<strong>PC 都指向主存中的某条机器语言指令。</strong></li><li>堆栈指针 (<code>stack pointer</code>): 它指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。</li><li>程序状态字寄存器 (<code>Program Status Word</code>): <strong>它会跟踪当前系统的状态</strong>。除非发生系统结束，否则我们可以忽略 PSW 。用户程序通常可以读取整个PSW，但通常只能写入其某些字段。PSW 在系统调用和 I/O 中起着重要作用。</li></ul><h2 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h2><p>理想情况下，内存应该非常快速(比执行一条指令要快，从而不会拖慢 CPU 执行效率)，而且足够大且便宜，但是目前的技术手段无法满足三者的需求。于是采用了不同的处理方式，存储器系统采用一种分层次的结构<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200916144656.png" srcset="/img/loading.gif" alt="" /><br />顶层的存储器速度最高，但是容量最小，成本非常高，层级结构越向下，其访问效率越慢，容量越大，但是造价也就越便宜。</p><h3 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h3><p>存储器的顶层是 CPU 中的寄存器，它们用和 CPU 一样的材料制成，所以和 CPU 一样快。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）</p><h3 id="高速缓存"><a class="markdownIt-Anchor" href="#高速缓存"></a> 高速缓存</h3><p>位于寄存器下面的是高速缓存，它多数由硬件控制。主存被分割成高速缓存行(<code>cache lines</code>)。</p><p>使用最频繁的高速缓存行保存在位于 <code>CPU</code> 内部或非常靠近 <code>CPU</code> 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是高速缓存命中(<code>cache hit</code>)。</p><p>高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。</p><p>现代 <code>CPU</code> 设计了两种缓存。第一级缓存或者说是 <code>L1 cache</code> 总是位于 CPU 内部，用来将已解码的指令调入 <code>CPU</code> 的执行引擎。典型的 <code>L1 cache</code> 的大小为 <code>16 KB</code>。<br />另外，往往还设有二级缓存，也就是 <code>L2 cache</code>，用来存放最近使用过的关键字，一般是<code>兆字节</code>为单位。<code>L1 cache</code> 和 <code>L2 cache</code> 最大的不同在于是否存在延迟。访问 <code>L1 cache</code> 没有任何的延迟，然而访问 L2 cache 会有 1 - 2 个时钟周期的延后。</p><h3 id="主存"><a class="markdownIt-Anchor" href="#主存"></a> 主存</h3><p>在上面的层次结构中再下一层是主存，这是内存系统的主力军，主存通常叫做 <code>RAM</code>(<code>Random Access Memory</code>)。所有不能在高速缓存中得到满足的内存访问请求都会转往主存中。</p><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。</p><ul><li>从物理上来说，主存是由一组<code>动态随机存取存储器</code>（<code>DRAM</code>）芯片组成的。</li><li>从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（即数组索引）。</li></ul><h3 id="磁盘"><a class="markdownIt-Anchor" href="#磁盘"></a> 磁盘</h3><p>下一个层次是磁盘(硬盘)，磁盘同 RAM 相比，每个二进制位的成本低了两个数量级，而且经常也有两个数量级大的容量。磁盘唯一的问题是随机访问数据时间大约慢了三个数量级。磁盘访问慢的原因是因为磁盘的构造不同。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200916150003.png" srcset="/img/loading.gif" alt="" /></p><blockquote><p>需要注意，固态硬盘(Solid State Disk, SSD)不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在存储器（闪存）中，与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。</p></blockquote><p>许多计算机支持一种著名的<strong>虚拟内存</strong>机制，这种机制使得期望运行的存储空间大于实际的物理存储空间。其方法是将程序放在磁盘上，而将主存作为一部分缓存，用来保存最频繁使用的部分程序，这种机制需要快速映像内存地址，用来把程序生成的地址转换为有关字节在 <code>RAM</code> 中的物理地址。这种映像由 <code>CPU</code> 中的一个称为 <strong>存储器管理单元</strong>(<code>Memory Management Unit</code>, <code>MMU</code>) 的部件来完成。</p><p>缓存和 <code>MMU</code> 的出现是对系统的性能有很重要的影响，在多道程序系统中，从一个程序切换到另一个程序的机制称为 <strong>上下文切换</strong>(<code>context switch</code>)，对来自缓存中的资源进行修改并把其写回磁盘是很有必要的。</p><h2 id="io-设备"><a class="markdownIt-Anchor" href="#io-设备"></a> I/O 设备</h2><p>I/O 设备一般包括两个部分：<strong>设备控制器</strong>和<strong>设备</strong>本身。</p><ul><li>控制器本身是一块芯片或者一组芯片，它能够控制物理设备。<br />控制器的工作就是接收操作系统的指令，为操作系统提供一个更简单的接口。也就是屏蔽物理细节。</li><li>设备本身有一个相对简单的接口。</li></ul><p>每种类型的设备控制器都是不同的，所以需要不同的软件进行控制。专门与控制器进行信息交流，发出命令处理指令接收响应的软件，称为 <strong>设备驱动程序</strong>(<code>device driver</code>)。 每个控制器厂家都应该针对不同的操作系统提供不同的设备驱动程序。</p><p>为了使设备驱动程序能够工作，必须把它安装在操作系统中，这样能够使它在内核态中运行。<br />要将设备驱动程序装入操作系统，一般有三个途径：</p><ol><li>将内核与设备启动程序重新连接，然后重启系统。这是 <code>UNIX</code> 系统采用的工作方式。</li><li>在一个操作系统文件中设置一个入口，通知该文件需要一个设备驱动程序，然后重新启动系统。在重启系统时，操作系统回寻找有关的设备启动程序并把它装载，这是 <code>Windows</code> 采用的工作方式。</li><li>操作系统能够在运行时接收新的设备驱动程序并立刻安装，无需重启操作系统。热插拔设备，比如 <code>USB</code> 需要动态可装载的设备驱动程序。</li></ol><p>实现输入和输出的方式有三种。</p><ol><li><p>在最简单的方式中，用户程序会发起系统调用，内核会将其转换为相应驱动程序的程序调用，然后设备驱动程序启动 <code>I/O</code> 并循环检查该设备，看该设备是否完成了工作（一般会有一些二进制位用来指示设备仍在忙碌中）。当 <code>I/O</code> 调用完成后，设备驱动程序把数据送到指定的地方并返回。然后操作系统会将控制权交给调用者。这种方式称为 <strong>忙等待</strong>(<code>busy waiting</code>)，这种方式的缺点是要一直占据 <code>CPU</code>，<code>CPU</code> 会一直轮询 <code>I/O</code> 设备直到 <code>I/O</code> 操作完成。</p></li><li><p><strong>设备驱动程序启动设备并且让该设备在操作完成时发生中断</strong>。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备操作完成时，它发出一个 <strong>中断</strong> 通知操作完成。</p></li></ol><ul><li>使用特殊的硬件：<strong>直接存储器访问</strong>(<code>Direct Memory Access</code>, <code>DMA</code>) 芯片。它可以控制内存和某些控制器之间的位流，而无需 <code>CPU</code> 的干预。<code>CPU</code> 会对 <code>DMA</code> 芯片进行设置，说明需要传送的字节数，有关的设备和内存地址以及操作方向。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200916153323.png" srcset="/img/loading.gif" alt="" /><br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200916152741.png" srcset="/img/loading.gif" alt="" /></li></ul><p>当另一个中断处理程序正在运行时，中断可能（并且经常）发生在不合宜的时间。 因此，CPU 可以禁用中断，并且可以在之后重启中断。<br />在 CPU 关闭中断后，任何已经发出中断的设备，可以继续保持其中断信号处理，但是 CPU 不会中断，直至中断再次启用为止。<br />如果在关闭中断时，已经有多个设备发出了中断信号，中断控制器将决定优先处理哪个中断，通常这取决于事先赋予每个设备的优先级，最高优先级的设备优先赢得中断权，其他设备则必须等待。</p><h2 id="总线"><a class="markdownIt-Anchor" href="#总线"></a> 总线</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200916153432.png" srcset="/img/loading.gif" alt="" /><br />总线贯穿整个系统，它携带信息字节并负责在各个部件间传递。</p><p>上图中的 x86 系统包含很多总线，高速缓存、内存、PCIe、PCI、USB、SATA 和 DMI，每条总线都有不同的传输速率和功能。操作系统必须了解所有的总线配置和管理。其中最主要的总线是 <code>PCIe</code>(<code>Peripheral Component Interconnect Express</code>) 总线。</p><p><code>PCIe</code> 选用了串行总线架构(<code>serial bus architecture</code>) ，并通过单个连接（称为通道）发送消息中的所有比特数据，就像网络数据包一样。这样做会简化很多，因为不再确保所有 32 位数据在同一时刻准确到达相同的目的地。通过将多个数据通路并行起来，并行性仍可以有效利用。</p><h2 id="计算机启动过程"><a class="markdownIt-Anchor" href="#计算机启动过程"></a> 计算机启动过程</h2><ul><li><p>一、<code>BIOS</code></p><ul><li>1.1 硬件自检<br /><code>BIOS</code> 程序首先检查，计算机硬件能否满足运行的基本条件，这叫做&quot;硬件自检&quot;（<code>Power-On Self-Test</code>），缩写为 <code>POST</code>。<br />如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</li><li>1.2 启动顺序<br />硬件自检完成后，<code>BIOS</code> 把控制权转交给下一阶段的启动程序。这时，<code>BIOS</code> 需要知道，“下一阶段的启动程序&quot;具体存放在哪一个设备。也就是说，<code>BIOS</code> 需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做&quot;启动顺序”（<code>Boot Sequence</code>）。</li></ul></li><li><p>二、主引导记录(<code>MBR</code>)<br /><code>BIOS</code> 按照&quot;启动顺序&quot;，把控制权转交给排在第一位的储存设备。<br />计算机读取该设备的第一个扇区，也就是读取最前面的 <code>512</code> 个字节。如果这 <code>512</code> 个字节的最后两个字节是 <code>0x55</code> 和 <code>0xAA</code>，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给&quot;启动顺序&quot;中的下一个设备。</p></li><li><p>三、硬盘启动<br />这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p><ul><li>3.1 情况 A：卷引导记录<br />&quot;卷引导记录&quot;的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</li><li>3.2 情况 B：扩展分区和逻辑分区<br />计算机先读取扩展分区的第一个扇区，叫做&quot;扩展引导记录&quot;（<code>Extended boot record</code>, <code>EBR</code>）。它里面也包含一张 64 字节的分区表，但是最多只有两项（也就是两个逻辑分区）。计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</li><li>3.3 情况 C：启动管理器在这种情况下，计算机读取&quot;主引导记录&quot;前面 446 字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的&quot;启动管理器&quot;（<code>boot loader</code>），由用户选择启动哪一个操作系统。</li></ul></li><li><p>四、操作系统<br />控制权转交给操作系统后，操作系统的内核首先被载入内存。</p><ol><li>以 <code>Linux</code> 系统为例，先载入 <code>/boot</code> 目录下面的 <code>kernel</code>。</li><li>内核加载成功后，第一个运行的程序是 <code>/sbin/init</code>。它根据配置文件产生 <code>init</code> 进程。这是 <code>Linux</code> 启动后的第一个进程，<code>pid</code> 进程编号为 <code>1</code>，其他进程都是它的后代。</li><li><code>init</code> 线程加载系统的各个模块，比如窗口程序和网络程序，直至执行 <code>/bin/login</code> 程序，跳出登录界面，等待用户输入用户名和密码。</li></ol></li></ul><h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><h2 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h2><p>进程的本质就是操作系统执行的一个程序。</p><ul><li>与每个进程相关的是地址空间(<code>address space</code>)，这是从某个最小值的存储位置（通常是 0）到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写操作。<strong>地址空间中存放有可执行程序，程序所需要的数据和它的栈。</strong></li><li>与每个进程相关的还有资源集，通常包括寄存器(<code>registers</code>)（寄存器一般包括<strong>程序计数器</strong>(<code>program counter</code>)和<strong>堆栈指针</strong>(<code>stack pointer</code>)）、打开文件的清单、突发的报警、有关的进程清单和其他需要执行程序的信息。</li></ul><h2 id="地址空间"><a class="markdownIt-Anchor" href="#地址空间"></a> 地址空间</h2><p>地址空间用来保存正在执行的程序。<br />每个进程有一些可以使用的地址集合，典型值从 0 开始直到某个最大值。一个进程可拥有的最大地址空间小于主存。在这种情况下，即使进程用完其地址空间，内存也会有足够的内存运行该进程。</p><h1 id="操作系统结构"><a class="markdownIt-Anchor" href="#操作系统结构"></a> 操作系统结构</h1><h2 id="单体系统"><a class="markdownIt-Anchor" href="#单体系统"></a> 单体系统</h2><p>到目前为止，在大多数系统中，整个系统在内核态以单一程序的方式运行。<br />在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中。<br />在单体系统中，对于每个系统调用都会有一个服务程序来保障和运行。需要一组实用程序来弥补服务程序需要的功能，例如从用户程序中获取数据。可将各种过程划分为一个三层模型。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200916163823.png" srcset="/img/loading.gif" alt="" /></p><h2 id="分层系统"><a class="markdownIt-Anchor" href="#分层系统"></a> 分层系统</h2><p>分层系统使用层来分隔不同的功能单元。每一层只与该层的上层和下层通信。每一层都使用下面的层来执行其功能。层之间的通信通过预定义的固定接口通信。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200916163904.png" srcset="/img/loading.gif" alt="" /></p><h2 id="微内核"><a class="markdownIt-Anchor" href="#微内核"></a> 微内核</h2><p>在分层方式中，设计者要确定在哪里划分 <strong>内核-用户</strong> 的边界。传统上，所有的层都在内核中，但是这样做没有必要。事实上，尽可能减少内核态中功能可能是更好的做法。因为内核中的错误很难处理，一旦内核态中出错误会拖累整个系统。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200916165043.png" srcset="/img/loading.gif" alt="" /><br />所以，为了实现高可靠性，将操作系统划分成小的、层级之间能够更好定义的模块是很有必要的，只有一个模块 — 微内核 — 运行在内核态，其余模块可以作为普通用户进程运行。由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使整个系统死机。</p><h2 id="客户-服务器模式"><a class="markdownIt-Anchor" href="#客户-服务器模式"></a> 客户-服务器模式</h2><p>微内核思想的策略是把进程划分为两类：<strong>服务器</strong>，每个服务器用来提供服务；<strong>客户端</strong>，使用这些服务。这个模式就是所谓的 <strong>客户-服务器模式</strong>。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200916164806.png" srcset="/img/loading.gif" alt="" /><br />客户-服务器模式会有两种载体，一种情况是一台计算机既是客户又是服务器，在这种方式下，操作系统会有某种优化；但是普遍情况下是客户端和服务器在不同的机器上，它们通过局域网或广域网连接。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 215. 数组中的第K个最大元素</title>
    <link href="/2020/09/15/LeetCode-215-kth-largest-element-in-an-array/"/>
    <url>/2020/09/15/LeetCode-215-kth-largest-element-in-an-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></p><h1 id="快排"><a class="markdownIt-Anchor" href="#快排"></a> 快排</h1><p>思想：排序后第 <code>k</code> 个最大元素位置 <code>= len - k</code>，每次 <code>partition</code> 后，都会将 <code>pivot</code> 移动到其最终位置，此时就可比较该位置是否是目标位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 排序后第 k 大的数所在位置</span>    <span class="hljs-keyword">int</span> target = len - k;    <span class="hljs-keyword">return</span> quickSort(nums, target, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> pivotPos = partition(nums, left, right);    <span class="hljs-comment">// 找到目标位置，返回</span>    <span class="hljs-keyword">if</span> (pivotPos == target) &#123;        <span class="hljs-keyword">return</span> nums[target];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivotPos &gt; target) &#123;        <span class="hljs-comment">// 比目标位置大，则往前查找</span>        <span class="hljs-keyword">return</span> quickSort(nums, target, left, pivotPos - <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> quickSort(nums, target, pivotPos + <span class="hljs-number">1</span>, right);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> pivot = nums[left];    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= pivot) &#123;            right--;        &#125;        nums[left] = nums[right];        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= pivot) &#123;            left++;        &#125;        nums[right] = nums[left];    &#125;    nums[left] = pivot;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><h1 id="优先队列"><a class="markdownIt-Anchor" href="#优先队列"></a> 优先队列</h1><p>小顶堆</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-comment">// 小顶堆 =&gt; 弹出比 目标小的 len - k 个元素，堆顶即为第 k 大</span>    PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        minHeap.add(num);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - k; i++) &#123;        minHeap.poll();    &#125;    <span class="hljs-keyword">return</span> minHeap.peek();&#125;</code></pre><p>大顶堆</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 大顶堆 =&gt; 弹出比 目标大的 k - 1 个元素，堆顶即为第 k 大</span>    PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(len, (a, b) -&gt; b - a);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        maxHeap.add(num);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++) &#123;        maxHeap.poll();    &#125;    <span class="hljs-keyword">return</span> maxHeap.peek();&#125;</code></pre><h1 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h1><p>每次调整都把最大的元素放到后面，因此要找到第 <code>K</code> 大的元素只需要遍历 <code>K</code> 次。</p><p>或者：使用小顶堆</p><ol><li>对 <code>K</code> 个元素先建堆</li><li>遍历剩下的元素，若大于堆顶，则加入堆并调整。</li><li>堆顶元素即为第 <code>K</code> 大的元素</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 将数组整理成堆</span>    heapify(nums);    <span class="hljs-comment">// 循环不变量：区间 [0, i] 堆有序</span>    <span class="hljs-comment">// 每次调整都把最大的元素放到后面</span>    <span class="hljs-comment">// 因此要找到第 K 大的元素只需要遍历 K 次</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; len - <span class="hljs-number">1</span> - k; ) &#123;        <span class="hljs-comment">// 把堆顶元素（当前最大）交换到数组末尾</span>        swap(nums, <span class="hljs-number">0</span>, i);        <span class="hljs-comment">// 逐步减少堆有序的部分</span>        i--;        <span class="hljs-comment">// 下标 0 位置下沉操作，使得区间 [0, i] 堆有序</span>        siftDown(nums, <span class="hljs-number">0</span>, i);    &#125;    <span class="hljs-keyword">return</span> nums[len - k];&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 将数组整理成堆（堆有序）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 只需要从 i = (len - 1) / 2 这个位置开始逐层下移</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        siftDown(nums, i, len - <span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k    当前下沉元素的下标</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> end  [0, end] 是 nums 的有效部分</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * k &lt; end) &#123;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>;        <span class="hljs-comment">// 左结点 &lt; 右结点，j 指向右结点</span>        <span class="hljs-keyword">if</span> (j &lt; end &amp;&amp; nums[j + <span class="hljs-number">1</span>] &gt; nums[j]) &#123;            j++;        &#125;        <span class="hljs-comment">// 子结点大于父结点</span>        <span class="hljs-keyword">if</span> (nums[j] &gt; nums[k]) &#123;            swap(nums, j, k);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;        k = j;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = nums[i];    nums[i] = nums[j];    nums[j] = temp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 51. 数组中的逆序对</title>
    <link href="/2020/09/14/LeetCode-offer-51-shu-zu-zhong-de-ni-xu-dui-lcof/"/>
    <url>/2020/09/14/LeetCode-offer-51-shu-zu-zhong-de-ni-xu-dui-lcof/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">剑指 Offer 51. 数组中的逆序对</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">return</span> reverse(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> leftPairs = reverse(nums, left, mid);    <span class="hljs-keyword">int</span> rightPairs = reverse(nums, mid + <span class="hljs-number">1</span>, right);    <span class="hljs-keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="hljs-number">1</span>]) &#123;        <span class="hljs-keyword">return</span> leftPairs + rightPairs;    &#125;    <span class="hljs-comment">// 在右区间的元素合并时，计算大于该元素的个数</span>    <span class="hljs-comment">// 左区间的所有元素都大于该元素，则逆序数 = 左区间长度 = mid - i + 1</span>    <span class="hljs-keyword">int</span> crossPairs = mergeAndCount(nums, left, mid, right);    <span class="hljs-keyword">return</span> leftPairs + crossPairs + rightPairs;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mergeAndCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = right - left + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;    <span class="hljs-comment">// [left, mid] [mid + 1, right]</span>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;            tmp[k++] = nums[j++];            <span class="hljs-comment">// 计算左区间长度</span>            count += mid - i + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            tmp[k++] = nums[i++];        &#125;    &#125;    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        tmp[k++] = nums[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= right) &#123;        tmp[k++] = nums[j++];    &#125;    System.arraycopy(tmp, <span class="hljs-number">0</span>, nums, left, len);    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>剑指 Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 912. 排序数组</title>
    <link href="/2020/09/14/LeetCode-912-sort-an-array/"/>
    <url>/2020/09/14/LeetCode-912-sort-an-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">912. 排序数组</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortArray(<span class="hljs-keyword">int</span>[] nums) &#123;    mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;        mergeSort(nums, low, mid);        mergeSort(nums, mid + <span class="hljs-number">1</span>, high);        merge(nums, low, mid, high);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = high - low + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-comment">// [low...mid] [mid + 1, high]</span>    <span class="hljs-keyword">int</span> i = low, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;        tmp[k++] = nums[i] &gt; nums[j] ? nums[j++] : nums[i++];    &#125;    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        tmp[k++] = nums[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= high) &#123;        tmp[k++] = nums[j++];    &#125;    System.arraycopy(tmp, <span class="hljs-number">0</span>, nums, low, len);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-keyword">int</span> pivotPos = partition(nums, low, high);        quickSort(nums, low, pivotPos - <span class="hljs-number">1</span>);        quickSort(nums, pivotPos + <span class="hljs-number">1</span>, high);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> cur = nums[low];    <span class="hljs-keyword">while</span> (low &lt; high) &#123;        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; cur &lt;= nums[high]) &#123;            high--;        &#125;        nums[low] = nums[high];        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; cur &gt;= nums[low]) &#123;            low++;        &#125;        nums[high] = nums[low];    &#125;    nums[low] = cur;    <span class="hljs-keyword">return</span> low;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串匹配算法</title>
    <link href="/2020/09/14/string-matching-algorithms/"/>
    <url>/2020/09/14/string-matching-algorithms/</url>
    
    <content type="html"><![CDATA[<h1 id="kmp"><a class="markdownIt-Anchor" href="#kmp"></a> KMP</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">kmpSearch</span><span class="hljs-params">(String str, String pattern)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// next 数组</span>    <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> Solution().getNext(pattern);    <span class="hljs-keyword">char</span>[] s = str.toCharArray();    <span class="hljs-keyword">char</span>[] p = pattern.toCharArray();    <span class="hljs-comment">// i: 要匹配的字符串位置</span>    <span class="hljs-comment">// j: 模式串位置</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; p.length) &#123;        <span class="hljs-comment">// pattern 匹配成功，继续后移，查找是否有多个 pattern 在 str 中出现</span>        <span class="hljs-keyword">if</span> (j == p.length - <span class="hljs-number">1</span> &amp;&amp; s[i] == p[j]) &#123;            res.add(i - j);            j = next[j];        &#125;        <span class="hljs-comment">// 当前字符匹配成功，进行下一个字符的匹配</span>        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || s[i] == p[j]) &#123;            i++;            j++;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 匹配不成功，pattern 前移，从 str 失配处继续匹配</span>            j = next[j];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取模式串的 next 数组</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> patternStr 模式串</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> next[]</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] getNext(String patternStr) &#123;    <span class="hljs-keyword">char</span>[] pattern = patternStr.toCharArray();    <span class="hljs-keyword">int</span> n = pattern.length;    <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];    <span class="hljs-comment">// 第 i 个位置前缀 = next[i + 1]</span>    next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;    <span class="hljs-comment">// 初始前缀长度为 -1</span>    <span class="hljs-keyword">int</span> len = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; n - <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">// 在上一个前缀的基础上新增的字符匹配，则 prefix[i] = len + 1</span>        <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span> || pattern[i] == pattern[len]) &#123;            len++;            <span class="hljs-comment">// i + 1 位置存放 pattern[i] 的前缀长度</span>            i++;            next[i] = len;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 前缀不匹配，往前查找与 pattern[i] 相等的字符直到 len == -1</span>            len = next[len];        &#125;    &#125;    <span class="hljs-keyword">return</span> next;&#125;</code></pre><h1 id="bm"><a class="markdownIt-Anchor" href="#bm"></a> BM</h1><ol><li>坏字符<ul><li>坏字符不在模式串中，移动模式串至坏字符后一位；</li><li>坏字符在模式串中，移动模式串中最靠后的那个字符。</li></ul></li><li>好后缀<ul><li>好后缀不在模式串中，移动模式串至好后缀的后一位；</li><li>好后缀在模式串中，移动模式串至好后缀匹配的地方；</li><li>好后缀的子串和模式串部分匹配，移动模式串至好后缀的子串重合的地方。</li></ul></li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bmSearch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-keyword">char</span>[] pattern = p.toCharArray();    <span class="hljs-keyword">int</span> m = str.length;    <span class="hljs-keyword">int</span> n = pattern.length;    <span class="hljs-comment">// 生成坏字符在模式串中的位置数组</span>    <span class="hljs-keyword">int</span>[] badChars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>];    badCharRule(pattern, badChars);    <span class="hljs-comment">// 长度 = i 的后缀子串在模式串中的起始位置</span>    <span class="hljs-keyword">int</span>[] suffix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];    <span class="hljs-comment">// 长度 = i 的后缀子串是否有可匹配的前缀子串</span>    <span class="hljs-keyword">boolean</span>[] hasPrefix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];    goodSuffixRule(pattern, suffix, hasPrefix);    <span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (i &lt; m) &#123;        <span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; pattern[j] == str[i]) &#123;            i--;            j--;            <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-comment">// 坏字符规则的移动次数</span>        <span class="hljs-keyword">int</span> moveWithBC = j - badChars[str[i]];        <span class="hljs-comment">// 好后缀规则的移动次数</span>        <span class="hljs-keyword">int</span> moveWithGS = Integer.MIN_VALUE;        <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span>) &#123;            moveWithGS = moveWithGS(n, j, suffix, hasPrefix);        &#125;        i += Math.max(moveWithBC, moveWithGS);    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 好后缀规则下的移动次数</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> n         模式串长度</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> j         失配位置</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> suffix    长度 = i 的后缀子串在模式串中的起始位置</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> hasPrefix 长度 = i 的后缀子串是否有可匹配的前缀子串</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">moveWithGS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span>[] suffix, <span class="hljs-keyword">boolean</span>[] hasPrefix)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = n - j - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 后缀存在于模式串前缀中</span>    <span class="hljs-keyword">if</span> (suffix[len] != -<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> j - suffix[len] + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 若不存在前缀与后缀匹配，则找后缀的子串位置</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">if</span> (hasPrefix[i]) &#123;            <span class="hljs-keyword">return</span> n - i;        &#125;    &#125;    <span class="hljs-keyword">return</span> n;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 生成好后缀数组</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pattern</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> suffix</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> hasPrefix</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goodSuffixRule</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] pattern, <span class="hljs-keyword">int</span>[] suffix, <span class="hljs-keyword">boolean</span>[] hasPrefix)</span> </span>&#123;    Arrays.fill(suffix, -<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> n = pattern.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">int</span> j = i;        <span class="hljs-comment">// 后缀子串的长度</span>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 若字符匹配，则往前查找后缀</span>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; pattern[j] == pattern[n - <span class="hljs-number">1</span> - len]) &#123;            j--;            len++;            suffix[len] = j + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span>) &#123;            hasPrefix[len] = <span class="hljs-keyword">true</span>;        &#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 记录 pattern 中每个字符的最靠后位置</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pattern</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> badChars</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">badCharRule</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] pattern, <span class="hljs-keyword">int</span>[] badChars)</span> </span>&#123;    Arrays.fill(badChars, -<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pattern.length; i++) &#123;        badChars[pattern[i]] = i;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 350. 两个数组的交集 II</title>
    <link href="/2020/09/13/LeetCode-350-intersection-of-two-arrays-ii/"/>
    <url>/2020/09/13/LeetCode-350-intersection-of-two-arrays-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></p><h1 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// map 中存储每个数的出现次数</span>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums1) &#123;        map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> key : nums2) &#123;        <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">int</span> count = map.get(key);        <span class="hljs-comment">// 出现次数大于 1 才有效</span>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;            list.add(key);            <span class="hljs-comment">// 更新剩下的次数</span>            map.put(key, count - <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : list) &#123;        res[k++] = num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    Arrays.sort(nums1);    Arrays.sort(nums2);    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;        <span class="hljs-keyword">if</span> (nums1[i] == nums2[j]) &#123;            list.add(nums1[i]);            i++;            j++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;            j++;        &#125; <span class="hljs-keyword">else</span> &#123;            i++;        &#125;    &#125;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : list) &#123;        res[k++] = num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 349. 两个数组的交集</title>
    <link href="/2020/09/13/LeetCode-349-intersection-of-two-arrays/"/>
    <url>/2020/09/13/LeetCode-349-intersection-of-two-arrays/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a></p><h1 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums1) &#123;        map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> key : nums2) &#123;        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            set.add(key);        &#125;    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[set.size()];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : set) &#123;        res[i++] = num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><p>两个数组排序后，分别查找相等的数。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    Arrays.sort(nums1);    Arrays.sort(nums2);    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;        <span class="hljs-comment">// 相等，加入集合</span>        <span class="hljs-keyword">if</span> (nums1[i] == nums2[j]) &#123;            set.add(nums1[i]);            i++;            j++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;            <span class="hljs-comment">// num2[j] 太小，往后查找</span>            j++;        &#125; <span class="hljs-keyword">else</span> &#123;            i++;        &#125;    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[set.size()];    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : set) &#123;        res[k++] = num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    Arrays.sort(nums2);    <span class="hljs-comment">// 在 num2 中查找 nums1 中的每个元素是否出现</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : nums1) &#123;        <span class="hljs-keyword">if</span> (binarySearch(value, nums2) &amp;&amp; !set.contains(value)) &#123;            set.add(value);        &#125;    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[set.size()];    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : set) &#123;        res[k++] = num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;        <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 227. 基本计算器 II</title>
    <link href="/2020/09/12/LeetCode-227-basic-calculator-ii/"/>
    <url>/2020/09/12/LeetCode-227-basic-calculator-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. 基本计算器 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        <span class="hljs-comment">// 每个数字前的符号</span>        <span class="hljs-keyword">char</span> sign = <span class="hljs-string">'+'</span>;        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> len = chars.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">char</span> c = chars[i];            <span class="hljs-comment">// 转换数字</span>            <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;                num = num * <span class="hljs-number">10</span> + (c - <span class="hljs-string">'0'</span>);            &#125;            <span class="hljs-comment">// 只能在这里去除空格，若空格在最后一位，会跳过计算结果</span>            <span class="hljs-keyword">if</span> ((!Character.isDigit(c) &amp;&amp; c != <span class="hljs-string">' '</span>) || i == len - <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">switch</span> (sign) &#123;                    <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:                        stack.push(num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:                        stack.push(-num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:                        stack.push(stack.pop() * num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:                        stack.push(stack.pop() / num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">default</span>:                        <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">// 更新符号</span>                sign = c;                <span class="hljs-comment">// 重置数字</span>                num = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;            res += stack.pop();        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1. 两数之和</title>
    <link href="/2020/09/12/LeetCode-1-two-sum/"/>
    <url>/2020/09/12/LeetCode-1-two-sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;        <span class="hljs-keyword">int</span> another = target - nums[i];        <span class="hljs-keyword">if</span> (map.containsKey(another)) &#123;            res[<span class="hljs-number">0</span>] = i;            res[<span class="hljs-number">1</span>] = map.get(another);            <span class="hljs-keyword">break</span>;        &#125;        map.put(nums[i], i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 560. 和为K的子数组</title>
    <link href="/2020/09/12/LeetCode-560-subarray-sum-equals-k/"/>
    <url>/2020/09/12/LeetCode-560-subarray-sum-equals-k/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前前缀和 sum, 之前的某个前缀和 preSum</span>    <span class="hljs-comment">// sum - preSum = k，preSum 出现的次数就是当前位置和为 k 的个数</span>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// key: 前缀和 value: 该前缀和出现的次数</span>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        sum += num;        <span class="hljs-keyword">int</span> preSum = sum - k;        <span class="hljs-comment">// 获取 有多少个 preSum，使得 sum - preSum = k</span>        <span class="hljs-keyword">if</span> (map.containsKey(preSum)) &#123;            count += map.get(preSum);        &#125;        <span class="hljs-comment">// 更新前缀和</span>        map.put(sum, map.getOrDefault(sum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 224. 基本计算器</title>
    <link href="/2020/09/12/LeetCode-224-basic-calculator/"/>
    <url>/2020/09/12/LeetCode-224-basic-calculator/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">224. 基本计算器</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">        数字：入 numStack</span><span class="hljs-comment">        运算符：进行加减运算直到栈空或遇到 '('</span><span class="hljs-comment">        '(': 入 opStack</span><span class="hljs-comment">        ')': 出栈并计算直到遇到 '('</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    Deque&lt;Integer&gt; numStack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    Deque&lt;Character&gt; opStack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> num = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        <span class="hljs-comment">// 遇到数字，组合数字并压入 numStack</span>        <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;            num = num == -<span class="hljs-number">1</span> ? c - <span class="hljs-string">'0'</span> : num * <span class="hljs-number">10</span> + c - <span class="hljs-string">'0'</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 数字入栈</span>            <span class="hljs-keyword">if</span> (num != -<span class="hljs-number">1</span>) &#123;                numStack.push(num);                num = -<span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">// 运算符，进行加减运算直到栈空或遇到 '('</span>            <span class="hljs-keyword">if</span> (isOperation(c)) &#123;                <span class="hljs-keyword">while</span> (!opStack.isEmpty()) &#123;                    <span class="hljs-keyword">if</span> (opStack.peek() == <span class="hljs-string">'('</span>) &#123;                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">int</span> ans = calc(numStack, opStack);                    numStack.push(ans);                &#125;                <span class="hljs-comment">// 当前运算符入栈</span>                opStack.push(c);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'('</span>) &#123;                <span class="hljs-comment">// '(' 直接入栈</span>                opStack.push(c);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">')'</span>) &#123;                <span class="hljs-comment">// ')': 出栈并计算直到遇到 ')'</span>                <span class="hljs-keyword">while</span> (opStack.peek() != <span class="hljs-string">'('</span>) &#123;                    <span class="hljs-keyword">int</span> ans = calc(numStack, opStack);                    numStack.push(ans);                &#125;                <span class="hljs-comment">// 将 '(' 出栈</span>                opStack.pop();            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (num != -<span class="hljs-number">1</span>) &#123;        numStack.push(num);    &#125;    <span class="hljs-comment">// 若 操作符栈不为空，继续运算</span>    <span class="hljs-keyword">while</span> (!opStack.isEmpty()) &#123;        <span class="hljs-keyword">int</span> ans = calc(numStack, opStack);        numStack.push(ans);    &#125;    <span class="hljs-keyword">return</span> numStack.pop();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 从 numStack 中出栈两个数进行加减运算</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> numStack 数字栈</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> opStack  操作符栈</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(Deque&lt;Integer&gt; numStack, Deque&lt;Character&gt; opStack)</span> </span>&#123;    <span class="hljs-keyword">int</span> num1 = numStack.pop();    <span class="hljs-keyword">int</span> num2 = numStack.pop();    <span class="hljs-keyword">char</span> op = opStack.pop();    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">'+'</span>) &#123;        <span class="hljs-keyword">return</span> num1 + num2;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> num2 - num1;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 判断 c 是否为运算符</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> c</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOperation</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;    <span class="hljs-keyword">return</span> c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span> || c == <span class="hljs-string">'*'</span> || c == <span class="hljs-string">'/'</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 205. 同构字符串</title>
    <link href="/2020/09/11/LeetCode-205-isomorphic-strings/"/>
    <url>/2020/09/11/LeetCode-205-isomorphic-strings/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">205. 同构字符串</a></p><p>需要从两个方向判断！</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">return</span> check(s, t) &amp;&amp; check(t, s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length();    Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">char</span> c = s.charAt(i);        <span class="hljs-keyword">char</span> key = t.charAt(i);        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            <span class="hljs-keyword">char</span> target = map.get(key);            <span class="hljs-keyword">if</span> (c != target) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            map.put(key, c);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-comment">// 双向验证</span>    <span class="hljs-keyword">return</span> check(s, t) &amp;&amp; check(t, s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];    <span class="hljs-keyword">char</span>[] chars1 = s.toCharArray();    <span class="hljs-keyword">char</span>[] chars2 = t.toCharArray();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> target = map[chars1[i]];        <span class="hljs-comment">// 判断对应位置是否匹配</span>        <span class="hljs-keyword">if</span> (target != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (target != chars2[i]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 新增 map</span>        map[chars1[i]] = chars2[i];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 583. 两个字符串的删除操作</title>
    <link href="/2020/09/10/LeetCode-583-delete-operation-for-two-strings/"/>
    <url>/2020/09/10/LeetCode-583-delete-operation-for-two-strings/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. 两个字符串的删除操作</a></p><p>和 <a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a> 类似。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = word1.length();    <span class="hljs-keyword">int</span> cols = word2.length();    <span class="hljs-keyword">char</span>[] chars1 = word1.toCharArray();    <span class="hljs-keyword">char</span>[] chars2 = word2.toCharArray();    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows + <span class="hljs-number">1</span>][cols + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = i;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cols; i++) &#123;        dp[<span class="hljs-number">0</span>][i] = i;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; j++) &#123;            <span class="hljs-keyword">if</span> (chars1[i - <span class="hljs-number">1</span>] == chars2[j - <span class="hljs-number">1</span>]) &#123;                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> &#123;                dp[i][j] = <span class="hljs-number">1</span> + Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[rows][cols];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 44. 通配符匹配</title>
    <link href="/2020/09/09/LeetCode-44-wildcard-matching/"/>
    <url>/2020/09/09/LeetCode-44-wildcard-matching/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. 通配符匹配</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = p.length();    <span class="hljs-keyword">int</span> cols = s.length();    <span class="hljs-keyword">char</span>[] sChars = s.toCharArray();    <span class="hljs-keyword">char</span>[] pChars = p.toCharArray();    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows + <span class="hljs-number">1</span>][cols + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// 若以 '*' 开始，则 p 可以匹配 空串</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;        <span class="hljs-keyword">if</span> (pChars[i - <span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>) &#123;            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; j++) &#123;            <span class="hljs-comment">// 对应字符匹配 || p[j] == '?' 可匹配任意字符</span>            <span class="hljs-keyword">if</span> (sChars[j - <span class="hljs-number">1</span>] == pChars[i - <span class="hljs-number">1</span>] || pChars[i - <span class="hljs-number">1</span>] == <span class="hljs-string">'?'</span>) &#123;                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pChars[i - <span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>) &#123;                <span class="hljs-comment">// '*' 可匹配任意长度</span>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i][j - <span class="hljs-number">1</span>];            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[rows][cols];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 10. 正则表达式匹配</title>
    <link href="/2020/09/09/LeetCode-10-regular-expression-matching/"/>
    <url>/2020/09/09/LeetCode-10-regular-expression-matching/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></p><p><code>dp[i][j]</code> 表示 <code>s[0:i]</code> 是否能匹配到 <code>p[0:j]</code></p><ul><li><code>s[i] == p[j]</code>，对应位置匹配<br /><code>dp[i][j] = dp[i - 1][j - 1]</code></li><li><code>p[j] == '.'</code>，<code>'.'</code> 可以匹配任意字符<br /><code>dp[i][j] = dp[i - 1][j - 1]</code></li><li><code>s[i] != p[j]</code>，若 <code>p[j] != '*'</code>，则肯定无法匹配，只有当 <code>*</code> 时才有可能消除不匹配的字符。<ul><li><code>s[i] != p[j - 1]</code>， <code>*</code> 的前一个字符与 <code>s[i]</code> 无法匹配，则消去 <code>s[i]</code>，此时 <code>#*</code> 代表 <code>#</code> 取 0 个。<br /><code>dp[i][j] = dp[j - 2]</code></li><li><code>s[i] == p[j - 1]</code>， <code>*</code> 的前一个字符与 <code>s[i]</code> 匹配，则 <code>p[j - 2]</code> 可以取 0 个， 1 个或多个<br /><code>dp[i][j] = dp[j - 2] || dp[i][j - 1] || dp[i - 1][j]</code><ul><li>取 0 个：aab - aab b*</li><li>取 1 个：aab - aa b*</li><li>取 n 个：aabbbb - aa b*</li></ul></li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = s.length();    <span class="hljs-keyword">int</span> cols = p.length();    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows + <span class="hljs-number">1</span>][cols + <span class="hljs-number">1</span>];    <span class="hljs-comment">// 空串肯定能匹配</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= cols; i++) &#123;        <span class="hljs-keyword">if</span> (p.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">'*'</span> &amp;&amp; dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">2</span>]) &#123;            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-keyword">true</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; j++) &#123;            <span class="hljs-comment">// s 和 p 当前匹配到的字符</span>            <span class="hljs-keyword">char</span> sc = s.charAt(i - <span class="hljs-number">1</span>);            <span class="hljs-keyword">char</span> pc = p.charAt(j - <span class="hljs-number">1</span>);            <span class="hljs-comment">// i, j 匹配或 j 可取任意值</span>            <span class="hljs-keyword">if</span> (sc == pc || pc == <span class="hljs-string">'.'</span>) &#123;                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pc == <span class="hljs-string">'*'</span>) &#123;                <span class="hljs-comment">// `*` 的前一个字符</span>                <span class="hljs-keyword">char</span> last = p.charAt(j - <span class="hljs-number">2</span>);                <span class="hljs-comment">// last 与 s 的当前位置匹配，则 last 可取 1 位或多位</span>                <span class="hljs-keyword">if</span> (sc == last || last == <span class="hljs-string">'.'</span>) &#123;                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] || dp[i - <span class="hljs-number">1</span>][j];                &#125;                <span class="hljs-comment">// 尝试不取 last</span>                dp[i][j] = dp[i][j] || dp[i][j - <span class="hljs-number">2</span>];            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[rows][cols];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 5. 最长回文子串</title>
    <link href="/2020/09/09/LeetCode-5-longest-palindromic-substring/"/>
    <url>/2020/09/09/LeetCode-5-longest-palindromic-substring/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><ul><li><p>如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；</p></li><li><p>如果一个字符串的头尾两个字符相等，才有必要继续判断下去。</p><ul><li><p>如果里面的子串是回文，整体就是回文串；</p></li><li><p>如果里面的子串不是回文串，整体就不是回文串。</p></li></ul></li></ul><p>状态：<code>dp[i][j]</code> - <code>s[i:j]</code> 是否为回文串<br />状态转移方程：<code>dp[i][j] = s[i] == s[j] and dp[i + 1][j - 1]</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len][len];    <span class="hljs-comment">// 起点</span>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 回文长度</span>    <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">1</span>;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; len; j++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) &#123;            <span class="hljs-comment">// 两侧不等，一定无法构成回文</span>            <span class="hljs-keyword">if</span> (chars[i] != chars[j]) &#123;                dp[i][j] = <span class="hljs-keyword">false</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 子串只有 0 个或 1 个字符</span>                <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">2</span>) &#123;                    dp[i][j] = <span class="hljs-keyword">true</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 两侧相等，看子串是不是回文</span>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];                &#125;            &#125;            <span class="hljs-comment">// 更新最长回文位置</span>            <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen) &#123;                maxLen = j - i + <span class="hljs-number">1</span>;                start = i;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> s.substring(start, start + maxLen);&#125;</code></pre><h1 id="中心扩散"><a class="markdownIt-Anchor" href="#中心扩散"></a> 中心扩散</h1><p>尝试以每个字符和每个字符间的间隙为中心，向两端扩散。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200909134124.jpeg" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> s;    &#125;    String res = s.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// 奇数扩散，以 s[i] 为中心</span>        String oddStr = centerSpread(s, i, i);        <span class="hljs-comment">// 偶数扩散，以 s[i] s[i + 1] 为中心</span>        String evenStr = centerSpread(s, i, i + <span class="hljs-number">1</span>);        String cur = oddStr.length() &gt; evenStr.length() ? oddStr : evenStr;        <span class="hljs-keyword">if</span> (cur.length() &gt; res.length()) &#123;            res = cur;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">centerSpread</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; len) &#123;        <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;            <span class="hljs-keyword">break</span>;        &#125;        left--;        right++;    &#125;    <span class="hljs-comment">// s[left] != s[right]，取中间的回文部分 s[left + 1:right - 1]</span>    <span class="hljs-keyword">return</span> s.substring(left + <span class="hljs-number">1</span>, right);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 680. 验证回文字符串 Ⅱ</title>
    <link href="/2020/09/09/LeetCode-680-valid-palindrome-ii/"/>
    <url>/2020/09/09/LeetCode-680-valid-palindrome-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">680. 验证回文字符串 Ⅱ</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = s.length() - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-comment">// 最多删除一个字符，当有一个字符不等时，判断删除该字符后剩下的部分是否为回文</span>        <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;            <span class="hljs-keyword">return</span> isPalindrome(s, left + <span class="hljs-number">1</span>, right) || isPalindrome(s, left, right - <span class="hljs-number">1</span>);        &#125;        left++;        right--;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        left++;        right--;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 125. 验证回文串</title>
    <link href="/2020/09/09/LeetCode-125-valid-palindrome/"/>
    <url>/2020/09/09/LeetCode-125-valid-palindrome/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">125. 验证回文串</a></p><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;    s = s.toLowerCase();    <span class="hljs-keyword">int</span> right = s.length() - <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left))) &#123;            left++;        &#125;        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right))) &#123;            right--;        &#125;        <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        left++;        right--;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h1 id="reverse"><a class="markdownIt-Anchor" href="#reverse"></a> reverse</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;        <span class="hljs-keyword">char</span> c = s.charAt(i);        <span class="hljs-keyword">if</span> (Character.isLetterOrDigit(c)) &#123;            sb.append(Character.toLowerCase(c));        &#125;    &#125;    String s1 = sb.toString();    String s2 = sb.reverse().toString();    <span class="hljs-keyword">return</span> s1.equals(s2);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 818. 赛车</title>
    <link href="/2020/09/08/LeetCode-818-race-car/"/>
    <url>/2020/09/08/LeetCode-818-race-car/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/race-car/" target="_blank" rel="noopener">818. 赛车</a></p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><p>需要注意：<code>newPos &lt; target * 2</code>，因为对于 <code>target</code> 而言，</p><ul><li>可以在 <code>target</code> 之前进行加速或减速操作；</li><li>或者超过 <code>target</code> 之后进行减速操作；</li></ul><p>这两种方式都可能到达 <code>target</code>，把 <code>newPos</code> 限制在 <code>2 * target</code> 里，是为了让操作的步数不再递增，导致找不到终点。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">racecar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;    Deque&lt;Car&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    queue.add(<span class="hljs-keyword">new</span> Car(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));    visited.add(<span class="hljs-string">"0@1"</span>);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        count++;        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            Car car = queue.poll();            <span class="hljs-keyword">int</span> curPos = car.position;            <span class="hljs-comment">// 达到终点</span>            <span class="hljs-keyword">if</span> (curPos == target) &#123;                <span class="hljs-keyword">return</span> count;            &#125;            <span class="hljs-keyword">int</span> speed = car.speed;            <span class="hljs-comment">// 加速</span>            <span class="hljs-keyword">int</span> newPos = curPos + speed;            <span class="hljs-keyword">int</span> newSpeed = speed &lt;&lt; <span class="hljs-number">1</span>;            String key = newPos + <span class="hljs-string">"@"</span> + newSpeed;            <span class="hljs-keyword">if</span> (!visited.contains(key) &amp;&amp; <span class="hljs-number">0</span> &lt; newPos &amp;&amp; newPos &lt; (target &lt;&lt; <span class="hljs-number">1</span>)) &#123;                queue.add(<span class="hljs-keyword">new</span> Car(newPos, newSpeed));                visited.add(key);            &#125;            <span class="hljs-comment">// 减速</span>            newSpeed = speed &gt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;            key = curPos + <span class="hljs-string">"@"</span> + newSpeed;            <span class="hljs-keyword">if</span> (!visited.contains(key) &amp;&amp; <span class="hljs-number">0</span> &lt; curPos &amp;&amp; curPos &lt; (target &lt;&lt; <span class="hljs-number">1</span>)) &#123;                queue.add(<span class="hljs-keyword">new</span> Car(curPos, newSpeed));                visited.add(key);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;    <span class="hljs-keyword">int</span> position;    <span class="hljs-keyword">int</span> speed;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> speed)</span> </span>&#123;        <span class="hljs-keyword">this</span>.position = position;        <span class="hljs-keyword">this</span>.speed = speed;    &#125;&#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">racecar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-comment">// dp[i]: 到达 i 位置的最小步数</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= target; i++) &#123;        dp[i] = Integer.MAX_VALUE;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>, cnt1 = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 在 i 位置之前进行加速、减速操作</span>        <span class="hljs-comment">// j 每次加速到 2 ^ cnt1 - 1 位置</span>        <span class="hljs-keyword">for</span> (; j &lt; i; j = (<span class="hljs-number">1</span> &lt;&lt; ++cnt1) - <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// k 每次反向加速到 2 ^ cnt2 - 1 位置</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, cnt2 = <span class="hljs-number">0</span>; k &lt; j; k = (<span class="hljs-number">1</span> &lt;&lt; ++cnt2) - <span class="hljs-number">1</span>) &#123;                <span class="hljs-comment">// 正向走了 (j - k) 步 + 加速 + 2 次反向操作</span>                dp[i] = Math.min(dp[i], dp[i - (j - k)] + cnt1 + <span class="hljs-number">1</span> + cnt2 + <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-comment">// 经过 cnt1 次正向加速，此时位置超过 i，然后进行 1 次反向操作</span>        <span class="hljs-comment">// 若 i == j 到达 target，否则还差 j - i 到达 i 位置</span>        dp[i] = Math.min(dp[i], cnt1 + (i == j ? <span class="hljs-number">0</span> : dp[j - i] + <span class="hljs-number">1</span>));    &#125;    <span class="hljs-keyword">return</span> dp[target];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 115. 不同的子序列</title>
    <link href="/2020/09/08/LeetCode-115-distinct-subsequences/"/>
    <url>/2020/09/08/LeetCode-115-distinct-subsequences/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">115. 不同的子序列</a></p><h1 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(String s, String t)</span> </span>&#123;        backtrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, s, t);        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sPos, <span class="hljs-keyword">int</span> tPos, String s, String t)</span> </span>&#123;        <span class="hljs-comment">// t 匹配完成</span>        <span class="hljs-keyword">if</span> (tPos == t.length()) &#123;            count++;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// s 到达终点</span>        <span class="hljs-keyword">if</span> (sPos == s.length()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 记忆化</span>        String key = sPos + <span class="hljs-string">"@"</span> + tPos;        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            count += map.get(key);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> pre = count;        <span class="hljs-comment">// 当前字符相等，进入下一个字符</span>        <span class="hljs-comment">// s, t 同时向后</span>        <span class="hljs-keyword">if</span> (s.charAt(sPos) == t.charAt(tPos)) &#123;            backtrack(sPos + <span class="hljs-number">1</span>, tPos + <span class="hljs-number">1</span>, s, t);        &#125;        <span class="hljs-comment">// s 向后，t 不变</span>        backtrack(sPos + <span class="hljs-number">1</span>, tPos, s, t);        <span class="hljs-comment">// 存储本地回溯的 count 增量</span>        <span class="hljs-keyword">int</span> diff = count - pre;        map.put(key, diff);    &#125;&#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = t.length();    <span class="hljs-keyword">int</span> cols = s.length();    <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span> || cols == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows + <span class="hljs-number">1</span>][cols + <span class="hljs-number">1</span>];    Arrays.fill(dp[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; j++) &#123;            <span class="hljs-keyword">if</span> (t.charAt(i - <span class="hljs-number">1</span>) != s.charAt(j - <span class="hljs-number">1</span>)) &#123;                <span class="hljs-comment">// 不相等：去除 s[j]，取 s[:j - 1] 和 t[:i] 的相同序列数</span>                dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// s[j] 可取，可不取</span>                <span class="hljs-comment">// 若取 s[j]，因为 s[j] == t[i]，比较 s[:j - 1] 和 t[:i - 1]</span>                <span class="hljs-comment">// 若不取 s[j]，比较 s[:j - 1] 和 t[:i]</span>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i][j - <span class="hljs-number">1</span>];            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[rows][cols];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 85. 最大矩形</title>
    <link href="/2020/09/08/LeetCode-85-maximal-rectangle/"/>
    <url>/2020/09/08/LeetCode-85-maximal-rectangle/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a></p><h1 id="暴力"><a class="markdownIt-Anchor" href="#暴力"></a> 暴力</h1><p>保存每个 <code>1</code> 元素的最长距离，向上查找高度。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = matrix.length;    <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 以 widths[row][col] 结尾的最长 `1` 的个数</span>    <span class="hljs-keyword">int</span>[][] widths = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][cols];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-comment">// 当前位置为 `1`</span>            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">'1'</span>) &#123;                widths[i][j] = <span class="hljs-number">1</span>;                <span class="hljs-comment">// 不是第一列，则 = 1 + 左边那个格子的最长数</span>                <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) &#123;                    widths[i][j] += widths[i][j - <span class="hljs-number">1</span>];                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                widths[i][j] = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">int</span> minWidth = widths[i][j];            <span class="hljs-comment">// 向上查找最小矩形</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = i; row &gt;= <span class="hljs-number">0</span>; row--) &#123;                minWidth = Math.min(minWidth, widths[row][j]);                <span class="hljs-keyword">int</span> height = i - row + <span class="hljs-number">1</span>;                res = Math.max(res, minWidth * height);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><p>在 <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a> 的基础上，转化为按行求每行的最大矩形面积。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = matrix.length;    <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 保存每一列的高度</span>    <span class="hljs-keyword">int</span>[] heights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[cols];    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">'1'</span>) &#123;                <span class="hljs-comment">// 当前列为 1，在上一行的基础上 + 1</span>                heights[j]++;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 重新开始</span>                heights[j] = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-comment">// 求每一行的最大值</span>        res = Math.max(res, largestRectangleArea(heights));    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 84. 柱状图中最大的矩形</title>
    <link href="/2020/09/08/LeetCode-84-largest-rectangle-in-histogram/"/>
    <url>/2020/09/08/LeetCode-84-largest-rectangle-in-histogram/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = heights.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> heights[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-comment">// 添加哨兵，头尾都加一个 0，避免边界判断</span>    <span class="hljs-keyword">int</span>[] newHeights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">2</span>];    System.arraycopy(heights, <span class="hljs-number">0</span>, newHeights, <span class="hljs-number">1</span>, len);    <span class="hljs-comment">// 单调递增栈，当要入栈元素小于栈顶元素时</span>    <span class="hljs-comment">// 栈顶元素为最大值，可计算以栈顶为高度的最大矩形面积</span>    Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(len);    stack.push(<span class="hljs-number">0</span>);    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; newHeights.length; i++) &#123;        <span class="hljs-comment">// 严格递减，则计算面积</span>        <span class="hljs-keyword">while</span> (newHeights[i] &lt; newHeights[stack.peek()]) &#123;            <span class="hljs-comment">// 高度为当前栈顶元素</span>            <span class="hljs-keyword">int</span> height = newHeights[stack.pop()];            <span class="hljs-comment">// 栈顶出栈后，新的栈顶 = 左边小于 height 的元素</span>            <span class="hljs-keyword">int</span> width = i - stack.peek() - <span class="hljs-number">1</span>;            res = Math.max(res, height * width);        &#125;        stack.push(i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 438. 找到字符串中所有字母异位词</title>
    <link href="/2020/09/07/LeetCode-438-find-all-anagrams-in-a-string/"/>
    <url>/2020/09/07/LeetCode-438-find-all-anagrams-in-a-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></p><h1 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h1><p>右指针不断向右移动，并且判断当前字符字符是否满足目标字符的出现频率，若不满足，则移动左指针直到满足为止。当窗口大小满足要求时，窗口内的所有字符都满足要求，则保存此时的 <code>left</code>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">char</span>[] sChar = s.toCharArray();    <span class="hljs-keyword">char</span>[] pChar = p.toCharArray();    <span class="hljs-comment">// 保存目标字符串的字符出现频率</span>    <span class="hljs-keyword">int</span>[] needs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : pChar) &#123;        needs[c - <span class="hljs-string">'a'</span>]++;    &#125;    <span class="hljs-comment">// 窗口内字符串的出现频率</span>    <span class="hljs-keyword">int</span>[] window = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = p.length();    <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;        <span class="hljs-keyword">int</span> curPos = sChar[right] - <span class="hljs-string">'a'</span>;        window[curPos]++;        right++;        <span class="hljs-comment">// 让窗口内的字符频率和目标频率一致</span>        <span class="hljs-keyword">while</span> (needs[curPos] &lt; window[curPos]) &#123;            window[sChar[left] - <span class="hljs-string">'a'</span>]--;            left++;        &#125;        <span class="hljs-comment">// 长度满足目标长度</span>        <span class="hljs-keyword">if</span> (right - left == len) &#123;            res.add(left);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">char</span>[] sChar = s.toCharArray();    <span class="hljs-keyword">char</span>[] pChar = p.toCharArray();    <span class="hljs-comment">// 窗口中每个有效字符的出现次数</span>    <span class="hljs-keyword">int</span>[] window = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-comment">// 需要的字符出现次数</span>    <span class="hljs-keyword">int</span>[] needs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : pChar) &#123;        needs[c - <span class="hljs-string">'a'</span>]++;    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> sLen = s.length();    <span class="hljs-keyword">int</span> pLen = p.length();    <span class="hljs-comment">// 窗口中满足要求的有效字符数</span>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; sLen) &#123;        <span class="hljs-keyword">int</span> pos = sChar[right] - <span class="hljs-string">'a'</span>;        <span class="hljs-comment">// 不是有效字符</span>        <span class="hljs-keyword">if</span> (needs[pos] == <span class="hljs-number">0</span>) &#123;            right++;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 当前字符满足要求</span>        <span class="hljs-keyword">if</span> (window[pos] &lt; needs[pos]) &#123;            count++;        &#125;        window[pos]++;        right++;        <span class="hljs-comment">// 字符数等于目标大小</span>        <span class="hljs-keyword">while</span> (count == pLen) &#123;            <span class="hljs-comment">// 异位词：窗口长度 == 目标长度 才更新</span>            <span class="hljs-keyword">if</span> (right - left == pLen) &#123;                res.add(left);            &#125;            <span class="hljs-keyword">int</span> leftPos = sChar[left] - <span class="hljs-string">'a'</span>;            <span class="hljs-comment">// left 不在目标字符中</span>            <span class="hljs-keyword">if</span> (needs[leftPos] == <span class="hljs-number">0</span>) &#123;                left++;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// left 在目标字符中</span>            <span class="hljs-keyword">if</span> (window[leftPos] == needs[leftPos]) &#123;                count--;            &#125;            window[leftPos]--;            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 49. 字母异位词分组</title>
    <link href="/2020/09/06/LeetCode-49-group-anagrams/"/>
    <url>/2020/09/06/LeetCode-49-group-anagrams/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;    Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (String str : strs) &#123;        <span class="hljs-keyword">char</span>[] chars = str.toCharArray();        Arrays.sort(chars);        String key = <span class="hljs-keyword">new</span> String(chars);        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            map.get(key).add(str);        &#125; <span class="hljs-keyword">else</span> &#123;            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            list.add(str);            map.put(key, list);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(map.values());&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 32. 最长有效括号</title>
    <link href="/2020/09/05/LeetCode-32-longest-valid-parentheses/"/>
    <url>/2020/09/05/LeetCode-32-longest-valid-parentheses/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200905165736.png" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 只有遇到 ) 才能组成有效括号</span>        <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">')'</span>) &#123;            <span class="hljs-comment">// .....() 的情况: i - 2 位置上的最长 dp[i - 2] + 2 (新的括号)</span>            <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">'('</span>) &#123;                <span class="hljs-keyword">if</span> (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span>) &#123;                    dp[i] = <span class="hljs-number">2</span> + dp[i - <span class="hljs-number">2</span>];                &#125; <span class="hljs-keyword">else</span> &#123;                    dp[i] = <span class="hljs-number">2</span>;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// pairPos: 与 ) 配对的 ( 位置</span>                <span class="hljs-comment">// .....)) 的情况: 2 + [pairPos:i] 之间的有效括号 + pairPos 之前的有效括号</span>                <span class="hljs-keyword">int</span> pairPos = i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;                <span class="hljs-comment">// pairPos 位置有效 &amp;&amp; 该位置 = '('</span>                <span class="hljs-keyword">if</span> (pairPos &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(pairPos) == <span class="hljs-string">'('</span>) &#123;                    <span class="hljs-keyword">if</span> (pairPos - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;                        dp[i] = <span class="hljs-number">2</span> + dp[i - <span class="hljs-number">1</span>] + dp[pairPos - <span class="hljs-number">1</span>];                    &#125; <span class="hljs-keyword">else</span> &#123;                        dp[i] = <span class="hljs-number">2</span> + dp[i - <span class="hljs-number">1</span>];                    &#125;                &#125;            &#125;            res = Math.max(res, dp[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><p>栈中存放最后一个 没有被匹配的括号位置，相当于一个分隔符，当进来的右括号没有匹配时，就可根据差值计算有效括号长度。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 栈中存放最后一个 没有被匹配的括号位置</span>    Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    stack.push(-<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 左括号直接入栈</span>        <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">'('</span>) &#123;            stack.push(i);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 遇到右括号，先弹出再判断是否有匹配的左括号</span>            stack.pop();            <span class="hljs-comment">// 若栈空，表示当前右括号没有被匹配</span>            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;                stack.push(i);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 栈不为空，表示当前右括号有匹配元素，即被出栈的那个元素</span>                <span class="hljs-comment">// 有效括号长度 = 当前位置 - 最后一个没有被匹配的括号位置</span>                res = Math.max(res, i - stack.peek());            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 20. 有效的括号</title>
    <link href="/2020/09/05/LeetCode-20-valid-parentheses/"/>
    <url>/2020/09/05/LeetCode-20-valid-parentheses/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;    Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">3</span>);    map.put(<span class="hljs-string">')'</span>, <span class="hljs-string">'('</span>);    map.put(<span class="hljs-string">'&#125;'</span>, <span class="hljs-string">'&#123;'</span>);    map.put(<span class="hljs-string">']'</span>, <span class="hljs-string">'['</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;        <span class="hljs-keyword">char</span> c = s.charAt(i);        <span class="hljs-comment">// 右括号</span>        <span class="hljs-keyword">if</span> (map.containsKey(c)) &#123;            <span class="hljs-keyword">char</span> top = stack.isEmpty() ? <span class="hljs-string">'#'</span> : stack.pop();            <span class="hljs-comment">// 和栈顶元素不匹配，直接返回</span>            <span class="hljs-comment">// 因为后续元素不会与当前右括号匹配</span>            <span class="hljs-keyword">if</span> (top != map.get(c)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 左括号 || 栈为空 直接入栈</span>            stack.push(c);        &#125;    &#125;    <span class="hljs-keyword">return</span> stack.isEmpty();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 91. 解码方法</title>
    <link href="/2020/09/05/LeetCode-91-Decode-Ways/"/>
    <url>/2020/09/05/LeetCode-91-Decode-Ways/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a></p><p>考虑 <code>s = 1234</code>，则可以看成两种方案：<code>234</code> 和 <code>34</code>，即去除一位或两位；而 <code>234</code> 和 <code>34</code> 又可以继续去除一位或两位，形成新的方案。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200905160755.png" srcset="/img/loading.gif" alt="" /></p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200905161307.png" srcset="/img/loading.gif" alt="" /></p><ul><li>状态：<code>dp[i]</code> - <code>s[0:i]</code> 能组成的方案数</li><li>状态转移方程：<ul><li><code>s[i]</code> 不为 <code>0</code> 时才有效，此时 <code>dp[i] = dp[i - 1]</code></li><li><code>s[i]</code> 和 <code>s[i - 1]</code> 可以组成一个数，此时 <code>dp[i] = dp[i - 2]</code></li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-comment">// dp[1] -&gt; s[0]</span>    dp[<span class="hljs-number">1</span>] = s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'0'</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; len + <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// s[i] 不为 0，表示可以单独组成一个解码方案</span>        <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) != <span class="hljs-string">'0'</span>) &#123;            dp[i] += dp[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-comment">// 10 &lt;= s[i - 1:i] &lt;= 26 可以组成一个解码方案</span>        <span class="hljs-keyword">int</span> num = (s.charAt(i - <span class="hljs-number">2</span>) - <span class="hljs-string">'0'</span>) * <span class="hljs-number">10</span> + (s.charAt(i - <span class="hljs-number">1</span>) - <span class="hljs-string">'0'</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-number">10</span> &lt;= num &amp;&amp; num &lt;= <span class="hljs-number">26</span>) &#123;            dp[i] += dp[i - <span class="hljs-number">2</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[len];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 3. 无重复字符的最长子串</title>
    <link href="/2020/09/04/LeetCode-3-longest-substring-without-repeating-characters/"/>
    <url>/2020/09/04/LeetCode-3-longest-substring-without-repeating-characters/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></p><p>判断重复：使用 <code>map</code> 保存当前字符最后一次出现的位置，若重复，则根据该位置更新区间的起点。</p><p>起点取 <code>max</code> 的原因：始终保证 <code>start</code> 不会左移，否则若 <code>start &lt; map[c]</code>时，直接赋值 <code>start = map[c]</code>，会导致左移，可能无法过滤重复值。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// value 表示字符 c 最后一次出现的位置</span>    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">// [start, end] 区间内的元素都是不重复的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>; end &lt; s.length(); end++) &#123;        <span class="hljs-keyword">char</span> c = s.charAt(end);        <span class="hljs-comment">// 若出现重复，则重新计算 start 位置</span>        <span class="hljs-keyword">if</span> (map.containsKey(c)) &#123;            <span class="hljs-comment">// 取 max 的原因：始终保证 start 不会左移，若左移可能无法过滤重复值</span>            <span class="hljs-comment">// e.g. ...a1...b1....a2...a3....b2... </span>            <span class="hljs-comment">// 当到达 b2，此时 start = a3, b = b1, 若不取 max, start = b1 + 1, 导致 a 重复</span>            start = Math.max(start, map.get(c) + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">// 每次都会更新最大的区间</span>        res = Math.max(res, end - start + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 更新 c 的最新位置，若下次出现重复的 c，则 start 从 map[c] + 1 开始计算</span>        map.put(c, end);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 300. 最长上升子序列</title>
    <link href="/2020/09/04/LeetCode-300-longest-increasing-subsequence/"/>
    <url>/2020/09/04/LeetCode-300-longest-increasing-subsequence/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><ul><li>状态：<code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的「上升子序列」的长度</li><li>状态转移方程<ol><li>在访问 <code>nums[i]</code> 时，需要把 <code>i</code> 之前的数都查看一遍；</li><li>只要 <code>nums[j] &lt; nums[i]</code>，表示可以形成一个上升子序列；</li><li><code>dp[i] = max(dp[0:i]) + 1</code></li></ol></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> max = -<span class="hljs-number">1</span>;        <span class="hljs-comment">// 遍历之前序列中上升的数，找到最大值</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; j--) &#123;            <span class="hljs-comment">// 严格上升</span>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;                <span class="hljs-comment">// 寻找最大上升值</span>                <span class="hljs-keyword">if</span> (dp[j] &gt; max) &#123;                    max = dp[j];                &#125;            &#125;        &#125;        dp[i] = max == -<span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : max + <span class="hljs-number">1</span>;        res = Math.max(res, dp[i]);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="动态规划-二分"><a class="markdownIt-Anchor" href="#动态规划-二分"></a> 动态规划 + 二分</h1><ul><li>状态：<code>tail[i]</code> 表示长度为 <code>i + 1</code> 的所有上升子序列的结尾的最小值。结尾的元素越小，则越可能构造更长的上升子序列。</li><li>状态转移方程：<ol><li>每来一个新数 <code>num</code>，如果这个数严格大于有序数组 <code>tail</code> 的最后一个元素，就把 <code>num</code> 放在有序数组 <code>tail</code> 的后面；否则进入 2, 3。</li><li>如果有序数组 <code>tail</code> 中存在等于 <code>num</code> 的元素，什么都不做，因为以 <code>num</code> 结尾的最短的「上升子序列」已经存在；</li><li>如果有序数组 <code>tail</code> 中存在大于 <code>num</code> 的元素，找到第 <code>1</code> 个，让它变小，这样我们就找到了一个<strong>结尾更小的相同长度的上升子序列</strong>。</li></ol></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-comment">// tail[i] 表示长度为 i + 1 的 LIS 序列 的最小值</span>    <span class="hljs-keyword">int</span>[] tail = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-comment">// 第一个数 LIS 长度即为 1</span>    tail[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-comment">// end 表示 tail 中最后一个已赋值的元素索引</span>    <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (tail[end] &lt; nums[i]) &#123;            <span class="hljs-comment">// 构造递增的 tail 数组</span>            tail[++end] = nums[i];        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// tail[end] &gt; nums[i]，则进行更新</span>            <span class="hljs-comment">// 在 tail 中找到第一个 &gt; nums[i] 的值进行更新</span>            <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> right = end;            <span class="hljs-keyword">while</span> (left &lt; right) &#123;                <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt;&gt; <span class="hljs-number">1</span>);                <span class="hljs-keyword">if</span> (tail[mid] &lt; nums[i]) &#123;                    left = mid + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    right = mid;                &#125;            &#125;            <span class="hljs-comment">// &gt; nums[i] 的值一定存在，直接更新</span>            tail[left] = nums[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> end + <span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 72. 编辑距离</title>
    <link href="/2020/09/04/LeetCode-72-edit-distance/"/>
    <url>/2020/09/04/LeetCode-72-edit-distance/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></p><ul><li>状态：<code>dp[i][j]</code> - <code>word1[0:i]</code> 和 <code>word2[0:j]</code> 的最小编辑距离。</li><li>状态转移方程：<ul><li>若 <code>i</code>, <code>j</code> 位置相等，则跳过，否则进行删除，插入，替换操作，取最小值。</li><li>删除 <code>word1[i]</code> =&gt; <code>dp[i - 1][j] + 1</code></li><li>在 <code>word1[i + 1]</code> 插入 <code>word2[j]</code> =&gt; <code>dp[i][j - 1] + 1</code></li><li>替换 <code>word1[i]</code> 或 <code>word2[j]</code> =&gt; <code>dp[i - 1][j - 1] + 1</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200910115038.png" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;    <span class="hljs-keyword">int</span> len1 = word1.length();    <span class="hljs-keyword">int</span> len2 = word2.length();    <span class="hljs-comment">// 0 行和 0 列表示有一个单词为空，另一个单词不为空的情况</span>    <span class="hljs-comment">// 所以考虑到空字符串的情况下，多分配一个空间</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len2; i++) &#123;        dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;            <span class="hljs-comment">// 字符相同，同时去除该字符，直接取上一个距离</span>            <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 字符不同，依次尝试去除不同位置，取最小距离 + 1</span>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[len1][len2];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 746. 使用最小花费爬楼梯</title>
    <link href="/2020/09/04/LeetCode-746-min-cost-climbing-stairs/"/>
    <url>/2020/09/04/LeetCode-746-min-cost-climbing-stairs/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></p><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">10</td><td style="text-align:center">15</td><td style="text-align:center">20</td><td style="text-align:center"></td></tr></tbody></table><p>爬上第 <code>3</code> 阶楼梯可以从第 <code>1</code> 阶爬两步或者从第 <code>2</code> 阶爬一步。</p><p>题意：阶梯总数 = <code>cost.length</code>，爬上第 <code>i</code> 阶楼梯 &lt;=&gt; 不能算上第 <code>i</code> 阶楼梯的花费 <code>cost[i]</code>，也就是只能算到 <code>i - 1</code> 和 <code>i - 2</code> 阶楼梯。</p><ul><li>状态转移方程: <code>dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]</code></li><li>结果: <code>min(dp[len - 1], dp[len - 2])</code></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = cost.length;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; len; i++) &#123;            dp[i] = Math.min(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i];        &#125;        <span class="hljs-keyword">return</span> Math.min(dp[len - <span class="hljs-number">1</span>], dp[len - <span class="hljs-number">2</span>]);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 493. 翻转对</title>
    <link href="/2020/09/03/LeetCode-493-reverse-pairs/"/>
    <url>/2020/09/03/LeetCode-493-reverse-pairs/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-pairs/" target="_blank" rel="noopener">493. 翻转对</a></p><p>解法：</p><ul><li>使用归并排序，把数组分为左右两部分，且都单调递增；</li><li>则每次都固定左边元素，遍历右边元素；</li><li>因为都是有序的，所以从位置索引就能获取个数，且右边的元素只要遍历一遍。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">return</span> mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-keyword">int</span> mid = (low + high) &gt;&gt; <span class="hljs-number">1</span>;        count = mergeSort(arr, low, mid) + mergeSort(arr, mid + <span class="hljs-number">1</span>, high);        <span class="hljs-comment">// 对于 [low, mid] 中的每个元素</span>        <span class="hljs-comment">// 寻找他们在 [mid + 1, high] 中的翻转数</span>        <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt;= mid; i++) &#123;            <span class="hljs-comment">// (arr[i] &gt;&gt; 1) + (arr[i] &amp; 1) &gt; arr[j]</span>            <span class="hljs-comment">// while (j &lt;= high &amp;&amp; arr[i] &gt; (long) arr[j] &lt;&lt; 1) &#123;</span>            <span class="hljs-keyword">while</span> (j &lt;= high &amp;&amp; arr[i] &gt; (<span class="hljs-keyword">long</span>) arr[j] * <span class="hljs-number">2</span>) &#123;                j++;            &#125;            count += j - mid - <span class="hljs-number">1</span>;        &#125;        merge(arr, low, mid, high);    &#125;    <span class="hljs-keyword">return</span> count;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = high - low + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> i = low, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;        tmp[k++] = arr[i] &lt; arr[j] ? arr[i++] : arr[j++];    &#125;    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        tmp[k++] = arr[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= high) &#123;        tmp[k++] = arr[j++];    &#125;    System.arraycopy(tmp, <span class="hljs-number">0</span>, arr, low, len);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 56. 合并区间</title>
    <link href="/2020/09/03/LeetCode-56-merge-intervals/"/>
    <url>/2020/09/03/LeetCode-56-merge-intervals/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;    <span class="hljs-keyword">int</span> len = intervals.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> intervals;    &#125;    quickSort(intervals, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    System.out.println(Arrays.deepToString(intervals));    List&lt;<span class="hljs-keyword">int</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> start = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 可以合并：(i + 1).开始 &lt;= i.结束</span>        <span class="hljs-comment">// 开始 = i.开始，结束 = max(i.结束, (i + 1).结束)</span>        <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt;= end) &#123;            <span class="hljs-comment">// 更新 end</span>            end = Math.max(end, intervals[i][<span class="hljs-number">1</span>]);        &#125; <span class="hljs-keyword">else</span> &#123;            list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;start, end&#125;);            <span class="hljs-comment">// 更新 start，用于下一次合并</span>            start = intervals[i][<span class="hljs-number">0</span>];            end = intervals[i][<span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-comment">// 添加最后一个区间</span>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;start, end&#125;);    <span class="hljs-keyword">int</span> count = list.size();    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[count][<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;        res[i] = list.get(i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-keyword">int</span> pivotPos = partition(arr, low, high);        quickSort(arr, low, pivotPos - <span class="hljs-number">1</span>);        quickSort(arr, pivotPos + <span class="hljs-number">1</span>, high);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] pivot = arr[low];    <span class="hljs-keyword">while</span> (low &lt; high) &#123;        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high][<span class="hljs-number">0</span>] &gt;= pivot[<span class="hljs-number">0</span>]) &#123;            high--;        &#125;        arr[low] = arr[high];        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low][<span class="hljs-number">0</span>] &lt;= pivot[<span class="hljs-number">0</span>]) &#123;            low++;        &#125;        arr[high] = arr[low];    &#125;    arr[low] = pivot;    <span class="hljs-keyword">return</span> low;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;    <span class="hljs-keyword">int</span> len = intervals.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> intervals;    &#125;    Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[<span class="hljs-number">0</span>]));    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];    <span class="hljs-keyword">int</span> idx = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] interval : intervals) &#123;        <span class="hljs-comment">// 可以合并：开始 &lt;= 结束</span>        <span class="hljs-keyword">if</span> (idx == -<span class="hljs-number">1</span> || interval[<span class="hljs-number">0</span>] &gt; res[idx][<span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// 无法合并或 res 为空，添加新区间</span>            res[++idx] = interval;        &#125; <span class="hljs-keyword">else</span> &#123;            res[idx][<span class="hljs-number">1</span>] = Math.max(res[idx][<span class="hljs-number">1</span>], interval[<span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> Arrays.copyOf(res, idx + <span class="hljs-number">1</span>);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 242. 有效的字母异位词</title>
    <link href="/2020/09/03/LeetCode-242-valid-anagram/"/>
    <url>/2020/09/03/LeetCode-242-valid-anagram/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. 有效的字母异位词</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] sc = s.toCharArray();    <span class="hljs-keyword">char</span>[] tc = t.toCharArray();    Arrays.sort(sc);    Arrays.sort(tc);    <span class="hljs-keyword">return</span> Arrays.equals(sc, tc);&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">if</span> (s.length() != t.length()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;        arr[s.charAt(i) - <span class="hljs-string">'a'</span>]++;        arr[t.charAt(i) - <span class="hljs-string">'a'</span>]--;    &#125;    <span class="hljs-comment">// 若同一字符数量不相等，则对应位置不为 0</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;        <span class="hljs-keyword">if</span> (value != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1122. 数组的相对排序</title>
    <link href="/2020/09/03/LeetCode-1122-relative-sort-array/"/>
    <url>/2020/09/03/LeetCode-1122-relative-sort-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/relative-sort-array/" target="_blank" rel="noopener">1122. 数组的相对排序</a></p><p>使用计数排序。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] relativeSortArray(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2) &#123;    <span class="hljs-keyword">if</span> (arr1.length == <span class="hljs-number">0</span> || arr2.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> arr1;    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr1.length];    <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1001</span>];    <span class="hljs-comment">// 标记 arr1 中的每个元素</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr1) &#123;        bucket[value]++;    &#125;    <span class="hljs-comment">// 输出 arr2 存在于 bucket 中的元素</span>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr2) &#123;        <span class="hljs-keyword">while</span> (bucket[value] &gt; <span class="hljs-number">0</span>) &#123;            res[idx++] = value;            bucket[value]--;        &#125;    &#125;    <span class="hljs-comment">// 输出剩下的元素</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucket.length; i++) &#123;        <span class="hljs-keyword">while</span> (bucket[i] &gt; <span class="hljs-number">0</span>) &#123;            res[idx++] = i;            bucket[i]--;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 917. 仅仅反转字母</title>
    <link href="/2020/09/02/LeetCode-917-reverse-only-letters/"/>
    <url>/2020/09/02/LeetCode-917-reverse-only-letters/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-only-letters/" target="_blank" rel="noopener">917. 仅仅反转字母</a></p><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseOnlyLetters</span><span class="hljs-params">(String S)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = S.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-comment">// 找到左边为字母的位置</span>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetter(chars[left])) &#123;            left++;        &#125;        <span class="hljs-comment">// 找到右边为字母的位置</span>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetter(chars[right])) &#123;            right--;        &#125;        <span class="hljs-keyword">char</span> c = chars[left];        chars[left++] = chars[right];        chars[right--] = c;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(chars);&#125;</code></pre><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseOnlyLetters</span><span class="hljs-params">(String S)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = S.toCharArray();    Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-comment">// 将所有字母入栈</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        <span class="hljs-keyword">if</span> (Character.isLetter(c)) &#123;            stack.push(c);        &#125;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        <span class="hljs-comment">// 若是字母从栈中取，否则取字符串的原字符</span>        <span class="hljs-keyword">if</span> (Character.isLetter(c)) &#123;            sb.append(stack.pop());        &#125; <span class="hljs-keyword">else</span> &#123;            sb.append(c);        &#125;    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 557. 反转字符串中的单词 III</title>
    <link href="/2020/09/02/LeetCode-557-reverse-words-in-a-string-iii/"/>
    <url>/2020/09/02/LeetCode-557-reverse-words-in-a-string-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">557. 反转字符串中的单词 III</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">' '</span>) &#123;            reverseWord(chars, start, i - <span class="hljs-number">1</span>);            start = i + <span class="hljs-number">1</span>;        &#125;    &#125;    reverseWord(chars, start, len - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(chars);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseWord</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">while</span> (start &lt; end) &#123;        <span class="hljs-keyword">char</span> c = chars[start];        chars[start++] = chars[end];        chars[end--] = c;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 151. 翻转字符串里的单词</title>
    <link href="/2020/09/02/LeetCode-151-reverse-words-in-a-string/"/>
    <url>/2020/09/02/LeetCode-151-reverse-words-in-a-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151. 翻转字符串里的单词</a></p><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> end = len - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 去除前面空格</span>    <span class="hljs-keyword">while</span> (start &lt; len &amp;&amp; chars[start] == <span class="hljs-string">' '</span>) &#123;        start++;    &#125;    <span class="hljs-comment">// 去除后面空格</span>    <span class="hljs-keyword">while</span> (end &gt;= <span class="hljs-number">0</span> &amp;&amp; chars[end] == <span class="hljs-string">' '</span>) &#123;        end--;    &#125;    <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    System.out.println(chars[end]);    Deque&lt;String&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> srcPos = start;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;        <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">' '</span>) &#123;            String word = s.substring(srcPos, i);            <span class="hljs-comment">// 若是空单词则跳过</span>            <span class="hljs-keyword">if</span> (!<span class="hljs-string">""</span>.equals(word)) &#123;                stack.push(word);            &#125;            srcPos = i + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 处理最后一个单词</span>        <span class="hljs-keyword">if</span> (i == end) &#123;            stack.push(s.substring(srcPos, Math.max(end, end + <span class="hljs-number">1</span>)));        &#125;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        sb.append(stack.pop());        <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;            sb.append(<span class="hljs-string">" "</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre><h1 id="双端队列"><a class="markdownIt-Anchor" href="#双端队列"></a> 双端队列</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> end = len - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 去除前面空格</span>    <span class="hljs-keyword">while</span> (start &lt; len &amp;&amp; chars[start] == <span class="hljs-string">' '</span>) &#123;        start++;    &#125;    <span class="hljs-comment">// 去除后面空格</span>    <span class="hljs-keyword">while</span> (end &gt;= <span class="hljs-number">0</span> &amp;&amp; chars[end] == <span class="hljs-string">' '</span>) &#123;        end--;    &#125;    <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    StringBuilder curWord = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;        <span class="hljs-keyword">char</span> c = chars[i];        <span class="hljs-comment">// 字符为空 &amp;&amp; 单词不为空</span>        <span class="hljs-keyword">if</span> (curWord.length() != <span class="hljs-number">0</span> &amp;&amp; (c == <span class="hljs-string">' '</span>)) &#123;            <span class="hljs-comment">// 添加到队列前部</span>            deque.addFirst(curWord.toString());            <span class="hljs-comment">// 重置当前单词</span>            curWord.setLength(<span class="hljs-number">0</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span>) &#123;            curWord.append(c);        &#125;    &#125;    <span class="hljs-comment">// 因为[start, end] 末尾 != ' '</span>    <span class="hljs-comment">// 所以需要手动添加最后一个单词</span>    deque.addFirst(curWord.toString());    <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">" "</span>, deque);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 541. 反转字符串 II</title>
    <link href="/2020/09/02/LeetCode-541-reverse-string-ii/"/>
    <url>/2020/09/02/LeetCode-541-reverse-string-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">541. 反转字符串 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; len) &#123;        <span class="hljs-comment">// 对 (i, i + k) 之间的字符翻转</span>        <span class="hljs-comment">// 需要注意越界的情况</span>        reverseString(chars, i, Math.min(i + k, len) - <span class="hljs-number">1</span>);        i = i + <span class="hljs-number">2</span> * k;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(chars);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">char</span> c = s[left];        s[left] = s[right];        s[right] = c;        left++;        right--;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 344. 反转字符串</title>
    <link href="/2020/09/02/LeetCode-344-reverse-string/"/>
    <url>/2020/09/02/LeetCode-344-reverse-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">char</span> c = s[left];        s[left] = s[right];        s[right] = c;        left++;        right--;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 14. 最长公共前缀</title>
    <link href="/2020/09/01/LeetCode-14-longest-common-prefix/"/>
    <url>/2020/09/01/LeetCode-14-longest-common-prefix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></p><p>只要求前缀而不是子串，所以可以从起点开始查找字符。</p><h1 id="解法一横向比较"><a class="markdownIt-Anchor" href="#解法一横向比较"></a> 解法一：横向比较</h1><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;    <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    <span class="hljs-comment">// 假设前缀为第一个字符串</span>    String res = strs[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; strs.length; i++) &#123;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 将 res 与每个字符串比较</span>        <span class="hljs-keyword">for</span> (; j &lt; res.length() &amp;&amp; j &lt; strs[i].length(); j++) &#123;            <span class="hljs-keyword">if</span> (res.charAt(j) != strs[i].charAt(j)) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// j 表示公共前缀的位置</span>        res = res.substring(<span class="hljs-number">0</span>, j);        <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(res)) &#123;            <span class="hljs-keyword">return</span> res;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="解法二横向比较"><a class="markdownIt-Anchor" href="#解法二横向比较"></a> 解法二：横向比较</h1><p>解法一的另一种写法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;    <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    String prefix = strs[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 两两比较前缀</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; strs.length; i++) &#123;        prefix = getPrefix(prefix, strs[i]);        <span class="hljs-keyword">if</span> (prefix.length() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> prefix;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取 str1 和 str2 的最长公共前缀</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> str1</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> str2</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getPrefix</span><span class="hljs-params">(String str1, String str2)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = Math.min(str1.length(), str2.length());    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (str1.charAt(i) != str2.charAt(i)) &#123;            <span class="hljs-keyword">break</span>;        &#125;        idx++;    &#125;    <span class="hljs-keyword">return</span> str1.substring(<span class="hljs-number">0</span>, idx);&#125;</code></pre><h1 id="解法三纵向比较"><a class="markdownIt-Anchor" href="#解法三纵向比较"></a> 解法三：纵向比较</h1><p>将每个字符串的每个位置上的字符进行比较。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;    <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    <span class="hljs-keyword">int</span> len = strs[<span class="hljs-number">0</span>].length();    <span class="hljs-comment">// i 表示要比较的每个字符位置</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">char</span> cur = strs[<span class="hljs-number">0</span>].charAt(i);        <span class="hljs-comment">// 将第 i 个字符与 strs[] 里的每个串对应位置进行比较</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; strs.length; j++) &#123;            String str = strs[j];            <span class="hljs-comment">// prefix 串长度 == str 长度</span>            <span class="hljs-comment">// 当前位置的字符不匹配</span>            <span class="hljs-keyword">if</span> (i == str.length() || str.charAt(i) != cur) &#123;                <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, i);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 8. 字符串转换整数 (atoi)</title>
    <link href="/2020/09/01/LeetCode-8-string-to-integer-atoi/"/>
    <url>/2020/09/01/LeetCode-8-string-to-integer-atoi/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. 字符串转换整数 (atoi)</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Solution().myAtoi(<span class="hljs-string">"-2147483647"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] chars = str.toCharArray();        <span class="hljs-keyword">int</span> len = chars.length;        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 去除前部的空格</span>        <span class="hljs-keyword">while</span> (start &lt; len &amp;&amp; chars[start] == <span class="hljs-string">' '</span>) &#123;            start++;        &#125;        <span class="hljs-comment">// 到达终点</span>        <span class="hljs-keyword">if</span> (start == len) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">boolean</span> negative = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (chars[start] == <span class="hljs-string">'-'</span>) &#123;            <span class="hljs-comment">// 负数</span>            negative = <span class="hljs-keyword">true</span>;            start++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[start] == <span class="hljs-string">'+'</span>) &#123;            <span class="hljs-comment">// 正数</span>            start++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!Character.isDigit(chars[start])) &#123;            <span class="hljs-comment">// 首位非数字</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (start &lt; len &amp;&amp; Character.isDigit(chars[start])) &#123;            <span class="hljs-keyword">int</span> digit = chars[start] - <span class="hljs-string">'0'</span>;            <span class="hljs-comment">// 溢出判断</span>            <span class="hljs-comment">/*if (negative) &#123;</span><span class="hljs-comment">                if (-num &lt; Integer.MIN_VALUE / 10 || (-num == Integer.MIN_VALUE / 10 &amp;&amp; -digit &lt; -8)) &#123;</span><span class="hljs-comment">                    return Integer.MIN_VALUE;</span><span class="hljs-comment">                &#125;</span><span class="hljs-comment">            &#125; else &#123;</span><span class="hljs-comment">                if (num &gt; Integer.MAX_VALUE / 10 || (num == Integer.MAX_VALUE / 10 &amp;&amp; digit &gt; 7)) &#123;</span><span class="hljs-comment">                    return Integer.MAX_VALUE;</span><span class="hljs-comment">                &#125;</span><span class="hljs-comment">            &#125;*/</span>            <span class="hljs-comment">// num * 10 + digit &gt; INT_MAX 可能越界</span>            <span class="hljs-keyword">if</span> (num &gt; (Integer.MAX_VALUE - digit) / <span class="hljs-number">10</span>) &#123;                <span class="hljs-keyword">return</span> negative ? Integer.MIN_VALUE : Integer.MAX_VALUE;            &#125;            <span class="hljs-comment">// 拼装数字</span>            num = num * <span class="hljs-number">10</span> + digit;            <span class="hljs-comment">// 下一位</span>            start++;        &#125;        <span class="hljs-keyword">return</span> negative ? -num : num;    &#125;&#125;</code></pre><h1 id="解法二自动机"><a class="markdownIt-Anchor" href="#解法二自动机"></a> 解法二：自动机</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200901204413.png" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(String str)</span> </span>&#123;        Automaton automaton = <span class="hljs-keyword">new</span> Automaton();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str.toCharArray()) &#123;            automaton.get(c);        &#125;        <span class="hljs-keyword">return</span> automaton.sign * (<span class="hljs-keyword">int</span>)automaton.ans;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Automaton</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> START = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNED = <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> IN_NUM = <span class="hljs-number">2</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> END = <span class="hljs-number">3</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自动机的状态</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> state = START;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 状态转移表</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Map&lt;Integer, <span class="hljs-keyword">int</span>[]&gt; map;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 符号</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 结果</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Automaton</span><span class="hljs-params">()</span> </span>&#123;        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(START, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;START, SIGNED, IN_NUM, END&#125;);        map.put(SIGNED, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;END, END, IN_NUM, END&#125;);        map.put(IN_NUM, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;END, END, IN_NUM, END&#125;);        map.put(END, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;END, END, END, END&#125;);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCol</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">' '</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;        <span class="hljs-comment">// 新的状态</span>        state = map.get(state)[getCol(c)];        <span class="hljs-comment">// 转移到 数字</span>        <span class="hljs-keyword">if</span> (state == IN_NUM) &#123;            <span class="hljs-keyword">int</span> digit = c - <span class="hljs-string">'0'</span>;            ans = ans * <span class="hljs-number">10</span> + digit;            <span class="hljs-keyword">if</span> (sign == <span class="hljs-number">1</span>) &#123;                <span class="hljs-comment">// 正数</span>                ans = Math.min(ans, Integer.MAX_VALUE);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 负数</span>                ans = Math.min(ans, -(<span class="hljs-keyword">long</span>) Integer.MIN_VALUE);            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == SIGNED) &#123;            <span class="hljs-comment">// 转移到符号</span>            sign = (c == <span class="hljs-string">'+'</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 387. 字符串中的第一个唯一字符</title>
    <link href="/2020/09/01/LeetCode-387-first-unique-character-in-a-string/"/>
    <url>/2020/09/01/LeetCode-387-first-unique-character-in-a-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">387. 字符串中的第一个唯一字符</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>记录每个字母出现的次数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-comment">// 记录每个字母出现的次数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        counts[c - <span class="hljs-string">'a'</span>]++;    &#125;    <span class="hljs-comment">// 寻找出现次数为 1 的字母位置</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;        <span class="hljs-keyword">if</span> (counts[chars[i] - <span class="hljs-string">'a'</span>] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>判断首次出现的位置和最后出现的位置是否相等。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;        <span class="hljs-keyword">if</span> (s.indexOf(chars[i]) == s.lastIndexOf(chars[i])) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2020/09/01/sorting-algorithms/"/>
    <url>/2020/09/01/sorting-algorithms/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h1><h2 id="1-直接插入排序"><a class="markdownIt-Anchor" href="#1-直接插入排序"></a> 1. 直接插入排序</h2><blockquote><p>将每个元素依次插入前面已经排序好的序列。需要反复把已排序元素向后移，为新元素提供插入空间。</p></blockquote><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：每趟操作都要比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。<ul><li>最好情况：元素已经有序，每个元素只需比较一次 - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>最坏情况：元素逆序 - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>平均：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>稳定性</strong>：<strong>稳定</strong> - 每次插入总是先比较再移动，不会出现相同元素的相对位置变化。</li><li><strong>适用性</strong>：适用于顺序存储和链式存储的线性表</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> cur, j;    <span class="hljs-comment">// 位置 0 作为第一个有序元素</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;        <span class="hljs-comment">// 当 cur &lt; 前一个元素，进行排序</span>        <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i - <span class="hljs-number">1</span>]) &#123;            cur = arr[i];            <span class="hljs-comment">// 后移直到 cur &gt;= arr[j]</span>            <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; cur; --j) &#123;                arr[j + <span class="hljs-number">1</span>] = arr[j];            &#125;            <span class="hljs-comment">// 插入当前元素</span>            arr[j + <span class="hljs-number">1</span>] = cur;        &#125;    &#125;&#125;</code></pre><h2 id="2-折半插入排序"><a class="markdownIt-Anchor" href="#2-折半插入排序"></a> 2. 折半插入排序</h2><blockquote><p>在查找有序表时使用折半查找实现。</p></blockquote><p>仅仅减少了比较次数，其他与直接插入相同。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> low, high;    <span class="hljs-keyword">int</span> cur;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;        cur = arr[i];        low = <span class="hljs-number">0</span>;        high = i - <span class="hljs-number">1</span>;        <span class="hljs-comment">// low = high + 1 时结束，即 low 为最终插入位置</span>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;            <span class="hljs-keyword">int</span> mid = (low + high) &gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (arr[mid] &gt; cur) &#123;                high = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                low = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-comment">// 移动 low 直到 i 位置</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= low; j--) &#123;            arr[j + <span class="hljs-number">1</span>] = arr[j];        &#125;        arr[low] = cur;    &#125;&#125;</code></pre><h2 id="3-希尔排序"><a class="markdownIt-Anchor" href="#3-希尔排序"></a> 3. 希尔排序</h2><blockquote><p>根据增量序列，对子序列进行排序。</p></blockquote><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：依赖于增量函数<ul><li><strong>最好</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>最坏</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>平均</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>稳定性</strong>：<strong>不稳定</strong> - 当相同元素被划分到不同的子序列时，相对位置可能改变。</li><li><strong>适用性</strong>：顺序存储的线性表</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = arr.length;    <span class="hljs-keyword">int</span> cur;    <span class="hljs-keyword">int</span> j;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> dk = n / <span class="hljs-number">2</span>; dk &gt;= <span class="hljs-number">1</span>; dk /= <span class="hljs-number">2</span>) &#123;        <span class="hljs-comment">// 对增量 dk 内的每个元素排序</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = dk + <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i - dk]) &#123;                cur = arr[i];                <span class="hljs-comment">// 寻找插入位置</span>                <span class="hljs-keyword">for</span> (j = i - dk; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; cur; j -= dk) &#123;                    arr[j + dk] = arr[j];                &#125;                arr[j + dk] = cur;            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="交换排序"><a class="markdownIt-Anchor" href="#交换排序"></a> 交换排序</h1><h2 id="1-冒泡排序"><a class="markdownIt-Anchor" href="#1-冒泡排序"></a> 1. 冒泡排序</h2><blockquote><p>两两比较相邻元素的值，若逆序则交换，一趟冒泡结束后，当前步骤的最大元素到达最终位置。</p></blockquote><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<ul><li><strong>最好</strong>：初始序列有序 - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>最坏</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>平均</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>稳定性</strong>：<strong>稳定</strong> - 元素相等时不进行交换</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">int</span> t = arr[j];                arr[j] = arr[j + <span class="hljs-number">1</span>];                arr[j + <span class="hljs-number">1</span>] = t;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="2-快速排序"><a class="markdownIt-Anchor" href="#2-快速排序"></a> 2. 快速排序</h2><blockquote><p>选取一个基准元素，将排序表分为两部分，该元素被放到最终位置，递归执行该过程。</p></blockquote><ul><li><strong>空间复杂度</strong>：与栈深度一致<ul><li>最好：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2(n+1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>最坏：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>平均：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>时间复杂度</strong>：与划分是否对称有关<ul><li><strong>最好</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>最坏</strong>：有序或逆序 - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>平均</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>稳定性</strong>：<strong>不稳定</strong> - 会进行左右区间的交换</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-comment">// pivot 的最终位置</span>        <span class="hljs-keyword">int</span> pivotPos = partition(arr, low, high);        <span class="hljs-comment">// 对左半部分递归排序</span>        quickSort(arr, low, pivotPos - <span class="hljs-number">1</span>);        <span class="hljs-comment">// 对右半部分递归排序</span>        quickSort(arr, pivotPos + <span class="hljs-number">1</span>, high);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> pivot = arr[low];    <span class="hljs-keyword">while</span> (low &lt; high) &#123;        <span class="hljs-comment">// 找到比 low 小的元素</span>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;            <span class="hljs-comment">// 向前查找</span>            high--;        &#125;        <span class="hljs-comment">// 小元素移到 low</span>        arr[low] = arr[high];        <span class="hljs-comment">// 找到比 pivot 大的元素</span>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;            <span class="hljs-comment">// 向后查找</span>            low++;        &#125;        <span class="hljs-comment">// 大元素移到 high</span>        arr[high] = arr[low];    &#125;    <span class="hljs-comment">// pivot 的最终位置</span>    arr[low] = pivot;    <span class="hljs-keyword">return</span> low;&#125;</code></pre><h1 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h1><h2 id="1-简单选择排序"><a class="markdownIt-Anchor" href="#1-简单选择排序"></a> 1. 简单选择排序</h2><blockquote><p>在未排序序列中找到最大（最小）值，存放到排序序列的末尾。一趟排序可以确定一个元素的最终位置。</p></blockquote><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>稳定性</strong>：<strong>不稳定</strong></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = arr.length;    <span class="hljs-comment">// 从 0 开始存放元素</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">int</span> min = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;            <span class="hljs-comment">// 找到最小的元素位置</span>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min]) &#123;                min = j;            &#125;        &#125;        <span class="hljs-comment">// 交换第 i 个元素和 min</span>        <span class="hljs-keyword">if</span> (min != i) &#123;            swap(arr, i, min);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> min)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = arr[i];    arr[i] = arr[min];    arr[min] = t;&#125;</code></pre><h2 id="2-堆排序"><a class="markdownIt-Anchor" href="#2-堆排序"></a> 2. 堆排序</h2><blockquote><p>使用大顶堆或小顶堆。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortArray(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 将数组整理成堆</span>    heapify(nums);    <span class="hljs-comment">// 循环不变量：区间 [0, i] 堆有序</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; ) &#123;        <span class="hljs-comment">// 把堆顶元素（当前最大）交换到数组末尾</span>        swap(nums, <span class="hljs-number">0</span>, i);        <span class="hljs-comment">// 逐步减少堆有序的部分</span>        i--;        <span class="hljs-comment">// 下标 0 位置下沉操作，使得区间 [0, i] 堆有序</span>        siftDown(nums, <span class="hljs-number">0</span>, i);    &#125;    <span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 将数组整理成堆（堆有序）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 只需要从 i = (len - 1) / 2 这个位置开始逐层下移</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        siftDown(nums, i, len - <span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k    当前下沉元素的下标</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> end  [0, end] 是 nums 的有效部分</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * k &lt; end) &#123;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>;        <span class="hljs-comment">// 左结点 &lt; 右结点，j 指向右结点</span>        <span class="hljs-keyword">if</span> (j &lt; end &amp;&amp; nums[j + <span class="hljs-number">1</span>] &gt; nums[j]) &#123;            j++;        &#125;        <span class="hljs-comment">// 子结点大于父结点</span>        <span class="hljs-keyword">if</span> (nums[j] &gt; nums[k]) &#123;            swap(nums, j, k);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;        k = j;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = nums[i];    nums[i] = nums[j];    nums[j] = temp;&#125;</code></pre><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>稳定性</strong>：<strong>不稳定</strong></li></ul><h1 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h1><h2 id="1-二路归并排序"><a class="markdownIt-Anchor" href="#1-二路归并排序"></a> 1. 二路归并排序</h2><blockquote><p>将两个或两个以上的有序表组合成一个新的有序表。</p></blockquote><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 一趟归并 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，共 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span> 趟</li><li><strong>稳定性</strong>：<strong>稳定</strong></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-keyword">int</span> mid = (low + high) &gt;&gt; <span class="hljs-number">1</span>;        mergeSort(arr, low, mid);        mergeSort(arr, mid + <span class="hljs-number">1</span>, high);        merge(arr, low, mid, high);    &#125;&#125;<span class="hljs-comment">// 写法一</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt;= high; i++) &#123;        tmp[i] = arr[i];    &#125;    <span class="hljs-keyword">int</span> i, j, k;    <span class="hljs-comment">// 合并 [low, mid]...[mid + 1, high]</span>    <span class="hljs-keyword">for</span> (i = low, j = mid + <span class="hljs-number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;        <span class="hljs-keyword">if</span> (tmp[i] &lt; tmp[j]) &#123;            arr[k] = tmp[i];            i++;        &#125; <span class="hljs-keyword">else</span> &#123;            arr[k] = tmp[j];            j++;        &#125;    &#125;    <span class="hljs-comment">// 合并剩余元素</span>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        arr[k++] = tmp[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= high) &#123;        arr[k++] = tmp[j++];    &#125;&#125;<span class="hljs-comment">// 写法二</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = high - low + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-comment">// [low...mid] [mid + 1, high]</span>    <span class="hljs-keyword">int</span> i = low, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;        tmp[k++] = nums[i] &gt; nums[j] ? nums[j++] : nums[i++];    &#125;    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        tmp[k++] = nums[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= high) &#123;        tmp[k++] = nums[j++];    &#125;    System.arraycopy(tmp, <span class="hljs-number">0</span>, nums, low, len);&#125;</code></pre><h1 id="非比较排序"><a class="markdownIt-Anchor" href="#非比较排序"></a> 非比较排序</h1><h2 id="1-计数排序"><a class="markdownIt-Anchor" href="#1-计数排序"></a> 1. 计数排序</h2><blockquote><p>将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p></blockquote><p>局限性：</p><ol><li>当数列最大最小值差距过大时，并不适用计数排序。</li><li>当数列元素不是整数，并不适用计数排序。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] countSort(<span class="hljs-keyword">int</span>[] arr) &#123;    <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;    <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;        max = Math.max(max, num);        min = Math.min(min, num);    &#125;    <span class="hljs-comment">// 桶数组的大小为 最大值和最小值的差值</span>    <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max - min + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;        <span class="hljs-comment">// value 偏移位置 = value - min</span>        bucket[value - min]++;    &#125;    <span class="hljs-comment">// 对每个值加上之前的和 作为当前值</span>    <span class="hljs-comment">// bucket[i] 表示 第 i 个元素的顺序</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; bucket.length; i++) &#123;        bucket[i] += bucket[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];    <span class="hljs-comment">// 获取原数组的每个元素的新位置</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;        <span class="hljs-comment">// 第 value - min 个元素的序号</span>        <span class="hljs-keyword">int</span> pos = bucket[value - min] - <span class="hljs-number">1</span>;        res[pos] = value;        <span class="hljs-comment">// 更新 第 value - min 个元素的新位置：用于重复元素的情况</span>        bucket[value - min]--;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></li><li><strong>稳定性</strong>：<strong>稳定</strong></li><li>其排序速度快于任何比较排序算法。当 <code>k</code> 不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</li></ul><h2 id="2-桶排序"><a class="markdownIt-Anchor" href="#2-桶排序"></a> 2. 桶排序</h2><blockquote><p>将数据分到有限数量的桶里，每个桶再分别排序，最后输出每个桶的数据。</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> bucketCount = arr.length;    <span class="hljs-keyword">int</span> min = arr[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;        min = Math.min(min, value);        max = Math.max(max, value);    &#125;    <span class="hljs-comment">// 每个桶的大小</span>    <span class="hljs-keyword">double</span> space = (<span class="hljs-keyword">double</span>) (max - min) / (bucketCount - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 初始化桶</span>    List&lt;List&lt;Integer&gt;&gt; buckets = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;        buckets.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());    &#125;    <span class="hljs-comment">// 每个数据入桶</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;        <span class="hljs-comment">// 每个元素对应的桶序号</span>        <span class="hljs-keyword">int</span> bucket = (<span class="hljs-keyword">int</span>) ((value - min) / space) - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (bucket &lt; <span class="hljs-number">0</span>) &#123;            bucket = <span class="hljs-number">0</span>;        &#125;        buckets.get(bucket).add(value);    &#125;    <span class="hljs-comment">// 对每个桶排序</span>    <span class="hljs-keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;        Collections.sort(bucket);    &#125;    <span class="hljs-comment">// 输出桶内的每个元素</span>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : bucket) &#123;            arr[idx++] = num;        &#125;    &#125;&#125;</code></pre><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<ul><li><strong>最好</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><strong>最坏</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>平均</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>稳定性</strong>：<strong>稳定</strong></li></ul><h2 id="3-基数排序"><a class="markdownIt-Anchor" href="#3-基数排序"></a> 3. 基数排序</h2><blockquote><p>按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;        max = Math.max(max, num);    &#125;    List&lt;List&lt;Integer&gt;&gt; buckets = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// 余数 0 ~ 9 对应的桶</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;            buckets.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());    &#125;    <span class="hljs-comment">// 当前排序位置</span>    <span class="hljs-keyword">int</span> location = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        <span class="hljs-keyword">int</span> radix = (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">10</span>, (location - <span class="hljs-number">1</span>));        <span class="hljs-comment">// max &lt; 需要取余的数，说明每一位都已排序完成</span>        <span class="hljs-keyword">if</span> (max &lt; radix) &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-comment">// 把每个元素放入对应的桶</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;            <span class="hljs-comment">// 计算余数</span>            <span class="hljs-keyword">int</span> bucket = (num / radix) % <span class="hljs-number">10</span>;            buckets.get(bucket).add(num);        &#125;        <span class="hljs-comment">// 取出桶内元素写回原数组</span>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : buckets.get(i)) &#123;                arr[idx++] = num;            &#125;            <span class="hljs-comment">// 清空本次排序的桶</span>            buckets.get(i).clear();        &#125;        location++;    &#125;&#125;</code></pre><ul><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></li><li><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d(n + r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li><strong>稳定性</strong>：<strong>稳定</strong></li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>每一次排序之后都能确定至少一个元素位置的排序方法包括：</p><ol><li><p><strong>选择排序</strong>：每次将最大的数放到最后。所以最大的数排一次序后位置就确定了。</p></li><li><p><strong>冒泡排序</strong>：同选择排序。每一次排序最大的值位置确定。</p></li><li><p><strong>快排</strong>：每一次排序 <code>pivot</code> 的位置确定。</p></li><li><p><strong>堆排序</strong>：每一次排序时，都是将堆顶的元素和最后一个节点互换，然后调整堆，再将堆大小减1。所以每一次排序堆顶元素确定。</p></li></ol><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">最好</th><th style="text-align:center">平均</th><th style="text-align:center">最坏</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">直接插入</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><code>不稳定</code></td></tr><tr><td style="text-align:center">冒泡</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快排</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><code>不稳定</code></td></tr><tr><td style="text-align:center">简单选择</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><code>不稳定</code></td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><code>不稳定</code></td></tr><tr><td style="text-align:center">二路归并</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><mi>d</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d(d+r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><mi>d</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d(d+r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><mi>d</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d(d+r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 771. 宝石与石头</title>
    <link href="/2020/08/31/LeetCode-771-jewels-and-stones/"/>
    <url>/2020/08/31/LeetCode-771-jewels-and-stones/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">771. 宝石与石头</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numJewelsInStones</span><span class="hljs-params">(String J, String S)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">char</span>[] js = J.toCharArray();    <span class="hljs-keyword">char</span>[] ss = S.toCharArray();    Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : js) &#123;        set.add(c);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : ss) &#123;        <span class="hljs-keyword">if</span> (set.contains(c)) &#123;            count++;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 58. 最后一个单词的长度</title>
    <link href="/2020/08/31/LeetCode-58-length-of-last-word/"/>
    <url>/2020/08/31/LeetCode-58-length-of-last-word/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">58. 最后一个单词的长度</a></p><p>需要注意最后一个字符为空的情况。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> end = s.length() - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 找到末尾不为空的字符位置</span>    <span class="hljs-keyword">while</span> (end &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(end) == <span class="hljs-string">' '</span>) &#123;        end--;    &#125;    <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 从后往前找第一个空的位置</span>    <span class="hljs-keyword">int</span> start = end;    <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(start) != <span class="hljs-string">' '</span>) &#123;        start--;    &#125;    <span class="hljs-keyword">return</span> end - start;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 709. 转换成小写字母</title>
    <link href="/2020/08/31/LeetCode-709-to-lower-case/"/>
    <url>/2020/08/31/LeetCode-709-to-lower-case/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/to-lower-case/" target="_blank" rel="noopener">709. 转换成小写字母</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLowerCase</span><span class="hljs-params">(String str)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = str.toCharArray();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;        <span class="hljs-keyword">if</span> (chars[i] &gt;= <span class="hljs-string">'A'</span> &amp;&amp; chars[i] &lt;= <span class="hljs-string">'Z'</span>) &#123;            chars[i] = (<span class="hljs-keyword">char</span>) (chars[i] + <span class="hljs-number">32</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> String.valueOf(chars);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 146. LRU 缓存机制</title>
    <link href="/2020/08/30/LeetCode-146-lru-cache/"/>
    <url>/2020/08/30/LeetCode-146-lru-cache/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 结点类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">int</span> key;    <span class="hljs-keyword">int</span> value;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.value = value;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Cache 对应的链表，用于增删结点 O(1)</span><span class="hljs-comment">     * Node&lt;k1, v1&gt; -&gt; Node&lt;k2, v2&gt; -&gt; ...</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> LinkedList&lt;Node&gt; cache;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * key 到 Node 的映射，用于查询 O(1)</span><span class="hljs-comment">     * key -&gt; Node</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Map&lt;Integer, Node&gt; map;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 最大容量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;        cache = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">this</span>.capacity = capacity;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 若 key 存在，返回，且要把对应结点移到前面</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            <span class="hljs-keyword">int</span> value = map.get(key).value;            <span class="hljs-comment">// 使用 put 方法移动已存在结点到前面</span>            put(key, value);            <span class="hljs-keyword">return</span> value;        &#125;        <span class="hljs-comment">// 结点不存在</span>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 若 key 存在，删除旧结点，添加新结点，并把对应结点移到前面</span><span class="hljs-comment">     * 否则插入新结点</span><span class="hljs-comment">     * 若容量达到上限，删除最久未使用的结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        Node node = <span class="hljs-keyword">new</span> Node(key, value);        <span class="hljs-comment">// 该结点已存在</span>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            <span class="hljs-comment">// 删除旧结点</span>            cache.remove(map.get(key));            map.remove(key);        &#125;        <span class="hljs-comment">// 该结点不存在，则要判断是否有空位置用来新增结点</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// cache 容量达到上限，删除最后一个结点</span>            <span class="hljs-keyword">if</span> (cache.size() == capacity) &#123;                Node last = cache.getLast();                cache.removeLast();                map.remove(last.key);            &#125;        &#125;        <span class="hljs-comment">// 添加新结点</span>        cache.addFirst(node);        map.put(key, node);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2020/08/29/bloom-filter/"/>
    <url>/2020/08/29/bloom-filter/</url>
    
    <content type="html"><![CDATA[<h1 id="bloom-filter-概念"><a class="markdownIt-Anchor" href="#bloom-filter-概念"></a> <code>Bloom Filter</code> 概念</h1><p>布隆过滤器（<code>Bloom Filter</code>）是1970年由一个叫布隆的小伙子提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p><em><strong>面试关联：一般都会在回答缓存穿透，或者海量数据去重这个时候引出来，加分项哟</strong></em></p><h1 id="bloom-filter-原理"><a class="markdownIt-Anchor" href="#bloom-filter-原理"></a> <code>Bloom Filter</code> 原理</h1><p>布隆过滤器的原理是，当一个元素被加入集合时，通过 <code>K</code> 个散列函数将这个元素映射成一个位数组中的 <code>K</code> 个点，把它们置为 <code>1</code>。检索时，我们只要看看这些点是不是都是 <code>1</code> 就（大约）知道集合中有没有它了：</p><ul><li>如果这些点有任何一个 <code>0</code>，则被检元素一定不在；</li><li>如果都是 <code>1</code>，则被检元素很可能在。这就是布隆过滤器的基本思想。</li></ul><p><code>Bloom Filter</code> 跟单哈希函数 <code>Bit-Map</code> 不同之处在于：<code>Bloom Filter</code> 使用了 <code>k</code> 个哈希函数，每个字符串跟 <code>k</code> 个 <code>bit</code> 对应。从而降低了冲突的概率。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200829182232.jpeg" srcset="/img/loading.gif" alt="" /></p><p>简单的说一下就是我们先把我们数据库的数据都加载到我们的过滤器中，比如数据库的 <code>id</code> 现在有：<code>1</code>、<code>2</code>、<code>3</code></p><p>那就用 <code>id = 1</code> 为例子他在上图中经过三次 <code>hash</code> 之后，把三次原本值 <code>0</code> 的地方改为 <code>1</code>。</p><p>下次我进来查询如果 <code>id</code>也是 <code>1</code> 那我就把 <code>1</code> 拿去三次 <code>hash</code> 发现跟上面的三个位置完全一样，那就能证明过滤器中有 <code>1</code> 的。</p><p>反之如果不一样就说明不存在了</p><p>那应用的场景在哪里呢？一般我们都会用来<strong>防止缓存击穿</strong>。</p><p>简单来说就是你数据库的id都是1开始然后自增的，那我知道你接口是通过 <code>id</code> 查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我又去数据库查也没有，一个请求这样，100 个，1000 个，10000 个呢？你的 DB 基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接 return 一个数据为空不就好了嘛。</p><p>这玩意这么好使那有啥缺点么？有的，我们接着往下看</p><h1 id="bloom-filter-的缺点"><a class="markdownIt-Anchor" href="#bloom-filter-的缺点"></a> Bloom Filter 的缺点</h1><p><code>Bloom Filter</code> 之所以能做到在时间和空间上的效率比较高，是因为牺牲了判断的准确率、删除的便利性</p><ul><li><p><strong>存在误判</strong>。可能要查到的元素并没有在容器中，但是 <code>hash</code> 之后得到的 <code>k</code> 个位置上值都是 <code>1</code>。如果 <code>bloom filter</code> 中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</p></li><li><p><strong>删除困难</strong>。一个放入容器的元素映射到 <code>bit</code> 数组的 <code>k</code> 个位置上是 <code>1</code>，删除的时候不能简单的直接置为 <code>0</code>，可能会影响其他元素的判断。可以采用 <a href="http://wiki.corp.qunar.com/confluence/download/attachments/199003276/US9740797.pdf?version=1&amp;modificationDate=1526538500000&amp;api=v2" target="_blank" rel="noopener">Counting Bloom Filter</a></p></li></ul><h1 id="bloom-filter-实现"><a class="markdownIt-Anchor" href="#bloom-filter-实现"></a> <code>Bloom Filter</code> 实现</h1><p>布隆过滤器有许多实现与优化，Guava中就提供了一种 <code>Bloom Filter</code> 的实现。</p><ul><li><p>在使用 <code>bloom filter</code> 时，绕不过的两点是预估数据量 <code>n</code> 以及期望的误判率 <code>fpp</code>，</p></li><li><p>在实现 <code>bloom filter</code> 时，绕不过的两点就是 <code>hash</code> 函数的选取以及 <code>bit</code> 数组的大小。</p></li></ul><p>对于一个确定的场景，我们预估要存的数据量为 <code>n</code>，期望的误判率为 <code>fpp</code>，然后需要计算我们需要的 <code>Bit</code> 数组的大小 <code>m</code>，以及 <code>hash</code> 函数的个数 <code>k</code>，并选择 <code>hash</code> 函数</p><h2 id="1-bit-数组大小选择"><a class="markdownIt-Anchor" href="#1-bit-数组大小选择"></a> (1) <code>Bit</code> 数组大小选择</h2><p>根据预估数据量 <code>n</code> 以及误判率 <code>fpp</code>，<code>bit</code> 数组大小的 <code>m</code> 的计算方式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mo>−</mo><mfrac><mrow><mi>n</mi><mi>l</mi><mi>n</mi><mi>f</mi><mi>p</mi><mi>p</mi></mrow><mrow><mo stretchy="false">(</mo><mi>l</mi><mi>n</mi><mn>2</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">m = -\frac{nlnfpp}{(ln2)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3074399999999997em;vertical-align:-0.936em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h2 id="2-哈希函数选择"><a class="markdownIt-Anchor" href="#2-哈希函数选择"></a> (2) 哈希函数选择</h2><p>由预估数据量 <code>n</code> 以及 <code>bit</code> 数组长度 <code>m</code>，可以得到一个 <code>hash</code> 函数的个数 <code>k</code>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mi>l</mi><mi>n</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k = \frac{m}{n}ln2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord">2</span></span></span></span></span></p><p>哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个<code>Bit</code>。选择 <code>k</code> 个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入 <code>k</code> 个不同的参数。</p><p>哈希函数个数 <code>k</code>、位数组大小 <code>m</code>、加入的字符串数量 <code>n</code> 的关系可以参考 <a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html" target="_blank" rel="noopener">Bloom Filters - the math</a>，<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">Bloom_filter-wikipedia</a></p><h1 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h1><h2 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h2><p>要使用 <code>BloomFilter</code>，需要引入 <code>guava</code>包：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>23.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>测试分两步：<br />1、往过滤器中放一百万个数，然后去验证这一百万个数是否能通过过滤器<br />2、另外找一万个数，去检验漏网之鱼的数量</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 测试布隆过滤器</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBloomFilter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> total = <span class="hljs-number">100_0000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total);<span class="hljs-comment">//    private static BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total, 0.001);</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 初始化 1000000 条数据到过滤器中</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++) &#123;            bf.put(i);        &#125;        <span class="hljs-comment">// 匹配已在过滤器中的值，是否有匹配不上的</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++) &#123;            <span class="hljs-keyword">if</span> (!bf.mightContain(i)) &#123;                System.out.println(<span class="hljs-string">"有坏人逃脱了~~~"</span>);            &#125;        &#125;        <span class="hljs-comment">// 匹配不在过滤器中的 10000 个值，有多少匹配出来</span>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = total; i &lt; total + <span class="hljs-number">10000</span>; i++) &#123;            <span class="hljs-keyword">if</span> (bf.mightContain(i)) &#123;                count++;            &#125;        &#125;        System.out.println(<span class="hljs-string">"误伤的数量："</span> + count);    &#125;&#125;</code></pre><h2 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BloomFilter&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(Funnel&lt;? <span class="hljs-keyword">super</span> T&gt; funnel, <span class="hljs-keyword">int</span> expectedInsertions)</span> </span>&#123;        <span class="hljs-keyword">return</span> create(funnel, (<span class="hljs-keyword">long</span>) expectedInsertions);    &#125;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BloomFilter&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(Funnel&lt;? <span class="hljs-keyword">super</span> T&gt; funnel, <span class="hljs-keyword">long</span> expectedInsertions)</span> </span>&#123;        <span class="hljs-keyword">return</span> create(funnel, expectedInsertions, <span class="hljs-number">0.03</span>); <span class="hljs-comment">// FYI, for 3%, we always get 5 hash functions</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BloomFilter&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">          Funnel&lt;? <span class="hljs-keyword">super</span> T&gt; funnel, <span class="hljs-keyword">long</span> expectedInsertions, <span class="hljs-keyword">double</span> fpp)</span> </span>&#123;        <span class="hljs-keyword">return</span> create(funnel, expectedInsertions, fpp, BloomFilterStrategies.MURMUR128_MITZ_64);    &#125;    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BloomFilter&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      Funnel&lt;? <span class="hljs-keyword">super</span> T&gt; funnel, <span class="hljs-keyword">long</span> expectedInsertions, <span class="hljs-keyword">double</span> fpp, Strategy strategy)</span> </span>&#123;     ......    &#125;</code></pre><p><code>BloomFilter</code> 一共四个 <code>create</code> 方法，不过最终都是走向第四个。看一下每个参数的含义：</p><ol><li><p><code>funnel</code>：数据类型(一般是调用 <code>Funnels</code> 工具类中的)</p></li><li><p><code>expectedInsertions</code>：期望插入的值的个数</p></li><li><p><code>fpp</code> 错误率(默认值为 <code>0.03</code>)</p></li><li><p><code>strategy</code> 哈希算法</p></li></ol><p>使用第三个 <code>create</code> 方法，我们设置下错误率：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total, <span class="hljs-number">0.0003</span>);</code></pre><p><strong>错误率越大，所需空间和时间越小，错误率越小，所需空间和时间越大。</strong></p><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h2><ul><li><p><code>cerberus</code> 在收集监控数据的时候, 有的系统的监控项量会很大, 需要检查一个监控项的名字是否已经被记录到 db 过了, 如果没有的话就需要写入 db.</p></li><li><p>爬虫过滤已抓到的 url 就不再抓，可用 bloom filter 过滤</p></li><li><p>垃圾邮件过滤。如果用哈希表，每存储一亿个 email 地址，就需要 1.6GB 的内存（用哈希表实现的具体办法是将每一个 email 地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB 的内存。而 Bloom Filter 只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 52. N皇后 II</title>
    <link href="/2020/08/29/LeetCode-52-n-queens-ii/"/>
    <url>/2020/08/29/LeetCode-52-n-queens-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">52. N皇后 II</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">totalNQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">this</span>.n = n;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-keyword">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : board) &#123;            Arrays.fill(line, <span class="hljs-string">'.'</span>);        &#125;        backtrack(<span class="hljs-number">0</span>, board);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">if</span> (row == n) &#123;            res++;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;            <span class="hljs-keyword">if</span> (!isValid(row, col, board)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            board[row][col] = <span class="hljs-string">'Q'</span>;            backtrack(row + <span class="hljs-number">1</span>, board);            board[row][col] = <span class="hljs-string">'.'</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : board) &#123;            <span class="hljs-keyword">if</span> (line[col] == <span class="hljs-string">'Q'</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--)&#123;            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'Q'</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'Q'</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 7. 整数反转</title>
    <link href="/2020/08/29/LeetCode-7-reverse-integer/"/>
    <url>/2020/08/29/LeetCode-7-reverse-integer/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. 整数反转</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 个位数</span>        <span class="hljs-keyword">int</span> pop = x % <span class="hljs-number">10</span>;        <span class="hljs-comment">// 去除个位数</span>        x = x / <span class="hljs-number">10</span>;        <span class="hljs-keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="hljs-number">10</span>                <span class="hljs-comment">// 最后一位溢出</span>                || (res == Integer.MAX_VALUE / <span class="hljs-number">10</span> &amp;&amp; pop &gt; <span class="hljs-number">7</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="hljs-number">10</span>                <span class="hljs-comment">// 最后一位溢出</span>                || (res == Integer.MIN_VALUE / <span class="hljs-number">10</span> &amp;&amp; pop &lt; -<span class="hljs-number">8</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// 翻转后的数</span>        res = res * <span class="hljs-number">10</span> + pop;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 338. 比特位计数</title>
    <link href="/2020/08/28/LeetCode-338-counting-bits/"/>
    <url>/2020/08/28/LeetCode-338-counting-bits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>每个数依次计数</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= num; i++) &#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = i;        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;            n = n &amp; (n - <span class="hljs-number">1</span>);            count++;        &#125;        res[i] = count;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>用奇偶数判断妙的很啊！！！</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= num; i++) &#123;        <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 奇数比前面的偶数多一个 1</span>            res[i] = res[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-comment">// 偶数的最低位是 0，所以 i 中 1 的个数和去除低位 0 后的那个数一样多</span>             res[i] = res[i &gt;&gt; <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><p>其实也是奇偶数的思路。<br /><code>i</code> 和 <code>i &gt;&gt; 1</code> 中 <code>1</code> 的个数是最低有效位上的差别。</p><pre><code class="hljs java">i = (<span class="hljs-number">100101</span>)i &gt;&gt; <span class="hljs-number">1</span> = (<span class="hljs-number">10010</span>)</code></pre><p>状态：<code>dp[i]</code> - 数字 <code>i</code> 中 <code>1</code> 的个数。<br />状态转移方程：<code>dp[i] = dp[i &gt;&gt; 1] + 最低有效位</code>。</p><hr /><p><code>i</code> 和 <code>i &amp; (i - 1)</code> 中 <code>1</code> 的个数总是相差 <code>1</code>，因为 <code>i</code> 中的最后一位 <code>1</code> 已经变为 <code>0</code>。<br />状态转移方程：<code>dp[i] = dp[i &amp; (i - 1)] + 1</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;        <span class="hljs-comment">// 使用最低有效位计算</span>        <span class="hljs-comment">// dp[i] = dp[i &gt;&gt; 1] + (i &amp; 1);</span>        <span class="hljs-comment">// 抹除最低位的 1</span>        dp[i] = dp[i &amp; (i - <span class="hljs-number">1</span>)] + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> dp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 190. 颠倒二进制位</title>
    <link href="/2020/08/28/LeetCode-190-reverse-bits/"/>
    <url>/2020/08/28/LeetCode-190-reverse-bits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>逐位移动，<code>n</code> 从<strong>右往左取</strong>，取出的每一位放到 <code>res</code> 中，<code>res</code> 从<strong>左往右放</strong>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">31</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;        <span class="hljs-comment">// 先左移空出最右边一位，再加上 n 的最后一位</span>        res = (res &lt;&lt; <span class="hljs-number">1</span>) + (n &amp; <span class="hljs-number">1</span>);        <span class="hljs-comment">// 删除最后一位</span>        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二：</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// 取最后一位移到左边</span>        res += (n &amp; <span class="hljs-number">1</span>) &lt;&lt; i;        <span class="hljs-comment">// 删除最后一位</span>        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 50. Pow(x, n)</title>
    <link href="/2020/08/28/LeetCode-50-powx-n/"/>
    <url>/2020/08/28/LeetCode-50-powx-n/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></p><h1 id="快速幂-递归"><a class="markdownIt-Anchor" href="#快速幂-递归"></a> 快速幂 + 递归</h1><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>77</mn></msup><mo>←</mo><msup><mi>x</mi><mn>38</mn></msup><mo>⋅</mo><mi>x</mi><mo>←</mo><msup><mi>x</mi><mn>19</mn></msup><mo>←</mo><msup><mi>x</mi><mn>9</mn></msup><mo>⋅</mo><mi>x</mi><mo>←</mo><msup><mi>x</mi><mn>4</mn></msup><mo>⋅</mo><mi>x</mi><mo>←</mo><msup><mi>x</mi><mn>2</mn></msup><mo>←</mo><mi>x</mi><mo>←</mo><msup><mi>x</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">x^{77} \leftarrow x^{38} \cdot x \leftarrow x^{19} \leftarrow x^9 \cdot x \leftarrow x^4 \cdot x \leftarrow x^2 \leftarrow x \leftarrow x^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">9</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></p><p>若 <code>n</code> 为偶数，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><msup><mi>x</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">x^n = x^{\frac{n}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.89708em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.89708em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>若 <code>n</code> 为奇数，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><msup><mi>x</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup><mo>⋅</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x^n = x^{\frac{n}{2}} \cdot x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.89708em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.89708em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></span></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">long</span> N = n;    <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? getPow(x, N) : <span class="hljs-number">1.0</span> / getPow(x, N);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;    &#125;    <span class="hljs-keyword">double</span> y = getPow(x, n / <span class="hljs-number">2</span>);    <span class="hljs-keyword">return</span> (n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> ? y * y * x : y * y;&#125;</code></pre><h1 id="快速幂-迭代"><a class="markdownIt-Anchor" href="#快速幂-迭代"></a> 快速幂 + 迭代</h1><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mi>m</mi></msub><msub><mo>⋯</mo><mn>3</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub></mrow></msup><mo>=</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>×</mo><mn>1</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mn>2</mn></msub><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mn>3</mn></msub><mo>×</mo><msup><mn>2</mn><mn>2</mn></msup></mrow></msup><mo separator="true">⋅</mo><mo>…</mo><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></msup><mo separator="true">⋅</mo></mrow><annotation encoding="application/x-tex">x^n = x^{b_m\dotsb_3b_2b_1} = x^{b_1\times1}·x^{b_2\times2^1}·x^{b_3\times2^2}·\dots·x^{b_m\times2^{m-1}}·</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.899108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.899108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="minner mtight"><span class="minner mtight">⋯</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0369199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.899108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>9</mn></msup><mo>=</mo><msup><mi>x</mi><mn>1001</mn></msup><mo>=</mo><msup><mi>x</mi><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><mn>0</mn><mo>×</mo><mn>2</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><mn>0</mn><mo>×</mo><mn>4</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><mn>1</mn><mo>×</mo><mn>8</mn></mrow></msup></mrow><annotation encoding="application/x-tex">x^9 = x^{1001} = x^{1\times1}·x^{0\times2}·x^{0\times4}·x^{1\times8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">×</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">×</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">×</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>所以当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 0 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></msup></mrow><annotation encoding="application/x-tex">x^{b_m\times2^{m-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869199999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> = 1，此时该项不用计算，每一项的规则如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></msup><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>x</mi><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></msup><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">x^{b_m\times2^{m-1}} = \begin{cases}1, &amp; b_m = 0 \\x^{2^{m-1}}, &amp; b_m = 1\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0369199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>最终的计算规则：</p><ul><li>先获取二进制位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><msub><mo>⋯</mo><mn>3</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_m\dotsb_3b_2b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner">⋯</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的值<ul><li><code>n &amp; 1</code>: 获取最后一位</li><li><code>n &gt;&gt; 1</code>: 删除最后一位，获取下一位</li></ul></li><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> == 1，则更新结果：<code>res *= x</code></li><li>计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>1</mn></msup><mo separator="true">,</mo><msup><mi>x</mi><mn>2</mn></msup><mo separator="true">,</mo><msup><mi>x</mi><mn>4</mn></msup><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msup><mi>x</mi><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></msup></mrow><annotation encoding="application/x-tex">x^1, x^2, x^4, \dots, x^{2^{m-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.18136em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 的值：循环操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x = x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">long</span> N = n;    <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? getPow(x, N) : <span class="hljs-number">1.0</span> / getPow(x, -N);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span> </span>&#123;    <span class="hljs-keyword">double</span> res = <span class="hljs-number">1.0</span>;    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 最后一位为 1，表示此时 x^n 有效</span>        <span class="hljs-comment">// 若为 0，增益为 0，结果不变</span>        <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;            res *= x;        &#125;        <span class="hljs-comment">// 保存当前位的 x^i</span>        x *= x;        <span class="hljs-comment">// 删除最后一位，进行下一位计算</span>        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 231. 2的幂</title>
    <link href="/2020/08/27/LeetCode-231-power-of-two/"/>
    <url>/2020/08/27/LeetCode-231-power-of-two/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">231. 2的幂</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><blockquote><p>二进制下，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 只有一位是 <code>1</code>。</p></blockquote><p>若 <code>x &amp; (x - 1) == 0</code>，表示 <code>x</code> 只有 <code>1</code> 个 <code>1</code>，即为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>。</p><table><thead><tr><th style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></th><th style="text-align:center">n</th><th style="text-align:center">n-1</th><th style="text-align:center">n &amp; (n - 1)</th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">1</td><td style="text-align:center">0000</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">10</td><td style="text-align:center">0001</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">100</td><td style="text-align:center">0011</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">1000</td><td style="text-align:center">0111</td><td style="text-align:center">0</td></tr></tbody></table><p>证明：<br />若 <code>n</code> 为 <code>2</code> 的幂，则 <code>n</code> 的二进制位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><msub><mi>n</mi><mn>2</mn></msub><msub><mi>n</mi><mn>3</mn></msub><msub><mi>n</mi><mn>4</mn></msub><mo>…</mo></mrow><annotation encoding="application/x-tex">n_1 n_2 n_3n_4\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span> 有且只有一位为 <code>1</code>，且为最高位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则 <code>n - 1</code> 的二进制位除了最高位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n_1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 外其余位都为 <code>1</code>。<br />在这种情况下，<code>n &amp; (n - 1) == 0</code>，因此可用来判断 <code>n</code> 是不是 <code>2</code> 的幂。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 除 1 之外的奇数</span>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 2 的幂最后商是 1</span>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 是奇数</span>        <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 191. 位1的个数</title>
    <link href="/2020/08/27/LeetCode-191-number-of-1-bits/"/>
    <url>/2020/08/27/LeetCode-191-number-of-1-bits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>任何数字 <code>&amp; 1</code> 都会获得这个数字的最低位，因此只要 <code>mask</code> 左移就能获取每个数字的最低位。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 32 位整数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;        <span class="hljs-keyword">if</span> ((n &amp; mask) != <span class="hljs-number">0</span>) &#123;            count++;        &#125;        mask &lt;&lt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;        count += n &amp; <span class="hljs-number">1</span>;        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p><code>n &amp; n - 1</code> 可以把最低位的 <code>1</code> 变为 <code>0</code>，因此只要循环操作，直到 <code>n == 0</code>，操作的次数就是 <code>1</code> 的个数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;        n = n &amp; (n - <span class="hljs-number">1</span>);        count++;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 773. 滑动谜题</title>
    <link href="/2020/08/27/LeetCode-773-sliding-puzzle/"/>
    <url>/2020/08/27/LeetCode-773-sliding-puzzle/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sliding-puzzle/" target="_blank" rel="noopener">773. 滑动谜题</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>需要注意棋盘的深拷贝。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">slidingPuzzle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">int</span> rows = board.length;        <span class="hljs-keyword">int</span> cols = board[<span class="hljs-number">0</span>].length;        Node start = <span class="hljs-keyword">null</span>;        String startBoardStr = <span class="hljs-string">""</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-number">0</span>) &#123;                    startBoardStr = Arrays.deepToString(board);                    start = <span class="hljs-keyword">new</span> Node(i, j, board.clone(), startBoardStr);                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> (start == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;        String target = Arrays.deepToString(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>&#125;&#125;);        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        Set&lt;String&gt; used = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        queue.add(start);        used.add(startBoardStr);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            count++;            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                Node curNode = queue.poll();                String curBoardStr = curNode.boardStr;                System.out.println(curBoardStr);                <span class="hljs-keyword">if</span> (target.equals(curBoardStr)) &#123;                    <span class="hljs-keyword">return</span> count - <span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                    <span class="hljs-keyword">int</span> newX = curNode.zeroX + dir[<span class="hljs-number">0</span>];                    <span class="hljs-keyword">int</span> newY = curNode.zeroY + dir[<span class="hljs-number">1</span>];                    <span class="hljs-comment">// 越界</span>                    <span class="hljs-keyword">if</span> (!inArea(newX, newY, rows, cols)) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-keyword">int</span>[][] newBoard = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][cols];                    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] line : curNode.board) &#123;                        newBoard[i++] = line.clone();                    &#125;                    <span class="hljs-comment">// 交换数字</span>                    newBoard[curNode.zeroX][curNode.zeroY] = newBoard[newX][newY];                    newBoard[newX][newY] = <span class="hljs-number">0</span>;                    String newBoardStr = Arrays.deepToString(newBoard);                    <span class="hljs-comment">// 已被使用</span>                    <span class="hljs-keyword">if</span> (used.contains(newBoardStr)) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-comment">// 加入队列并标记</span>                    queue.add(<span class="hljs-keyword">new</span> Node(newX, newY, newBoard, newBoardStr));                    used.add(newBoardStr);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">int</span> zeroX;    <span class="hljs-keyword">int</span> zeroY;    <span class="hljs-keyword">int</span>[][] board;    String boardStr;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> zeroX, <span class="hljs-keyword">int</span> zeroY, <span class="hljs-keyword">int</span>[][] board, String boardStr)</span> </span>&#123;        <span class="hljs-keyword">this</span>.zeroX = zeroX;        <span class="hljs-keyword">this</span>.zeroY = zeroY;        <span class="hljs-keyword">this</span>.board = board;        <span class="hljs-keyword">this</span>.boardStr = boardStr;    &#125;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>把二维数组映射为字符串，每次移动一个数字就相当于交换字符，省去了很多边界判断。</p><pre><code class="hljs java">String TARGET = <span class="hljs-string">"123450"</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">slidingPuzzle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;&#125;;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] row : board) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : row) &#123;            sb.append(num);        &#125;    &#125;    String start = sb.toString();    <span class="hljs-keyword">if</span> (TARGET.equals(start)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    Set&lt;String&gt; used = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    queue.add(start);    used.add(start);    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        count++;        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            String cur = queue.poll();            <span class="hljs-keyword">if</span> (TARGET.equals(cur)) &#123;                <span class="hljs-keyword">return</span> count - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">char</span>[] arr = cur.toCharArray();            <span class="hljs-comment">// 一定会找到 0，不用特判</span>            <span class="hljs-keyword">int</span> zeroIdx = cur.indexOf(<span class="hljs-string">'0'</span>);            <span class="hljs-keyword">int</span>[] moves = dirs[zeroIdx];            <span class="hljs-comment">// 尝试交换每个位置</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> next : moves) &#123;                <span class="hljs-comment">// 交换 0</span>                arr[zeroIdx] = arr[next];                arr[next] = <span class="hljs-string">'0'</span>;                <span class="hljs-comment">// 若未出现过，则加入队列</span>                String candidate = String.valueOf(arr);                <span class="hljs-keyword">if</span> (!used.contains(candidate)) &#123;                    queue.add(candidate);                    used.add(candidate);                &#125;                <span class="hljs-comment">// 还原</span>                arr[next] = arr[zeroIdx];                arr[zeroIdx] = <span class="hljs-string">'0'</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1091. 二进制矩阵中的最短路径</title>
    <link href="/2020/08/27/LeetCode-1091-shortest-path-in-binary-matrix/"/>
    <url>/2020/08/27/LeetCode-1091-shortest-path-in-binary-matrix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">1091. 二进制矩阵中的最短路径</a></p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><p>需要注意起点和终点都要 <code>== 0</code>，提交了好多次都在判断边界。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = grid.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 一开始就走不通</span>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 只有一个元素</span>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len][len];        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(<span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            count++;            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                Node curNode = queue.poll();                <span class="hljs-comment">// System.out.println(count + ": " + curNode.x + ", " + curNode.y);</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                    <span class="hljs-keyword">int</span> newX = curNode.x + dir[<span class="hljs-number">0</span>];                    <span class="hljs-keyword">int</span> newY = curNode.y + dir[<span class="hljs-number">1</span>];                    <span class="hljs-comment">// System.out.println(newX + ", " + newY + ", len = " + len);</span>                    <span class="hljs-keyword">if</span> (!inArea(newX, newY, len) || visited[newX][newY] || grid[newX][newY] == <span class="hljs-number">1</span>) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-comment">// grid[i][j] == 0 时才有效</span>                    <span class="hljs-keyword">if</span> (newX == (len - <span class="hljs-number">1</span>) &amp;&amp; newY == (len - <span class="hljs-number">1</span>)) &#123;                        <span class="hljs-keyword">return</span> count + <span class="hljs-number">1</span>;                    &#125;                    queue.add(<span class="hljs-keyword">new</span> Node(newX, newY));                    visited[newX][newY] = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; len &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; len;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">int</span> y;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 37. 解数独</title>
    <link href="/2020/08/26/LeetCode-37-sudoku-solver/"/>
    <url>/2020/08/26/LeetCode-37-sudoku-solver/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></p><p>如果采用与 <a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独</a> 类似的解法，使用下面这种方式来判断重复也很有效。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">return</span> rows[row][num] + cols[col][num] + boxes[(row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + col / <span class="hljs-number">3</span>][num] == <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        backtrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, board);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-comment">// 最后一行，结束</span>        <span class="hljs-keyword">if</span> (row == <span class="hljs-number">9</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 到最后一列，进入下一行</span>        <span class="hljs-keyword">if</span> (col == <span class="hljs-number">9</span>) &#123;            <span class="hljs-keyword">return</span> backtrack(row + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, board);        &#125;        <span class="hljs-comment">// 当前位置已经是数字，进入下一个位置</span>        <span class="hljs-keyword">if</span> (board[row][col] != <span class="hljs-string">'.'</span>) &#123;            <span class="hljs-keyword">return</span> backtrack(row, col + <span class="hljs-number">1</span>, board);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;            <span class="hljs-keyword">if</span> (!isValid((<span class="hljs-keyword">char</span>) (i + <span class="hljs-string">'0'</span>), row, col, board)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            board[row][col] = (<span class="hljs-keyword">char</span>) (i + <span class="hljs-string">'0'</span>);            <span class="hljs-comment">// 当前位置可以放置，进入下一个位置</span>            <span class="hljs-comment">// 若返回 true，表示所有位置都已正确放置，结束递归</span>            <span class="hljs-keyword">if</span> (backtrack(row, col + <span class="hljs-number">1</span>, board)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            board[row][col] = <span class="hljs-string">'.'</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            <span class="hljs-comment">// 判断行是否重复</span>            <span class="hljs-keyword">if</span> (board[row][i] == ch) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 判断列是否重复</span>            <span class="hljs-keyword">if</span> (board[i][col] == ch) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 判断九宫格是否重复</span>            <span class="hljs-keyword">int</span> x = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + i / <span class="hljs-number">3</span>;            <span class="hljs-keyword">int</span> y = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + i % <span class="hljs-number">3</span>;            <span class="hljs-keyword">if</span> (board[x][y] == ch) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 36. 有效的数独</title>
    <link href="/2020/08/26/LeetCode-36-valid-sudoku/"/>
    <url>/2020/08/26/LeetCode-36-valid-sudoku/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p><code>board[i][j]</code> 是字符型，判断九宫格重复时不要忘了转为数字。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span>[][] boxes;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 9 个格子，每个格子 9 个数</span>        <span class="hljs-comment">// 一行代表一个格子，若格子中某个位置为 1，表示该位置对应的数已经出现过</span>        boxes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, board);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-comment">// 所有行遍历完成，则结束</span>        <span class="hljs-keyword">if</span> (row == rows) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 对当前行的每一个位置判断</span>        <span class="hljs-keyword">char</span>[] curLine = board[row];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; curLine.length; col++) &#123;            <span class="hljs-keyword">if</span> (board[row][col] == <span class="hljs-string">'.'</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (!isValid(row, col, board)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 进入下一行</span>        <span class="hljs-keyword">return</span> dfs(row + <span class="hljs-number">1</span>, board);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-comment">// 判断列是否重复</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">if</span> (i != row &amp;&amp; board[i][col] == board[row][col]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 判断行是否重复</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (j != col &amp;&amp; board[row][j] == board[row][col]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 判断九宫格是否重复</span>        <span class="hljs-keyword">int</span> boxNum = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + col / <span class="hljs-number">3</span>;        <span class="hljs-keyword">int</span> num = board[row][col] - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">if</span> (boxes[boxNum][num] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 未出现过则设置为 1，用于下一个数字判断</span>        boxes[boxNum][num] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>把行列，九宫格的数字都映射到数组里，加快判断效率。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-comment">// 每行记录 board 的每行数字是否出现</span>    <span class="hljs-comment">// 下标代表对应元素</span>    <span class="hljs-comment">// 1: 出现 0: 未出现</span>    <span class="hljs-keyword">int</span>[][] rows = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];    <span class="hljs-comment">// 每行记录 board 的每列数字是否出现</span>    <span class="hljs-keyword">int</span>[][] cols = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];    <span class="hljs-comment">// 每行记录 board 每个九宫格是否出现</span>    <span class="hljs-keyword">int</span>[][] boxes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'.'</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">int</span> num = board[i][j] - <span class="hljs-string">'0'</span>;            <span class="hljs-keyword">if</span> (rows[i][num] == <span class="hljs-number">1</span> || cols[j][num] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-keyword">int</span> box = (i / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;            <span class="hljs-keyword">if</span> (boxes[box][num] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 标记对应元素</span>            rows[i][num] = <span class="hljs-number">1</span>;            cols[j][num] = <span class="hljs-number">1</span>;            boxes[box][num] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 130. 被围绕的区域</title>
    <link href="/2020/08/25/LeetCode-130-surrounded-regions/"/>
    <url>/2020/08/25/LeetCode-130-surrounded-regions/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><p>先标记边界以及和边界连通的 <code>O</code>，剩下的就是需要填充的格子，最后还原之前标记的格子。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-comment">// 左</span>            <span class="hljs-keyword">if</span> (board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">'O'</span>) &#123;                dfs(i, <span class="hljs-number">0</span>, board);            &#125;            <span class="hljs-comment">// 右</span>            <span class="hljs-keyword">if</span> (board[i][cols - <span class="hljs-number">1</span>] == <span class="hljs-string">'O'</span>) &#123;                dfs(i, cols - <span class="hljs-number">1</span>, board);            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;            <span class="hljs-comment">// 上</span>            <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>][i] == <span class="hljs-string">'O'</span>) &#123;                dfs(<span class="hljs-number">0</span>, i, board);            &#125;            <span class="hljs-comment">// 下</span>            <span class="hljs-keyword">if</span> (board[rows - <span class="hljs-number">1</span>][i] == <span class="hljs-string">'O'</span>) &#123;                dfs(rows - <span class="hljs-number">1</span>, i, board);            &#125;        &#125;        <span class="hljs-comment">// 填充 O 为 X</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'O'</span>) &#123;                    board[i][j] = <span class="hljs-string">'X'</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 还原 O</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'#'</span>) &#123;                    board[i][j] = <span class="hljs-string">'O'</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        board[x][y] = <span class="hljs-string">'#'</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = x + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = y + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (inArea(newX, newY) &amp;&amp; board[newX][newY] == <span class="hljs-string">'O'</span>) &#123;                dfs(newX, newY, board);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;&#125;</code></pre><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><ul><li>将边界的 <code>O</code> 与 <code>dummy</code> 连接</li><li>将内部的 <code>O</code> 互相连接，剩下的未与 <code>dummy</code> 连接的 <code>O</code> 即为需要填充的部分</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span> dummy;    UnionFind uf;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 所有未被围绕的 O 都与 dummy 连接</span>        dummy = rows * cols;        uf = <span class="hljs-keyword">new</span> UnionFind(dummy + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 连接左右边界</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-comment">// 左</span>            <span class="hljs-keyword">if</span> (board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">'O'</span>) &#123;                uf.union(dummy, getIndex(i, <span class="hljs-number">0</span>));            &#125;            <span class="hljs-comment">// 右</span>            <span class="hljs-keyword">if</span> (board[i][cols - <span class="hljs-number">1</span>] == <span class="hljs-string">'O'</span>) &#123;                uf.union(dummy, getIndex(i, cols - <span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-comment">// 连接上下边界</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;            <span class="hljs-comment">// 上</span>            <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>][i] == <span class="hljs-string">'O'</span>) &#123;                uf.union(dummy, getIndex(<span class="hljs-number">0</span>, i));            &#125;            <span class="hljs-comment">// 下</span>            <span class="hljs-keyword">if</span> (board[rows - <span class="hljs-number">1</span>][i] == <span class="hljs-string">'O'</span>) &#123;                uf.union(dummy, getIndex(rows - <span class="hljs-number">1</span>, i));            &#125;        &#125;        <span class="hljs-comment">// 遍历中间的 O，并将它们互相连接</span>        <span class="hljs-comment">// 则未与 dummy 连接的 O 即为需要填充的</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; cols - <span class="hljs-number">1</span>; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'O'</span>) &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                        <span class="hljs-keyword">int</span> newX = i + dir[<span class="hljs-number">0</span>];                        <span class="hljs-keyword">int</span> newY = j + dir[<span class="hljs-number">1</span>];                        <span class="hljs-keyword">if</span> (board[newX][newY] == <span class="hljs-string">'O'</span>) &#123;                            uf.union(getIndex(i, j), getIndex(newX, newY));                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 未与 dummy 连接的 O 填充为 X</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (!uf.connected(dummy, i * cols + j)) &#123;                    board[i][j] = <span class="hljs-string">'O'</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x * cols + y;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 547. 朋友圈</title>
    <link href="/2020/08/25/LeetCode-547-friend-circles/"/>
    <url>/2020/08/25/LeetCode-547-friend-circles/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">547. 朋友圈</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-keyword">boolean</span>[] visited;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] M)</span> </span>&#123;    n = M.length;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];    <span class="hljs-comment">// i 表示第 i 个人</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">if</span> (!visited[i]) &#123;            count++;            dfs(i, M);        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>[][] m)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;        <span class="hljs-comment">// i 和 j 为朋友，则从 j 开始递归查找</span>        <span class="hljs-comment">// 直到 j 的朋友为空</span>        <span class="hljs-keyword">if</span> (m[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j]) &#123;            visited[j] = <span class="hljs-keyword">true</span>;            dfs(j, m);        &#125;    &#125;&#125;</code></pre><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><p>并查集的连通分量数就是朋友圈的数量。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] M)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = M.length;    UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; M[<span class="hljs-number">0</span>].length; j++) &#123;            <span class="hljs-keyword">if</span> (M[i][j] == <span class="hljs-number">1</span>) &#123;                uf.union(i, j);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> uf.getCount();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2020/08/25/data-structure-union-find/"/>
    <url>/2020/08/25/data-structure-union-find/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 连通分量个数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 并查集对应的树</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每棵树的子结点数量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">this</span>.count = n;        <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.count];        <span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.count];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.count; i++) &#123;            <span class="hljs-comment">// 初始根节点为自己</span>            parent[i] = i;            <span class="hljs-comment">// 初始子结点只有自己</span>            size[i] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取连通分量个数</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 连接 p, q 结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> q</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;        <span class="hljs-keyword">int</span> rootP = findRoot(p);        <span class="hljs-keyword">int</span> rootQ = findRoot(q);        <span class="hljs-comment">// p, q 已经连接</span>        <span class="hljs-keyword">if</span> (rootP == rootQ) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 把 小树 挂到 大树 下，使得整棵树更平衡</span>        <span class="hljs-keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;            parent[rootQ] = rootP;            size[rootP] += size[rootQ];        &#125; <span class="hljs-keyword">else</span> &#123;            parent[rootP] = rootQ;            size[rootQ] += size[rootP];        &#125;        <span class="hljs-keyword">this</span>.count--;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断 p, q 结点是否属于同一个集合</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> q</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;        <span class="hljs-keyword">int</span> rootP = findRoot(p);        <span class="hljs-keyword">int</span> rootQ = findRoot(q);        <span class="hljs-comment">// 若根结点相同 则属于同一个集合</span>        <span class="hljs-keyword">return</span> rootP == rootQ;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 找到 x 的根节点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRoot</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-comment">// parent[x] == x 表示 到达根结点</span>        <span class="hljs-keyword">while</span> (parent[x] != x) &#123;            <span class="hljs-comment">// 路径压缩，把 x 挂到 x 的 爷爷上</span>            <span class="hljs-comment">// 压缩树的高度</span>            parent[x] = parent[parent[x]];            x = parent[x];        &#125;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 212. 单词搜索 II</title>
    <link href="/2020/08/24/LeetCode-212-word-search-ii/"/>
    <url>/2020/08/24/LeetCode-212-word-search-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">212. 单词搜索 II</a><br />坑：查找前缀时，若找到 <code>word</code>，不能 <code>return</code>，否则递归结束会导致与 <code>word</code> 同前缀的单词丢失，如 <code>aaba</code> 和 <code>aaab</code>，只能找到 <code>aaba</code>。</p><p>还是对前缀树理解不够，找了好久才发现。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">boolean</span>[][] used;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findWords</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String[] words)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span> || words.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];        Trie trie = <span class="hljs-keyword">new</span> Trie();        <span class="hljs-keyword">for</span> (String word : words) &#123;            trie.insert(word);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                backtrack(i, j, board, trie.root);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">char</span>[][] board, TrieNode node)</span> </span>&#123;        node = node.links[board[i][j] - <span class="hljs-string">'a'</span>];        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (node.word != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (!res.contains(node.word)) &#123;                res.add(node.word);                <span class="hljs-comment">// 一定不能 return，否则会丢失前缀</span>                <span class="hljs-comment">// return;</span>            &#125;        &#125;        used[i][j] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = i + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = j + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (inArea(newX, newY) &amp;&amp; !used[newX][newY]) &#123;                backtrack(newX, newY, board, node);            &#125;        &#125;        used[i][j] = <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;    TrieNode[] links;    String word;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> R = <span class="hljs-number">26</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.links = <span class="hljs-keyword">new</span> TrieNode[R];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>] != <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TrieNode <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key, TrieNode node)</span> </span>&#123;        <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>] = node;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;    TrieNode root;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;        root = <span class="hljs-keyword">new</span> TrieNode();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;        TrieNode node = root;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">char</span> key = word.charAt(i);            <span class="hljs-keyword">if</span> (!node.containsKey(key)) &#123;                node.put(key, <span class="hljs-keyword">new</span> TrieNode());            &#125;            node = node.get(key);        &#125;        node.word = word;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 79. 单词搜索</title>
    <link href="/2020/08/24/LeetCode-79-word-search/"/>
    <url>/2020/08/24/LeetCode-79-word-search/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></p><p>还是类似岛屿数量的回溯思想，整体不难，注意细节。<br />一开始方向的坐标写重复了一个，还忘了状态重置，一直无法通过，调了很久才发现。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span> || word.length() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">boolean</span>[][] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-comment">// 假设 (i, j) 都是起点进行搜索</span>                <span class="hljs-keyword">if</span> (backtrack(i, j, <span class="hljs-number">0</span>, used, board, word)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">boolean</span>[][] used, <span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;        <span class="hljs-comment">// 可避免只有一个元素的情况</span>        <span class="hljs-keyword">if</span> (pos == word.length() - <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> board[x][y] == word.charAt(pos);        &#125;        <span class="hljs-comment">// 当前位置匹配时，获取下一个位置</span>        <span class="hljs-keyword">if</span> (board[x][y] == word.charAt(pos)) &#123;            used[x][y] = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                <span class="hljs-keyword">int</span> newX = x + dir[<span class="hljs-number">0</span>];                <span class="hljs-keyword">int</span> newY = y + dir[<span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span> (inArea(newX, newY) &amp;&amp; !used[newX][newY]) &#123;                    <span class="hljs-keyword">if</span> (backtrack(newX, newY, pos + <span class="hljs-number">1</span>, used, board, word)) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                    &#125;                &#125;            &#125;            <span class="hljs-comment">// !!! 状态还原</span>            used[x][y] = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 208. 实现 Trie (前缀树)</title>
    <link href="/2020/08/24/LeetCode-208-implement-trie-prefix-tree/"/>
    <url>/2020/08/24/LeetCode-208-implement-trie-prefix-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></p><p>字典树 结点定义：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 字典树 结点</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每个结点相当于一个数组</span><span class="hljs-comment">     * 若数组的某个位置不为空，则指向下一个结点</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> TrieNode[] links;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 数组的长度</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> R = <span class="hljs-number">26</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 是否到达叶子结点</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnd;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.links = <span class="hljs-keyword">new</span> TrieNode[R];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断 key 位置上是否为空</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 用于计算 key 所在位置</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>] != <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取 key 位置上的下一个结点</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TrieNode <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 设置 key 位置上的下一个结点为 node</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key, TrieNode node)</span> </span>&#123;        <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>] = node;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断是否到达叶子结点</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isEnd;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 设置叶子结点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.isEnd = <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><p>字典树：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;    <span class="hljs-keyword">private</span> TrieNode root;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;        root = <span class="hljs-keyword">new</span> TrieNode();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Inserts a word into the trie.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;        TrieNode node = root;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">char</span> key = word.charAt(i);            <span class="hljs-keyword">if</span> (!node.containsKey(key)) &#123;                node.put(key, <span class="hljs-keyword">new</span> TrieNode());            &#125;            node = node.get(key);        &#125;        node.setEnd();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> TrieNode <span class="hljs-title">searchPrefix</span><span class="hljs-params">(String word)</span> </span>&#123;        TrieNode node = root;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">char</span> key = word.charAt(i);            <span class="hljs-keyword">if</span> (!node.containsKey(key)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            node = node.get(key);        &#125;        <span class="hljs-keyword">return</span> node;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns if the word is in the trie.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;        TrieNode node = searchPrefix(word);        <span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span> &amp;&amp; node.isEnd();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns if there is any word in the trie that starts with the given prefix.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 309. 最佳买卖股票时机含冷冻期</title>
    <link href="/2020/08/23/LeetCode-309-best-time-to-buy-and-sell-stock-with-cooldown/"/>
    <url>/2020/08/23/LeetCode-309-best-time-to-buy-and-sell-stock-with-cooldown/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">    0 rest</span><span class="hljs-comment">    1 买入</span><span class="hljs-comment">    2 卖出</span><span class="hljs-comment">    3 卖出后的冷冻期</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">4</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = Integer.MIN_VALUE;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] - prices[i]));        dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);    &#125;    <span class="hljs-keyword">return</span> Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]));&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 714. 买卖股票的最佳时机含手续费</title>
    <link href="/2020/08/22/LeetCode-309-best-time-to-buy-and-sell-stock-with-transaction-fee/"/>
    <url>/2020/08/22/LeetCode-309-best-time-to-buy-and-sell-stock-with-transaction-fee/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></p><p>此题加了手续费，但解法还是和第二题类似。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -(prices[<span class="hljs-number">0</span>] + fee);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i] - fee);    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre><p>可进行状态压缩</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = prices.length;        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> dp0 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> dp1 = -(prices[<span class="hljs-number">0</span>] + fee);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            <span class="hljs-comment">// 保存前一天持有现金时的最大收益</span>            <span class="hljs-keyword">int</span> pre = dp0;            dp0 = Math.max(dp0, dp1 + prices[i]);            dp1 = Math.max(dp1, pre - prices[i] - fee);        &#125;        <span class="hljs-keyword">return</span> dp0;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 188.  买卖股票的最佳时机 IV</title>
    <link href="/2020/08/22/LeetCode-188-best-time-to-buy-and-sell-stock-iv/"/>
    <url>/2020/08/22/LeetCode-188-best-time-to-buy-and-sell-stock-iv/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></p><blockquote><p>一次交易至少需要 2 天，一天买，一天卖。因此如果 <code>k</code> 很大，大到大于等于 <code>len / 2</code>，就相当于股票系列的第 2 题，使用贪心算法去做就可以了。这是一个特判。</p></blockquote><p>可进行状态压缩，省去第一维空间。加上无限交易次数的贪心版本，可加快速度。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 若 交易次数 &gt; 天数 / 2，则无法达成有效的交易，此时等价于无限次交易次数</span>    <span class="hljs-keyword">if</span> (k &gt; len / <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> maxProfit(prices);    &#125;    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];    <span class="hljs-comment">// 初始化第一次状态</span>    <span class="hljs-comment">// 1 次买入</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; k + <span class="hljs-number">1</span>; i++) &#123;        dp[<span class="hljs-number">0</span>][i][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = k; j &gt; <span class="hljs-number">0</span>; j--) &#123;            dp[i][j][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + prices[i]);            dp[i][j][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 123. 买卖股票的最佳时机 III</title>
    <link href="/2020/08/22/LeetCode-123-best-time-to-buy-and-sell-stock-iii/"/>
    <url>/2020/08/22/LeetCode-123-best-time-to-buy-and-sell-stock-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];    <span class="hljs-comment">// 初始化第一天状态，只需要考虑持有股票的情况</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 1 次交易买入</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 2 次交易买入</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 第一次交易</span>        dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        <span class="hljs-comment">// 可能买入 dp[i - 1][0][0] - prices[i]</span>        dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - prices[i]);        <span class="hljs-comment">// 第二次交易</span>        dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] + prices[i]);        <span class="hljs-comment">// 可能买入 dp[i - 1][1][0] - prices[i]</span>        dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>];&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">    dp[i][0] 没有交易 rest</span><span class="hljs-comment">    dp[i][1] 第一次买入</span><span class="hljs-comment">    dp[i][2] 第一次卖出</span><span class="hljs-comment">    dp[i][3] 第二次买入</span><span class="hljs-comment">    dp[i][4] 第二次卖出</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">5</span>];    <span class="hljs-comment">// 第一次买入</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 第二次买入卖出都还没发生</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = Integer.MIN_VALUE;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>] = Integer.MIN_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);        dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);        dp[i][<span class="hljs-number">4</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);    &#125;    <span class="hljs-comment">// 没有交易 第一次卖出 第二次卖出 中可能存在最大值</span>    <span class="hljs-keyword">return</span> Math.max(Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]), dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>]);&#125;</code></pre><p>可进行状态压缩，省去第一维空间。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 121. 买卖股票的最佳时机</title>
    <link href="/2020/08/22/LeetCode-121-best-time-to-buy-and-sell-stock/"/>
    <url>/2020/08/22/LeetCode-121-best-time-to-buy-and-sell-stock/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>状态：<br /><code>dp[i][j][s]</code>: 第 <code>i</code> 天最多进行了 <code>j</code> 次交易后，持有股票状态为 <code>s</code> 的最大利润。</p><ul><li><code>i</code>: 第 <code>i</code> 天</li><li><code>j</code>: 到今天进行的最大交易次数</li><li><code>s</code>: 今天是否持有股票</li></ul><p>状态转移方程：</p><ul><li><code>dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])</code><ul><li>昨天就没有持有，然后今天选择 <code>rest</code>，所以我今天还是没有持有；</li><li>昨天持有股票，但是今天我 <code>sell</code> 了，所以我今天没有持有股票了。</li></ul></li><li><code>dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])</code><ul><li>昨天就持有着股票，然后今天选择 <code>rest</code>，所以我今天还持有着股票；</li><li>昨天本没有持有，但今天我选择 <code>buy</code>，所以今天我就持有股票了。</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span>;    <span class="hljs-comment">// dp[i][j][1]: 第 i 天，持有股票，至今已经进行了 j 次交易</span>    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][k][<span class="hljs-number">2</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; k; j++) &#123;            dp[i][j][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + prices[i]);            dp[i][j][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][k - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>状态：</p><ul><li><code>dp[i][0]</code> - 持有现金 表示第 <code>i</code> 天<strong>卖出股票后的最大利润</strong></li><li><code>dp[i][1]</code> - 持有股票 表示第 <code>i</code> 天持有股票的最大利润</li></ul><p>状态转移方程：</p><ul><li><code>dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</code><ul><li>昨天持有现金，今天 <code>rest</code>，今天仍持有现金</li><li>昨天持有股票，今天 <code>sell</code>，今天变为持有现金</li></ul></li><li><code>dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);</code><ul><li>昨天持有股票，今天 <code>rest</code>，今天仍持有股票</li><li>昨天持有现金，今天 <code>buy</code>，今天变为持有股票，由于只能进行一次交易，只能买入一次股票，不能加上昨天卖出股票后的最大利润</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = prices.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// dp[i][0] - 持有现金 表示第 i 天卖出股票后的最大利润</span>        <span class="hljs-comment">// dp[i][1] - 持有股票 表示第 i 天买入股票的最大利润</span>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);            <span class="hljs-comment">// 只能进行一次交易，意味着只能卖出一次股票，dp[i][1] 不可以从 dp[i][0] 转移而来</span>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);        &#125;        <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    &#125;</code></pre><h1 id="解法三"><a class="markdownIt-Anchor" href="#解法三"></a> 解法三</h1><p>使用差分数组，求数组的最大子序和就是最大盈利。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = prices.length;        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len - <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            diff[i - <span class="hljs-number">1</span>] = prices[i] - prices[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len - <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>] + diff[i], diff[i]);        &#125;                <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;            max = Math.max(max, dp[i]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 337. 打家劫舍 III</title>
    <link href="/2020/08/21/LeetCode-337-house-robber-iii/"/>
    <url>/2020/08/21/LeetCode-337-house-robber-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></p><h1 id="解法一记忆化递归"><a class="markdownIt-Anchor" href="#解法一记忆化递归"></a> 解法一：记忆化递归</h1><pre><code class="hljs java">Map&lt;TreeNode, Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> (memo.containsKey(root)) &#123;            <span class="hljs-keyword">return</span> memo.get(root);        &#125;        <span class="hljs-comment">// 打劫根结点</span>        <span class="hljs-keyword">int</span> doRob = root.val;        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;            doRob += rob(root.left.left) + rob(root.left.right);        &#125;        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;            doRob += rob(root.right.left) + rob(root.right.right);        &#125;        <span class="hljs-comment">// 不打劫根结点</span>        <span class="hljs-keyword">int</span> notRob = rob(root.left) + rob(root.right);        <span class="hljs-keyword">int</span> res = Math.max(doRob, notRob);        memo.put(root, res);        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>状态：</p><ul><li><code>dp[root][0]</code> - 不打劫 <code>root</code> 结点</li><li><code>dp[root][1]</code> - 打劫 <code>root</code> 结点</li></ul><p>转移方程：</p><ul><li><code>dp[root][0]</code>：左右子结点可选择偷或不偷，取他们的最大值</li><li><code>dp[root][1]</code>：左右子结点不偷</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] res = robber(root);    <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] robber(TreeNode root) &#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;    &#125;    <span class="hljs-comment">// 后序遍历，自底向上，先计算左右结点，再计算 root</span>    <span class="hljs-keyword">int</span>[] left = robber(root.left);    <span class="hljs-keyword">int</span>[] right = robber(root.right);    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];    <span class="hljs-comment">// 打劫 root</span>    dp[<span class="hljs-number">1</span>] = root.val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 不打劫 root</span>    dp[<span class="hljs-number">0</span>] = Math.max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + Math.max(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">return</span> dp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 213. 打家劫舍 II</title>
    <link href="/2020/08/21/LeetCode-213-house-robber-ii/"/>
    <url>/2020/08/21/LeetCode-213-house-robber-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></p><p>题目说明：首尾不能同时 rob，那么可以去除第一个元素或去除最后一个元素进行 rob，还是使用 <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a> 的解法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">return</span> Math.max(robRange(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">2</span>), robRange(nums, <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">robRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">int</span> i_2 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> i_1 = nums[start];    <span class="hljs-keyword">int</span> cur = nums[start];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>; i &lt;= end; i++) &#123;        cur = Math.max(i_1, i_2 + nums[i]);        i_2 = i_1;        i_1 = cur;    &#125;    <span class="hljs-keyword">return</span> cur;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 198. 打家劫舍</title>
    <link href="/2020/08/21/LeetCode-198-house-robber/"/>
    <url>/2020/08/21/LeetCode-198-house-robber/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></p><p>状态：<code>dp[i]</code> 第 <code>i</code> 个数结尾的最大子序列和<br />转移：</p><ul><li>不偷 <code>nums[i]</code>, <code>dp[i] = dp[i - 1]</code></li><li>偷 <code>nums[i - 2]</code>, <code>dp[i] = dp[i - 2] + nums[i - 1]</code></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= len; i++) &#123;        dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">return</span> dp[len];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 152. 乘积最大子数组</title>
    <link href="/2020/08/21/LeetCode-152-maximum-product-subarray/"/>
    <url>/2020/08/21/LeetCode-152-maximum-product-subarray/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></p><p>状态：</p><ul><li><code>dp[i][0]</code>: 以 <code>nums[i]</code> 结尾的子数组最小值</li><li><code>dp[i][1]</code>: 以 <code>nums[i]</code> 结尾的子数组最大值</li></ul><p>状态转移：</p><ul><li><code>nums[i] &gt; 0</code><ul><li><code>最大值 * nums[i]</code> 还是最大值</li><li><code>最小值 * nums[i]</code> 还是最小值</li></ul></li><li><code>nums[i] &gt; 0</code><ul><li><code>最大值 * nums[i]</code> = 最小值</li><li><code>最小值 * nums[i]</code> = 最大值</li></ul></li></ul><p>和 <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a> 类似，只要计算当前数字 <code>nums[i]</code> 对 <code>min</code> 或 <code>max</code> 的增益，若有利于他们的最值，则进行更新，否则从 <code>nums[i]</code> 开始重新计算最值。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">/*</span><span class="hljs-comment">         nums[i] &gt; 0:</span><span class="hljs-comment">            max * nums[i] -&gt; max</span><span class="hljs-comment">                dp[i - 1][1] &gt; 0, max = nums[i] * dp[i - 1][1] else nums[i]</span><span class="hljs-comment">            min * nums[i] -&gt; min</span><span class="hljs-comment">                dp[i - 1][0] &lt; 0, min = nums[i] * dp[i - 1][0] else nums[i]</span><span class="hljs-comment"></span><span class="hljs-comment">         num[i] &lt; 0:</span><span class="hljs-comment">            max * nums[i] -&gt; min</span><span class="hljs-comment">                dp[i - 1][1] &gt; 0, min = nums[i] * dp[i - 1][1] else nums[i]</span><span class="hljs-comment">            min * nums[i] -&gt; max</span><span class="hljs-comment">                dp[i - 1][0] &lt; 0, max = nums[i] * dp[i - 1][0] else nums[i]</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> max = dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;                dp[i][<span class="hljs-number">0</span>] = Math.min(nums[i], nums[i] * dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);                dp[i][<span class="hljs-number">1</span>] = Math.max(nums[i], nums[i] * dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);            &#125; <span class="hljs-keyword">else</span> &#123;                dp[i][<span class="hljs-number">0</span>] = Math.min(nums[i], nums[i] * dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);                dp[i][<span class="hljs-number">1</span>] = Math.max(nums[i], nums[i] * dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);            &#125;            max = Math.max(max, dp[i][<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre><p>空间优化：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> imax = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> imin = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> max = imax;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 交换 imax 和 imin，省去后面的二次判断</span>        <span class="hljs-comment">// 否则会出现 imax 和 imin 互相依赖的情况</span>        <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> t = imin;            imin = imax;            imax = t;        &#125;        imin = Math.min(nums[i], nums[i] * imin);        imax = Math.max(nums[i], nums[i] * imax);        max = Math.max(max, imax);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 53. 最大子序和</title>
    <link href="/2020/08/20/LeetCode-53-maximum-subarray/"/>
    <url>/2020/08/20/LeetCode-53-maximum-subarray/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p><p>状态转移：如果前一个子序列和 <code>nums[i - 1]</code> 无法为 <code>nums[i]</code> 带来正增益，则 <code>nums[i]</code> 为 <code>dp[i]</code> 的最大值。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 状态：dp[i] 以 nums[i] 结尾的子数组最大和</span><span class="hljs-comment"> * 转移方程：</span><span class="hljs-comment"> * dp[i] = 前一个子序列 + nums[i] if 前一个子序列 + nums[i] &gt; nums[i] else nums[i]</span><span class="hljs-comment"> * dp[i] = nums[i] 表示重新开始计算新的子序列和</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;        dp[i] = Math.max(nums[i], dp[i - <span class="hljs-number">1</span>] + nums[i]);        max = Math.max(dp[i], max);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><p>空间优化：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> dp = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> max = dp;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            dp = Math.max(nums[i], dp + nums[i]);            max = Math.max(dp, max);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 120. 三角形最小路径和</title>
    <link href="/2020/08/20/LeetCode-120-triangle/"/>
    <url>/2020/08/20/LeetCode-120-triangle/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></p><p>最开始用回溯，最后一个测试用例未通过，原因是输出太长了。<br />然后用动态规划：<br />状态转移方程：<br /><code>dp[i][j] = triangle[i][j] + min(dp[i + 1][j], dp[i + 1][j + 1])</code></p><h1 id="自顶向下"><a class="markdownIt-Anchor" href="#自顶向下"></a> 自顶向下</h1><p>判断很多，最后还要排序，虽然也过了，后来题解发现可以采用自底向上可以方便很多。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;    <span class="hljs-keyword">int</span> size = triangle.size();    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size][size];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] line : dp) &#123;        Arrays.fill(line, Integer.MAX_VALUE);    &#125;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) &#123;        List&lt;Integer&gt; curRow = triangle.get(i);        <span class="hljs-comment">// 每行的第一个位置</span>        dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + curRow.get(<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; curRow.size(); j++) &#123;            dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + curRow.get(j);        &#125;    &#125;    <span class="hljs-comment">// 求最后一行的最小值</span>    Arrays.sort(dp[size - <span class="hljs-number">1</span>]);    <span class="hljs-keyword">return</span> dp[size - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre><h1 id="自底向上"><a class="markdownIt-Anchor" href="#自底向上"></a> 自底向上</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = triangle.size();    <span class="hljs-comment">// 多分配一行，不用判断边界</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// 每行元素的个数就是该行 行号</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;            <span class="hljs-comment">// 因为上面的行数总是 &lt; 下面的行数，不用担心越界</span>            dp[i][j] = triangle.get(i).get(j) + Math.min(dp[i + <span class="hljs-number">1</span>][j], dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];&#125;</code></pre><p>空间优化：<br />计算 <code>dp[i][j]dp[i][j]</code> 时，只用到了下一行的 <code>dp[i + 1][j]dp[i+1][j]</code> 和 <code>dp[i + 1][j + 1]dp[i+1][j+1]</code>，因此只用一行就可以了。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = triangle.size();    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;            dp[j] = triangle.get(i).get(j) + Math.min(dp[j], dp[j + <span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1143. 最长公共子序列</title>
    <link href="/2020/08/20/LeetCode-1143-longest-common-subsequence/"/>
    <url>/2020/08/20/LeetCode-1143-longest-common-subsequence/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200820153633.png" srcset="/img/loading.gif" alt="" /></p><p>base: 两个字符串中有一个为空，则 <code>dp[0][j] = 0</code> 或 <code>dp[i][0] = 0</code><br />状态：<code>dp[i][j]</code> -&gt; <code>str1[:i]</code> 和 <code>str[:j]</code> 的最长序列<br />转移：</p><ul><li>比较位置：<code>str[:i], str[:j]</code> || <code>str1[:i-1]</code>, <code>str2[:j]</code> || <code>str1[:i]</code>, <code>str2[:j-1]</code></li><li>若 <code>i</code>, <code>j</code> 位置相等，直接 + 1</li><li>若不等：取 <code>str1[:i-1]</code>, <code>str2[:j]</code> 和 <code>str1[:i]</code>, <code>str2[:j-1]</code> 中的最大值</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;        <span class="hljs-keyword">int</span> len1 = text1.length();        <span class="hljs-keyword">int</span> len2 = text2.length();        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[len1][len2];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 322. 零钱兑换</title>
    <link href="/2020/08/19/LeetCode-322-coin-change/"/>
    <url>/2020/08/19/LeetCode-322-coin-change/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] mem = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];    <span class="hljs-keyword">return</span> dp(amount, coins, mem);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span>[] mem)</span> </span>&#123;    <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 若命中缓存，直接返回</span>    <span class="hljs-keyword">if</span> (mem[amount] != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> mem[amount];    &#125;    <span class="hljs-keyword">int</span> count = Integer.MAX_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;        <span class="hljs-comment">// 计算减去 coin 后最小的硬币数量</span>        <span class="hljs-keyword">int</span> prev = amount - coin;        <span class="hljs-keyword">int</span> prevCount = dp(prev, coins, mem);        <span class="hljs-comment">// 若能找到 prev 的最小数目，计算本次 count 的最小值</span>        <span class="hljs-keyword">if</span> (prevCount != -<span class="hljs-number">1</span>) &#123;            count = Math.min(prevCount + <span class="hljs-number">1</span>, count);        &#125;    &#125;    <span class="hljs-comment">// 更新缓存</span>    mem[amount] = count == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : count;    <span class="hljs-keyword">return</span> mem[amount];&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;    <span class="hljs-comment">// 1, 2, 5 =&gt; 11</span>    <span class="hljs-comment">// 10: dp[10] + 1</span>    <span class="hljs-comment">// 9: dp[9] + 1</span>    <span class="hljs-comment">// 6: dp[6] + 1</span>    <span class="hljs-comment">// base: 0, 1, 1</span>    <span class="hljs-comment">// 状态: dp[i] 表示第 i 个值需要的最小硬币数</span>    <span class="hljs-comment">// 选择：每一种硬币</span>    <span class="hljs-comment">// dp[i] = min(dp[i - coin])</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];    Arrays.fill(dp, Integer.MAX_VALUE);    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; amount; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;            <span class="hljs-comment">// 前一个值有效 &amp;&amp; 前一个值能够取得最小硬币数</span>            <span class="hljs-keyword">if</span> (i - coin &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i - coin] != Integer.MAX_VALUE) &#123;                dp[i] = Math.min(dp[i - coin] + <span class="hljs-number">1</span>, dp[i]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : dp[amount];&#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;    ArrayDeque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[amount + <span class="hljs-number">1</span>];    queue.add(amount);    visited[amount] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        count++;        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> cur = queue.poll();            <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> count - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">// 依次变换零钱</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;                <span class="hljs-keyword">int</span> diff = cur - coin;                <span class="hljs-keyword">if</span> (diff &gt;= <span class="hljs-number">0</span> &amp;&amp; !visited[diff]) &#123;                    queue.add(diff);                    visited[diff] = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 复制</title>
    <link href="/2020/08/19/MySQL-replication/"/>
    <url>/2020/08/19/MySQL-replication/</url>
    
    <content type="html"><![CDATA[<h1 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h1><ol><li>主服务器把数据更改记录到二进制日志中。</li><li>从服务器把主服务器的二进制日志复制到自己的中继日志中。</li><li>从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。</li></ol><p>需要注意的是：复制不是完全实时地进行同步，而是<strong>异步实时</strong>。这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819125023.png" srcset="/img/loading.gif" alt="" /></p><h1 id="快照-复制的备份架构"><a class="markdownIt-Anchor" href="#快照-复制的备份架构"></a> 快照 + 复制的备份架构</h1><p>复制的主要功能：</p><ul><li><strong>数据分布</strong><br />可以在不同的数据中心实现数据的复制。</li><li><strong>读取的负载平衡</strong><br />通过建立多个从服务器，可将读取平均地分布到这些从服务器中，并且减少了主服务器的压力</li><li><strong>数据库备份</strong><br />复制对备份很有帮助，但是从服务器不是备份，不能完全代替备份。</li><li><strong>高可用性和故障转移</strong><br />从服务器有助于故障转移，减少故障的停机时间和恢复时间</li></ul><p>通过对从服务器上的数据库所在分区做快照，可避免误操作对复制造成影响。当发生主服务器上的误操作时，只需要将从服务器上的快照进行恢复，然后再根据二进制日志进行 <code>point-in-time</code> 的恢复。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819131452.png" srcset="/img/loading.gif" alt="" /></p><h1 id="复制的原理"><a class="markdownIt-Anchor" href="#复制的原理"></a> 复制的原理</h1><p>默认情况下使用基于语句的复制模式，如果发现语句无法被正确地复制，就切换到基于行的复制模式。</p><h2 id="基于语句的复制"><a class="markdownIt-Anchor" href="#基于语句的复制"></a> 基于语句的复制</h2><p>在基于语句的复制模式下，主库会记录那些造成数据更改的查询，当备库读取并重放这些事件时，实际上只是把主库上执行的 <code>SQL</code> 语句再执行一遍。</p><p><code>mysqlbinlog</code> 工具是使用基于语句的日志的最佳工具。</p><p>好处：</p><ol><li>实现简单。只要记录和执行 <code>SQL</code> 语句。</li><li>二进制日志里的事件更加紧凑，不会使用太多带宽。</li></ol><p>缺点：</p><ol><li>使用存储过程和触发器的语句复制时可能存在问题（时间戳、用户）。</li><li>更新必须是串行的，需要更多的锁。</li></ol><h2 id="基于行的复制"><a class="markdownIt-Anchor" href="#基于行的复制"></a> 基于行的复制</h2><p>基于行的复制会将实际数据记录在二进制日志中。</p><p>好处：</p><ol><li>几乎没有基于行的复制模式无法处理的场景。</li><li>可能减少锁的使用。</li><li>会记录数据变更。</li></ol><p>缺点：</p><ol><li>由于语句并没有在日志里记录，无法判断执行了哪些 <code>SQL</code>。</li><li>使用一种完全不同的方式在备库进行数据变更，无法知道服务器在做什么。</li></ol><h1 id="复制拓扑"><a class="markdownIt-Anchor" href="#复制拓扑"></a> 复制拓扑</h1><p>基本原则：</p><ol><li>一个 <code>MySQL</code> 备库实例只能有一个主库。</li><li>一个主库可以有多个备库。</li><li>每个备库必须有一个唯一的服务器 <code>ID</code>。</li><li>如果打开了 <code>log_slave_updates</code> 选项，一个备库可以把其主库上的数据变化传播到其他备库。</li></ol><h2 id="一主库多备库"><a class="markdownIt-Anchor" href="#一主库多备库"></a> 一主库多备库</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819135637.png" srcset="/img/loading.gif" alt="" /></p><p>用途：</p><ol><li>为不同的角色使用不同的备库。</li><li>把一台备库当作待用的主库，除了复制没有其他数据传输。</li><li>将一台备库放到远程数据中心，用作灾难恢复。</li><li>将一台备库作为备份、培训、开发、测试服务器。</li></ol><h2 id="主动-主动模式下的主-主复制"><a class="markdownIt-Anchor" href="#主动-主动模式下的主-主复制"></a> 主动-主动模式下的主-主复制</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819135956.png" srcset="/img/loading.gif" alt="" /></p><ul><li>主-主复制包含两台服务器，每一个都被配置成对方的主库和备库，它们是一对主库。</li><li>该模式的使用场景是两个处于不同地理位置的办公室，并且都需要一份可写的数据拷贝。</li></ul><h2 id="主动-被动模式下的主-主复制"><a class="markdownIt-Anchor" href="#主动-被动模式下的主-主复制"></a> 主动-被动模式下的主-主复制</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819140316.png" srcset="/img/loading.gif" alt="" /></p><ul><li>这是主-主结构的变体，主要区别在于其中的一台服务器是只读的被动服务器。</li><li>这种方式使得反复切换主动和被动服务器非常方便，因为服务器是对称的。</li><li>该结构类似于创建一个热备份，用来提高性能。</li></ul><h2 id="拥有备库的主-主结构"><a class="markdownIt-Anchor" href="#拥有备库的主-主结构"></a> 拥有备库的主-主结构</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819140659.png" srcset="/img/loading.gif" alt="" /></p><p>为每个主库增加一个备库，增加了冗余，对于不同地理位置的复制拓扑，能够消除单点失效的问题。当主库失效时，用备库来代替主库是可行的。</p><h2 id="环形复制"><a class="markdownIt-Anchor" href="#环形复制"></a> 环形复制</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819141026.png" srcset="/img/loading.gif" alt="" /></p><ul><li><p>环形结构可以拥有三个或更多的主库。每个服务器都是在它之前的服务器的备库，是在它之后服务器的主库。</p></li><li><p>环形结构完全依赖于环上的每一个结点，这大大增加了系统失效的几率。如果从环中移除一个节点，这个节点发起的事件就会陷入无限循环：它们将永远绕着服务器链循环。</p></li></ul><h2 id="主库-分发主库以及备库"><a class="markdownIt-Anchor" href="#主库-分发主库以及备库"></a> 主库、分发主库以及备库</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819141525.png" srcset="/img/loading.gif" alt="" /></p><p>分发主库事实上也是一个备库，它的唯一目的就是提取和提供主库的二进制日志。多个备库连接到分发主库，这使原来的主库摆脱了负担。</p><h2 id="树或金字塔形"><a class="markdownIt-Anchor" href="#树或金字塔形"></a> 树或金字塔形</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200819142034.png" srcset="/img/loading.gif" alt="" /></p><p>和分发主库一样，减轻了主库的负担。<br />它的缺点是中间层出现的任何错误都会影响到多个服务器，中间层次越多，处理故障会更困难、更复杂。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 63. 不同路径 II</title>
    <link href="/2020/08/18/LeetCode-63-unique-paths-ii/"/>
    <url>/2020/08/18/LeetCode-63-unique-paths-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></p><p>一开始判断第一行或第一列的障碍时没有及时 <code>break</code>，导致若只有一行或一列的情况下出错。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * base: 若左边或上边存在障碍，则不能继续往下走</span><span class="hljs-comment">         * 状态：dp[i][j]</span><span class="hljs-comment">         * 选择：左，上</span><span class="hljs-comment">         * dp[i][[j] = dp[i - 1][j] + dp[i][j - 1]</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span> rows = obstacleGrid.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> cols = obstacleGrid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][cols];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-comment">// 如果有一个位置有障碍，那么该列剩下的位置都走不过去了</span>            <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;            <span class="hljs-comment">// 如果有一个位置有障碍，那么该行剩下的位置都走不过去了</span>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">0</span>) &#123;                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[rows - <span class="hljs-number">1</span>][cols - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 62. 不同路径</title>
    <link href="/2020/08/18/LeetCode-62-unique-paths/"/>
    <url>/2020/08/18/LeetCode-62-unique-paths/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></p><p>边界条件：第一行 <code>dp[0][i]</code> 和第一列 <code>dp[i][0]</code> 值为 <code>1</code>：只有一条路径可到达该位置。<br />状态转移方程：每个位置的路径 = 左边路径数 + 上边路径数。</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><code>2</code></td><td style="text-align:center"><code>3</code></td><td style="text-align:center"><code>4</code></td><td style="text-align:center"><code>5</code></td><td style="text-align:center"><code>6</code></td><td style="text-align:center"><code>7</code></td></tr><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><code>3</code></td><td style="text-align:center"><code>6</code></td><td style="text-align:center"><code>10</code></td><td style="text-align:center"><code>15</code></td><td style="text-align:center"><code>21</code></td><td style="text-align:center"><code>28</code></td></tr></tbody></table><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * base: 第一行和第一列为 1</span><span class="hljs-comment">     * 状态：dp[i][j] 每个位置路径数 = 左 + 上</span><span class="hljs-comment">     * 选择：左，上</span><span class="hljs-comment">     * dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];&#125;</code></pre><p>优化：</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th></tr></thead><tbody></tbody></table><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center"><code>2</code></th><th style="text-align:center"><code>3</code></th><th style="text-align:center"><code>4</code></th><th style="text-align:center"><code>5</code></th><th style="text-align:center"><code>6</code></th><th style="text-align:center"><code>7</code></th></tr></thead><tbody></tbody></table><p>省去列上的空间：<code>dp[j] = dp[j] + dp[j - 1]</code><br /><code>dp[j]</code> 在更新前相当于上边的值<br /><code>dp[j - 1]</code> 在更新 <code>dp[j]</code> 时，已经更新了 <code>dp[j - 1]</code> ，所以它相当于左边的值。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;     <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];     Arrays.fill(dp, <span class="hljs-number">1</span>);     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;             dp[j] += dp[j - <span class="hljs-number">1</span>];         &#125;     &#125;     <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>]; &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 备份与恢复</title>
    <link href="/2020/08/18/MySQL-backup-recovery/"/>
    <url>/2020/08/18/MySQL-backup-recovery/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>根据备份方法：</p><ul><li><strong>热备</strong>（<code>Hot Backup</code>）：运行的数据库中备份，对数据库操作没有影响</li><li><strong>冷备</strong>（<code>Cold Backup</code>）：数据库停止的情况下，复制物理文件</li><li><strong>温备</strong>（<code>Warm Backup</code>）：运行的数据库，但对数据库操作有影响，如加一个全局读锁保证数据一致性。</li></ul><p>根据备份后文件的内容：</p><ul><li><strong>逻辑备份</strong>：内容一般是一条条 <code>SQL</code> 语句，恢复时间长</li><li><strong>裸文件备份</strong>：复制数据库的物理文件，恢复时间短</li></ul><p>根据备份数据库的内容：</p><ul><li><strong>完全备份</strong>：对数据库进行一个完整的备份。</li><li><strong>增量备份</strong>：在上次完全备份的基础上，对于更改的数据进行备份。</li><li><strong>日志备份</strong>：对二进制日志的备份，通过对二进制日志的重做完成恢复。</li></ul><h1 id="冷备"><a class="markdownIt-Anchor" href="#冷备"></a> 冷备</h1><p>只需要备份 <code>MySQL</code> 数据库的 <code>frm</code> 文件，共享表空间文件，独立表空间（<code>*.ibd</code>）文件，重做日志文件。</p><p>优点：</p><ul><li>备份简单，只要复制相关文件即可</li><li>备份文件易于在不同操作系统，不同 <code>MySQL</code> 版本上恢复</li><li>恢复简单，只要把文件恢复到指定位置即可</li><li>恢复速度快，不需要执行任何 <code>SQL</code> 语句，也不需要重建索引</li></ul><p>缺点：</p><ul><li>冷备的文件通常比逻辑文件大很多，因为表空间中存放着很多其他的数据，如 <code>undo</code> 段，插入缓冲等信息。</li><li>冷备不总是可以轻易地跨平台。操作系统、<code>MySQL</code> 的版本、文件大小写敏感和浮点数格式都会成为问题。</li></ul><h1 id="热备"><a class="markdownIt-Anchor" href="#热备"></a> 热备</h1><h2 id="ibbackup"><a class="markdownIt-Anchor" href="#ibbackup"></a> <code>ibbackup</code></h2><p><code>ibbackup</code> 可以同时备份 <code>MyISAM</code> 和 <code>InnoDB</code> 存储引擎表。工作原理如下：</p><ol><li>记录备份开始时，重做日志文件检查点的 <code>LSN</code>。</li><li>复制共享表空间文件及独立表空间文件。</li><li>记录复制完表空间文件后，重做日志文件检查点的 <code>LSN</code>。</li><li>复制在备份时产生的重做日志。</li></ol><p>优点：</p><ul><li>在线备份，不阻塞任何的 <code>SQL</code> 语句。</li><li>备份性能好，<strong>备份的实质是复制数据库文件和重做日志文件</strong>。</li><li>支持压缩备份，通过选项，可以支持不同级别的压缩。</li><li>跨平台支持。</li></ul><p>恢复步骤：</p><ul><li>恢复表空间文件。</li><li>应用重做日志文件。</li></ul><h2 id="xtrabackup"><a class="markdownIt-Anchor" href="#xtrabackup"></a> <code>XtraBackup</code></h2><p><code>XtraBackup</code> 是一款开源免费的热备工具，它实现了 <code>ibbackup</code> 的所有功能，并且支持了真正的增量备份功能，是热备的更好选择。</p><p>工作原理：</p><ol><li>首先完成一个全备，并记录下此时检查点的 <code>LSN</code>。</li><li>在进行增量备份时，比较表空间中每个页的 <code>LSN</code> 是否大于上次备份时的 <code>LSN</code>，如果是，则备份该页，同时记录当前检查点的 <code>LSN</code>。</li></ol><h1 id="逻辑备份"><a class="markdownIt-Anchor" href="#逻辑备份"></a> 逻辑备份</h1><h2 id="备份方式"><a class="markdownIt-Anchor" href="#备份方式"></a> 备份方式</h2><h3 id="mysqldump"><a class="markdownIt-Anchor" href="#mysqldump"></a> <code>mysqldump</code></h3><p><code>mysqldump</code> 通常用来完成转存（<code>dump</code>）数据库的备份及不同数据库之间的移植。</p><h3 id="selectinto-outfile"><a class="markdownIt-Anchor" href="#selectinto-outfile"></a> <code>SELECT...INTO OUTFILE</code></h3><p><code>SELECT...INTO OUTFILE</code> 可以导出一张表中的数据。</p><h2 id="逻辑备份的恢复"><a class="markdownIt-Anchor" href="#逻辑备份的恢复"></a> 逻辑备份的恢复</h2><h3 id="mysqldump-2"><a class="markdownIt-Anchor" href="#mysqldump-2"></a> <code>mysqldump</code></h3><p><code>mysqldump</code> 的恢复操作比较简单，因为备份的文件就是导出的 <code>SQL</code> 语句，一般只需要执行这个文件就可以了。</p><p><code>mysqldump</code> <strong>不能导出视图</strong>，因此若数据库中使用了视图，还需要导出视图的定义，或者备份视图定义的 <code>frm</code> 文件，并在恢复时进行导入。</p><h3 id="load-data-infile"><a class="markdownIt-Anchor" href="#load-data-infile"></a> <code>LOAD DATA INFILE</code></h3><p>若通过 <code>mysqldump-tab</code>，或者通过 <code>SELECT...INTO OUTFILE</code> 导出的数据需要恢复，可以通过命令 <code>LOAD DATA INFILE</code> 来进行导入。</p><h3 id="mysqlimport"><a class="markdownIt-Anchor" href="#mysqlimport"></a> <code>mysqlimport</code></h3><p><code>mysqlimport</code> 是 <code>LOAD DATA INFILE</code> 的命令接口，而且大多数选项都和 <code>LOAD DATA INFILE</code> 语法相同。</p><p>和 <code>LOAD DATA INFILE</code> 不同的是，<code>mysqlimport</code> 可以用来导入<strong>多张表</strong>，或者<strong>并发地导入多个文件</strong>。</p><h1 id="二进制日志备份与恢复"><a class="markdownIt-Anchor" href="#二进制日志备份与恢复"></a> 二进制日志备份与恢复</h1><p>在默认情况下并不启用二进制日志，启用它需在配置文件中设置：</p><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><span class="hljs-attr">log-bin</span>=mysql-bin</code></pre><p>通过 <code>mysqlbinlog</code> 可恢复二进制日志。<br />如果需要恢复多个二进制文件，也可以先通过 <code>mysqlbinlog</code> 命令导出到一个文件，然后再通过 <code>SOURCE</code> 命令来导入。</p><h1 id="快照备份"><a class="markdownIt-Anchor" href="#快照备份"></a> 快照备份</h1><p><code>MySQL</code> 数据库本身并不支持快照功能，因此快照备份是指通过文件系统支持的快照功能对数据库进行备份。</p><ul><li>备份的前提是将所有数据库文件放在同一文件分区中，然后对该分区进行快照操作。</li><li>支持快照功能的文件系统和设备包括 <code>FreeBSD</code> 的 <code>UFS</code>，<code>Solaris</code> 的 <code>ZFS</code>，<code>GNU/Linux</code> 的逻辑管理器（<code>Logical Volume Manager, LVM</code>）等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 事务</title>
    <link href="/2020/08/17/MySQL-transaction/"/>
    <url>/2020/08/17/MySQL-transaction/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><blockquote><p>事务是访问并更新数据库中各种数据项的一个程序执行单元。<br />在事务中的操作，要么都不做，要么都做修改，这就是事务的目的，也是事务模型区别于文件系统的重要特征之一。</p></blockquote><ul><li>事务就是一组原子性的 <code>SQL</code> 语句。具体来说，事务指的是满足 <code>ACID</code> 特性的一组操作。</li><li>通过 <code>COMMIT</code> 提交一个事务，也可以使用 <code>ROLLBACK</code> 进行回滚。</li><li>事务内的 <code>SQL</code> 语句，要么全执行成功，要么全执行失败。</li><li>通过加锁的方式，可以实现不同的事务隔离机制。</li></ul><h2 id="acid-特性"><a class="markdownIt-Anchor" href="#acid-特性"></a> <code>ACID</code> 特性</h2><ul><li><p><strong>原子性 (<code>Atomicity</code>)</strong>：原子性是指整个数据库事务是不可分割的工作单位。<br />事务的所有操作够执行成功，整个事务才算成功。<br />事务的任何一个 <code>SQL</code> 语句执行失败，数据库状态应该退回到执行事务前的状态。</p></li><li><p><strong>一致性 (<code>Consistency</code>)</strong>：一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和结束之后，数据库的完整性约束没有被破坏。</p></li><li><p><strong>隔离性 (<code>Isolation</code>)</strong>：每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，通常使用锁来实现。</p></li><li><p><strong>持久性 (<code>Durability</code>)</strong>：事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。</p></li></ul><h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2><h3 id="扁平事务"><a class="markdownIt-Anchor" href="#扁平事务"></a> 扁平事务</h3><p>扁平事务中，所有操作都处于同一层次，由 <code>BEGIN WORK</code> 开始，由 <code>COMMIT WORK</code> 或 <code>ROLLBACK WORK</code> 结束，其间的操作是原子的。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200817194044.png" srcset="/img/loading.gif" alt="" /></p><p>扁平事务的主要限制是<strong>不能提交或者回滚事务的某一部分</strong>。</p><p><strong>带有保存点的扁平事务</strong>：<br />允许在事务执行过程中回滚到同一事务中较早的一个状态。<br />保存点（<code>Savepoint</code>）用来通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。</p><h3 id="链事务"><a class="markdownIt-Anchor" href="#链事务"></a> 链事务</h3><p>可视为保存点模式的一种变种。带有保存点的扁平事务，当发生系统崩溃时，所有的保存点都将消失，因为其保存点是易失的（<code>volatile</code>），而非持久的（<code>persistent</code>）。当恢复时，事务要从开始处重新执行，而不能从最近的一个保存点继续执行。</p><p>链事务：当提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传递给下一个要开始的事务。</p><ul><li>链事务只能恢复到<strong>最近</strong>的一个保存点，而带有保存点的扁平事务能回滚到<strong>任意正确的时间点</strong>。</li><li>链事务在执行 <code>COMMIT</code> 后即释放了当前事务所持有的锁，而带有保存点的扁平事务不影响所持有的锁。</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200817195151.png" srcset="/img/loading.gif" alt="" /></p><h3 id="嵌套事务"><a class="markdownIt-Anchor" href="#嵌套事务"></a> 嵌套事务</h3><p>嵌套事务是一个层次结构框架。由一个顶层事务控制着各个层次的事务。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200817195457.png" srcset="/img/loading.gif" alt="" /></p><h3 id="分布式事务"><a class="markdownIt-Anchor" href="#分布式事务"></a> 分布式事务</h3><p>分布式事务通常是一个在分布式环境下运行的扁平事务，需要根据数据所在位置访问网络中的不同节点，它也需要满足 <code>ACID</code> 特性。</p><h1 id="acid-实现"><a class="markdownIt-Anchor" href="#acid-实现"></a> <code>ACID</code> 实现</h1><ul><li>事务的隔离性通过锁实现。</li><li>原子性、一致性、持久性通过 <code>redo log</code> 和 <code>undo log</code> 来完成。<ul><li><code>redo log</code> 用来保证原子性和持久性；</li><li><code>undo log</code> 用来保证一致性。</li></ul></li></ul><p><code>redo</code> 和 <code>undo</code> 的区别：</p><ul><li><code>redo</code> 恢复提交事务修改的页操作，是<strong>物理日志</strong>，记录的是<strong>页的物理修改</strong>操作。</li><li><code>undo</code> 回滚行记录到某个特定版本，是<strong>逻辑日志</strong>，根据<strong>每行记录</strong>进行记录。</li></ul><h2 id="redo"><a class="markdownIt-Anchor" href="#redo"></a> <code>redo</code></h2><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><p>重做日志由两部分组成：</p><ol><li>重做日志缓冲（<code>redo log buffer</code>），其是易失的</li><li>重做日志文件（<code>redo log file</code>），其是持久的</li></ol><p>当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的 <code>COMMIT</code> 操作完成才算完成。<br />为了确保每次日志都写入重做日志文件，在每次将重做日志缓冲写入重做日志文件后，<code>InnoDB</code> 都需要调用一次 <code>fsync</code> 操作。</p><h3 id="log-block"><a class="markdownIt-Anchor" href="#log-block"></a> <code>log block</code></h3><p>重做日志都是以 <code>512</code> 字节进行存储的，这意味着重做日志缓存、重做日志文件都是以块（<code>block</code>）的方式保存的，称之为重做日志块（<code>redo log block</code>）。</p><p>由于重做日志块的大小和磁盘扇区大小一样，因此重做日志的写入可以保证原子性，不需要 <code>doublewrite</code> 技术。</p><h3 id="log-group"><a class="markdownIt-Anchor" href="#log-group"></a> <code>log group</code></h3><p><code>log group</code> 为重做日志组，其中有多个重做日志文件，<code>InnoDB</code> 实际只有一个 <code>log group</code>。<br /><code>log group</code> 是一个逻辑上的概念，并没有一个实际的物理文件来表示 <code>log group</code> 信息。</p><h2 id="undo"><a class="markdownIt-Anchor" href="#undo"></a> <code>undo</code></h2><h3 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h3><ul><li><code>undo</code> 是逻辑日志，只是通过<strong>回滚</strong>操作将数据库逻辑地恢复到原来的样子，数据结构和页本身在回滚之后可能大不相同，这是因为在并发系统中，不能将页回滚到事务开始时的样子，否则会影响其他事务正在进行的工作。</li><li><code>undo</code> 的另一个作用是 <strong><code>MVCC</code></strong>，<code>MVCC</code> 的实现是通过 <code>undo</code> 来完成。当用户读取一行时，若该行已被其他事务占用，当前事务可以通过 <code>undo</code> 读取之前的行版本信息，实现非锁定读取。</li><li><code>undo log</code> 会产生 <code>redo log</code>，这是因为 <code>undo log</code> 也需要持久性的保护。</li></ul><h3 id="undo-log-格式"><a class="markdownIt-Anchor" href="#undo-log-格式"></a> <code>undo log</code> 格式</h3><p><code>undo log</code> 分为：</p><ol><li><code>insert undo log</code></li><li><code>update undo log</code></li></ol><ul><li><p><code>insert undo log</code> 是指在 <code>insert</code> 操作中产生的 <code>undo log</code>，因为 insert 操作的记录，只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后删除。</p></li><li><p><code>update undo log</code> 记录的是对 <code>delete</code> 和 <code>update</code> 操作产生的 <code>undo log</code>，该 <code>undo log</code> 可能需要提供 <code>MVCC</code> 机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge</code> 线程进行最后的删除。</p></li></ul><h1 id="事务控制语句"><a class="markdownIt-Anchor" href="#事务控制语句"></a> 事务控制语句</h1><ul><li><code>START TRANSACTION | BEGIN</code>: 显式地开启一个事务。</li><li><code>COMMIT</code>: 提交事务。</li><li><code>ROLLBACK</code>: 结束用户的事务，撤销正在进行的所有未提交的事务。</li><li><code>SAVEPOINT identifier</code>: 创建一个保存点。</li><li><code>RELEASE SAVEPOINT identifier</code>: 删除一个事务的保存点。</li><li><code>ROLLBACK TO [SAVEPOINT] identifier</code>: 把事务回滚到标记点，而不回滚在此标记点之前的任何工作。</li><li><code>SET TRANSACTION</code>: 设置隔离级别。</li></ul><h1 id="隐式提交"><a class="markdownIt-Anchor" href="#隐式提交"></a> 隐式提交</h1><p><code>MySQL</code> 默认采用<strong>隐式提交策略</strong>（<code>autocommit</code>）。每执行一条语句就把这条语句当成一个事务然后进行提交。</p><ul><li>当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；</li><li>当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</li></ul><p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对<strong>每个连接</strong>而不是针对服务器的。</p><h1 id="隔离级别"><a class="markdownIt-Anchor" href="#隔离级别"></a> 隔离级别</h1><h2 id="读未提交-脏读"><a class="markdownIt-Anchor" href="#读未提交-脏读"></a> 读未提交 - 脏读</h2><p><strong>脏读</strong>（<code>Dirty Read</code>）：事务可以读取未提交的数据。</p><p><code>T1</code> 修改一个数据，<code>T2</code> 随后读取这个数据。如果 <code>T1</code> 撤销了这次修改，那么 <code>T2</code> 读取的数据是脏数据。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200818130050.png" srcset="/img/loading.gif" alt="" /></p><h2 id="读已提交-不可重复读"><a class="markdownIt-Anchor" href="#读已提交-不可重复读"></a> 读已提交 - 不可重复读</h2><p>读已提交解决了脏读的问题：每次读取数据前都生成一个 <code>ReadView</code>，每次都可判断事务是否提交。</p><p><strong>不可重复读</strong>：执行两次相同的查询，得到的结果可能不一致。<br /><code>T2</code> 读取一个数据，<code>T1</code> 对该数据做了修改。如果 <code>T2</code> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200818131135.png" srcset="/img/loading.gif" alt="" /></p><h2 id="可重复读-幻读"><a class="markdownIt-Anchor" href="#可重复读-幻读"></a> 可重复读 - 幻读</h2><p>解决了不可重复读的问题：在第一次读取数据时生成一个 <code>ReadView</code>，每次访问时都读取最初的版本。</p><p><strong>幻读</strong>：当某个事务读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务又再次读取该范围的记录时，得到结果与第一次不一致。</p><p><code>T1</code> 读取某个范围的数据，<code>T2</code> 在这个范围内插入新的数据，<code>T1</code> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><blockquote><p>InnoDB 使用 <code>Next-Key Lock</code>，避免了幻读。</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200818131209.png" srcset="/img/loading.gif" alt="" /></p><h2 id="串行化"><a class="markdownIt-Anchor" href="#串行化"></a> 串行化</h2><p>强制事务串行执行，则避免了所有的并发问题。</p><p>串行化策略会在读取的每一行数据上都加锁，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。</p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><ul><li><code>READ UNCOMMITTED</code> - 事务中的修改，即使没有提交，对其它事务也是可见的。</li><li><code>READ COMMITTED</code> - 一个事务只能读取已经提交的事务所做的修改，避免<strong>脏读</strong>。</li><li><code>REPEATABLE READ</code> - 默认隔离级别，解决了不可重复读的问题，使用 <code>Next-Key Lock</code>，避免<strong>幻读</strong>。</li><li><code>SERIALIZABLE</code> - 对每个读取操作加共享锁，强制事务串行执行，不支持一致性的非锁定读。</li></ul><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">读未提交（<code>READ UNCOMMITTED</code>）</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">读已提交（<code>READ COMMITTED</code>）</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">可重复读（<code>REPREATABLE READ</code>）</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">❌ (<code>InnoDB</code> - ✔️)</td></tr><tr><td style="text-align:center">串行化（<code>SERIALIZABLE</code>）</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 35. 搜索插入位置</title>
    <link href="/2020/08/17/LeetCode-35-search-insert-position/"/>
    <url>/2020/08/17/LeetCode-35-search-insert-position/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;            left = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> mid;        &#125;     &#125;    <span class="hljs-comment">// 单独处理 left == right 的情况</span>    <span class="hljs-keyword">return</span> nums[left] &gt;= target ? left : left + <span class="hljs-number">1</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (target == nums[mid]) &#123;                <span class="hljs-keyword">return</span> mid;            &#125;            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;                right = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 154. 寻找旋转排序数组中的最小值 II</title>
    <link href="/2020/08/17/LeetCode-154-find-minimum-in-rotated-sorted-array-ii/"/>
    <url>/2020/08/17/LeetCode-154-find-minimum-in-rotated-sorted-array-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[right] &lt; nums[mid]) &#123;                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[right] &gt; nums[mid]) &#123;                right = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 若 右 == 中，因为最小值一定靠近左边，丢弃右边的重复值，缩小右边界</span>                right--;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left];    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 153. 寻找旋转排序数组中的最小值</title>
    <link href="/2020/08/17/LeetCode-153-find-minimum-in-rotated-sorted-array/"/>
    <url>/2020/08/17/LeetCode-153-find-minimum-in-rotated-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></p><p>第一次通过的代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[left] &gt; nums[mid]) &#123;            <span class="hljs-comment">// 左 &gt; 中，min 在 中 后面的部分</span>            min = Math.min(nums[mid], min);            <span class="hljs-comment">// 到左边查找</span>            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 中 &gt;= 左，min 在最左边</span>            min = Math.min(nums[left], min);            <span class="hljs-comment">// 到右边查找</span>            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> Math.min(min, nums[left]);&#125;</code></pre><p>评论区：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * [3,4,5,1,2]</span><span class="hljs-comment">     * [4,5,6,7,0,1,2]</span><span class="hljs-comment">     * [0,1,2,3,4]</span><span class="hljs-comment">     * [2,1]</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[right] &lt; nums[mid]) &#123;            <span class="hljs-comment">// 右 &lt; 中，一定在右边，则到右边查找</span>            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 右 &gt;= 中，一定在左边</span>            right = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> nums[left];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 81. 搜索旋转排序数组 II</title>
    <link href="/2020/08/17/LeetCode-81-search-in-rotated-sorted-array-ii/"/>
    <url>/2020/08/17/LeetCode-81-search-in-rotated-sorted-array-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></p><p>本题加入重复数字，所以在判断哪一部分有序时，若 <code>nums[left] == nums[mid]</code> 可能出现判断不出来的情况，一开始一直卡着，后来发现只要丢弃一个重复数字，则下一次就可成功判断。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (target == nums[mid]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">if</span> (nums[left] &lt; nums[mid]) &#123;                <span class="hljs-comment">// 左半部分有序</span>                <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid]) &#123;                    right = mid;                &#125; <span class="hljs-keyword">else</span> &#123;                    left = mid + <span class="hljs-number">1</span>;                &#125;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] &gt; nums[mid]) &#123;                <span class="hljs-comment">// 右半部分有序</span>                <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;                    left = mid + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    right = mid;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// nums[left] == nums[mid] 时无法判断哪部分有序，则丢弃一个重复数字</span>                <span class="hljs-comment">// [1,3,1,1,1]</span>                <span class="hljs-comment">// [1,3,1,1]</span>                left++;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left] == target;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 74. 搜索二维矩阵</title>
    <link href="/2020/08/17/LeetCode-74-search-a-2d-matrix/"/>
    <url>/2020/08/17/LeetCode-74-search-a-2d-matrix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a><br />一开始用 <code>i = mid / rows</code> 计算行数，导致位置计算不正确。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> rows = matrix.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = rows * cols - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-comment">// 行数是对每行大小进行整除，</span>            <span class="hljs-comment">// 列数是对每行大小进行取余</span>            <span class="hljs-keyword">int</span> i = mid / cols;            <span class="hljs-keyword">int</span> j = mid % cols;            <span class="hljs-keyword">if</span> (matrix[i][j] == target) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target) &#123;                <span class="hljs-comment">// 不使用 left = mid</span>                <span class="hljs-comment">// 原因在于向上取整时 matrix 可能会越界，所以采用向下取整</span>                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                right = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> matrix[left / cols][left % cols] == target;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 33. 搜索旋转排序数组</title>
    <link href="/2020/08/17/LeetCode-33-search-in-rotated-sorted-array/"/>
    <url>/2020/08/17/LeetCode-33-search-in-rotated-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;                <span class="hljs-keyword">return</span> mid;            &#125;            <span class="hljs-keyword">if</span> (nums[left] &lt; nums[mid]) &#123;                <span class="hljs-comment">// 1. 左半部分 [left, mid] 有序</span>                <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;                    <span class="hljs-comment">// 1.1 target in [left, mid]</span>                    <span class="hljs-comment">// left &lt;= target &lt; mid.....right</span>                    <span class="hljs-comment">// [left, mid - 1]</span>                    right = mid - <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 1.2 target in [mid + 1, right]</span>                    <span class="hljs-comment">// [mid, right]</span>                    left = mid;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 2. 右半部分 [mid, right] 有序</span>                <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;                    <span class="hljs-comment">// 2.1 target in [mid, right]</span>                    <span class="hljs-comment">// left.....mid &lt; target &lt;= right</span>                    <span class="hljs-comment">// [mid, right]</span>                    left = mid;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 2.2 target in [left, mid - 1]</span>                    <span class="hljs-comment">// [left, mid - 1]</span>                    right = mid - <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 367. 有效的完全平方数</title>
    <link href="/2020/08/16/LeetCode-367.%20valid-perfect-square/"/>
    <url>/2020/08/16/LeetCode-367.%20valid-perfect-square/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-perfect-square/" target="_blank" rel="noopener">367. 有效的完全平方数</a></p><p>两种解法都击败 <code>100%</code></p><h1 id="二分法"><a class="markdownIt-Anchor" href="#二分法"></a> 二分法</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">long</span> left = <span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> right = num / <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">long</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">long</span> prod = mid * mid;        <span class="hljs-keyword">if</span> (prod == num) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prod &gt; num) &#123;            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> left * left == num;&#125;</code></pre><h1 id="牛顿迭代法"><a class="markdownIt-Anchor" href="#牛顿迭代法"></a> 牛顿迭代法</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">long</span> x = num / <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (x * x &gt; num) &#123;        x = (x + num / x) / <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> x * x == num;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 69. x 的平方根</title>
    <link href="/2020/08/15/LeetCode-69-sqrtx/"/>
    <url>/2020/08/15/LeetCode-69-sqrtx/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></p><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><blockquote><p><code>sqrt(x) &lt;= x / 2</code><br />一个数的平方根 <code>&lt;=</code> 这个数的一半，所以右边界最大 <code>= x / 2</code></p></blockquote><ul><li>先写分支逻辑，再决定中间数是否上取整；</li><li>只要看到 <code>left = mid</code> ，它对应的取中位数的取法一定是 <code>mid = left + (right - left + 1) / 2;</code>。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">long</span> left = <span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> right = x / <span class="hljs-number">2</span>;    <span class="hljs-comment">// 排除元素，使用 &lt;，每次都使用 [left, right] 查找</span>    <span class="hljs-comment">// 查找元素，使用 &lt;=</span>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-comment">// +1 向上取整，避免死循环</span>        <span class="hljs-comment">// 不使用 (left + right) / 2 是为了避免 long 溢出</span>        <span class="hljs-keyword">long</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (mid * mid &gt; x) &#123;            <span class="hljs-comment">// [left, mid - 1]</span>            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// [mid, right]</span>            left = mid;        &#125;    &#125;    <span class="hljs-comment">// 退出循环时 left == right</span>    <span class="hljs-comment">// 还剩一个元素没有查找，</span>    <span class="hljs-comment">// 因为答案一定存在，即一定在搜索区间，剩下的元素就是问题答案</span>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)left;&#125;</code></pre><h1 id="牛顿迭代法"><a class="markdownIt-Anchor" href="#牛顿迭代法"></a> 牛顿迭代法</h1><p>要使用 <code>double</code> 类型，一开始使用 <code>float</code> 精度不够，有三个测试用例无法通过。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mspace linebreak="newline"></mspace><mo>=</mo><mo>&gt;</mo><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>x</mi><mo>=</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mspace linebreak="newline"></mspace><mi>x</mi><mo>=</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><mfrac><mrow><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup><mo>−</mo><mi>a</mi></mrow><mrow><mn>2</mn><msub><mi>x</mi><mi>n</mi></msub></mrow></mfrac><mspace linebreak="newline"></mspace><mi>x</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>+</mo><mfrac><mi>a</mi><msub><mi>x</mi><mi>n</mi></msub></mfrac><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">f(x) = x^2 - a \\=&gt; y = f(x_n) + f&#x27;(x_n)(x - x_n) \\x = x_n - \frac{f(x_n)}{f&#x27;(x_n)}\\x = x_n - \frac{x_n^2 - a}{2x_n}\\x = \frac{1}{2}(x_n + \frac{a}{x_n})\\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6778919999999999em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.327108em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.9435600000000002em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span></span></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">double</span> cur = <span class="hljs-number">1.0</span>;    <span class="hljs-keyword">double</span> pre = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (Math.abs(cur - pre) &gt; <span class="hljs-number">1e-6</span>) &#123;        pre = cur;        cur = (cur + x / cur) / <span class="hljs-number">2</span>;    &#125;    System.out.println(cur);    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)cur;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 45. 跳跃游戏 II</title>
    <link href="/2020/08/14/LeetCode-45-jump-game-ii/"/>
    <url>/2020/08/14/LeetCode-45-jump-game-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></p><p>本题在 <a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a> 基础上加了个最小次数，其实也是计算每个位置能跳到的最远距离，关键在于要保存上一次的最远边界，用来判断跳跃的次数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (pos &lt; nums.length - <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 本次能跳到的最远位置</span>            <span class="hljs-keyword">int</span> max = pos;            <span class="hljs-comment">// 每次都在 [begin, end] 区间里找到能跳到的最远位置</span>            <span class="hljs-comment">// 一个区间表示一次跳跃的所有可能起点，选取能跳到的最远位置</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin; i &lt;= end; i++) &#123;                max = Math.max(max, i + nums[i]);            &#125;            <span class="hljs-comment">// 更新下一次跳的区间</span>            begin = end + <span class="hljs-number">1</span>;            end = max;            <span class="hljs-comment">// 更新最远位置</span>            pos = max;            count++;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre><p>优化：计算从每个位置能跳到的最远距离。每次最远，最终最远，则跳跃次数最少。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">// 一次跳跃可到达的最远位置</span>        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-comment">// 若上一次已到达终点，则结束</span>            <span class="hljs-keyword">if</span> (end == nums.length - <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> count;            &#125;            <span class="hljs-comment">// 计算从第 i 个位置起跳的最远位置</span>            max = Math.max(max, i + nums[i]);            <span class="hljs-comment">// 一次跳跃到达终点，更新跳跃次数和下一次的跳跃边界</span>            <span class="hljs-keyword">if</span> (end == i) &#123;                count++;                end = max;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 55. 跳跃游戏</title>
    <link href="/2020/08/14/LeetCode-55-jump-game/"/>
    <url>/2020/08/14/LeetCode-55-jump-game/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></p><p>(🙃一开始还用的回溯。。。)<br />关键在于：若能跳到第 <code>i</code> 个位置，则在这之前的所有位置都能到达，所以只要计算从第 <code>i</code> 个位置起跳能跳到的最远位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> maxPos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-comment">// 若能跳到的最远位置 &lt; 当前位置</span>            <span class="hljs-comment">// 说明连当前位置都跳不到，也就跳不到终点了</span>            <span class="hljs-keyword">if</span> (maxPos &lt; i) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 能跳到第 i 个位置的情况下，</span>            <span class="hljs-comment">// 计算从第 i 个位置起跳，能跳到的最远位置</span>            <span class="hljs-comment">// 最远 = max(本次起跳，上次最远位置)</span>            maxPos = Math.max(i + nums[i], maxPos);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 锁</title>
    <link href="/2020/08/14/InnoDB-Lock/"/>
    <url>/2020/08/14/InnoDB-Lock/</url>
    
    <content type="html"><![CDATA[<h1 id="innodb-中的锁"><a class="markdownIt-Anchor" href="#innodb-中的锁"></a> <code>InnoDB</code> 中的锁</h1><h2 id="表级锁和行级锁"><a class="markdownIt-Anchor" href="#表级锁和行级锁"></a> 表级锁和行级锁</h2><table><thead><tr><th style="text-align:center">锁类型</th><th style="text-align:center">开销</th><th style="text-align:center">加锁速度</th><th style="text-align:center">死锁</th><th style="text-align:center">粒度</th><th style="text-align:center">锁冲突</th><th style="text-align:center">并发性</th></tr></thead><tbody><tr><td style="text-align:center">表级锁（<code>table lock</code>）</td><td style="text-align:center">小</td><td style="text-align:center">快</td><td style="text-align:center">无</td><td style="text-align:center">大</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">行级锁（<code>row lock</code>）</td><td style="text-align:center">大</td><td style="text-align:center">慢</td><td style="text-align:center">有</td><td style="text-align:center">小</td><td style="text-align:center">小</td><td style="text-align:center">高</td></tr></tbody></table><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，锁竞争的发生频率就越小，系统的并发程度就越高。但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此锁粒度越小，系统开销就越大。</p><p>不同的存储引擎支持的锁粒度是不一样的：</p><ul><li><code>InnoDB</code> 行锁和表锁都支持。</li><li><code>MyISAM</code> 只支持表锁。</li></ul><p>在 <code>InnoDB</code> 中，行锁是通过给索引上的索引项加锁来实现的。如果没有索引，<code>InnoDB</code> 将会通过隐藏的聚簇索引来对记录加锁。</p><h2 id="行级锁的类型"><a class="markdownIt-Anchor" href="#行级锁的类型"></a> 行级锁的类型</h2><p><code>InnoDB</code> 实现了如下两种标准的行级锁：</p><ol><li>共享锁（读锁、<code>S</code> 锁）：允许事务读一行数据。</li><li>排他锁(写锁、<code>X</code> 锁)：允许事务删除或更新一行数据。</li></ol><p><code>InnoDB</code> 支持在不同粒度上进行加锁操作，称为意向锁，即为<strong>表级别的锁</strong>，对程序员透明。若对细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。<br />两种意向锁：</p><ol><li>意向共享锁：事务想要获得一张表中某几行的共享锁。</li><li>意向排他锁：事务想要获得一张表中某几行的排他锁。</li></ol><h2 id="一致性非锁定读"><a class="markdownIt-Anchor" href="#一致性非锁定读"></a> 一致性非锁定读</h2><p>指的是 <code>InnoDB</code> 通过行多版本控制的方式来读取当前执行时间数据库中行的数据。<br />如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会等待行锁的释放，而是去读取行的一个快照数据。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200814141414.png" srcset="/img/loading.gif" alt="" /></p><p>默认配置下，事务的隔离级别为 <code>REPREATABLE READ</code>。</p><ul><li>在 <code>READ COMMITTED</code> 事务隔离级别下，非一致性读总是读取被锁定行的<strong>最新一份</strong>快照数据。</li><li>在 <code>REPREATABLE READ</code> 事务隔离级别下，非一致性读总是读取<strong>事务开始时</strong>的行数据版本。</li></ul><h2 id="一致性锁定读"><a class="markdownIt-Anchor" href="#一致性锁定读"></a> 一致性锁定读</h2><p><code>InnoDB</code> 对于 <code>SELECT</code> 语句支持两种一致性的锁定读操作：</p><ol><li><code>SELECT ··· FOR UPDATE</code>: 对读取的行加一个 <code>X</code> 锁，其他事务不能对已锁定的行加任何锁。</li><li><code>SELECT ··· LOCK IN SHARE MODE</code>: 对读取的行加一个 <code>S</code> 锁，其他事务可以向被锁定的行加 <code>S</code> 锁，如果加 <code>X</code> 锁，则会被阻塞。</li></ol><p>在使用上述两句 <code>SELECT</code> 语句时，务必加上 <code>BEGIN, START TRANSACTION</code> 或者 <code>SET AUTOCOMMIT = 0</code>，因为他们必须在一个事务中，当事务提交了，锁也就释放了。</p><h2 id="自增长与锁"><a class="markdownIt-Anchor" href="#自增长与锁"></a> 自增长与锁</h2><p>每个含有自增长值的表都有一个自增长计数器（<code>auto-increment counter</code>），当表进行插入操作时，这个计数器会被初始化，插入操作会根据这个自增长的计数器加 <code>1</code> 赋予自增长列。<br />这个实现方式称作 <code>AUTO-INC Locking</code>。这种锁其实是采用一种特殊的表锁机制，为了提高插入的性能，<strong>锁不是在一个事务完成后释放，而是在完成对自增长值插入的 <code>SQL</code> 语句后释放</strong>。</p><p>在 <code>InnoDB</code> 中，自增长值的列必须是索引，同时必须是索引的第一个列。如果不是第一个列，会抛出异常，而 <code>MyISAM</code> 没有这个问题。</p><h1 id="行锁的三种算法"><a class="markdownIt-Anchor" href="#行锁的三种算法"></a> 行锁的三种算法</h1><ul><li><code>Record Lock</code>: 单个行记录上的锁。</li><li><code>Gap Lock</code>: 间隙锁，锁定一个范围，但不包含记录本身。</li><li><code>Next-Key Lock</code>: <code>Gap Lock + Record Lock</code>，锁定一个范围，并且锁定记录本身。</li></ul><p>加锁规则：</p><p>在 <code>READ COMMITTED</code> 事务隔离级别下，采用 <code>Record Lock</code>。<br />在 <code>REPREATABLE READ</code> 事务隔离级别下，采用 <code>Next-Key Lock</code>。</p><ul><li><p>当查询的索引含有唯一属性时，<code>Next-Key Lock</code> 会降级为 <code>Record Lock</code>，即仅锁住索引本身，而不是范围。</p></li><li><p>而对于辅助索引，会加上 <code>Next-Key Lock</code>，还会对辅助索引的下一个键值加上 <code>Gap Lock</code>。</p></li></ul><h1 id="事务隔离级别与锁问题"><a class="markdownIt-Anchor" href="#事务隔离级别与锁问题"></a> 事务隔离级别与锁问题</h1><h2 id="隔离级别"><a class="markdownIt-Anchor" href="#隔离级别"></a> 隔离级别</h2><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">读未提交（<code>READ UNCOMMITTED</code>）</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">读已提交（<code>READ COMMITTED</code>）</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">可重复读（<code>REPREATABLE READ</code>）</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">❌ (<code>InnoDB</code> - ✔️)</td></tr><tr><td style="text-align:center">串行化（<code>SERIALIZABLE</code>）</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td></tr></tbody></table><h2 id="脏读"><a class="markdownIt-Anchor" href="#脏读"></a> 脏读</h2><blockquote><p>针对未提交数据</p></blockquote><p>脏读指的是在<strong>不同的事务</strong>下，当前事务可以读到另外事务<strong>未提交</strong>的数据。</p><p>脏读发生的条件是需要事务的隔离级别为 <code>READ UNCOMMITTED</code>，而目前绝大部分的数据库都至少设置成 <code>READ COMMITTED</code>。</p><h2 id="不可重复读"><a class="markdownIt-Anchor" href="#不可重复读"></a> 不可重复读</h2><blockquote><p>针对其他事务提交前后，读取<strong>数据本身</strong>的对比<br />重点在于同一条数据被修改了</p></blockquote><p>不可重复读是指在<strong>同一事务</strong>下，在两次读同一个数据之间，由于第二个事务的修改，导致两次读到的数据不一样。</p><p><code>InnoDB</code> 在 <code>REPREATABLE READ</code> 事务隔离级别下，采用 <code>Next-Key Lock</code> 解决不可重复读的问题。</p><h2 id="幻读"><a class="markdownIt-Anchor" href="#幻读"></a> 幻读</h2><blockquote><p>针对其他事务提交前后，读取<strong>数据条数</strong>的对比<br />重点在于表中数据的<strong>新增</strong>或者<strong>删除</strong></p></blockquote><p>幻读是指在<strong>同一事务</strong>下，<strong>连续执行两次同样的 <code>SQL</code> 语句可能导致不同的结果</strong>，第二次的 <code>SQL</code> 语句可能会返回之前不存在的行。</p><p><code>InnoDB</code> 在 <code>REPREATABLE READ</code> 事务隔离级别下，采用 <code>Next-Key Lock</code> 已经能避免幻读的产生。<br />而其他数据库，如 <code>ORACLE</code> 可能需要在 <code>SERIALIZABLE</code> 下才能解决幻读。</p><h2 id="版本链"><a class="markdownIt-Anchor" href="#版本链"></a> 版本链</h2><p>每次对某条聚簇索引记录进行改动时，都会生成一个版本，都会记录一条 <code>undo</code> 日志，每条 <code>undo</code> 日志也都有一个 <code>roll_pointer</code> 属性。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200814164939.png" srcset="/img/loading.gif" alt="" /></p><p>对该记录每次更新后，都会将旧值放到一条 <code>undo</code> 日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 <code>roll_pointer</code> 属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务 <code>id</code>。</p><h2 id="readview"><a class="markdownIt-Anchor" href="#readview"></a> <code>ReadView</code></h2><ul><li>对于使用 <code>READ UNCOMMITTED</code> 隔离级别的事务来说，直接读取记录的最新版本就好了。</li><li>对于使用 <code>SERIALIZABLE</code> 隔离级别的事务来说，使用加锁的方式来访问记录。</li><li>对于使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务来说，就需要用到版本链了，核心问题就是：<strong>需要判断一下版本链中的哪个版本是当前事务可见的</strong>。</li></ul><p><code>ReadView</code> 中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务 <code>id</code> 放到一个列表中。这样在访问某条记录时，就可判断记录的某个版本是否可见。</p><ul><li><p><code>READ COMMITTED</code>：每次读取数据前都生成一个 <code>ReadView</code>，每次都可判断事务是否提交。</p></li><li><p><code>REPEATABLE READ</code>：在第一次读取数据时生成一个 <code>ReadView</code>，每次访问时都读取最初的版本。</p></li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://juejin.im/post/6844903808376504327" target="_blank" rel="noopener">MySQL事务隔离级别和MVCC</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 874. 模拟行走机器人</title>
    <link href="/2020/08/13/LeetCode-874-walking-robot-simulation/"/>
    <url>/2020/08/13/LeetCode-874-walking-robot-simulation/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/walking-robot-simulation/" target="_blank" rel="noopener">874. 模拟行走机器人</a></p><p>一开始用的 <code>findObstacle()</code>，每走一步都要遍历 <code>obstacles</code>，效率很慢，官方题解采取<strong>将障碍编码</strong>的方式，这样只要 <code>O(1)</code> 就可以完成判断。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">robotSim</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] commands, <span class="hljs-keyword">int</span>[][] obstacles)</span> </span>&#123;        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[][] dirs = &#123;                <span class="hljs-comment">// 北：0</span>                &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,                <span class="hljs-comment">// 东：1</span>                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,                <span class="hljs-comment">// 南：2</span>                &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,                <span class="hljs-comment">// 西：3</span>                &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        &#125;;        <span class="hljs-keyword">int</span> dir = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 将障碍编码，加快判断效率</span>        Set&lt;Long&gt; obstacleSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] ob : obstacles) &#123;            <span class="hljs-keyword">long</span> ox = ob[<span class="hljs-number">0</span>] + <span class="hljs-number">30000</span>;            <span class="hljs-keyword">long</span> oy = ob[<span class="hljs-number">1</span>] + <span class="hljs-number">30000</span>;            obstacleSet.add((ox &lt;&lt; <span class="hljs-number">16</span>) + oy);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step : commands) &#123;            <span class="hljs-keyword">if</span> (step == -<span class="hljs-number">1</span>) &#123;                <span class="hljs-comment">// 右转</span>                dir = (dir + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (step == -<span class="hljs-number">2</span>) &#123;                <span class="hljs-comment">// 左转</span>                dir = (dir + <span class="hljs-number">3</span>) % <span class="hljs-number">4</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 向前走 step 步，直到遇上障碍物</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; step; i++) &#123;                    <span class="hljs-keyword">long</span> nx = x + dirs[dir][<span class="hljs-number">0</span>] + <span class="hljs-number">30000</span>;                    <span class="hljs-keyword">long</span> ny = y + dirs[dir][<span class="hljs-number">1</span>] + <span class="hljs-number">30000</span>;                    <span class="hljs-keyword">if</span> (!obstacleSet.contains((nx &lt;&lt; <span class="hljs-number">16</span>) + ny)) &#123;                        x = x + dirs[dir][<span class="hljs-number">0</span>];                        y = y + dirs[dir][<span class="hljs-number">1</span>];                        max = Math.max(max, x * x + y * y);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;<span class="hljs-comment">//////////////////////// obsolete ////////////////////////////////</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findObstacle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span>[][] obstacles)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] ob : obstacles) &#123;            <span class="hljs-keyword">if</span> (ob[<span class="hljs-number">0</span>] == x &amp;&amp; ob[<span class="hljs-number">1</span>] == y) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 455. 分发饼干</title>
    <link href="/2020/08/13/LeetCode-455-assign-cookies/"/>
    <url>/2020/08/13/LeetCode-455-assign-cookies/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></p><p>优先用小饼干满足胃口小的孩子</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] g, <span class="hljs-keyword">int</span>[] s)</span> </span>&#123;        Arrays.sort(g);        Arrays.sort(s);        <span class="hljs-keyword">int</span> child = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> cookie = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (child &lt; g.length &amp;&amp; cookie &lt; s.length) &#123;            <span class="hljs-comment">// 满足要求，换下一个小孩</span>            <span class="hljs-keyword">if</span> (s[cookie] &gt;= g[child]) &#123;                count++;                child++;            &#125;            <span class="hljs-comment">// 下一个饼干</span>            cookie++;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 122. 买卖股票的最佳时机 II</title>
    <link href="/2020/08/12/LeetCode-122-best-time-to-buy-and-sell-stock-ii/"/>
    <url>/2020/08/12/LeetCode-122-best-time-to-buy-and-sell-stock-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></p><h1 id="贪心"><a class="markdownIt-Anchor" href="#贪心"></a> 贪心</h1><blockquote><p>贪心的思想在于每一步作出的决策在现在看来总是最好的，它不关心过去或者未来的状态。</p></blockquote><p>只要今天的价格高于明天就计算收益：相当于在今天判断：是否买入昨天，卖出今天。这样每一天都有收益，最终的收益就是最大的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> profit = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;            <span class="hljs-keyword">int</span> cur = prices[i] - prices[i - <span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (cur &gt; <span class="hljs-number">0</span>)&#123;                profit += cur;            &#125;        &#125;        <span class="hljs-keyword">return</span> profit;    &#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><p><strong>1. 状态 <code>dp[i][j]</code></strong>:</p><p>第 <code>i</code> 天所能获得的最大利润，<code>j = 0</code>: 第 <code>i</code> 天持有现金，<code>j = 1</code>: 第 <code>i</code> 天持有股票。</p><p><strong>2. 状态转移方程：</strong></p><p>每一天可能持有股票或现金。</p><ul><li>若第 <code>i</code> 天持有股票 (<code>dp[i][0]</code>)：<ul><li>第 <code>i - 1</code> 天持有股票，则第 <code>i</code> 天无操作。</li><li>第 <code>i - 1</code> 天持有现金，则第 <code>i</code> 天买入新股票  (<code>+prices[i]</code>)。</li></ul></li><li>若第 <code>i</code> 天持有现金 (<code>dp[i][1]</code>)：<ul><li>第 <code>i - 1</code> 天持有股票，则第 <code>i</code> 天卖出 (<code>-prices[i]</code>)。</li><li>第 <code>i - 1</code> 天持有现金，则第 <code>i</code> 天无操作。</li></ul></li></ul><p><strong>3. 结束</strong></p><p>输出最后一天持有现金 (<code>dp[len - 1][0]</code>)，持有现金的情况下才会把之前的股票卖出，若最后一天持有股票，金额还会更少 <code>dp[len - 1][0] &gt; dp[len - 1][1]</code>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[prices.length][<span class="hljs-number">2</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;            <span class="hljs-comment">// 第 i 天持有现金</span>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);            <span class="hljs-comment">// 第 i 天持有股票</span>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">return</span> dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    &#125;</code></pre><p><strong>状态压缩</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-comment">// 今天持有现金</span>        <span class="hljs-keyword">int</span> cash = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 今天持有股票</span>        <span class="hljs-keyword">int</span> hold = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 昨天持有现金</span>        <span class="hljs-keyword">int</span> preCash = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 昨天持有股票</span>        <span class="hljs-keyword">int</span> preHold = -prices[<span class="hljs-number">0</span>];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> price : prices) &#123;            cash = Math.max(preCash, preHold + price);            hold = Math.max(preHold, preCash - price);                        preCash = cash;            preHold = hold;        &#125;        <span class="hljs-keyword">return</span> cash;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 860. 柠檬水找零</title>
    <link href="/2020/08/11/LeetCode-860-lemonade-change/"/>
    <url>/2020/08/11/LeetCode-860-lemonade-change/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lemonade-change/" target="_blank" rel="noopener">860. 柠檬水找零</a></p><blockquote><p>不带零钱你买什么柠檬水！！！</p></blockquote><p>虽然有点贪心的思想，我感觉这题在搞笑。。。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] bills)</span> </span>&#123;        <span class="hljs-keyword">if</span> (bills.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> money : bills) &#123;            <span class="hljs-keyword">switch</span> (money) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                    five++;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:                    five--;                    ten++;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>:                    <span class="hljs-keyword">if</span> (ten &gt; <span class="hljs-number">0</span>) &#123;                        five--;                        ten--;                    &#125; <span class="hljs-keyword">else</span> &#123;                        five -= <span class="hljs-number">3</span>;                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span> (five &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 529. 扫雷游戏</title>
    <link href="/2020/08/11/LeetCode-529-minesweeper/"/>
    <url>/2020/08/11/LeetCode-529-minesweeper/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">529. 扫雷游戏</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><blockquote><p>找周围的雷和进入下一层递归都是在 <strong>八个方向</strong> 游走。</p></blockquote><p>典型的 <code>DFS</code>。</p><p>若 <code>click</code> 位置为 <code>M</code>，标记返回，否则进入递归。</p><p>需要注意的是新的位置不能越界，且未被标记过。</p><ol><li>若周围有雷，遍历周围的八个位置，找到雷的数量，标记后返回</li><li>若周围没有雷，标记为 <code>B</code>，遍历周围八个位置，进入递归。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dirs = &#123;            <span class="hljs-comment">// 上：(x - 1, y)</span>            &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,            <span class="hljs-comment">// 下：(x + 1, y)</span>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,            <span class="hljs-comment">// 左：(x, y - 1)</span>            &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 右：(x, y + 1)</span>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 左上：(x - 1, y - 1)</span>            &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 右上，(x - 1, y + 1)</span>            &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 左下：(x + 1, y - 1)</span>            &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 右下：(x + 1, y + 1)</span>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;    &#125;;    <span class="hljs-keyword">boolean</span>[][] used;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[][] updateBoard(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span>[] click) &#123;        <span class="hljs-keyword">if</span> (notInArea(click[<span class="hljs-number">0</span>], click[<span class="hljs-number">1</span>], board)) &#123;            <span class="hljs-keyword">return</span> board;        &#125;        <span class="hljs-keyword">if</span> (board[click[<span class="hljs-number">0</span>]][click[<span class="hljs-number">1</span>]] == <span class="hljs-string">'M'</span>) &#123;            board[click[<span class="hljs-number">0</span>]][click[<span class="hljs-number">1</span>]] = <span class="hljs-string">'X'</span>;            <span class="hljs-keyword">return</span> board;        &#125; <span class="hljs-keyword">else</span> &#123;            used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[board.length][board[<span class="hljs-number">0</span>].length];            dfs(click[<span class="hljs-number">0</span>], click[<span class="hljs-number">1</span>], board);        &#125;        <span class="hljs-keyword">return</span> board;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        used[x][y] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> mineCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = x + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = y + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (notInArea(newX, newY, board)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (board[newX][newY] == <span class="hljs-string">'M'</span>) &#123;                mineCount++;            &#125;        &#125;        <span class="hljs-comment">// 找到地雷返回上一层</span>        <span class="hljs-keyword">if</span> (mineCount &gt; <span class="hljs-number">0</span>) &#123;            board[x][y] = (<span class="hljs-keyword">char</span>) (mineCount + <span class="hljs-string">'0'</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 未找到雷，进行标记，进入下一个位置</span>        board[x][y] = <span class="hljs-string">'B'</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = x + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = y + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (notInArea(newX, newY, board) || used[newX][newY]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            dfs(newX, newY, board);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">notInArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> || x &gt;= board.length                || y &lt; <span class="hljs-number">0</span> || y &gt;= board[<span class="hljs-number">0</span>].length;    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dirs = &#123;        <span class="hljs-comment">// 上：(x - 1, y)</span>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 下：(x + 1, y)</span>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 左：(x, y - 1)</span>        &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 右：(x, y + 1)</span>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 左上：(x - 1, y - 1)</span>        &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 右上，(x - 1, y + 1)</span>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 左下：(x + 1, y - 1)</span>        &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 右下：(x + 1, y + 1)</span>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-keyword">boolean</span>[][] used;<span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[][] updateBoard(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span>[] click) &#123;    <span class="hljs-keyword">if</span> (notInArea(click[<span class="hljs-number">0</span>], click[<span class="hljs-number">1</span>], board)) &#123;        <span class="hljs-keyword">return</span> board;    &#125;    <span class="hljs-keyword">if</span> (board[click[<span class="hljs-number">0</span>]][click[<span class="hljs-number">1</span>]] == <span class="hljs-string">'M'</span>) &#123;        board[click[<span class="hljs-number">0</span>]][click[<span class="hljs-number">1</span>]] = <span class="hljs-string">'X'</span>;        <span class="hljs-keyword">return</span> board;    &#125;    used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[board.length][board[<span class="hljs-number">0</span>].length];    Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(click);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-keyword">int</span>[] cur = queue.poll();        used[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> mineCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = cur[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = cur[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (notInArea(newX, newY, board)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (board[newX][newY] == <span class="hljs-string">'M'</span>) &#123;                mineCount++;            &#125;        &#125;        <span class="hljs-keyword">if</span> (mineCount &gt; <span class="hljs-number">0</span>) &#123;            board[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] = (<span class="hljs-keyword">char</span>) (mineCount + <span class="hljs-string">'0'</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            board[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] = <span class="hljs-string">'B'</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                <span class="hljs-keyword">int</span> newX = cur[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];                <span class="hljs-keyword">int</span> newY = cur[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span> (notInArea(newX, newY, board) || used[newX][newY]) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;newX, newY&#125;);                <span class="hljs-comment">// 避免超时</span>                used[newX][newY] = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> board;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">notInArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> || x &gt;= board.length            || y &lt; <span class="hljs-number">0</span> || y &gt;= board[<span class="hljs-number">0</span>].length;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 200. 岛屿数量</title>
    <link href="/2020/08/10/LeetCode-200-number-of-islands/"/>
    <url>/2020/08/10/LeetCode-200-number-of-islands/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 已被访问的数组</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">boolean</span>[][] visited;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 移动方向</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] dir = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;            <span class="hljs-comment">// 上: (x - 1, y)</span>            &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,            <span class="hljs-comment">// 右: (x, y + 1)</span>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 下: (x + 1, y)</span>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,            <span class="hljs-comment">// 左: (x, y - 1)</span>            &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;    &#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;        rows = grid.length;        <span class="hljs-keyword">if</span> (rows &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        cols = grid[<span class="hljs-number">0</span>].length;        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-comment">// 当前位置未访问过 &amp;&amp; 是陆地</span>                <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-string">'1'</span>) &#123;                    <span class="hljs-comment">// 只要未访问过且为 1 肯定存在一个岛屿</span>                    <span class="hljs-comment">// 需要做的就是找到这个岛屿连通的所有位置</span>                    count++;                    dfs(grid, i, j);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        visited[x][y] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dir.length; i++) &#123;            <span class="hljs-keyword">int</span> nextX = x + dir[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> nextY = y + dir[i][<span class="hljs-number">1</span>];            <span class="hljs-comment">// 新位置 未越界 &amp;&amp; 未访问过 &amp;&amp; 是陆地</span>            <span class="hljs-keyword">if</span> (inArea(nextX, nextY) &amp;&amp; !visited[nextX][nextY] &amp;&amp; grid[nextX][nextY] == <span class="hljs-string">'1'</span>) &#123;                dfs(grid, nextX, nextY);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span> rows;<span class="hljs-keyword">int</span> cols;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 已被访问的数组</span><span class="hljs-comment"> */</span><span class="hljs-keyword">boolean</span>[][] visited;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 移动方向</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span>[][] dir = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;        <span class="hljs-comment">// 上: (x - 1, y)</span>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 右: (x, y + 1)</span>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 下: (x + 1, y)</span>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 左: (x, y - 1)</span>        &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">int</span> y;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;    rows = grid.length;    <span class="hljs-keyword">if</span> (rows &lt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    cols = grid[<span class="hljs-number">0</span>].length;    visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-comment">// 当前位置未访问过 &amp;&amp; 是陆地</span>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-string">'1'</span>) &#123;                <span class="hljs-comment">// 只要未访问过且为 1 肯定存在一个岛屿</span>                <span class="hljs-comment">// 需要做的就是找到这个岛屿连通的所有位置</span>                count++;                Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();                visited[i][j] = <span class="hljs-keyword">true</span>;                queue.offer(<span class="hljs-keyword">new</span> Node(i, j));                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;                    Node cur = queue.poll();                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; dir.length; k++) &#123;                        <span class="hljs-keyword">int</span> nextX = cur.x + dir[k][<span class="hljs-number">0</span>];                        <span class="hljs-keyword">int</span> nextY = cur.y + dir[k][<span class="hljs-number">1</span>];                        <span class="hljs-comment">// 新位置 未越界 &amp;&amp; 未访问过 &amp;&amp; 是陆地</span>                        <span class="hljs-keyword">if</span> (inArea(nextX, nextY) &amp;&amp; !visited[nextX][nextY] &amp;&amp; grid[nextX][nextY] == <span class="hljs-string">'1'</span>) &#123;                            queue.offer(<span class="hljs-keyword">new</span> Node(nextX, nextY));                            <span class="hljs-comment">// 及时标记，避免超时</span>                            visited[nextX][nextY] = <span class="hljs-keyword">true</span>;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;&#125;</code></pre><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><p>把所有的水连接到水域结点，若是陆地尝试与周围结点链接。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;        rows = grid.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        cols = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> len = rows * cols;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(len + <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-comment">// 如果是 水，连接到 dummy 结点</span>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">'0'</span>) &#123;                    uf.union(len, getIndex(i, j));                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 如果是 陆地，尝试连接到周围的陆地</span>                    <span class="hljs-comment">// 这里 dirs 只要 右和下两个方向就能遍历到周围的结点</span>                    <span class="hljs-comment">// 因为在上一次遍历时已经访问过左和上方的结点</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                        <span class="hljs-keyword">int</span> newX = i + dir[<span class="hljs-number">0</span>];                        <span class="hljs-keyword">int</span> newY = j + dir[<span class="hljs-number">1</span>];                        <span class="hljs-keyword">if</span> (inArea(newX, newY) &amp;&amp; grid[newX][newY] == <span class="hljs-string">'1'</span>) &#123;                            uf.union(getIndex(i, j), getIndex(newX, newY));                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 减去水域的结点才是所有的陆地结点</span>        <span class="hljs-keyword">return</span> uf.getCount() - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">return</span> i * cols + j;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &lt; rows &amp;&amp; y &lt; cols;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 126. 单词接龙 II</title>
    <link href="/2020/08/09/LeetCode-126-word-ladder-ii/"/>
    <url>/2020/08/09/LeetCode-126-word-ladder-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. 单词接龙 II</a></p><ul><li>找的是最短路径，且可能有多个</li><li>一开始用的 <code>List</code> 存放每层元素，结果 回溯的时候难以访问下一层，最好用 <code>Map</code> 存放</li><li>！！最短路径要及时剪枝</li><li>！！不能用 <code>used</code> 数组标记访问过的元素，而是标记当前层和以上层已经访问过的数组，因为若存在多个最短路径，元素可能重复使用，<code>used</code> 数组标记后会把下层的元素也标记，会导致漏解。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (!wordList.contains(endWord)) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-comment">// boolean[] used = new boolean[wordList.size()];</span>        Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(beginWord);        <span class="hljs-comment">// int start = wordList.indexOf(beginWord);</span>        <span class="hljs-comment">// if (start != -1) &#123;</span>        <span class="hljs-comment">//     used[start] = true;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// key: 当前层每一个单词 value: 每个单词对应的下一层所有单词</span>        Map&lt;String, HashSet&lt;String&gt;&gt; successors = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        Set&lt;String&gt; level = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                String word = queue.poll();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordList.size(); i++) &#123;                    String candidate = wordList.get(i);                    <span class="hljs-comment">// 下一层 candidate 未被使用 &amp;&amp; 可以接龙</span>                    <span class="hljs-keyword">if</span> (!visited.contains(candidate) &amp;&amp; canLadder(word, candidate)) &#123;                        <span class="hljs-comment">// System.out.println(word + " -&gt; " + candidate);</span>                        <span class="hljs-keyword">if</span> (endWord.equals(candidate)) &#123;                            found = <span class="hljs-keyword">true</span>;                        &#125;                        <span class="hljs-keyword">if</span> (!level.contains(candidate))&#123;                            <span class="hljs-comment">// used[i] = true;</span>                            queue.offer(candidate);                            level.add(candidate);                        &#125;                        successors.computeIfAbsent(word, e -&gt; <span class="hljs-keyword">new</span> HashSet&lt;&gt;());                        successors.get(word).add(candidate);                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 若 found 为 true，说明已找到 end 的路径</span>            <span class="hljs-comment">// 可保证为最短路径</span>            <span class="hljs-comment">// ! 第一次提交没 AC 的原因：忘了找最短路径，把所有路径都找出来了</span>            <span class="hljs-keyword">if</span> (found) &#123;                <span class="hljs-keyword">break</span>;            &#125;            System.out.println(level.toString());            visited.addAll(level);            level.clear();        &#125;        System.out.println(successors.toString());        <span class="hljs-comment">// 未找到，返回空集</span>        <span class="hljs-keyword">if</span> (!found) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        path.add(beginWord);        dfs(beginWord, endWord, path, successors, res);        System.out.println(res);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; path, Map&lt;String, HashSet&lt;String&gt;&gt; successors, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;        <span class="hljs-keyword">if</span> (endWord.equals(beginWord)) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// ！及时剪枝，否则 NPE</span>        <span class="hljs-keyword">if</span> (!successors.containsKey(beginWord)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 选择队列：是当前 单词 的下一层，</span>        <span class="hljs-comment">// 所以如果用 List 来保存每一层的话，获取下一层就会比较麻烦</span>        HashSet&lt;String&gt; successor = successors.get(beginWord);        <span class="hljs-keyword">for</span> (String word : successor) &#123;            <span class="hljs-keyword">if</span> (path.contains(word)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            path.add(word);            dfs(word, endWord, path, successors, res);            path.remove(word);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canLadder</span><span class="hljs-params">(String word, String candidate)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">if</span> (word.charAt(i) != candidate.charAt(i)) &#123;                <span class="hljs-keyword">if</span> (++count &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 127. 单词接龙</title>
    <link href="/2020/08/08/LeetCode-127-word-ladder/"/>
    <url>/2020/08/08/LeetCode-127-word-ladder/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. 单词接龙</a></p><p>和 433.最小基因那题很像，不过本题变异的字母是不确定的，不再是 <code>ACGT</code>，若用回溯会超时。</p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;        <span class="hljs-comment">// ! endWord 不在 wordList 中直接返回</span>        <span class="hljs-keyword">if</span> (!wordList.contains(endWord)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[wordList.size()];        LinkedList&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-comment">// 将 beginWord 加入队列，标记访问数组</span>        queue.offer(beginWord);        <span class="hljs-keyword">int</span> start = wordList.indexOf(beginWord);        <span class="hljs-keyword">if</span> (start != -<span class="hljs-number">1</span>) &#123;            used[start] = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            step++;            <span class="hljs-comment">// 此时队列中的所有元素相当于上一个 word 可向下接龙的所有选择</span>            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                String word = queue.poll();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordList.size(); i++) &#123;                    String candidate = wordList.get(i);                    <span class="hljs-comment">// 若已经访问过 || word 无法接龙到 candidate，则跳过 </span>                    <span class="hljs-keyword">if</span> (used[i] || !canLadder(word, candidate)) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-comment">// candidate 到达 end，返回</span>                    <span class="hljs-keyword">if</span> (endWord.equals(candidate)) &#123;                        <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// 标记访问数组，将 candidate 加入队列</span>                        used[i] = <span class="hljs-keyword">true</span>;                        queue.offer(candidate);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// ！！！返回 0，不是 step</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canLadder</span><span class="hljs-params">(String word, String candidate)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate.length(); i++) &#123;            <span class="hljs-keyword">if</span> (word.charAt(i) != candidate.charAt(i)) &#123;                <span class="hljs-keyword">if</span> (++count &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><h1 id="双向-bfs"><a class="markdownIt-Anchor" href="#双向-bfs"></a> 双向 BFS</h1><p>采用左右两个扩散集合，当集合重复即表示扩散结束。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;        <span class="hljs-comment">// 不用 set 竟然超时了！</span>        Set&lt;String&gt; wordSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordList);        <span class="hljs-keyword">if</span> (!wordSet.contains(endWord)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// 标记已访问过的元素</span>        Set&lt;String&gt; used = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-comment">// 左边扩散集合，每次都假设该集合元素最少，则扩散速度更快</span>        Set&lt;String&gt; beginSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        beginSet.add(beginWord);        <span class="hljs-comment">// 右边扩散集合</span>        Set&lt;String&gt; endSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        endSet.add(endWord);        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!beginSet.isEmpty() &amp;&amp; !endSet.isEmpty()) &#123;            step++;            <span class="hljs-comment">// 使 beginSet 的元素最少</span>            <span class="hljs-keyword">if</span> (beginSet.size() &gt; endSet.size()) &#123;                Set&lt;String&gt; tmp = beginSet;                beginSet = endSet;                endSet = tmp;            &#125;            <span class="hljs-comment">// 下一层扩散的集合</span>            Set&lt;String&gt; nextLevel = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();            <span class="hljs-keyword">for</span> (String word : beginSet) &#123;                <span class="hljs-keyword">char</span>[] words = word.toCharArray();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;                    <span class="hljs-keyword">char</span> old = words[i];                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c = <span class="hljs-string">'a'</span>; c &lt;= <span class="hljs-string">'z'</span>; c++) &#123;                        <span class="hljs-keyword">if</span> (old == c) &#123;                            <span class="hljs-keyword">continue</span>;                        &#125;                        words[i] = c;                        String nextWord = String.valueOf(words);                        <span class="hljs-comment">// 新元素必须存在于提供的 list 中</span>                        <span class="hljs-keyword">if</span> (wordSet.contains(nextWord)) &#123;                            <span class="hljs-comment">// 右边集合包含该元素，说明扩散重复，直接返回</span>                            <span class="hljs-keyword">if</span> (endSet.contains(nextWord)) &#123;                                <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span>;                            &#125;                            <span class="hljs-comment">// 加入下一层扩散集合</span>                            <span class="hljs-keyword">if</span> (!used.contains(nextWord)) &#123;                                nextLevel.add(nextWord);                                <span class="hljs-comment">// 标记已访问</span>                                used.add(nextWord);                            &#125;                        &#125;                    &#125;                    words[i] = old;                &#125;            &#125;            <span class="hljs-comment">// 设置下一层的扩散集合</span>            beginSet = nextLevel;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 515. 在每个树行中找最大值</title>
    <link href="/2020/08/07/LeetCode-515-find-largest-value-in-each-tree-row/"/>
    <url>/2020/08/07/LeetCode-515-find-largest-value-in-each-tree-row/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">515. 在每个树行中找最大值</a></p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><p>层次遍历</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(root);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                TreeNode p = queue.poll();                max = Math.max(p.val, max);                <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) &#123;                    queue.offer(p.left);                &#125;                <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) &#123;                    queue.offer(p.right);                &#125;            &#125;            res.add(max);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><p>判断是否到了新的一层：<code>res</code> 中保存的是每一层的最大值，所以 <code>res.size()</code> 等于遍历过的层数，若 <code>res.size() &lt; level</code> 表示到了新层。</p><pre><code class="hljs java">List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;            dfs(root, <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> level)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 遍历到了下一层，添加新元素</span>        <span class="hljs-keyword">if</span> (res.size() &lt; level) &#123;            res.add(root.val);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 计算当前层的最大值</span>            <span class="hljs-keyword">int</span> levelMax = Math.max(root.val, res.get(level - <span class="hljs-number">1</span>));            res.set(level - <span class="hljs-number">1</span>, levelMax);        &#125;        dfs(root.left, level + <span class="hljs-number">1</span>);        dfs(root.right, level + <span class="hljs-number">1</span>);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 22. 括号生成</title>
    <link href="/2020/08/07/LeetCode-22-generate-parentheses/"/>
    <url>/2020/08/07/LeetCode-22-generate-parentheses/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/generate-parentheses/submissions/" target="_blank" rel="noopener">22. 括号生成</a></p><h1 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h1><pre><code class="hljs java">List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        backtrack(n, n, <span class="hljs-string">""</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 路径：生成的括号字符串</span><span class="hljs-comment">     * 选择列表：路径中可放置的左右括号数量</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> left  左括号剩余数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> right 右括号剩余数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path  路径</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, String path)</span> </span>&#123;        <span class="hljs-comment">// 左括号剩余 &gt; 右括号剩余：剪枝</span>        <span class="hljs-comment">// e.g. )</span>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;            res.add(path);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 左边可放置左括号</span>        <span class="hljs-comment">// e.g. ()</span>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;            backtrack(left - <span class="hljs-number">1</span>, right, path + <span class="hljs-string">"("</span>);        &#125;        <span class="hljs-comment">// 左括号剩余 &lt; 右括号剩余：右边可放置右括号</span>        <span class="hljs-comment">// e.g. ((, (</span>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;            backtrack(left, right - <span class="hljs-number">1</span>, path + <span class="hljs-string">")"</span>);        &#125;    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    String path;    <span class="hljs-keyword">int</span> left;    <span class="hljs-keyword">int</span> right;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path  当前结点产生的路径</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> left  左边剩余括号</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> right 右边剩余括号</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String path, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">this</span>.path = path;        <span class="hljs-keyword">this</span>.left = left;        <span class="hljs-keyword">this</span>.right = right;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(<span class="hljs-keyword">new</span> Node(<span class="hljs-string">""</span>, n, n));        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            Node q = queue.poll();            <span class="hljs-comment">// 左右括号均已用完</span>            <span class="hljs-keyword">if</span> (q.left == <span class="hljs-number">0</span> &amp;&amp; q.right == <span class="hljs-number">0</span>) &#123;                res.add(q.path);            &#125;            <span class="hljs-comment">// 左括号剩余</span>            <span class="hljs-keyword">if</span> (q.left &gt; <span class="hljs-number">0</span>) &#123;                queue.offer(<span class="hljs-keyword">new</span> Node(q.path + <span class="hljs-string">"("</span>, q.left - <span class="hljs-number">1</span>, q.right));            &#125;            <span class="hljs-comment">// 右括号剩余</span>            <span class="hljs-keyword">if</span> (q.right &gt; <span class="hljs-number">0</span> &amp;&amp; q.right &gt; q.left) &#123;                queue.offer(<span class="hljs-keyword">new</span> Node(q.path + <span class="hljs-string">")"</span>, q.left, q.right - <span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 索引</title>
    <link href="/2020/08/07/InnoDB-index/"/>
    <url>/2020/08/07/InnoDB-index/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><h2 id="b-树"><a class="markdownIt-Anchor" href="#b-树"></a> <code>B+</code> 树</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200807153046.png" srcset="/img/loading.gif" alt="" /></p><blockquote><p>🙃又是考研内容。</p></blockquote><p>一棵 <code>m</code> 阶 <code>B+</code> 树需满足下列条件：</p><ul><li>每个分支结点最多有 <code>m</code> 棵子树（子结点）。</li><li>非叶根结点至少有两棵子树，其他每个分支结点至少有 <code>⌈m / 2⌉</code> 棵子树。</li><li><strong>结点的子树个数与关键字个数相等</strong>。</li><li>所有叶子结点包含<strong>全部关键字</strong>及指向相应记录的<strong>指针</strong>，叶子结点中关键字按大小排序，相邻叶结点按大小顺序<strong>相互链接</strong>起来。</li><li>所有分支结点中仅包含它的各个子结点中<strong>关键字的最大值</strong>及指向其子结点的<strong>指针</strong>。</li></ul><p><code>m</code> 阶 <code>B+</code> 树与 <code>m</code> 阶 <code>B</code> 树的区别：</p><ol><li><strong>子树和结点的关系：</strong><br /><code>B+</code> 树 <code>n</code> 个关键字的结点只含有 <code>n</code> 棵子树，<strong>即每个关键字对应一棵子树</strong>；<br /><code>B</code> 树 <code>n</code> 个关键字的结点含有 <code>n + 1</code> 棵子树。</li><li><strong>结点关键字个数</strong><br /><code>B+</code> 树非根结点关键字个数：<code>⌈m / 2⌉ &lt;= n &lt;= m</code>，根结点：<code>1 &lt;= n &lt;= m</code>；<br /><code>B</code> 树非根结点关键字个数：<code>⌈m / 2⌉ - 1 &lt;= n &lt;= m - 1</code>，根结点：<code>1 &lt;= n &lt;= m - 1</code></li><li><strong>叶子结点和非叶结点</strong><br /><code>B+</code> 树叶结点包含信息，所有<strong>非叶结点仅起到索引作用</strong>，非叶结点中的每个索引项值含有子树最大关键字和指向子树的指针，<strong>不含该关键字的存储地址</strong>。</li><li><strong>关键字重复性</strong><br /><code>B+</code> 树中叶结点包含全部关键字，<strong>即关键字会和非叶结点重复</strong>；<br /><code>B</code> 树中叶结点包含的关键字和其他结点包含的关键字是<strong>不重复</strong>的。</li><li><strong>查找过程</strong><br /><code>B+</code> 树查找过程中，如果非叶结点上的关键字等于给定值时并不终止，而是继续向下查找直到叶结点为止。每次查找都是一条从根节点到叶结点的路径。</li></ol><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><p><code>B+</code> 树索引按照顺序存储，可以用来做 <code>ORDER BY</code> 和 <code>GROUP</code> 操作。<br />因为索引中存储了实际的列值，覆盖索引只需要使用索引就能完成查询。</p><ul><li>索引大大减少了服务器需要扫描的数据量。</li><li>索引可以帮助服务器避免排序和临时表。</li><li>索引可以将随机 <code>IO</code> 变为顺序 <code>IO</code>。</li></ul><h2 id="不使用索引的情况"><a class="markdownIt-Anchor" href="#不使用索引的情况"></a> 不使用索引的情况</h2><p>在范围查找、<code>JOIN</code> 链接操作等情况下，优化器直接进行全表的扫描来得到数据。<br />当用户要选取的数据是整行信息，而索引不能覆盖到要查询的信息，在通过索引查到指定数据后，还要一次书签访问来查找整行的信息。</p><p>可使用关键字 <code>FORCE INDEX</code> 来强制使用某个索引。</p><ul><li>表记录太少</li><li>经常增删改的表</li><li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li><li><strong>频繁更新</strong>的字段不适合创建索引（会加重 <code>IO</code> 负担）</li><li><code>where</code> 条件里用不到的字段不创建索引</li></ul><h2 id="需要创建索引的情况"><a class="markdownIt-Anchor" href="#需要创建索引的情况"></a> 需要创建索引的情况</h2><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li><li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li><li>查询中统计或分组字段</li></ul><h1 id="索引类型"><a class="markdownIt-Anchor" href="#索引类型"></a> 索引类型</h1><blockquote><p><code>InnoDB</code> 的索引是自适应哈希索引，使用 <code>B+</code> 树索引。<br /><code>B+</code> 树索引并不能找到一个给定键值的具体行，它只能找到被查找数据行所在的页，然后通过把页读入内存，在内存中查找想要的数据。</p></blockquote><h2 id="1-b-树索引"><a class="markdownIt-Anchor" href="#1-b-树索引"></a> 1. <code>B+</code> 树索引</h2><p><code>B+</code> 树索引能够加快访问数据的速度，因为存储引擎<strong>不再需要进行全表扫描</strong>来获取数据，而是从索引的根节点开始进行搜索。</p><ul><li>根节点存放了<strong>指向子节点的指针</strong>，存储引擎根据这些指针向下层查找，通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点。</li><li>叶子节点指向的是<strong>被索引的数据</strong>，而不是其他的节点页。</li></ul><p>索引列是按<strong>顺序组织</strong>存储的，所以很适合查找范围数据，多个值进行排序的依据是 <code>CREATE TABLE</code> 语句中定义索引时列的顺序。</p><h3 id="限制"><a class="markdownIt-Anchor" href="#限制"></a> 限制</h3><ul><li><strong>如果不是按照索引的最左列开始查找，则无法使用索引</strong>。如 <code>key(last_name,first_name, dob)</code> 无法用于查找特定的 <code>first_name</code> 和 <code>dob</code>。</li><li><strong>不能跳过索引中的列</strong>。如不能查找 <code>last_name</code> 和 <code>dob</code> 为特定值的记录。如果不指定 <code>first_name</code>，则只能使用索引的第一列。</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li></ul><h3 id="聚集索引"><a class="markdownIt-Anchor" href="#聚集索引"></a> 聚集索引</h3><p>聚集索引按照每张表的主键构造一棵 <code>B+</code> 树，叶子结点中存放的为整张表的行记录数据，叶子结点也称为数据页。<strong>一张表只能有一个聚集索引。</strong> 它对于主键的排序查找和范围查找非常快。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200811143800.png" srcset="/img/loading.gif" alt="" /><br />聚集索引的存储并不是物理上连续的（维护成本高），而是<strong>逻辑上连续</strong>的。</p><ul><li>页通过双向链表链接，页按照主键的顺序排序。<br />如果没有定义主键，<code>InnoDB</code> 会选择一个唯一的非空索引代替。<br />如果没有这样的主键，<code>InnoDB</code> 会隐式定义一个主键来作为聚集索引。</li><li>页中的记录通过双向链表链接，物理存储上也可以不按照主键存储。</li></ul><p>优点：</p><ul><li>可以把相关数据保存在一起，减少磁盘 <code>IO</code>。</li><li>数据访问更快。索引和数据都在同一个 <code>B+</code> 树中。</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li></ul><p>缺点：</p><ul><li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 <code>InnoDB</code> 表中速度最快的方式。</li><li>更新聚集索引列的代价很高，因为会强制 <code>InnoDB</code> 将每个被更新的行移动到新的位置。</li><li>可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li><li>二级索引（非聚集索引）可能很大，因为二级索引的叶子结点包含了引用行的主键列。</li><li>二级索引需要两次索引查找，而不是一次。</li></ul><h3 id="辅助索引非聚集索引"><a class="markdownIt-Anchor" href="#辅助索引非聚集索引"></a> 辅助索引（非聚集索引）</h3><p>辅助索引中，叶子结点并不包含行记录的全部数据。叶子结点除了包含键值以外，每个叶子结点中的索引行还包含了一个书签，该书签用来告诉 <code>InnoDB</code> 哪里可以找到与索引相对应的行数据。</p><p>辅助索引的存在并不影响数据在聚集索引中的组织，因此<strong>一张表可以有多个辅助索引。</strong></p><h3 id="覆盖索引"><a class="markdownIt-Anchor" href="#覆盖索引"></a> 覆盖索引</h3><blockquote><p>查询只要访问索引，而无须访问数据行。</p></blockquote><p>覆盖索引从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量 <code>IO</code>。</p><p>不是所有类型的索引都可以成为覆盖索引。<strong>覆盖索引必须要存储索引列的值</strong>，而哈希索引和全文索引等都不存储索引列的值，所以 <code>MySQL</code> 只能使用 <code>B+</code> 树索引做覆盖索引。</p><h3 id="联合索引"><a class="markdownIt-Anchor" href="#联合索引"></a> 联合索引</h3><p>联合索引是指对表上的多个列进行索引。其键值的数量不是 <code>1</code>，而是大于等于 <code>2</code>。</p><h2 id="2-哈希索引"><a class="markdownIt-Anchor" href="#2-哈希索引"></a> 2. 哈希索引</h2><blockquote><p>在 <code>MySQL</code> 中，只有 <code>Memory</code> 引擎显式支持哈希索引，它还支持非唯一哈希索引，如果多个列的哈希值相同，使用链表存放记录指针。</p></blockquote><p>哈希索引（<code>hash index</code>）基于哈希表实现，只有<strong>精确匹配</strong>索引所有列的查询才有效。</p><p>对于每一行数据，存储引擎会对<strong>所有的索引列</strong>计算一个哈希码（<code>hash code</code>），哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p><h3 id="限制-2"><a class="markdownIt-Anchor" href="#限制-2"></a> 限制</h3><ul><li>只包含<strong>哈希值</strong>和<strong>指针</strong>，不存储字段值，所以不能使用索引中的值来避免读取行。</li><li><strong>不支持顺序和范围查询</strong>。</li><li>哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序。</li><li>不支持部分索引列匹配查找，因为哈希索引始终使用索引列的全部内容来计算哈希值。</li><li>出现哈希冲突，必须遍历链表中所有指针。</li><li>如果哈希冲突很多，索引维护操作的代价很高。</li></ul><h3 id="自适应哈希索引"><a class="markdownIt-Anchor" href="#自适应哈希索引"></a> 自适应哈希索引</h3><p>当 <code>InnoDB</code> 注意到某些索引值被使用得很频繁时，它会自动在内存中基于 <code>B+</code> 树索引之上再创建一个哈希索引，这样就让 <code>B+</code> 树索引也具有哈希索引的一些优点，如快速哈希查找。</p><h2 id="3-全文索引"><a class="markdownIt-Anchor" href="#3-全文索引"></a> 3. 全文索引</h2><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文索引类似于搜索引擎，适用于 <code>MATCH AGAINST</code> 而不是简单的 <code>WHERE</code> 条件匹配。</p><h1 id="高性能的索引策略"><a class="markdownIt-Anchor" href="#高性能的索引策略"></a> 高性能的索引策略</h1><h2 id="独立的列"><a class="markdownIt-Anchor" href="#独立的列"></a> 独立的列</h2><blockquote><p>如果查询的列不是独立的，<code>MySQL</code> 就不会使用索引。</p></blockquote><p>独立的列：索引列不能是表达式的一部分，也不能是函数的参数。</p><h2 id="前缀索引和索引选择性"><a class="markdownIt-Anchor" href="#前缀索引和索引选择性"></a> 前缀索引和索引选择性</h2><blockquote><p>索引选择性 = 不重复的索引值 / 记录总数( <code>#T</code>)，范围从 <code>1 / #T</code> 到 <code>1</code> 之间，选择性越高则查询效率越高，因为选择性高的索引可以在查找时过滤更多的行。</p></blockquote><p>选择某个列选择性高的前缀进行查询。但前缀索引无法进行 <code>ORDER BY</code> 和 <code>GROUP</code> 操作。</p><h2 id="选择合适的索引列"><a class="markdownIt-Anchor" href="#选择合适的索引列"></a> 选择合适的索引列</h2><p>经验法则：将选择性高的索引刚到索引最前列。（并不适用所有情况，也要考虑 <code>WHERE</code> 子句中的排序，分组和范围条件等其他因素）</p><h2 id="聚集索引和覆盖索引"><a class="markdownIt-Anchor" href="#聚集索引和覆盖索引"></a> 聚集索引和覆盖索引</h2><h2 id="使用索引扫描来做排序"><a class="markdownIt-Anchor" href="#使用索引扫描来做排序"></a> 使用索引扫描来做排序</h2><p><code>MySQL</code> 可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务。<br />只有当索引的列顺序和 <code>ORDER BY</code> 子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，<code>MySQL</code> 才能使用索引来对结果做排序。</p><h2 id="冗余和重复索引"><a class="markdownIt-Anchor" href="#冗余和重复索引"></a> 冗余和重复索引</h2><ul><li>重复索引是指在相同的列上按照相同的顺序创建相同类型的索引。应该避免创建重复索引。</li><li>如果创建了索引 <code>(A, B)</code>，再创建索引 <code>(A)</code> 就是冗余索引，因为这只是前一个索引的前缀索引。<br />但是如果创建 <code>(B, A), (B)</code>，则不是冗余索引，因为它们不是 <code>(A, B)</code> 的最左前缀列。<br />其他不同类型的索引（哈希索引、全文索引）也不是 <code>B+</code> 树索引的冗余索引，无论它们覆盖的索引列是什么。</li></ul><h2 id="未使用的索引列"><a class="markdownIt-Anchor" href="#未使用的索引列"></a> 未使用的索引列</h2><p>建议删除未使用的索引列。</p><h2 id="索引和锁"><a class="markdownIt-Anchor" href="#索引和锁"></a> 索引和锁</h2><ul><li><strong>索引可以让查询锁定更少的行</strong>。如果查询从不访问那些不需要的行，那么会锁定更少的行。</li><li><code>InnoDB</code> 只有在访问行的时候才会对其加锁，而索引能减少访问行的次数，从而<strong>减少锁的数量</strong>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 433. 最小基因变化</title>
    <link href="/2020/08/06/LeetCode-433-minimum-genetic-mutation/"/>
    <url>/2020/08/06/LeetCode-433-minimum-genetic-mutation/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener">433. 最小基因变化</a></p><h1 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h1><p>第一次解法击败 <code>100%</code> 用户。</p><p>每一次的变异都可在基因库中找到，因此从基因库中构建决策树，与当前基因相差一个碱基且在之前的选择路径中未出现的基因即为下一步变异的基因。</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> minStep = Integer.MAX_VALUE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(String start, String end, String[] bank)</span> </span>&#123;        dfs(start, end, <span class="hljs-number">0</span>, bank);        <span class="hljs-keyword">return</span> minStep == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : minStep;    &#125;    List&lt;String&gt; selectedList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 选择队列：bank 中在决策树中未选择的元素</span><span class="hljs-comment">     * 路径：selectedList</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start 当前变异到的基因</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end   最终的基因</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> count 需要变为最终基因的次数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bank  选择队列</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String start, String end, <span class="hljs-keyword">int</span> count, String[] bank)</span> </span>&#123;        <span class="hljs-comment">// 当前步数 &gt; 最小步数：剪枝</span>        <span class="hljs-keyword">if</span> (count &gt; minStep) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 若 当前基因 可以变为 最终基因</span>        <span class="hljs-comment">// 则计算最小步数，结束递归</span>        <span class="hljs-keyword">if</span> (start.equals(end)) &#123;            minStep = Math.min(minStep, count);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (String candidate : bank) &#123;            <span class="hljs-comment">// 若 candidate 不在决策树中 &amp;&amp; start 可变异为 candidate</span>            <span class="hljs-comment">// 则进入决策</span>            <span class="hljs-keyword">if</span> (notSelected(candidate) &amp;&amp; canMutate(start, candidate)) &#123;                selectedList.add(candidate);                dfs(candidate, end, count + <span class="hljs-number">1</span>, bank);                selectedList.remove(candidate);            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断 start 基因是否可以变为 candidate 基因</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidate</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canMutate</span><span class="hljs-params">(String start, String candidate)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; start.length(); i++) &#123;            <span class="hljs-keyword">if</span> (start.charAt(i) != candidate.charAt(i)) &#123;                <span class="hljs-keyword">if</span> (++count &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断在之前的路径中是否未选择 candidate</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidate</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">notSelected</span><span class="hljs-params">(String candidate)</span> </span>&#123;        <span class="hljs-keyword">return</span> !selectedList.contains(candidate);    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><p>每次变异一个碱基，队列中保存的即为当前可变异的所有基因，且这些基因都在基因库中未被变异过。<br />相当于构建一棵树，进行树的层次遍历。<br />需要注意的是变异完后的碱基需要恢复原样，否则在下一次获取新基因时可能导致多个碱基都发生了变异。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(String start, String end, String[] bank)</span> </span>&#123;        Set&lt;String&gt; unSelectedSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(bank));        <span class="hljs-keyword">if</span> (!unSelectedSet.contains(end)) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">char</span>[] mutGenes = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'T'</span>&#125;;        LinkedList&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(start);        unSelectedSet.remove(start);        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            step++;            <span class="hljs-comment">// 队列中保存的是一个基因一次变异可以产生的新基因序列</span>            <span class="hljs-comment">// 队列为空则表示这次的序列变异结束，进入下一次遍历</span>            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 基因</span>                <span class="hljs-keyword">char</span>[] genes = queue.poll().toCharArray();                <span class="hljs-comment">// 1. 对每个基因位变异</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; genes.length; i++) &#123;                    <span class="hljs-comment">// 保存旧的碱基</span>                    <span class="hljs-keyword">char</span> oldGene = genes[i];                    <span class="hljs-comment">// 2. 基因的每一位依次进行 ACGT 变异</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> mutGene : mutGenes) &#123;                        genes[i] = mutGene;                        <span class="hljs-comment">// 3. 获取碱基变异后的新基因</span>                        String newGene = String.valueOf(genes);                        <span class="hljs-comment">// 4. 变到 end，直接返回</span>                        <span class="hljs-keyword">if</span> (end.equals(newGene)) &#123;                            <span class="hljs-keyword">return</span> step;                            <span class="hljs-comment">// 5. 在未变异的基因库中找到新基因</span>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unSelectedSet.contains(newGene)) &#123;                            unSelectedSet.remove(newGene);                            queue.offer(newGene);                        &#125;                    &#125;                    <span class="hljs-comment">// 变异的基因位要恢复原来的碱基</span>                    <span class="hljs-comment">// 否则在 3 中获取的新基因会变成 TTTT*，进而影响 4, 5</span>                    genes[i] = oldGene;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre><h1 id="双向-bfs"><a class="markdownIt-Anchor" href="#双向-bfs"></a> 双向 BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(String start, String end, String[] bank)</span> </span>&#123;        <span class="hljs-keyword">if</span> (start.length() == <span class="hljs-number">0</span> || end.length() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        Set&lt;String&gt; list = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(bank));        <span class="hljs-keyword">if</span> (!list.contains(end)) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">char</span>[] muteList = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'T'</span>&#125;;        Set&lt;String&gt; beginSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        beginSet.add(start);        Set&lt;String&gt; endSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        endSet.add(end);        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!beginSet.isEmpty() &amp;&amp; !endSet.isEmpty()) &#123;            count++;            <span class="hljs-comment">// 每次都假设从数目小的集合遍历</span>            <span class="hljs-keyword">if</span> (beginSet.size() &gt; endSet.size()) &#123;                Set&lt;String&gt; tmp = beginSet;                beginSet = endSet;                endSet = tmp;            &#125;            <span class="hljs-comment">// 下一次变异的列表</span>            Set&lt;String&gt; nextLevel = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();            <span class="hljs-keyword">for</span> (String word : beginSet) &#123;                <span class="hljs-keyword">char</span>[] words = word.toCharArray();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;                    <span class="hljs-keyword">char</span> old = words[i];                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : muteList) &#123;                        <span class="hljs-keyword">if</span> (old == c) &#123;                            <span class="hljs-keyword">continue</span>;                        &#125;                        words[i] = c;                        String candidate = String.valueOf(words);                        <span class="hljs-keyword">if</span> (endSet.contains(candidate)) &#123;                            <span class="hljs-keyword">return</span> count;                        &#125;                        <span class="hljs-comment">// 这里一定注意只能变异到 bank 中的单词</span>                        <span class="hljs-comment">// 如果使用 used 判断，会加入不在 bank 中的单词，导致出错</span>                        <span class="hljs-keyword">if</span> (list.contains(candidate)) &#123;                            nextLevel.add(candidate);                            list.remove(candidate);                        &#125;                    &#125;                    words[i] = old;                &#125;            &#125;            beginSet = nextLevel;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 102. 二叉树的层序遍历</title>
    <link href="/2020/08/06/LeetCode-102-binary-tree-level-order-traversal/"/>
    <url>/2020/08/06/LeetCode-102-binary-tree-level-order-traversal/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></p><p>主要在于判断每一层有哪些结点：遍历之前先保存每层结点数，然后按层处理结点。</p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(root);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-comment">// 保存当前层的结点数</span>            <span class="hljs-keyword">int</span> n = queue.size();            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-comment">// 遍历当前层的结点</span>            <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 对头出队，并将左右结点入队</span>                <span class="hljs-comment">// 当本轮循环结束后，队列里都是同一层的结点</span>                TreeNode p = queue.poll();                level.add(p.val);                <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) &#123;                    queue.add(p.left);                &#125;                <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) &#123;                    queue.add(p.right);                &#125;            &#125;            <span class="hljs-comment">// 将当前层加入结果</span>            res.add(level);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        dfs(root, <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> level)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (res.size() &lt; level) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(root.val)));        &#125; <span class="hljs-keyword">else</span> &#123;            res.get(level - <span class="hljs-number">1</span>).add(root.val);        &#125;        dfs(root.left, level + <span class="hljs-number">1</span>);        dfs(root.right, level + <span class="hljs-number">1</span>);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 表</title>
    <link href="/2020/08/06/InnoDB-table/"/>
    <url>/2020/08/06/InnoDB-table/</url>
    
    <content type="html"><![CDATA[<h1 id="索引组织表"><a class="markdownIt-Anchor" href="#索引组织表"></a> 索引组织表</h1><p>在 <code>InnoDB</code> 中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（<code>index organized table</code>）。如果在创建表时没有显式地定义主键，则会按以下方式选择或创建主键：</p><ul><li>首先判断表中是否有<strong>非空的唯一索引</strong>（<code>Unique NOT NULL</code>），如果有，则该列为主键；</li><li>否则，自动创建一个 <code>6</code> 字节大小的指针。</li></ul><p>当表中有多个非空唯一索引时，<code>InnoDB</code> 存储引擎将选择建表时第一个定义的非空唯一索引（<strong>索引的顺序</strong>）为主键。</p><h1 id="innodb-逻辑存储结构"><a class="markdownIt-Anchor" href="#innodb-逻辑存储结构"></a> <code>InnoDB</code> 逻辑存储结构</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805154705.png" srcset="/img/loading.gif" alt="" /></p><p>所有数据都存放在表空间，表空间由段（<code>segment</code>）、区（<code>extent</code>）、页（<code>page</code>）组成。</p><h2 id="段"><a class="markdownIt-Anchor" href="#段"></a> 段</h2><ul><li>数据段：<code>B+</code> 树的叶子节点（<code>Leaf node segment</code>）</li><li>索引段：<code>B+</code> 树的非叶子节点（<code>Non-Leaf node segment</code>）</li><li>回滚段：<code>Rollback segment</code></li></ul><h2 id="区"><a class="markdownIt-Anchor" href="#区"></a> 区</h2><p>区是由连续页组成的空间，<strong>在任何情况下每个区的大小都为 <code>1MB</code>。</strong> 为了保证区中页的连续性，<code>InnoDB</code> 一次从磁盘申请 <code>4 ~ 5</code> 个区，在默认情况下，页的大小为 <code>16KB</code>，即一个区中一共有 <code>64</code> 个连续的页。</p><h2 id="页"><a class="markdownIt-Anchor" href="#页"></a> 页</h2><p>页是 <code>InnoDB</code> 磁盘管理的最小单位。可通过 <code>innodb_page_size</code> 将页的大小设置为 <code>4K</code>、<code>8K</code>、<code>16K</code>。</p><h2 id="行"><a class="markdownIt-Anchor" href="#行"></a> 行</h2><p>数据按行存放，每页最多存放 <code>16KB / 2 - 200 = 7992</code> 行的记录。</p><h1 id="innodb-行记录格式"><a class="markdownIt-Anchor" href="#innodb-行记录格式"></a> <code>InnoDB</code> 行记录格式</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805164415.png" srcset="/img/loading.gif" alt="" /></p><h2 id="compact-行记录格式"><a class="markdownIt-Anchor" href="#compact-行记录格式"></a> <code>Compact</code> 行记录格式</h2><p>其目的是高效地存储数据，一个页中存放的数据越多，其性能就越高。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805162732.png" srcset="/img/loading.gif" alt="" /></p><h2 id="redundant-行记录格式"><a class="markdownIt-Anchor" href="#redundant-行记录格式"></a> <code>Redundant</code> 行记录格式</h2><p><code>Redundant</code> 是 <code>MySQL 5.0</code> 之前的行记录存储方式，它是为了兼容之前版本的页格式。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805162855.png" srcset="/img/loading.gif" alt="" /></p><h2 id="行溢出数据"><a class="markdownIt-Anchor" href="#行溢出数据"></a> 行溢出数据</h2><p>如果页中只能存放下一条记录，那么 <code>InnoDB</code> 会自动将行数据存放到溢出页中。</p><h2 id="compressed-和-dynamic-行记录格式"><a class="markdownIt-Anchor" href="#compressed-和-dynamic-行记录格式"></a> <code>Compressed</code> 和 <code>Dynamic</code> 行记录格式</h2><p>这两种记录格式对于存放在 <code>BLOB</code> 中的数据采用了完全的行溢出的方式。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805163825.png" srcset="/img/loading.gif" alt="" /><br />数据页中只存放 <code>20</code> 个字节的指针，实际数据都存放在 <code>Off Page</code> 中。</p><h1 id="约束"><a class="markdownIt-Anchor" href="#约束"></a> 约束</h1><h2 id="数据完整性"><a class="markdownIt-Anchor" href="#数据完整性"></a> 数据完整性</h2><ul><li><strong>实体完整性</strong>：保证表中有一个主键。</li><li><strong>域完整性</strong>：保证数据<strong>每列的值</strong>满足特定的条件。<ul><li>选择合适的数据类型确保一个数据值满足特定条件</li><li>外键约束</li><li>触发器</li><li><code>DEFAULT</code> 约束</li></ul></li><li><strong>参照完整性</strong>：保证<strong>两张表</strong>之间的关系。<ul><li><code>Primary Key</code></li><li><code>Unique Key</code></li><li><code>Foreigh Key</code></li><li><code>Default</code></li><li><code>NOT NULL</code></li></ul></li></ul><h2 id="约束的创建"><a class="markdownIt-Anchor" href="#约束的创建"></a> 约束的创建</h2><ol><li>表建立时进行约束定义</li><li>利用 <code>ALTER TABLE</code> 命令进行创建约束</li></ol><h2 id="约束和索引的区别"><a class="markdownIt-Anchor" href="#约束和索引的区别"></a> 约束和索引的区别</h2><ul><li>约束是一个<strong>逻辑概念</strong>，用来保证数据的完整性；</li><li>索引是一个数据结构，既有<strong>逻辑概念</strong>，在数据库中还代表着<strong>物理存储</strong>的方式。</li></ul><h1 id="视图"><a class="markdownIt-Anchor" href="#视图"></a> 视图</h1><blockquote><p>视图是一个命名的虚表，由一个 <code>SQL</code> 查询定义，视图中的数据没有实际的物理存储。</p></blockquote><p>视图的主要用途是被用做一个抽象装置，程序本身不需要关心基表（<code>base table</code>）的结构，只需要按照视图定义来<strong>获取数据或更新数据</strong>。</p><ul><li>通过定义视图 <code>WITH CHECK OPTION</code> 可对基本表进行更新。</li><li><code>SHOW TABLES</code> 命令也会把视图作为表显示出来。</li></ul><h1 id="分区表"><a class="markdownIt-Anchor" href="#分区表"></a> 分区表</h1><blockquote><p>分区的过程是将一个表或索引分解为多个更小、更可管理的部分。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。<br />从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。</p></blockquote><ul><li><code>MySQL</code> 支持<strong>水平分区</strong>，并不支持垂直分区；</li><li><code>MySQL</code> 的分区是<strong>局部分区索引</strong>，一个分区中既存放了数据又存放了索引。</li></ul><h2 id="分区类型"><a class="markdownIt-Anchor" href="#分区类型"></a> 分区类型</h2><ul><li><code>RANGE</code> 分区：行数据基于属于一个给定连续区间的列值被放入分区。</li><li><code>LIST</code> 分区：和 <code>RANGE</code> 分区类似，只是 <code>LIST</code> 分区面向的是离散的值。</li><li><code>HASH</code> 分区：根据用户自定义的表达式的返回值来进行分区。</li><li><code>KEY</code> 分区：根据 <code>MySQL</code> 提供的哈希函数来进行分区。</li><li><code>COLUMNS</code> 分区：不同于以上四种，该分区可以直接使用非整形的数据进行分区，分区根据类型比较而得，不需要转化为整形。</li></ul><h2 id="子分区"><a class="markdownIt-Anchor" href="#子分区"></a> 子分区</h2><p>子分区是在分区的基础上再进行分区。<code>MySQL</code> 允许在 <code>RANGE</code> 和 <code>LIST</code> 的分区上再进行 <code>HASH</code> 或 <code>KEY</code> 的子分区。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 51. N皇后</title>
    <link href="/2020/08/05/LeetCode-51-n-queens/"/>
    <url>/2020/08/05/LeetCode-51-n-queens/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></p><p>棋盘每一行相当于决策树的每一层，每行的任意一列都可放置皇后。因此，从 <strong>每一行</strong> 开始，选择该行的 <strong>每一列</strong> 作为选择列表进行递归，该行以上的所有行此时都正确放置了皇后，当行数达到棋盘深度时结束递归，返回本次递归的结果。</p><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] row : board) &#123;            Arrays.fill(row, <span class="hljs-string">'.'</span>);        &#125;        backtrack(board, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> board 棋盘</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> row   行号</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> row)</span> </span>&#123;        <span class="hljs-comment">// 行数达到棋盘最后一行结束</span>        <span class="hljs-comment">// 此时棋盘已正确放置皇后，返回本轮结果</span>        <span class="hljs-keyword">if</span> (row == board.length) &#123;            res.add(genBoard(board));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 路径：row 行上面的那些行都成功放置了 Q</span>        <span class="hljs-keyword">char</span>[] line = board[row];        <span class="hljs-comment">// 选择列表：第 row 行的每一列都是 Q 的可选位置</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; line.length; col++) &#123;            <span class="hljs-comment">// 排除不合法选择</span>            <span class="hljs-comment">// 若当前 (row, col) 位置不满足，则进入该行的下一列</span>            <span class="hljs-keyword">if</span> (!isValid(board, row, col)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 做选择</span>            board[row][col] = <span class="hljs-string">'Q'</span>;            <span class="hljs-comment">// 进入下一行决策</span>            backtrack(board, row + <span class="hljs-number">1</span>);            <span class="hljs-comment">// 撤销选择</span>            board[row][col] = <span class="hljs-string">'.'</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 因为其它位置还处于初始状态</span><span class="hljs-comment">     * 只需要验证每一列，左上和右上位置是否有皇后</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> board 棋盘</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> row   当前行</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> col   当前列</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前位置是否可以放置 皇后</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;        <span class="hljs-comment">// 验证 col 所在列是否有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : board) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-string">'Q'</span> == line[col]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 验证当前位置左上角是否有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>;             i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>;             i--, j--) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-string">'Q'</span> == board[i][j]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 验证当前位置右上角是否有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>;             i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; board.length;             i--, j++) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-string">'Q'</span> == board[i][j]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title">genBoard</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        List&lt;String&gt; bd = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : board) &#123;            bd.add(String.valueOf(line));        &#125;        <span class="hljs-keyword">return</span> bd;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 文件</title>
    <link href="/2020/08/05/InnoDB-file/"/>
    <url>/2020/08/05/InnoDB-file/</url>
    
    <content type="html"><![CDATA[<h1 id="参数文件"><a class="markdownIt-Anchor" href="#参数文件"></a> 参数文件</h1><blockquote><p>告诉 <code>MySQL</code> 实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置。</p></blockquote><p><code>MySQL</code> 实例可以不需要参数文件，这时所有的参数值取决于编译 <code>MySQL</code> 时指定的默认值和源代码中指定参数的默认值。</p><p>参数类型：</p><ul><li><strong>动态参数</strong> - 可以在 <code>MySQL</code> 实例运行中进行更改</li><li><strong>静态参数</strong> - 在整个实例生命周期内都不得进行修改</li></ul><h1 id="日志文件"><a class="markdownIt-Anchor" href="#日志文件"></a> 日志文件</h1><blockquote><p>日志文件记录了影响 <code>MySQL</code> 数据库的各种类型活动。</p></blockquote><ul><li><p><strong>错误日志（<code>error log</code>）</strong><br />记录 MySQL 的启动、运行、关闭过程。不仅记录所有错误信息，也记录一些警告或正确的信息。<br />可通过命令 <code>SHOW VARIABLES LIKE 'log_error'</code> 来定位该文件</p></li><li><p><strong>慢查询日志（<code>slow log</code>）</strong><br />定位可能存在问题的 <code>SQL</code> 语句，从而进行 <code>SQL</code> 语句层面的优化。<br />可通过设置参数 <code>long_query_time</code> 来设置阈值（默认为 <code>10</code>），将运行时间超过该值的所有 <code>SQL</code> 语句都记录到该慢查询日志文件中。</p></li><li><p><strong>查询日志（<code>log</code>）</strong><br />记录所有对 <code>MySQL</code> 数据库请求的信息，无论这些请求是否得到了正确的执行。<br />默认文件名为：<code>主机名.log</code></p></li><li><p><strong>二进制日志（<code>binlog</code>）</strong><br />记录对 <code>MySQL</code> 数据库执行更改的所有操作，但是不包括 <code>SELECT</code> 和 <code>SHOW</code> 这类操作。<br />作用：</p><ul><li>恢复（<code>recovery</code>）：数据恢复</li><li>复制（<code>replication</code>）：主从同步</li><li>审计（<code>audit</code>）：判断是否有对数据库进行注入攻击</li></ul></li></ul><h1 id="套接字文件"><a class="markdownIt-Anchor" href="#套接字文件"></a> 套接字文件</h1><p>在 <code>UNIX</code> 系统下本地连接 <code>MySQL</code> 可以采用 <code>UNIX</code> 域套接字方式，通过套接字（<code>socket</code>）文件连接。</p><h1 id="pid-文件"><a class="markdownIt-Anchor" href="#pid-文件"></a> <code>pid</code> 文件</h1><p>当 <code>MySQL</code> 实例启动时，会将自己的进程 <code>ID</code> 写入一个 <code>pid</code> 文件中。<br />默认位于数据库目录下，文件名为：<code>主机名.pid</code>。</p><h1 id="表结构定义文件"><a class="markdownIt-Anchor" href="#表结构定义文件"></a> 表结构定义文件</h1><p><code>MySQL</code> 的数据存储是根据表进行的，每个表/视图都有一个以 <code>frm</code> 为后缀名的文件，该文件记录了该表的表结构定义。</p><h1 id="innodb-存储引擎文件"><a class="markdownIt-Anchor" href="#innodb-存储引擎文件"></a> <code>InnoDB</code> 存储引擎文件</h1><p>以上文件都是 <code>MySQL</code> 数据库本身的文件，而 <code>InnoDB</code> 存储引擎还有其自己独有的文件。</p><h2 id="表空间文件"><a class="markdownIt-Anchor" href="#表空间文件"></a> 表空间文件</h2><p><code>InnoDB</code> 采用将存储的表空间（<code>tablespace</code>）进行存放的设计，默认配置下初始大小为 <code>10MB</code>，文件名为 <code>ibdata1</code>。<br />表空间分为共享表空间与独立表空间，用户可以将每个基于 <code>InnoDB</code> 存储引擎的表产生一个独立表空间，单独的表空间文件仅存储该表的数据、索引和插入缓冲 <code>BITMAP</code> 等信息，其余信息还是存放在默认的表空间中。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805144502.png" srcset="/img/loading.gif" alt="" /></p><h2 id="重做日志文件"><a class="markdownIt-Anchor" href="#重做日志文件"></a> 重做日志文件</h2><p>当实例或介质失败（<code>media failure</code>）时，<code>InnoDB</code> 存储引擎会使用重做日志恢复到实例正常的时刻，以此来保证数据的完整性。</p><p>每个 <code>InnoDB</code> 存储引擎至少有 <code>1</code> 个重做日志文件组，每个文件组下至少有 <code>2</code> 个重做日志文件。</p><p>重做日志文件的大小对存储引擎的性能有非常大的影响。</p><ul><li>如果太大，在恢复时可能需要很长的时间；</li><li>如果太小，可能导致一个事务的日志需要多次切换重做日志文件，还会呆滞频繁地发生 <code>async checkpoint</code>，导致性能的抖动。</li></ul><p><strong>与二进制日志的区别</strong>：</p><ul><li>二进制日志记录与 <code>MySQL</code> 数据库有关的日志记录，包括<strong>所有存储引擎</strong>的日志。<br /><code>InnoDB</code> 的重做日志只记录<strong>该存储引擎本身</strong>的事务日志。</li><li>二进制日志记录关于一个事务的<strong>具体操作内容</strong>。<br />重做日志记录的是每个页的<strong>物理更改</strong>情况。</li><li>二进制日志仅在事务提交前进行提交，<strong>只写磁盘一次</strong>。<br />而事务进行的过程中，不断有重做日志条目被写入到重做日志文件中。</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200805150220.png" srcset="/img/loading.gif" alt="" /><br /><strong>写入流程</strong>：先写入一个重做日志缓冲（<code>redo log buffer</code>）中，然后按照一定的条件顺序地写入日志文件。<br /><strong>写入条件</strong>：</p><ul><li>主线程每秒写入重做日志文件，不论事务是否已经提交。</li><li>在提交（<code>commit</code>）操作时，设置 <code>innodb_flush_log_at_trx_commit = 1</code>，在 <code>commit</code> 提交时将重做日志缓冲同步写到磁盘。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 17. 电话号码的字母组合</title>
    <link href="/2020/08/04/LeetCode-17-letter-combinations-of-a-phone-number/"/>
    <url>/2020/08/04/LeetCode-17-letter-combinations-of-a-phone-number/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></p><h1 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h1><p>选择列表：每个 <code>digit</code> 对应的字母列表<br />路径：已选字母组合 + 选择列表的字母<br />终止条件：递归深度达到 <code>digits</code> 的长度</p><pre><code class="hljs java"><span class="hljs-comment">// 2 ~ 9 每个位置所对应的选择列表</span>String[] map = &#123;<span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>, <span class="hljs-string">"ghi"</span>, <span class="hljs-string">"jkl"</span>, <span class="hljs-string">"mno"</span>, <span class="hljs-string">"pqrs"</span>, <span class="hljs-string">"tuv"</span>, <span class="hljs-string">"wxyz"</span>&#125;;List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;    <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    combine(digits, <span class="hljs-string">""</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> digits</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> path   当前已选择的组合路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> len    当前递归到的 digits 位置</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">combine</span><span class="hljs-params">(String digits, String path, <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-comment">// 递归深度为 digits 的长度</span>    <span class="hljs-keyword">if</span> (len == digits.length()) &#123;        res.add(path);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 找到当前 digit 所对应的字母组合</span>    <span class="hljs-keyword">char</span> c = digits.charAt(len);    <span class="hljs-keyword">int</span> pos = c - <span class="hljs-string">'0'</span>;    <span class="hljs-comment">// 所需要的选择列表</span>    String candidateString = map[pos];    <span class="hljs-comment">// 枚举每个字母组合</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; candidateString.length(); i++) &#123;        <span class="hljs-comment">// 路径为：上一轮的路径 + 选择列表中的每个字母</span>        <span class="hljs-comment">// 递归深度/路径长度 + 1</span>        combine(digits, path + candidateString.charAt(i), len + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><p><code>8.16</code> 按照模板的回溯解法：添加 <code>add</code>，<code>remove</code> 操作。<br />一开始 <code>path</code> 使用的是 <code>List</code>，总是无法通过，后来发现若是 <code>digits</code> 由同一个数字组成的情况下，路径中的元素可能是重复的，此时使用 <code>list.remove()</code> 操作会删除错误位置的元素，使用栈的思想可解决这个问题。</p><pre><code class="hljs java">List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();String[] num2Str = &#123;<span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>, <span class="hljs-string">"ghi"</span>, <span class="hljs-string">"jkl"</span>, <span class="hljs-string">"mno"</span>, <span class="hljs-string">"pqrs"</span>, <span class="hljs-string">"tuv"</span>, <span class="hljs-string">"wxyz"</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;    <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">// 使用 StringBuilder</span>    <span class="hljs-comment">// 如果使用 List，当例子为 "999" 等相同数字时，在回溯时 remove 会出错</span>    StringBuilder path = <span class="hljs-keyword">new</span> StringBuilder();    backtrack(<span class="hljs-number">0</span>, path, digits);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len, StringBuilder path, String digits)</span> </span>&#123;    <span class="hljs-keyword">if</span> (len == digits.length()) &#123;        res.add(path.toString());        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> pos = digits.charAt(len) - <span class="hljs-string">'0'</span>;    String str = num2Str[pos];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; str.length(); j++) &#123;        String candidate = String.valueOf(str.charAt(j));        <span class="hljs-comment">// 末尾添加</span>        path.append(candidate);        backtrack(len + <span class="hljs-number">1</span>, path, digits);        <span class="hljs-comment">// 末尾删除</span>        path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h1 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h1><blockquote><p>‘’<br />a, b, c<br />b, c, ad, ae, af<br />…</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">// 2 ~ 9 每个位置所对应的选择列表</span>    String[] map = &#123;<span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>, <span class="hljs-string">"ghi"</span>, <span class="hljs-string">"jkl"</span>, <span class="hljs-string">"mno"</span>, <span class="hljs-string">"pqrs"</span>, <span class="hljs-string">"tuv"</span>, <span class="hljs-string">"wxyz"</span>&#125;;    <span class="hljs-comment">// 添加空元素，初始化时使第一个位置的字母入队</span>    res.add(<span class="hljs-string">""</span>);    <span class="hljs-comment">// 1. 遍历 digits e.g. "23"</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; digits.length(); i++) &#123;        <span class="hljs-keyword">int</span> pos = digits.charAt(i) - <span class="hljs-string">'0'</span>;        <span class="hljs-comment">// 选择列表 e.g. "def"</span>        String candidateStr = map[pos];        <span class="hljs-comment">// 2. 遍历队列，组合字母 res: a, b, c</span>        <span class="hljs-comment">// !! 先缓存当前的队列长度，否则动态 add path 时，队列长度在变化</span>        <span class="hljs-keyword">int</span> size = res.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++) &#123;            <span class="hljs-comment">// 队头出队 e.g. a</span>            String path = res.remove(<span class="hljs-number">0</span>);            <span class="hljs-comment">// 3. 组合队头和选择列表</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; candidateStr.length(); k++) &#123;                <span class="hljs-comment">// b, c, ad, ae, af</span>                res.add(path + candidateStr.charAt(k));            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 存储引擎</title>
    <link href="/2020/08/04/InnoDB-engine/"/>
    <url>/2020/08/04/InnoDB-engine/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql-体系结构"><a class="markdownIt-Anchor" href="#mysql-体系结构"></a> MySQL 体系结构</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200804132116.png" srcset="/img/loading.gif" alt="" /></p><ul><li>连接池组件</li><li>管理服务和工具类</li><li><code>SQL</code> 接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲组件</li><li>插件式存储引擎</li><li>物理文件</li></ul><blockquote><p>存储引擎是基于表的，而不是数据库。</p></blockquote><h1 id="innodb-体系架构"><a class="markdownIt-Anchor" href="#innodb-体系架构"></a> <code>InnoDB</code> 体系架构</h1><p><code>InnoDB</code> 存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池：负责以下工作：</p><ul><li>维护所有进程、线程需要访问的多个内部数据结构</li><li>缓存磁盘数据</li><li>重做日志缓冲</li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200804133649.png" srcset="/img/loading.gif" alt="" /></p><p>后台线程的主要作用是<strong>负责刷新内存池中的数据</strong>，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下 <code>InnoDB</code> 能恢复到正常运行状态。</p><h2 id="后台线程"><a class="markdownIt-Anchor" href="#后台线程"></a> 后台线程</h2><ul><li><p><code>Master Thread</code><br /><code>Master Thread</code> 是一个非常核心的后台线程，主要负责将缓冲池中的<strong>数据异步刷新</strong>到磁盘，保证数据的一致性。包括脏页的刷新、合并插入缓冲、<code>UNDO</code> 页的回收等。</p></li><li><p><code>IO Thread</code><br /><code>InnoDB</code> 存储引擎中大量使用了 <code>AIO</code> 来处理写请求，<code>IO Thread</code> 的工作主要是负责这些 <strong><code>IO</code> 请求的回调处理</strong>。</p></li><li><p><code>Purge Thread</code><br />事务被提交后，其所使用的 <code>undolog</code> 可能不再需要，因此需要使用 <code>Purge Thread</code> 来<strong>回收</strong>已经使用并分配的 <code>undo</code> 页。</p></li><li><p><code>Page Cleaner Thread</code><br />其作用是将<strong>脏页的刷新操作</strong>都放入到单独的线程中来完成，其目的是为了减轻 <code>Master Thread</code> 的工作及对于用户查询线程的阻塞，进一步提高 <code>InnoDB</code> 的性能。</p></li></ul><h2 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200804135715.png" srcset="/img/loading.gif" alt="" /></p><h3 id="缓冲池"><a class="markdownIt-Anchor" href="#缓冲池"></a> 缓冲池</h3><p><code>InnoDB</code> 存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。<br />对于数据库中页的修改操作，首先修改在缓冲池中的页，然后再通过 <code>Checkpoint</code> 机制刷新到磁盘上。</p><h3 id="lru-list-free-list-flush-list"><a class="markdownIt-Anchor" href="#lru-list-free-list-flush-list"></a> <code>LRU List</code>, <code>Free List</code>, <code>Flush List</code></h3><p><code>InnoDB</code> 存储引擎中，<code>LRU List</code> 中还加入了 <code>midpoint</code> 位置，<code>midpoint</code> 之后的列表称为 <code>old</code> 列表， 之前的列表称为 <code>new</code> 列表，<code>new</code> 列表中的页都是最为活跃的热点数据。新读取到的页，并不是直接放入 <code>LRU</code> 列表的首部，而是放入 <code>LRU</code> 列表的 <code>midpoint</code> 位置。在默认配置下，这个位置在 <code>LRU</code> 列表长度的 <code>5/8</code> 处。</p><blockquote><p>那为什么不采用朴素的 <code>LRU</code> 算法，直接将读取的页放入到 <code>LRU List</code> 的首部呢？<br />若直接将读取到的页放人到 <code>LRU</code> 的首部，那么某些 <code>SQL</code> 操作可能会使缓冲池中的热点数据被刷新，而在下一次需要读取该页时，需要再次访问磁盘。<br />常见的这类操作为<strong>索引</strong>或<strong>数据的扫描</strong>操作。这类操作需要访问表中的许多页，甚至是全部的页，而这些页通常来说又仅在这次查询操作中需要，并不是活跃的热点数据。</p></blockquote><p><code>LRU List</code> 用来管理已经读取的页，但当数据库刚启动时，<code>LRU List</code> 是空的，即没有任何的页。这时页都存放在 <code>Free List</code> 中。当需要从缓冲池中分页时，首先从 <code>Free List</code> 中查找是否有可用的空闲页</p><ul><li>若有则将该页从 <code>Free List</code> 中删除，放入到 <code>LRU List</code> 中。</li><li>否则，根据 <code>LRU</code> 算法，淘汰 <code>LRU List</code> 末尾的页，将该内存空间分配给新的页。</li></ul><ul><li><code>page made young</code>: 页从 <code>LRU List</code> 的 <code>old</code> 部分加入到 <code>new</code> 部分。</li><li><code>page not made young</code>: 因为 <code>innodb-old_blocks-time</code> 的设置而导致页没有从 <code>old</code> 部分移动到 <code>new</code> 部分。</li></ul><p>当 <code>LRU List</code> 中的页被修改后，称该页为脏页（<code>dirty page</code>），即缓冲池中的页和磁盘上的页数据产生了不一致。这时候数据库会通过 <code>checkpoint</code> 机制将脏页刷新回磁盘，而 <code>Flush List</code> 中的页即为脏页列表。注意脏页也存在于 <code>LRU List</code> 中。</p><h3 id="重做日志缓冲"><a class="markdownIt-Anchor" href="#重做日志缓冲"></a> 重做日志缓冲</h3><p><code>InnoDB</code> 引擎首先将重做日志信息先放到重做日志缓冲区(<code>redo log buffer</code>)，然后按一定频率刷新到重做日志文件。重做日志缓冲不需要设置很大，一般每一秒都会刷新 <code>redo log buffer</code>，配置的大小只需要保证每秒产生的事务在这个缓冲区大小之内即可。通过参数 <code>innodb_log_buffer_size</code> 设置。<br />在下列情况下会将重做日志缓冲中的内容刷新到磁盘重做日志文件中：</p><ul><li><code>Master Thread</code> 每一秒中刷新一次；</li><li>每个事务提交时会刷新；</li><li>当重做日志缓冲区空间小于 <code>1/2</code> 时会刷新。</li></ul><h3 id="额外的内存池"><a class="markdownIt-Anchor" href="#额外的内存池"></a> 额外的内存池</h3><p>额外的内存池用来对一些数据结构本身的内存进行分配，例如缓冲控制对象(<code>buffer control block</code>)记录的 <code>LRU</code>，锁，等待等信息。额外的内存池不够时会从缓冲池中进行申请。因此，在申请了很大的 <code>InnoDB</code> 缓冲池时，额外的内存池也要适当的调大。通过参数 <code>innodb_additional_mem_pool_size</code> 来设置大小。</p><h1 id="checkpoint-技术"><a class="markdownIt-Anchor" href="#checkpoint-技术"></a> <code>Checkpoint</code> 技术</h1><p>作用：将脏页刷新到磁盘。<br />目的：</p><ul><li>缩短数据库的恢复时间</li><li>缓冲池不够用时，将脏页刷新到磁盘</li><li>重做日志不可用时，刷新脏页</li></ul><p>类型：</p><ul><li><code>Sharp Checkpoint</code> - 数据库关闭时将所有的脏页都刷新回磁盘。</li><li><code>Fuzzy Checkpoint</code>:<ul><li><code>Master THread Checkpoint</code> - 每秒或每十秒刷新</li><li><code>FLUSH_LRU_LIST Checkpoint</code> - 脏页来自于 <code>LRU List</code></li><li><code>Async/Sync Flush Checkpoint</code> - 重做日志不可用，强制刷新脏页</li><li><code>Dirty Page too mush Checkpoint</code> - 脏页太多强制刷新</li></ul></li></ul><h1 id="master-thread-工作方式"><a class="markdownIt-Anchor" href="#master-thread-工作方式"></a> <code>Master Thread</code> 工作方式</h1><p><code>Master Thread</code> 具有<strong>最高的线程优先级别</strong>，其内部由多个循环组成</p><ul><li>主循环（<code>loop</code>）</li><li>后台循环（<code>background loop</code>）</li><li>刷新循环（<code>lush loop</code>）</li><li>暂停循环（<code>suspend loop</code>）</li></ul><h2 id="主循环"><a class="markdownIt-Anchor" href="#主循环"></a> 主循环</h2><p>大多数的操作都是在<strong>主循环</strong>中，其中包括每秒的操作和每 <code>10</code> 秒的操作。</p><p>每秒的操作：</p><ul><li>日志缓冲刷新到磁盘，即使这个事务还没提交（总是）</li><li>合并插入缓冲（前一秒 <code>IO</code> 小于 <code>5</code> 次）</li><li>至多刷新 <code>100</code> 个 脏页到磁盘（脏页比例超过阈值）</li><li>如果没有用户活动，切换到后台循环</li></ul><p>每 <code>10</code> 秒的操作：</p><ul><li>刷新 <code>100</code> 个脏页到磁盘（过去 <code>10</code> 秒 <code>IO</code> 小于 <code>200</code> 次）</li><li>合并至多 <code>5</code> 个插入缓冲（总是）</li><li>将日志缓冲刷新到磁盘 （总是）</li><li>删除无用的 <code>undo</code> 页（总是）</li><li>刷新 <code>100</code> 个或者 <code>10</code> 个脏页到磁盘（总是）</li></ul><h2 id="后台循环"><a class="markdownIt-Anchor" href="#后台循环"></a> 后台循环</h2><blockquote><p>当前没有用户活动（数据库空闲时）或数据库关闭时，切换到后台循环。<br />操作：</p></blockquote><ul><li>删除无用的 <code>undo</code> 页（总是）</li><li>合并 <code>20</code> 个插入缓冲（总是）</li><li>调回到主循环（总是）</li><li>不断刷新 <code>100</code> 个页直到符合条件（可能，跳转到 <code>flush loop</code> 中完成）</li></ul><h1 id="innodb-关键特性"><a class="markdownIt-Anchor" href="#innodb-关键特性"></a> <code>InnoDB</code> 关键特性</h1><h2 id="插入缓冲"><a class="markdownIt-Anchor" href="#插入缓冲"></a> 插入缓冲</h2><h3 id="insert-buffer"><a class="markdownIt-Anchor" href="#insert-buffer"></a> <code>Insert Buffer</code></h3><p>对于<strong>非聚集索引</strong>的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入；若不在，则先放入到一个 <code>Insert Buffr</code> 对象中。<br />然后再以一定频率和情况进行插入缓冲的合并操作，将多个插入合并到一个操作中。</p><p>使用条件：</p><ol><li>索引是辅助索引</li><li>索引不是唯一的</li></ol><h3 id="change-buffer"><a class="markdownIt-Anchor" href="#change-buffer"></a> <code>Change Buffer</code></h3><p><code>Change Buffer</code> 可视为 <code>Insert Buffer</code> 的升级，可以对 <code>DML</code> 操作：<code>INSERT</code>, <code>DELETE</code>, <code>UPDATE</code> 都进行缓冲，分别是：<code>Insert Buffer</code>, <code>Delete Buffer</code>, <code>Purge Buffer</code>。</p><p>适用对象依然是<strong>非唯一的辅助索引</strong>。<br /><code>Insert/Change Buffer</code> 是一棵 <code>B+</code> 树。</p><p>操作过程：</p><ol><li>将记录标记为已删除（<code>Delete Buffer</code>）；</li><li>真正将记录删除（<code>Purge Buffer</code>）。</li></ol><h3 id="merge-insert-buffer"><a class="markdownIt-Anchor" href="#merge-insert-buffer"></a> <code>Merge Insert Buffer</code></h3><p><code>Merge Insert Buffer</code> 的操作可能发生在以下几种情况下：</p><ul><li>辅助索引页被读取到缓冲池时；</li><li><code>Insert Buffer Bitmap</code> 页追踪到该辅助索引页已无可用空间时；</li><li><code>Master Thread</code>：每秒或每 <code>10</code> 秒。</li></ul><h2 id="两次写"><a class="markdownIt-Anchor" href="#两次写"></a> 两次写</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200804162449.png" srcset="/img/loading.gif" alt="" /></p><ol><li>当刷新缓冲池脏页时，并不直接写到数据文件中，而是先拷贝至内存中的两次写缓冲区；</li><li>接着从两次写缓冲区分两次写入磁盘共享表空间中，每次写入 <code>1MB</code>；</li><li>待第2步完成后，再将两次写缓冲区写入数据文件。</li></ol><p>这样就可以解决<strong>部分写失效</strong>的问题，因为在磁盘共享表空间中已有数据页副本拷贝，如果数据库在页写入数据文件的过程中宕机，在实例恢复时，可以从共享表空间中找到该页副本，将其拷贝覆盖原有的数据页，再应用重做日志即可。</p><h2 id="自适应哈希索引"><a class="markdownIt-Anchor" href="#自适应哈希索引"></a> 自适应哈希索引</h2><blockquote><p><code>InnoDB</code> 会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。它是通过缓冲池中的 <code>B+</code> 树构造而来，且不需要对整个表建立哈希索引，因此它的速度非常快。</p></blockquote><p><code>InnoDB</code> 采用自适应哈希索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引。</p><h2 id="异步-io"><a class="markdownIt-Anchor" href="#异步-io"></a> 异步 IO</h2><ul><li><code>AIO</code> 可以使用户在发出一个 <code>IO</code> 请求后立即再发出另一个 <code>IO</code> 请求，当全部请求发送完毕后，等待所有 <code>IO</code> 操作的完成。</li><li>可以进行 <code>IO Merge</code> 操作，将多个 <code>IO</code> 合并为 <code>1</code> 个 <code>IO</code>。</li></ul><h2 id="刷新邻接页"><a class="markdownIt-Anchor" href="#刷新邻接页"></a> 刷新邻接页</h2><p>当刷新一个脏页时，<code>InnoDB</code> 会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。<br />好处是通过 <code>AIO</code> 将多个 <code>IO</code> 写入操作合并成一个 <code>IO</code> 操作，在传统机械硬盘下有着显著优势。而对于固态硬盘建议关闭此特性。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 169. 多数元素</title>
    <link href="/2020/08/03/LeetCode-169-majority-element/"/>
    <url>/2020/08/03/LeetCode-169-majority-element/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></p><h1 id="解法一hashmap"><a class="markdownIt-Anchor" href="#解法一hashmap"></a> 解法一：<code>HashMap</code></h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = nums.length;    <span class="hljs-keyword">int</span> maj = n / <span class="hljs-number">2</span>;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(n);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">if</span> (map.get(num) != <span class="hljs-keyword">null</span>) &#123;            map.put(num, map.get(num) + <span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            map.put(num, <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;        <span class="hljs-keyword">if</span> (entry.getValue() &gt; maj) &#123;            <span class="hljs-keyword">return</span> entry.getKey();        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h1 id="解法二排序"><a class="markdownIt-Anchor" href="#解法二排序"></a> 解法二：排序</h1><blockquote><p>给定的数组总是存在多数元素。</p></blockquote><p>排序后中间位置的元素一定是众数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        Arrays.sort(nums);        <span class="hljs-keyword">return</span> nums[nums.length / <span class="hljs-number">2</span>];&#125;</code></pre><ul><li>时间复杂度：<code>O(nlogn)</code></li><li>空间复杂度：<code>O(logn)</code></li></ul><h1 id="解法三随机化"><a class="markdownIt-Anchor" href="#解法三随机化"></a> 解法三：随机化</h1><p>因为超过 <code>n/2</code> 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;       <span class="hljs-keyword">int</span> maj = nums.length / <span class="hljs-number">2</span>;       Random random = <span class="hljs-keyword">new</span> Random();       <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;           <span class="hljs-keyword">int</span> candidate = nums[getRandIdx(random, <span class="hljs-number">0</span>, nums.length)];           <span class="hljs-keyword">if</span> (count(nums, candidate) &gt; maj) &#123;               <span class="hljs-keyword">return</span> candidate;           &#125;       &#125;   &#125;   <span class="hljs-comment">// 1. 获取随机位置</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRandIdx</span><span class="hljs-params">(Random random, <span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> max)</span> </span>&#123;       <span class="hljs-keyword">return</span> random.nextInt(max - min) + min;   &#125;   <span class="hljs-comment">// 2. 计算 candidate 出现次数</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> candidate)</span> </span>&#123;       <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;           <span class="hljs-keyword">if</span> (nums[i] == candidate) &#123;               count++;           &#125;       &#125;       <span class="hljs-keyword">return</span> count;   &#125;</code></pre><ul><li>时间复杂度：理论上最坏情况下的时间复杂度为 <code>O(∞)</code>，平均时间复杂度为 <code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h1 id="方法四分治"><a class="markdownIt-Anchor" href="#方法四分治"></a> 方法四：分治</h1><p>将数组分成左右两部分，直到所有的子问题都是长度为 <code>1</code> 的数组，分别求出左半部分的众数 <code>leftEle</code> 以及右半部分的众数 <code>rightEle</code>，随后在 <code>leftEle</code> 和 <code>rightEle</code> 中选出正确的众数。</p><ul><li>如果回溯后某区间的长度为 <code>1</code>，则子数组中唯一的数显然是众数，直接返回即可。</li><li>如果回溯后某区间的长度大于 <code>1</code>，我们必须将左右子区间的值合并。<ul><li>如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。</li><li>如果它们的众数不同，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">return</span> majEle(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majEle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-comment">// 1. 数组区间中只有一个元素，则直接返回</span>    <span class="hljs-keyword">if</span> (low == high) &#123;        <span class="hljs-keyword">return</span> nums[low];    &#125;    <span class="hljs-comment">// 2. 区间中存在多个元素，计算左右部分的众数</span>    <span class="hljs-keyword">int</span> mid = (high - low) / <span class="hljs-number">2</span> + low;    <span class="hljs-keyword">int</span> leftEle = majEle(nums, low, mid);    <span class="hljs-keyword">int</span> rightEle = majEle(nums, mid + <span class="hljs-number">1</span>, high);    <span class="hljs-comment">//  2.1 左右部分的众数相等</span>    <span class="hljs-keyword">if</span> (leftEle == rightEle) &#123;        <span class="hljs-keyword">return</span> leftEle;    &#125;    <span class="hljs-comment">// 2.2 左右部分众数不等，则计算他们在整个区间的出现次数</span>    <span class="hljs-keyword">int</span> lCount = count(nums, leftEle, low, high);    <span class="hljs-keyword">int</span> rCount = count(nums, rightEle, low, high);    <span class="hljs-keyword">return</span> lCount &gt; rCount ? leftEle : rightEle;&#125;<span class="hljs-comment">// 计算 candidate 出现次数</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> candidate, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt;= high; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] == candidate) &#123;            count++;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><ul><li>时间复杂度：<code>O(nlogn)</code>。</li><li>空间复杂度：<code>O(logn)</code>。尽管分治算法没有直接分配额外的数组空间，但在递归的过程中使用了额外的栈空间。算法每次将数组从中间分成两部分，所以数组长度变为 <code>1</code> 之前需要进行 <code>O(logn)</code> 次递归，即空间复杂度为 <code>O(logn)</code>。</li></ul><h1 id="方法五boyer-moore-投票算法"><a class="markdownIt-Anchor" href="#方法五boyer-moore-投票算法"></a> 方法五：<code>Boyer-Moore</code> 投票算法</h1><ul><li><p>我们维护一个候选众数 <code>candidate</code> 和它出现的次数 <code>count</code>。初始时 <code>candidate</code> 可以为任意值，<code>count</code> 为 0；</p></li><li><p>我们遍历数组 <code>nums</code> 中的所有元素，对于每个元素 <code>x</code>，在判断 <code>x</code> 之前，如果 <code>count</code> 的值为 0，我们先将 <code>x</code> 的值赋予 <code>candidate</code>，随后我们判断 x：</p><ul><li><p>如果 <code>x</code> 与 <code>candidate</code> 相等，那么计数器 <code>count + 1</code>；</p></li><li><p>如果 <code>x</code> 与 <code>candidate</code> 不等，那么计数器 <code>count - 1</code>。</p></li></ul></li><li><p>在遍历完成后，<code>candidate</code> 即为整个数组的众数。</p></li></ul><p>举个例子，我们的输入数组为 <code>[1, 1, 0, 0, 0, 1, 0]</code>，那么 <code>0</code> 就是多数元素。<br />首先，<code>candidate</code> 被设置为第一个元素 <code>1</code>，<code>count</code> 也变成 <code>1</code>，由于 <code>1</code> 不是多数元素，所以当扫描到数组某个位置时，<code>count</code> 一定会减为 <code>0</code> 。在我们的例子中，当扫描到第四个位置时，<code>count</code> 变成 <code>0</code>.</p><p><code>count</code> 值变化过程：<br /><code>[1, 2, 1, 0 ……]</code></p><p>当 <code>count</code> 变成 <code>0</code> 时，对于每一个出现的 <code>1</code>，我们都用一个 <code>0</code> 与其进行抵消，所以我们消耗掉了与其一样多的<code>0</code>，而 <code>0</code> 是多数元素，这意味着当扫描到第四个位置时，我们已经最大程度的消耗掉了多数元素。然而，对于数组从第五个位置开始的剩余部分，<code>0</code> 依然是其中的多数元素(注意，多数元素出现次数大于 <code>⌊ n/2 ⌋</code>，而我们扫描过的部分中多数元素只占一半，那剩余部分中多数元素还有一半)。如果之前用于抵消的元素中存在非多数元素，那么数组剩余部分包含的多数元素就更多了。</p><blockquote><p>数组中从 <code>candidate</code> 被赋值到 <code>count</code> 减到 <code>0</code> 的那一段可以被去除，余下部分的多数元素依然是原数组的多数元素。我们可以不断重复这个过程，直到扫描到数组尾部，那么 <code>count</code> 必然会大于 <code>0</code>，而且这个 <code>count</code> 对应的 <code>candinate</code> 就是原数组的多数元素。</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> candidate = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;            candidate = num;        &#125;        count += (candidate == num) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> candidate;&#125;</code></pre><ul><li><p>时间复杂度：<code>O(n)</code>。</p></li><li><p>空间复杂度：<code>O(1)</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VIM 指令记录</title>
    <link href="/2020/08/01/vim-command/"/>
    <url>/2020/08/01/vim-command/</url>
    
    <content type="html"><![CDATA[<p><code>vim</code> 常用指令记录</p><h1 id="命令模式"><a class="markdownIt-Anchor" href="#命令模式"></a> 命令模式</h1><h2 id="光标移动"><a class="markdownIt-Anchor" href="#光标移动"></a> 光标移动</h2><table><thead><tr><th style="text-align:center">cmd</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>h</code></td><td style="text-align:center">左移一个字符</td></tr><tr><td style="text-align:center"><code>l</code></td><td style="text-align:center">右移</td></tr><tr><td style="text-align:center"><code>k</code></td><td style="text-align:center">上移</td></tr><tr><td style="text-align:center"><code>j</code></td><td style="text-align:center">下移</td></tr><tr><td style="text-align:center"><code>{n}{op}</code></td><td style="text-align:center"><code>10j</code> 表示下移 <code>10</code> 行</td></tr><tr><td style="text-align:center"><code>{n}&lt;Space&gt;</code></td><td style="text-align:center">向后移动 <code>n</code> 个字符</td></tr><tr><td style="text-align:center"><code>{n}&lt;Enter&gt;</code></td><td style="text-align:center"><strong>向下移动 <code>n</code> 行</strong></td></tr><tr><td style="text-align:center"><code>$</code></td><td style="text-align:center"><strong>移动到行首</strong></td></tr><tr><td style="text-align:center"><code>0</code></td><td style="text-align:center"><strong>移动到行尾</strong></td></tr><tr><td style="text-align:center"><code>ctrl + f</code></td><td style="text-align:center"><strong>Page Down</strong></td></tr><tr><td style="text-align:center"><code>ctrl + b</code></td><td style="text-align:center"><strong>Page Up</strong></td></tr><tr><td style="text-align:center"><code>ctrl + d</code></td><td style="text-align:center">下移半页</td></tr><tr><td style="text-align:center"><code>ctrl + u</code></td><td style="text-align:center">上移半页</td></tr><tr><td style="text-align:center"><code>H</code></td><td style="text-align:center">移动到这个屏幕的第一行的第一个字符</td></tr><tr><td style="text-align:center"><code>M</code></td><td style="text-align:center">移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td style="text-align:center"><code>L</code></td><td style="text-align:center">移动到这个屏幕的最后一行的第一个字符</td></tr><tr><td style="text-align:center"><code>gg</code></td><td style="text-align:center"><strong>移动到文件第一行</strong></td></tr><tr><td style="text-align:center"><code>G</code></td><td style="text-align:center"><strong>移动到文件最后一行</strong></td></tr><tr><td style="text-align:center"><code>{n}G</code></td><td style="text-align:center">移动到第 <code>n</code> 行</td></tr></tbody></table><h2 id="剪切删除"><a class="markdownIt-Anchor" href="#剪切删除"></a> 剪切/删除</h2><table><thead><tr><th style="text-align:center">cmd</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>x</code>, <code>X</code></td><td style="text-align:center">delete, backspace</td></tr><tr><td style="text-align:center"><code>{n}x</code></td><td style="text-align:center">向后删除 <code>n</code> 个字符</td></tr><tr><td style="text-align:center"><code>dd</code></td><td style="text-align:center"><strong>删除一行</strong></td></tr><tr><td style="text-align:center"><code>{n}dd</code></td><td style="text-align:center"><strong>删除 <code>n</code> 行</strong></td></tr><tr><td style="text-align:center"><code>d1G</code></td><td style="text-align:center">删除第一行到光标所在行</td></tr><tr><td style="text-align:center"><code>dG</code></td><td style="text-align:center">删除光标所在行到最后一行</td></tr><tr><td style="text-align:center"><code>d0</code></td><td style="text-align:center"><strong>删除光标到该行首部</strong></td></tr><tr><td style="text-align:center"><code>d$</code></td><td style="text-align:center"><strong>删除光标所在处，到该行尾部(包括光标选中的字符)</strong></td></tr></tbody></table><h2 id="复制"><a class="markdownIt-Anchor" href="#复制"></a> 复制</h2><table><thead><tr><th style="text-align:center">cmd</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>y</code></td><td style="text-align:center"><code>v</code> 选中</td></tr><tr><td style="text-align:center"><code>yy</code></td><td style="text-align:center"><strong>复制一行</strong></td></tr><tr><td style="text-align:center"><code>{n}yy</code></td><td style="text-align:center"><strong>复制 <code>n</code> 行</strong></td></tr><tr><td style="text-align:center"><code>y1G</code></td><td style="text-align:center">复制第一行到光标所在行</td></tr><tr><td style="text-align:center"><code>yG</code></td><td style="text-align:center">复制光标所在行到最后一行</td></tr><tr><td style="text-align:center"><code>y0</code></td><td style="text-align:center"><strong>复制光标到该行首部</strong></td></tr><tr><td style="text-align:center"><code>y$</code></td><td style="text-align:center"><strong>复制光标所在处，到该行尾部(包括光标选中的字符)</strong></td></tr></tbody></table><h2 id="粘贴"><a class="markdownIt-Anchor" href="#粘贴"></a> 粘贴</h2><table><thead><tr><th style="text-align:center">cmd</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>p</code>, <code>P</code></td><td style="text-align:center">粘贴在上/下一行</td></tr><tr><td style="text-align:center"><code>J</code></td><td style="text-align:center">合并光标所在行和下一行</td></tr></tbody></table><h2 id="撤销-重做-重复"><a class="markdownIt-Anchor" href="#撤销-重做-重复"></a> 撤销、重做、重复</h2><table><thead><tr><th style="text-align:center">cmd</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>u</code></td><td style="text-align:center"><strong>撤销</strong></td></tr><tr><td style="text-align:center"><code>ctrl + r</code></td><td style="text-align:center"><strong>重做</strong></td></tr><tr><td style="text-align:center"><code>.</code></td><td style="text-align:center"><strong>重复上一个动作</strong></td></tr></tbody></table><h1 id="末行模式"><a class="markdownIt-Anchor" href="#末行模式"></a> 末行模式</h1><p>只记录不熟悉的</p><table><thead><tr><th style="text-align:center">cmd</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>ZZ</code></td><td style="text-align:center">相当于 <code>wq</code></td></tr><tr><td style="text-align:center"><code>ZQ</code></td><td style="text-align:center">相当于 <code>q!</code></td></tr><tr><td style="text-align:center"><code>:w {filename}</code></td><td style="text-align:center">save as</td></tr><tr><td style="text-align:center"><code>:r {filename}</code></td><td style="text-align:center">将 <code>filename</code> 文件追加到光标后</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 内存模型</title>
    <link href="/2020/07/29/java-memory-model/"/>
    <url>/2020/07/29/java-memory-model/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Java</code> 内存模型（<code>Java Memory Model</code>），简称 <code>JMM</code>。</p><p><code>JVM</code> 中试图定义一种 <code>JMM</code> 来屏蔽各种硬件和操作系统的内存访问差异，以实现让 <code>Java</code> 程序在各种平台下都能达到一致的内存访问效果。</p></blockquote><h1 id="物理内存模型"><a class="markdownIt-Anchor" href="#物理内存模型"></a> 物理内存模型</h1><p>物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</p><h2 id="硬件处理效率"><a class="markdownIt-Anchor" href="#硬件处理效率"></a> 硬件处理效率</h2><p>物理内存的第一个问题是：硬件处理效率。</p><ul><li><p>绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少需要与<strong>内存交互</strong>，如读取运算数据、存储运算结果，这个 <code>I/O</code> 操作是很难消除的（无法仅靠寄存器完成所有运算任务）。</p></li><li><p><strong>由于计算机的存储设备与处理器的运算速度有几个数量级的差距</strong> ，这种速度上的矛盾，会降低硬件的处理效率。所以，现代计算机都不得不 <strong>加入高速缓存（Cache）</strong> 来作为内存和处理器之间的缓冲。将需要用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步会内存中，这样处理器就无需等待缓慢的内存读写了。</p></li></ul><h2 id="缓存一致性"><a class="markdownIt-Anchor" href="#缓存一致性"></a> 缓存一致性</h2><p>高速缓存解决了 硬件效率问题，但是引入了一个新的问题：缓存一致性（<code>Cache Coherence</code>）。</p><p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。</p><p>为了解决缓存一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200729160602.png" srcset="/img/loading.gif" alt="" /></p><h2 id="代码乱序执行优化"><a class="markdownIt-Anchor" href="#代码乱序执行优化"></a> 代码乱序执行优化</h2><p>除了高速缓存以外，为了使得处理器内部的运算单元尽量被充分利用，处理器可能会对输入代码进行乱序执行（<code>Out-Of-Order Execution</code>）优化。处理器会在计算之后将乱序执行的结果重组，<strong>保证该结果与顺序执行的结果是一致的</strong>，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200729160655.png" srcset="/img/loading.gif" alt="" /></p><p>乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化。</p><ul><li><p>单核环境下，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此。</p></li><li><p>多核环境下， 如果存在一个核的计算任务依赖另一个核的计算任务的中间结果，而且对相关数据读写没做任何防护措施，那么其顺序性并不能靠代码的先后顺序来保证。</p></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200729160753.png" srcset="/img/loading.gif" alt="" /></p><h1 id="java-内存模型"><a class="markdownIt-Anchor" href="#java-内存模型"></a> Java 内存模型</h1><p><strong>内存模型</strong> 这个概念。我们可以理解为：在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理计算机可以有不一样的内存模型，<code>JVM</code> 也有自己的内存模型。</p><p><code>JVM</code> 中试图定义一种 <code>Java</code> 内存模型（<code>Java Memory Model</code>, <code>JMM</code>）来<strong>屏蔽各种硬件和操作系统的内存访问差异</strong>，以实现让 <code>Java</code> 程序 <strong>在各种平台下都能达到一致的内存访问效果</strong>。<code>JMM</code> 决定一个线程对共享变量的写入何时对另一个线程可见。</p><h2 id="jvm-内存结构-vs-java-内存模型"><a class="markdownIt-Anchor" href="#jvm-内存结构-vs-java-内存模型"></a> JVM 内存结构 vs Java 内存模型</h2><ul><li><p><code>JVM</code> 内存结构，由 <code>Java</code> 虚拟机规范定义。描述的是 <code>Java</code> 程序执行过程中，由 <code>JVM</code> 管理的不同数据区域。各个区域有其特定的功能。</p></li><li><p><code>Java</code> 的多线程之间是通过<strong>共享内存</strong>进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、有序性等问题，而 <code>JMM</code> 就是围绕着<strong>多线程通信</strong>以及与其相关的一系列特性而建立的模型。</p></li><li><p><code>JMM</code> 并不像 <code>JVM</code> 内存结构一样是真实存在的，它只是一个抽象的概念。</p></li></ul><h2 id="主内存和工作内存"><a class="markdownIt-Anchor" href="#主内存和工作内存"></a> 主内存和工作内存</h2><p><code>JMM</code> 规定了所有的变量都存储在主内存（<code>Main Memory</code>）中。</p><p>每条线程还有自己的<strong>工作内存</strong>（<code>Working Memory</code>），工作内存中保留了该线程使用到的变量的<strong>主内存的副本</strong>。工作内存是 <code>JMM</code> 的一个抽象概念，并不真实存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200729161040.png" srcset="/img/loading.gif" alt="" /></p><p>线程对变量的<strong>所有操作都必须在工作内存中进行</strong>，而不能直接读写主内存中的变量。不同的线程间也无法直接访问对方工作内存中的变量，<strong>线程间变量值的传递均需要通过主内存来完成</strong>。</p><h2 id="jmm-内存操作的问题"><a class="markdownIt-Anchor" href="#jmm-内存操作的问题"></a> JMM 内存操作的问题</h2><ul><li><strong>工作内存数据一致性</strong> - 各个线程操作数据时会保存使用到的主内存中的共享变量副本，当多个线程的运算任务都涉及同一个共享变量时，将导致各自的的共享变量副本不一致。如果真的发生这种情况，数据同步回主内存以谁的副本数据为准？ <code>Java</code> 内存模型主要通过一系列的数据同步协议、规则来保证数据的一致性。</li><li><strong>指令重排序优化</strong> - <code>Java</code> 中重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：<strong>编译期重排序</strong>和<strong>运行期重排序</strong>，分别对应编译时和运行时环境。 同样的，指令重排序不是随意重排序，它需要满足以下两个条件：<ul><li>在单线程环境下不能改变程序运行的结果。即时编译器（和处理器）需要保证程序能够遵守 <code>as-if-serial</code> 属性。通俗地说，就是在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。</li><li>存在数据依赖关系的不允许重排序。</li><li>多线程环境下，如果线程处理逻辑之间存在依赖关系，有可能因为指令重排序导致运行结果与预期不同。</li></ul></li></ul><h1 id="java-内存模型规则"><a class="markdownIt-Anchor" href="#java-内存模型规则"></a> Java 内存模型规则</h1><h2 id="内存交互操作的三大特性"><a class="markdownIt-Anchor" href="#内存交互操作的三大特性"></a> 内存交互操作的三大特性</h2><p>Java 内存三大特性：原子性、可见性、有序性。</p><p>而这三大特性，归根结底，是为了实现多线程的 <strong>数据一致性</strong>，使得程序在多线程并发，指令重排序优化的环境中能如预期运行。</p><h3 id="原子性"><a class="markdownIt-Anchor" href="#原子性"></a> 原子性</h3><blockquote><p>原子性即一个操作或者多个操作，要么全部执行（执行的过程不会被任何因素打断），要么就都不执行。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。</p></blockquote><p>在 <code>Java</code> 中，为了保证原子性，提供了两个高级的字节码指令 <code>monitorenter</code> 和 <code>monitorexit</code>。这两个字节码，在 <code>Java</code> 中对应的关键字就是 <code>synchronized</code>。</p><p>因此，在 <code>Java</code> 中可以使用 <code>synchronized</code> 来保证方法和代码块内的操作是原子性的。</p><h3 id="可见性"><a class="markdownIt-Anchor" href="#可见性"></a> 可见性</h3><blockquote><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></blockquote><p>JMM 是通过 “<strong>变量修改后将新值同步回主内存， 变量读取前从主内存刷新变量值</strong>” 这种依赖主内存作为传递媒介的方式来实现的。</p><p><code>Java</code> 实现多线程可见性的方式有：</p><ul><li><p><code>volatile</code></p></li><li><p><code>synchronized</code></p></li><li><p><code>final</code></p></li></ul><h3 id="有序性"><a class="markdownIt-Anchor" href="#有序性"></a> 有序性</h3><p>有序性规则表现在以下两种场景: 线程内和线程间</p><ul><li><p><strong>线程内</strong> - 从某个线程的角度看方法的执行，指令会按照一种叫“串行”（<code>as-if-serial</code>）的方式执行，此种方式已经应用于顺序编程语言。</p></li><li><p><strong>线程间</strong> - 这个线程“观察”到其他线程并发地执行非同步的代码时，由于指令重排序优化，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块（<code>synchronized</code> 关键字修饰）以及 <code>volatile</code> 字段的操作仍维持相对有序。</p></li></ul><p>在 Java 中，可以使用 <code>synchronized</code> 和 <code>volatile</code> 来保证多线程之间操作的有序性。实现方式有所区别：</p><ul><li><p><code>volatile</code> 关键字会禁止指令重排序。</p></li><li><p><code>synchronized</code> 关键字通过互斥保证同一时刻只允许一条线程操作。</p></li></ul><h2 id="happens-before-原则"><a class="markdownIt-Anchor" href="#happens-before-原则"></a> Happens-Before 原则</h2><blockquote><p>在 <code>JMM</code> 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 <code>happens-before</code> 关系。</p></blockquote><ul><li><p><strong>程序次序规则</strong> - 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。</p></li><li><p><strong>管程锁定规则</strong> - 一个 <code>unLock</code> 操作先行发生于后面对同一个锁的 <code>lock</code> 操作。</p></li><li><p><strong><code>volatile</code> 变量规则</strong> - 对一个 <code>volatile</code> 变量的写操作先行发生于后面对这个变量的读操作。</p></li><li><p><strong>线程启动规则</strong> - <code>Thread</code> 对象的 <code>start()</code> 方法先行发生于此线程的每个一个动作。</p></li><li><p><strong>线程终止规则</strong> - 线程中所有的操作都先行发生于线程的终止检测，我们可以通过 <code>Thread.join()</code> 方法结束、<code>Thread.isAlive()</code> 的返回值手段检测到线程已经终止执行。</p></li><li><p><strong>线程中断规则</strong> - 对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 <code>Thread.interrupted()</code>方法检测到是否有中断发生。</p></li><li><p><strong>对象终结规则</strong> - 一个对象的初始化完成先行发生于它的 <code>finalize()</code> 方法的开始。</p></li><li><p><strong>传递性</strong> - 如果操作 <code>A</code> 先行发生于 操作 <code>B</code>，而操作 <code>B</code> 又 先行发生于 操作 <code>C</code>，则可以得出操作 <code>A</code> 先行发生于 操作 <code>C</code>。</p></li></ul><h2 id="内存屏障"><a class="markdownIt-Anchor" href="#内存屏障"></a> 内存屏障</h2><p><code>Java</code> 中如何保证底层操作的<strong>有序性</strong>和<strong>可见性</strong>？可以通过内存屏障。</p><p>内存屏障是被插入两个 <code>CPU</code> 指令之间的一种指令，<strong>用来禁止处理器指令发生重排序</strong>（像屏障一样），从而保障有序性的。另外，为了达到屏障的效果，它也会<strong>使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列</strong>，从而保障可见性。</p><p>举个例子：</p><pre><code class="hljs bash">Store1;Store2;Load1;StoreLoad;  // 内存屏障Store3;Load2;Load3;</code></pre><p>对于上面的一组 <code>CPU</code> 指令，<code>StoreLoad</code> 屏障之前的 <code>Store</code> 指令无法与 <code>StoreLoad</code> 屏障之后的 <code>Load</code> 指令进行交换位置，即<strong>重排序</strong>。但是 <code>StoreLoad</code> 屏障之前和之后的指令是可以互换位置的，即 <code>Store1</code> 可以和 <code>Store2</code> 互换，<code>Load2</code> 可以和 <code>Load3</code> 互换。</p><p>常见有 4 种屏障</p><ul><li><p><strong><code>LoadLoad</code> 屏障</strong> - 对于这样的语句 <code>Load1; LoadLoad; Load2</code>，在 <code>Load2</code> 及后续读取操作要读取的数据被访问前，保证 <code>Load1</code> 要读取的数据被读取完毕。</p></li><li><p><strong><code>StoreStore</code> 屏障</strong> - 对于这样的语句 <code>Store1; StoreStore; Store2</code>，在 <code>Store2</code> 及后续写入操作执行前，保证 <code>Store1</code> 的写入操作对其它处理器可见。</p></li><li><p><strong><code>LoadStore</code> 屏障</strong> - 对于这样的语句 <code>Load1; LoadStore; Store2</code>，在 <code>Store2</code> 及后续写入操作被执行前，保证 <code>Load1</code> 要读取的数据被读取完毕。</p></li><li><p><strong><code>StoreLoad</code> 屏障</strong> - 对于这样的语句 <code>Store1; StoreLoad; Load2</code>，在 <code>Load2</code> 及后续所有读取操作执行前，保证 <code>Store1</code> 的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p></li></ul><p><code>Java</code> 中对内存屏障的使用在一般的代码中不太容易见到，常见的有 <code>volatile</code> 和 <code>synchronized</code> 关键字修饰的代码块，还可以通过 <code>Unsafe</code> 这个类来使用内存屏障。</p><h2 id="volatile-变量的特殊规则"><a class="markdownIt-Anchor" href="#volatile-变量的特殊规则"></a> volatile 变量的特殊规则</h2><p><code>volatile</code> 是 <code>JVM</code> 提供的 <strong>最轻量级的同步机制</strong>。</p><p>特性：</p><ul><li>保证变量对所有线程的可见性。</li><li>禁止进行指令重排序</li></ul><h3 id="保证变量对所有线程的可见性"><a class="markdownIt-Anchor" href="#保证变量对所有线程的可见性"></a> 保证变量对所有线程的可见性</h3><p>这里的可见性是指当一条线程修改了 <code>volatile</code> 变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。</p><p>线程写 <code>volatile</code> 变量的过程：</p><ol><li>改变线程工作内存中 <code>volatile</code> 变量副本的值</li><li>将改变后的副本的值从工作内存刷新到主内存</li></ol><p>线程读 <code>volatile</code> 变量的过程：</p><ul><li>从主内存中读取 <code>volatile</code> 变量的最新值到线程的工作内存中</li><li>从工作内存中读取 <code>volatile</code> 变量的副本</li></ul><p>但是如果多个线程同时把更新后的变量值同时刷新回主内存，可能导致得到的值不是预期结果：</p><h3 id="禁止进行指令重排序"><a class="markdownIt-Anchor" href="#禁止进行指令重排序"></a> 禁止进行指令重排序</h3><ul><li><p>当程序执行到 <code>volatile</code> 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p></li><li><p>在进行指令优化时，不能将在对 <code>volatile</code> 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。</p></li></ul><h3 id="volatile-的原理"><a class="markdownIt-Anchor" href="#volatile-的原理"></a> volatile 的原理</h3><p>具体实现方式是在编译期生成字节码时，会<strong>在指令序列中增加内存屏障</strong>来保证，下面是基于保守策略的 <code>JMM</code> 内存屏障插入策略：</p><ul><li><p>在每个 <code>volatile</code> 写操作的前面插入一个 <code>StoreStore</code> 屏障。 该屏障除了保证了屏障之前的写操作和该屏障之后的写操作不能重排序，还会保证了 <code>volatile</code> 写操作之前，任何的读写操作都会先于 <code>volatile</code> 被提交。</p></li><li><p>在每个 <code>volatile</code> 写操作的后面插入一个 <code>StoreLoad</code> 屏障。 该屏障除了使 <code>volatile</code> 写操作不会与之后的读操作重排序外，还会刷新处理器缓存，使 <code>volatile</code> 变量的写更新对其他线程可见。</p></li><li><p>在每个 <code>volatile</code> 读操作的前面插入一个 <code>LoadLoad</code> 屏障。 该屏障除了使 <code>volatile</code> 读操作不会与之前的写操作发生重排序外，还会刷新处理器缓存，使 <code>volatile</code> 变量读取的为最新值。</p></li><li><p>在每个 <code>volatile</code> 读操作的后面插入一个 <code>LoadStore</code> 屏障。 该屏障除了禁止了 <code>volatile</code> 读操作与其之后的任何写操作进行重排序，还会刷新处理器缓存，使其他线程 <code>volatile</code> 变量的写更新对 <code>volatile</code> 读操作的线程可见。</p></li></ul><h3 id="volatile-的使用场景"><a class="markdownIt-Anchor" href="#volatile-的使用场景"></a> volatile 的使用场景</h3><p>总结起来，就是“一次写入，到处读取”，某一线程负责更新变量，其他线程只读取变量(不更新变量)，并根据变量的新值执行相应逻辑。例如状态标志位更新，观察者模型变量值发布。</p><h2 id="long-和-double-变量的特殊规则"><a class="markdownIt-Anchor" href="#long-和-double-变量的特殊规则"></a> long 和 double 变量的特殊规则</h2><p><code>JMM</code> 要求 <code>lock</code>、<code>unlock</code>、<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>、<code>write</code> 这 8 种操作都具有原子性，但是对于 64 位的数据类型（<code>long</code> 和 <code>double</code>），在模型中特别定义相对宽松的规定：允许虚拟机将没有被 <code>volatile</code> 修饰的 64 位数据的读写操作分为 2 次 32 位的操作来进行，即允许虚拟机可选择不保证 64 位数据类型的 <code>load</code>、<code>store</code>、<code>read</code> 和 <code>write</code> 这 4 个操作的原子性。由于这种非原子性，有可能导致其他线程读到同步未完成的“32 位的半个变量”的值。</p><p>不过实际开发中，<code>Java</code> 内存模型强烈建议虚拟机把 64 位数据的读写实现为具有原子性，目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的 <code>long</code> 和 <code>double</code> 变量专门声明为 <code>volatile</code>。</p><h2 id="final-型变量的特殊规则"><a class="markdownIt-Anchor" href="#final-型变量的特殊规则"></a> final 型变量的特殊规则</h2><p>我们知道，<code>final</code> 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。 <code>fina</code> 关键字的可见性是指：被 <code>final</code> 修饰的字段在声明时或者构造器中，一旦初始化完成，那么在其他线程无须同步就能正确看见 <code>final</code> 字段的值。这是因为一旦初始化完成，<code>final</code> 变量的值立刻回写到主内存。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发-工具类</title>
    <link href="/2020/07/28/concurrent-utils/"/>
    <url>/2020/07/28/concurrent-utils/</url>
    
    <content type="html"><![CDATA[<h1 id="countdownlatch"><a class="markdownIt-Anchor" href="#countdownlatch"></a> CountDownLatch</h1><blockquote><p><code>CountDownLatch</code> 维护一个计数器 <code>count</code>，表示需要等待的事件数量。<code>countDown()</code> 方法递减计数器，表示有一个事件已经发生。调用 <code>await()</code> 方法的线程会一直阻塞直到<strong>计数器为零</strong>，或者等待中的<strong>线程中断</strong>，或者<strong>等待超时</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200728155654.png" srcset="/img/loading.gif" alt="" /></p><p><code>CountDownLatch</code> 是基于 <code>AQS</code> 实现的。</p><p><code>CountDownLatch</code> 唯一的构造方法：</p><pre><code class="hljs java"><span class="hljs-comment">// count 计数器</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CountDownLatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"count &lt; 0"</span>);        <span class="hljs-keyword">this</span>.sync = <span class="hljs-keyword">new</span> Sync(count);&#125;</code></pre><p><code>CountDownLatch</code> 的重要方法：</p><pre><code class="hljs java"><span class="hljs-comment">// 等待直到 count 值为 0  才继续执行或当前线程被中断</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123; &#125;;<span class="hljs-comment">// 和 await() 类似，只不过等待一定的时间后 count 值还没变为 0 的话就会继续执行</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123; &#125;;<span class="hljs-comment">// 将统计值 count 减 1</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countDown</span><span class="hljs-params">()</span> </span>&#123; &#125;;</code></pre><h1 id="cyclicbarrier"><a class="markdownIt-Anchor" href="#cyclicbarrier"></a> CyclicBarrier</h1><blockquote><p>字面意思是 循环栅栏。<code>CyclicBarrier</code> 可以让<strong>一组线程</strong>等待至某个状态（遵循字面意思，不妨称这个状态为栅栏）之后再全部同时执行。之所以叫循环栅栏是因为：当所有等待线程都被释放以后，<code>CyclicBarrier</code> 可以被重用。</p><p><code>CyclicBarrier</code> 维护一个计数器 <code>count</code>。每次执行 <code>await</code> 方法之后，<code>count</code> 加 1，直到计数器的值和设置的值相等，等待的所有线程才会继续执行。</p></blockquote><ul><li><p><code>CyclicBarrier</code> 是基于 <code>ReentrantLock</code> 和 <code>Condition</code> 实现的。</p></li><li><p><code>CyclicBarrier</code> 应用场景：<code>CyclicBarrier</code> 在并行迭代算法中非常有用。</p></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200728160917.png" srcset="/img/loading.gif" alt="" /></p><p><code>CyclicBarrier</code> 提供了 2 个构造方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;&#125;</code></pre><ul><li><p><code>parties</code> - <code>parties</code> 数相当于一个阈值，当有 <code>parties</code> 数量的线程在等待时， <code>CyclicBarrier</code> 处于栅栏状态。</p></li><li><p><code>barrierAction</code> - 当 <code>CyclicBarrier</code> 处于栅栏状态时执行的动作。</p></li></ul><p>重要方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException,</span><span class="hljs-function">               BrokenBarrierException,</span><span class="hljs-function">               TimeoutException </span>&#123;&#125;<span class="hljs-comment">// 将屏障重置为初始状态</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;&#125;</code></pre><ul><li><p><code>await()</code> - 等待调用 <code>await()</code> 的线程数达到屏障数。如果当前线程是最后一个到达的线程，并且在构造函数中提供了非空屏障操作，则当前线程在允许其他线程继续之前运行该操作。如果在屏障动作期间发生异常，那么该异常将在当前线程中传播并且屏障被置于断开状态。</p></li><li><p><code>await(long timeout, TimeUnit unit)</code> - 相比于 <code>await()</code> 方法，这个方法让这些线程等待至一定的时间，如果还有线程没有到达栅栏状态就直接让到达栅栏状态的线程执行后续任务。</p></li><li><p><code>reset()</code> - 将屏障重置为初始状态。</p></li></ul><h1 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore"></a> Semaphore</h1><blockquote><p>字面意思为 <strong>信号量</strong>。<code>Semaphore</code> 用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。</p></blockquote><p><code>Semaphore</code> 管理着一组虚拟的许可（<code>permit</code>），<code>permit</code> 的初始数量可通过构造方法来指定。每次执行 <code>acquire</code> 方法可以获取一个 <code>permit</code>，如果没有就等待；而 <code>release</code> 方法可以释放一个 <code>permit</code>。</p><p><code>Semaphore</code> 应用场景：</p><ul><li><p><code>Semaphore</code> 可以用于实现资源池，如数据库连接池。</p></li><li><p><code>Semaphore</code> 可以用于将任何一种容器变成有界阻塞容器。</p></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200728162824.png" srcset="/img/loading.gif" alt="" /></p><p><code>Semaphore</code> 提供了 2 个构造方法：</p><pre><code class="hljs java"><span class="hljs-comment">// 初始化固定数量的 permit，并且默认为非公平模式。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Semaphore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits)</span> </span>&#123;&#125;<span class="hljs-comment">// 设置是否为公平模式。所谓公平，是指等待久的优先获取 permit。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Semaphore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;&#125;</code></pre><p>重要方法：</p><pre><code class="hljs java"><span class="hljs-comment">// 获取 1 个许可</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;&#125;<span class="hljs-comment">//获取 permits 个许可</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;&#125;<span class="hljs-comment">// 释放 1 个许可</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">//释放 permits 个许可</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits)</span> </span>&#123;&#125;</code></pre><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li><p><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 都能够实现线程之间的等待，只不过它们侧重点不同：</p><ul><li><p><code>CountDownLatch</code> 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；</p></li><li><p><code>CyclicBarrier</code> 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p></li><li><p>另外，<code>CountDownLatch</code> 是不可以重用的，而 <code>CyclicBarrier</code> 是可以重用的。</p></li></ul></li><li><p><code>Semaphore</code> 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>工具类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发-线程池</title>
    <link href="/2020/07/27/concurrent-threadpool/"/>
    <url>/2020/07/27/concurrent-threadpool/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><blockquote><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。</p></blockquote><p>如果并发请求数量很多，但每个线程执行的时间很短，就会出现频繁的创建和销毁线程。如此一来，会大大降低系统的效率，可能频繁创建和销毁线程的时间、资源开销要大于实际工作的所需。</p><p>正是由于这个问题，所以有必要引入线程池。使用 <strong>线程池的好处</strong> 有以下几点：</p><ul><li><p><strong>降低资源消耗</strong> - 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p></li><li><p><strong>提高响应速度</strong> - 当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p><strong>提高线程的可管理性</strong> - 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p></li></ul><h1 id="executor-框架"><a class="markdownIt-Anchor" href="#executor-框架"></a> <code>Executor</code> 框架</h1><h2 id="简介-2"><a class="markdownIt-Anchor" href="#简介-2"></a> 简介</h2><p><code>Executor</code> 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。</p><p>还有关键的一点：有助于避免 <code>this</code> 逃逸问题。</p><blockquote><p><code>this</code> 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><h2 id="框架结构"><a class="markdownIt-Anchor" href="#框架结构"></a> 框架结构</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727102933.png" srcset="/img/loading.gif" alt="" /></p><h3 id="1-任务runnable-callable"><a class="markdownIt-Anchor" href="#1-任务runnable-callable"></a> 1. 任务(<code>Runnable</code> / <code>Callable</code>)</h3><p>执行任务需要实现的 <code>Runnable</code> 接口 或 <code>Callable</code> 接口。他们的实现类都可以被 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。</p><h3 id="2-任务的执行executor"><a class="markdownIt-Anchor" href="#2-任务的执行executor"></a> 2. 任务的执行(<code>Executor</code>)</h3><p>任务执行机制的核心接口 <code>Executor</code> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。<br /><code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 这两个关键类实现了 <code>ExecutorService</code> 接口。</p><h4 id="21-executor"><a class="markdownIt-Anchor" href="#21-executor"></a> 2.1 <code>Executor</code></h4><p><code>Executor</code> 接口中只定义了一个 <code>execute</code> 方法，用于接收一个 <code>Runnable</code> 对象。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;&#125;</code></pre><h4 id="22-executorservice"><a class="markdownIt-Anchor" href="#22-executorservice"></a> 2.2 <code>ExecutorService</code></h4><p><code>ExecutorService</code> 接口继承了 <code>Executor</code> 接口，它还提供了 <code>invokeAll</code>、<code>invokeAny</code>、<code>shutdown</code>、<code>submit</code> 等方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Executor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException</span>;    &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;    &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span></span>;    Future&lt;?&gt; submit(Runnable task);    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        <span class="hljs-keyword">throws</span> InterruptedException;    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                  <span class="hljs-keyword">long</span> timeout, TimeUnit unit)        <span class="hljs-keyword">throws</span> InterruptedException;    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;&#125;</code></pre><p>比于 <code>Executor</code> 接口，<code>ExecutorService</code> 接口主要的扩展是：</p><ul><li>支持有返回值的线程 - <code>sumbit</code>、<code>invokeAll</code>、<code>invokeAny</code> 方法中都支持传入 <code>Callable</code> 对象。</li><li>支持管理线程生命周期 - <code>shutdown</code>、<code>shutdownNow</code>、<code>isShutdown</code> 等方法。</li></ul><h4 id="23-scheduledexecutorservice"><a class="markdownIt-Anchor" href="#23-scheduledexecutorservice"></a> 2.3 <code>ScheduledExecutorService</code></h4><p><code>ScheduledExecutorService</code> 接口扩展了 <code>ExecutorService</code> 接口。</p><p>它除了支持前面两个接口的所有能力以外，还支持定时调度线程。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ScheduledExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExecutorService</span> </span>&#123;    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-keyword">long</span> delay, TimeUnit unit);    <span class="hljs-keyword">public</span> &lt;V&gt; <span class="hljs-function">ScheduledFuture&lt;V&gt; <span class="hljs-title">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable, <span class="hljs-keyword">long</span> delay, TimeUnit unit)</span></span>;    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,                                                  <span class="hljs-keyword">long</span> initialDelay,                                                  <span class="hljs-keyword">long</span> period,                                                  TimeUnit unit);    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,                                                     <span class="hljs-keyword">long</span> initialDelay,                                                     <span class="hljs-keyword">long</span> delay,                                                     TimeUnit unit);&#125;</code></pre><p>其扩展的接口提供以下能力：</p><ul><li><p><code>schedule</code> 方法可以在指定的延时后执行一个 <code>Runnable</code> 或者 <code>Callable</code> 任务。</p></li><li><p><code>scheduleAtFixedRate</code> 方法和 <code>scheduleWithFixedDelay</code> 方法可以按照指定时间间隔，定期执行任务。</p></li></ul><h3 id="3-异步计算的结果future"><a class="markdownIt-Anchor" href="#3-异步计算的结果future"></a> 3. 异步计算的结果(<code>Future</code>)</h3><blockquote><p><code>Future</code> 接口以及 <code>Future</code> 接口的实现类 <code>FutureTask</code> 类都可以代表异步计算的结果。</p></blockquote><p>当我们把 <code>Runnable</code> 接口或 <code>Callable</code> 接口的实现类提交给 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行，调用 <code>submit()</code> 方法时会返回一个 <code>FutureTask</code> 对象，可通过 <code>FutureTask.get()</code> 捕获抛出的异常。</p><h2 id="executor-框架的使用示意图"><a class="markdownIt-Anchor" href="#executor-框架的使用示意图"></a> <code>Executor</code> 框架的使用示意图</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727105429.png" srcset="/img/loading.gif" alt="" /></p><ul><li><p>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</p></li><li><p>把创建完成的实现 <code>Runnable</code> / <code>Callable</code> 接口的对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit(Runnable task)</code>或 <code>ExecutorService.submit(Callable &lt;T&gt; task)</code>）。</p></li><li><p>如果执行 <code>ExecutorService.submit(...)</code>，<code>ExecutorService</code> 将返回一个实现 <code>Future</code> 接口的对象。由于 <code>FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</p></li><li><p>最后，主线程可以执行 <code>FutureTask.get()</code> 方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel(boolean mayInterruptIfRunning)</code>来取消此任务的执行。</p></li></ul><h1 id="threadpoolexecutor"><a class="markdownIt-Anchor" href="#threadpoolexecutor"></a> <code>ThreadPoolExecutor</code></h1><h2 id="使用示例"><a class="markdownIt-Anchor" href="#使用示例"></a> 使用示例</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : ThreadPoolTest.java 2020/07/27 Mon 3:29 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolTest</span> </span>&#123;    <span class="hljs-comment">// 核心线程数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CORE_POOL_SIZE = <span class="hljs-number">5</span>;    <span class="hljs-comment">// 最大线程数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_POOL_SIZE = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 任务队列容量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> QUEUE_CAPACITY = <span class="hljs-number">100</span>;    <span class="hljs-comment">// 等待时间</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> KEEP_ALIVE_TIME = <span class="hljs-number">1L</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建线程池</span>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                CORE_POOL_SIZE,                MAX_POOL_SIZE,                KEEP_ALIVE_TIME,                TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),                <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">// 执行工作线程</span>            Runnable worker = <span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-string">""</span> + i);            executor.execute(worker);            String info = String.format(<span class="hljs-string">"线程池中线程数目：%s，队列中等待执行的任务数目：%s，已执行完的任务数目：%s"</span>,                    executor.getPoolSize(),                    executor.getQueue().size(),                    executor.getCompletedTaskCount());            System.out.println(info);        &#125;        <span class="hljs-comment">// 终止线程池</span>        executor.shutdown();        <span class="hljs-keyword">while</span> (!executor.isTerminated()) &#123;        &#125;        System.out.println(<span class="hljs-string">"Finish all threads"</span>);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 工作线程类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> String cmd;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRunnable</span><span class="hljs-params">(String cmd)</span> </span>&#123;        <span class="hljs-keyword">this</span>.cmd = cmd;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" Start time = "</span> + <span class="hljs-keyword">new</span> Date());        processCmd();        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" End time = "</span> + <span class="hljs-keyword">new</span> Date());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCmd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">2000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"MyRunnable&#123;"</span> +                <span class="hljs-string">"cmd='"</span> + cmd + <span class="hljs-string">'\''</span> +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre><h2 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h2><p><code>ThreadPoolExecutor</code> 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, // 线程池的核心线程数量</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize, // 线程池的最大线程数</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime, // 当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit, // 时间单位</span></span><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列，用来储存等待执行任务的队列</span></span><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory, // 线程工厂，用来创建线程，一般默认即可</span></span><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler // 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><span class="hljs-function"><span class="hljs-params">                           )</span> </span>&#123;    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;    <span class="hljs-keyword">this</span>.workQueue = workQueue;    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;    <span class="hljs-keyword">this</span>.handler = handler;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727145107.png" srcset="/img/loading.gif" alt="" /></p><p>参数说明：</p><ol><li><p><code>corePoolSize</code> - <strong>核心线程数量</strong>。当有新任务通过 <code>execute</code> 方法提交时 ，线程池会执行以下判断：</p><ul><li>如果运行的线程数少于 <code>corePoolSize</code>，则创建新线程来处理任务，即使线程池中的其他线程是空闲的。</li><li>如果线程池中的线程数量大于等于 <code>corePoolSize</code> 且小于 <code>maximumPoolSize</code>，则只有当 <code>workQueue</code> 满时才创建新的线程去处理任务，否则将任务存储在队列里；</li><li>如果设置的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 相同，则创建的线程池的大小是固定的。这时如果有新任务提交，若 <code>workQueue</code> 未满，则将请求放入 <code>workQueue</code> 中，等待有空闲的线程去从 <code>workQueue</code> 中取任务并处理；</li><li>如果运行的线程数量大于等于 <code>maximumPoolSize</code>，这时如果 <code>workQueue</code> 已经满了，则使用 <code>handler</code> 所指定的策略来处理任务；</li><li>所以，任务提交时，判断的顺序为 <code>corePoolSize</code> =&gt; <code>workQueue</code> =&gt; <code>maximumPoolSize</code>。</li></ul></li><li><p><code>maximumPoolSize</code> - <strong>最大线程数量</strong>。</p><ul><li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</li><li>值得注意的是：如果使用了无界的任务队列这个参数就没什么效果。</li></ul></li><li><p><code>keepAliveTime</code> - <strong>线程保持活动的时间</strong>。</p><ul><li>当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>。</li><li>所以，如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li></ul></li><li><p><code>unit</code> - <strong><code>keepAliveTime</code> 的时间单位</strong>。<br />有 7 种取值。可选的单位有天（<code>DAYS</code>），小时（<code>HOURS</code>），分钟（<code>MINUTES</code>），毫秒(<code>MILLISECONDS</code>)，微秒(<code>MICROSECONDS</code>, 千分之一毫秒)和毫微秒(<code>NANOSECONDS</code>, 千分之一微秒)。</p></li><li><p><code>workQueue</code> - <strong>等待执行的任务队列</strong>。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。</p><ul><li><p><code>ArrayBlockingQueue</code> - <strong>有界阻塞队列</strong>。</p><ul><li>此队列是基于<strong>数组</strong>的先进先出队列（<code>FIFO</code>）。</li><li>创建时必须指定大小。</li></ul></li><li><p><code>LinkedBlockingQueue</code> - <strong>无界阻塞队列</strong>。</p><ul><li>此队列是基于<strong>链表</strong>的先进先出队列（<code>FIFO</code>）。</li><li>如果创建时没有指定此队列大小，则默认为 <code>Integer.MAX_VALUE</code>。</li><li>吞吐量通常要高于 <code>ArrayBlockingQueue</code>。</li><li>使用 <code>LinkedBlockingQueue</code> 意味着： <code>maximumPoolSize</code> 将不起作用，线程池能创建的最大线程数为 <code>corePoolSize</code>，因为任务等待队列是无界队列。</li><li><code>Executors.newFixedThreadPool</code> 使用了这个队列。</li></ul></li><li><p><code>SynchronousQueue</code> - <strong>不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</strong></p><ul><li>每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。</li><li>吞吐量通常要高于 <code>LinkedBlockingQueue</code>。</li><li><code>Executors.newCachedThreadPool</code> 使用了这个队列。</li></ul></li></ul></li><li><p><code>threadFactory</code> - <strong>线程工厂</strong>。可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</p></li><li><p><code>handler</code> - <strong>饱和策略</strong>。它是 <code>RejectedExecutionHandler</code> 类型的变量。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。线程池支持以下策略：</p><ul><li><p><code>AbortPolicy</code> - 抛出  <code>RejectedExecutionException</code> 来拒绝新任务的处理。这也是默认策略。</p></li><li><p><code>DiscardPolicy</code> - 丢弃任务，但不抛出异常。</p></li><li><p><code>DiscardOldestPolicy</code> - 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。</p></li><li><p><code>CallerRunsPolicy</code> - 只用调用者所在的线程来运行任务。</p></li><li><p>如果以上策略都不能满足需要，也可以通过实现           <code>RejectedExecutionHandler</code> 接口来定制处理策略。如记录日志或持久化不能处理的任务。</p></li></ul></li></ol><p>工作流程如下图：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727145919.png" srcset="/img/loading.gif" alt="" /></p><h2 id="execute-方法"><a class="markdownIt-Anchor" href="#execute-方法"></a> <code>execute</code> 方法</h2><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</p><p>提交任务可以使用 <code>execute</code> 方法，它是 <code>ThreadPoolExecutor</code> 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p><p><code>execute</code> 方法工作流程如下：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727162758.png" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs java"><span class="hljs-comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>)); <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;     <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125; <span class="hljs-comment">// 任务队列</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;     <span class="hljs-comment">// 如果任务为 null，则抛出异常。</span>     <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();     <span class="hljs-comment">// ctl 中保存的线程池当前的一些状态信息</span>     <span class="hljs-keyword">int</span> c = ctl.get();     <span class="hljs-comment">//  下面会涉及到 3 步 操作</span>     <span class="hljs-comment">// 1.首先判断当前线程池中之行的任务数量是否小于  corePoolSize</span>     <span class="hljs-comment">// 如果小于的话，则创建新的核心线程并且执行传入的任务</span>     <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;         <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))             <span class="hljs-comment">// 如果创建新的核心线程成功则直接返回</span>             <span class="hljs-keyword">return</span>;         <span class="hljs-comment">// 这里说明创建核心线程失败，需要更新 ctl 的临时变量 c</span>         c = ctl.get();     &#125;     <span class="hljs-comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span>     <span class="hljs-comment">// 判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务</span>     <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;         <span class="hljs-keyword">int</span> recheck = ctl.get();         <span class="hljs-comment">// 二次检查线程池状态。如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span>         <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))             <span class="hljs-comment">// 调用拒绝策略处理任务 - 返回</span>             reject(command);             <span class="hljs-comment">// 如果当前线程池为空就新创建一个线程并执行。</span>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)             addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);     &#125;     <span class="hljs-comment">// 3. 如果任务不能加入任务队列，则会尝试创建非核心线程传入任务执行</span>     <span class="hljs-comment">// 创建非核心线程失败，此时需要拒绝执行任务</span>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))         <span class="hljs-comment">// 调用拒绝策略处理任务 - 返回</span>         reject(command); &#125;</code></pre><p>关于二次检查线程池运行状态：</p><blockquote><p>如果一个任务成功加入任务队列，我们依然需要二次检查是否需要添加一个工作线程（因为所有存活的工作线程有可能在最后一次检查之后已经终结）或者执行当前方法的时候线程池是否已经终结了。所以我们需要二次检查线程池的状态，必须时把任务从任务队列中移除或者在没有可用的工作线程的前提下新建一个工作线程。</p></blockquote><h2 id="其他重要方法"><a class="markdownIt-Anchor" href="#其他重要方法"></a> 其他重要方法</h2><ul><li><code>submit</code> 类似于 <code>execute</code>，但是针对的是有返回值的线程。<code>submit</code> 方法是在 <code>ExecutorService</code> 中声明的方法，在 <code>AbstractExecutorService</code> 就已经有了具体的实现。<code>ThreadPoolExecutor</code> 直接复用 <code>AbstractExecutorService</code> 的 <code>submit</code> 方法。</li><li><code>shutdown</code> - 不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</li><li><code>shutdownNow</code> - 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</li><li><code>isShutdown</code> - 调用了 <code>shutdown</code> 或 <code>shutdownNow</code> 方法后，<code>isShutdown</code> 方法就会返回 <code>true</code>。</li><li><code>isTerminaed</code> - 当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 <code>isTerminaed</code> 方法会返回 <code>true</code>。</li></ul><h1 id="scheduledthreadpoolexecutor"><a class="markdownIt-Anchor" href="#scheduledthreadpoolexecutor"></a> <code>ScheduledThreadPoolExecutor</code></h1><p><code>ScheduledThreadPoolExecutor</code> 主要用来在给定的延迟后运行任务，或者定期执行任务。 这个在实际项目中基本不会被用到，因为有其他方案选择比如 <code>quartz</code>。</p><h2 id="简介-3"><a class="markdownIt-Anchor" href="#简介-3"></a> 简介</h2><p><code>ScheduledThreadPoolExecutor</code> 使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</p><h2 id="运行机制"><a class="markdownIt-Anchor" href="#运行机制"></a> 运行机制</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727200044.png" srcset="/img/loading.gif" alt="" /></p><p><code>ScheduledThreadPoolExecutor</code> 的执行主要分为两大部分：</p><ul><li><p>当调用 <code>ScheduledThreadPoolExecutor</code> 的 <code>scheduleAtFixedRate()</code> 方法或者 <code>scheduleWirhFixedDelay()</code> 方法时，会向 <code>ScheduledThreadPoolExecutor</code> 的 <code>DelayQueue</code> 添加一个实现了 <code>RunnableScheduledFuture</code> 接口的 <code>ScheduledFutureTask</code> 。</p></li><li><p>线程池中的线程从 <code>DelayQueue</code> 中获取 <code>ScheduledFutureTask</code>，然后执行任务。</p></li></ul><p><code>ScheduledThreadPoolExecutor</code> 为了实现周期性的执行任务，对 <code>ThreadPoolExecutor</code> 做了如下修改：</p><ul><li><p>使用 <code>DelayQueue</code> 作为任务队列；</p></li><li><p>获取任务的方不同</p></li><li><p>执行周期任务后，增加了额外的处理</p></li></ul><h2 id="执行周期任务的步骤"><a class="markdownIt-Anchor" href="#执行周期任务的步骤"></a> 执行周期任务的步骤</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727200325.png" srcset="/img/loading.gif" alt="" /></p><ul><li><p>线程 1 从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask</code>（<code>DelayQueue.take()</code>）。到期任务是指 <code>ScheduledFutureTask</code> 的 <code>time</code> 大于等于当前系统的时间；</p></li><li><p>线程 1 执行这个 <code>ScheduledFutureTask</code>；</p></li><li><p>线程 1 修改 <code>ScheduledFutureTask</code> 的 <code>time</code> 变量为下次将要被执行的时间；</p></li><li><p>线程 1 把这个修改 <code>time</code> 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中 (<code>DelayQueue.add()</code>)。</p></li></ul><h1 id="常见线程池"><a class="markdownIt-Anchor" href="#常见线程池"></a> 常见线程池</h1><p><code>JDK</code> 的 <code>Executors</code> 类中提供了几种具有代表性的线程池，这些线程池 都是基于 <code>ThreadPoolExecutor</code> 的定制化实现。</p><blockquote><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p></blockquote><h2 id="创建线程池方式"><a class="markdownIt-Anchor" href="#创建线程池方式"></a> 创建线程池方式</h2><ol><li>通过 <code>ThreadPoolExecutor</code> 构造函数实现（推荐）</li><li>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现 我们可以创建三种类型的 <code>ThreadPoolExecutor</code><ul><li><code>FixedThreadPool</code></li><li><code>SingleThreadExecutor</code></li><li><code>CachedThreadPool</code></li></ul></li></ol><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 <code>OOM</code>。</li><li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 <code>OOM</code>。</li></ul><h2 id="fixedthreadpool"><a class="markdownIt-Anchor" href="#fixedthreadpool"></a> <code>FixedThreadPool</code></h2><p>创建一个<strong>固定大小</strong>的线程池。</p><p>每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中。</p><p><code>FixedThreadPool</code> 是一个典型且优秀的线程池，它具有线程池<strong>提高程序效率</strong>和<strong>节省创建线程时所耗的开销</strong>的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p><pre><code class="hljs java"> <span class="hljs-comment">/**</span><span class="hljs-comment">  * 创建一个可重用固定数量线程的线程池</span><span class="hljs-comment">  */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(        nThreads,        nThreads,        <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,        <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),        threadFactory);    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727191728.png" srcset="/img/loading.gif" alt="" /></p><p>上图说明：</p><ul><li><p>如果当前运行的线程数小于 <code>corePoolSize</code>， 如果再来新任务的话，就创建新的线程来执行任务；</p></li><li><p>当前运行的线程数等于 <code>corePoolSize</code> 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</p></li><li><p>线程池中的线程执行完 手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</p></li></ul><p><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 <code>Intger.MAX_VALUE</code>）作为线程池的工作队列会对线程池带来如下影响 ：</p><ul><li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code>corePoolSize</code></li><li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况</li><li>使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数</li><li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code> 或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 <code>OOM</code></li></ul><h2 id="singlethreadexecutor"><a class="markdownIt-Anchor" href="#singlethreadexecutor"></a> <code>SingleThreadExecutor</code></h2><p>创建一个<strong>单线程</strong>的线程池。</p><p>只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序(<code>FIFO</code>, <code>LIFO</code>, 优先级)执行。 如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它 。</p><p>单工作线程最大的特点是：<strong>可保证顺序地执行各个任务</strong>。</p><pre><code class="hljs java">  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 返回只有一个线程的线程池</span><span class="hljs-comment">   */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),                                    threadFactory));    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727192058.png" srcset="/img/loading.gif" alt="" /></p><p>上图说明：</p><ul><li><p>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</p></li><li><p>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></p></li><li><p>线程执行完当前的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</p></li></ul><p>影响： <code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 <code>Intger.MAX_VALUE</code>）。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同，也可能导致 <code>OOM</code>。</p><h2 id="cachedthreadpool"><a class="markdownIt-Anchor" href="#cachedthreadpool"></a> <code>CachedThreadPool</code></h2><p>创建一个<strong>可缓存</strong>的线程池。</p><ul><li><p>如果线程池大小超过处理任务所需要的线程数，就会回收部分空闲的线程；</p></li><li><p>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p></li><li><p>此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 <code>JVM</code>）能够创建的最大线程大小。因此，使用 <code>CachedThreadPool</code> 时，一定要注意<strong>控制任务的数量</strong>，否则，由于大量线程同时运行，很有会造成系统瘫痪。</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                                      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),                                      threadFactory);    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727192747.png" srcset="/img/loading.gif" alt="" /></p><p>上图说明：</p><ul><li><p>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 <code>offer</code> 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code> 方法执行完成，否则执行下面的步骤 2；</p></li><li><p>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，<code>execute</code> 方法执行完成；</p></li></ul><p>影响：<code>CachedThreadPool</code> 允许创建的线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致 <code>OOM</code>。</p><h1 id="线程池大小确定"><a class="markdownIt-Anchor" href="#线程池大小确定"></a> 线程池大小确定</h1><blockquote><p>上下文切换：</p><p>多线程编程中一般线程的个数都大于 <code>CPU</code> 核心的个数，而一个 <code>CPU</code> 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，<code>CPU</code> 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 <code>CPU</code> 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p><p>上下文切换通常是<strong>计算密集型</strong>的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 <code>CPU</code> 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p><code>Linux</code> 相比与其他操作系统（包括其他类 <code>Unix</code> 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p></blockquote><p>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 <code>OOM</code>。这样很明显是有问题的！ <code>CPU</code> 根本没有得到充分利用。</p><p>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 <code>CPU</code> 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</p><p>有一个简单并且适用面比较广的公式：</p><ul><li><p><code>CPU</code> 密集型任务(<code>N + 1</code>)：这种任务消耗的主要是 <code>CPU</code> 资源，可以将线程数设置为 <code>N（CPU 核心数）+ 1</code>，比 <code>CPU</code> 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，<code>CPU</code> 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 <code>CPU</code> 的空闲时间。</p></li><li><p><code>I/O</code> 密集型任务(<code>2N</code>)：这种任务应用起来，系统会用大部分的时间来处理 <code>I/O</code> 交互，而线程在处理 <code>I/O</code> 的时间段内不会占用 <code>CPU</code> 来处理，这时就可以将 <code>CPU</code> 交出给其它线程使用。因此在 <code>I/O</code> 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 <code>2N</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发-容器</title>
    <link href="/2020/07/24/concurrent-container/"/>
    <url>/2020/07/24/concurrent-container/</url>
    
    <content type="html"><![CDATA[<h1 id="同步容器"><a class="markdownIt-Anchor" href="#同步容器"></a> 同步容器</h1><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>在 <code>Java</code> 中，同步容器主要包括 <code>2</code> 类：</p><ul><li><p><code>Vector</code>, <code>Stack</code>, <code>HashTable</code></p><ul><li><code>Vector</code> - <code>Vector</code> 实现了 <code>List</code> 接口。<code>Vector</code> 实际上就是一个数组，和 <code>ArrayList</code> 类似。但是 <code>Vector</code> 中的方法都是 <code>synchronized</code> 方法，即进行了同步措施。</li><li><code>Stack</code> - <code>Stack</code> 继承于 <code>Vector</code> 类，也是一个同步容器，它的方法也用 <code>synchronized</code> 进行了同步。</li><li><code>Hashtable</code>- <code>Hashtable</code> 实现了 <code>Map</code> 接口，但是 <code>Hashtable</code> 用 <code>synchronized</code> 进行了同步。</li></ul></li><li><p><code>Collections</code> 类中提供的静态工厂方法创建的类（由 <code>Collections.synchronizedXXX</code> 等方法）。</p></li></ul><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>同步容器的同步原理就是在方法上用 <code>synchronized</code> 修饰。</p><h3 id="性能问题"><a class="markdownIt-Anchor" href="#性能问题"></a> 性能问题</h3><p><code>synchronized</code> 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 <code>synchronized</code> 的容器性能要差。</p><h3 id="安全问题"><a class="markdownIt-Anchor" href="#安全问题"></a> 安全问题</h3><p>同步容器真的绝对安全吗？</p><p>其实也未必。在做复合操作（非原子操作）时，仍然需要加锁来保护。常见复合操作如下：</p><ul><li><p>迭代：反复访问元素，直到遍历完全部元素；</p></li><li><p>跳转：根据指定顺序寻找当前元素的下一个（下 <code>n</code> 个）元素；</p></li><li><p>条件运算：例如若没有则添加等；</p></li></ul><p>❌ 不安全的示例</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : ConcurrentContainerTest.java 2020/07/24 Fri 1:56 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentContainerTest</span> </span>&#123;    <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; vector = <span class="hljs-keyword">new</span> Vector&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            vector.clear();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                vector.add(i);            &#125;            Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;                    vector.remove(i);                &#125;            &#125;);            Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;                    vector.get(i);                &#125;            &#125;);            t1.start();            t2.start();            <span class="hljs-keyword">while</span> (Thread.activeCount() &gt; <span class="hljs-number">10</span>) &#123;                System.out.println(<span class="hljs-string">"同时存在十个以上线程， 退出"</span>);                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;&#125;</code></pre><p>以上程序执行时可能会出现数组越界错误。</p><p>这是因为，对于 <code>Vector</code>，虽然能保证每一个时刻只能有一个线程访问它，但是不排除这种可能：<br />当某个线程进行读操作时，其他线程可能已经删除了该线程所要读的那个元素。</p><p>因此为了保证线程安全，必须在方法调用端做额外的同步措施，如下面所示：</p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (vector) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;        vector.remove(i);    &#125;&#125;<span class="hljs-keyword">synchronized</span> (vector) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;        vector.remove(i);    &#125;&#125;</code></pre><h1 id="并发容器简介"><a class="markdownIt-Anchor" href="#并发容器简介"></a> 并发容器简介</h1><blockquote><p>同步容器将所有对容器状态的访问都串行化，以保证线程安全性，这种策略会严重降低并发性。</p><p>Java 1.5 后提供了多种并发容器，使用并发容器来替代同步容器，可以极大地提高伸缩性并降低风险。</p></blockquote><p>J.U.C 包中提供了几个非常有用的并发容器作为线程安全的容器：</p><table><thead><tr><th style="text-align:center">并发容器</th><th style="text-align:center">对应的普通容器</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>ConcurrentHashMap</code></td><td style="text-align:center"><code>HashMap</code></td><td style="text-align:center"><code>Java 1.8</code> 之前采用<strong>分段锁机制</strong>细化锁粒度，降低阻塞，从而提高并发性；<code>Java 1.8</code> 之后基于 <code>CAS</code> 实现。</td></tr><tr><td style="text-align:center"><code>ConcurrentSkipListMap</code></td><td style="text-align:center"><code>SortedMap</code></td><td style="text-align:center">基于跳表实现的</td></tr><tr><td style="text-align:center"><code>CopyOnWriteArrayList</code></td><td style="text-align:center"><code>ArrayList</code></td><td style="text-align:center">写时复制</td></tr><tr><td style="text-align:center"><code>CopyOnWriteArraySet</code></td><td style="text-align:center"><code>Set</code></td><td style="text-align:center">基于 <code>CopyOnWriteArrayList</code> 实现。</td></tr><tr><td style="text-align:center"><code>ConcurrentSkipListSet</code></td><td style="text-align:center"><code>SortedSet</code></td><td style="text-align:center">基于 <code>ConcurrentSkipListMap</code> 实现。</td></tr><tr><td style="text-align:center"><code>ConcurrentLinkedQueue</code></td><td style="text-align:center"><code>Queue</code></td><td style="text-align:center">线程安全的无界队列。底层采用单链表。支持 <code>FIFO</code>。</td></tr><tr><td style="text-align:center"><code>ConcurrentLinkedDeque</code></td><td style="text-align:center"><code>Deque</code></td><td style="text-align:center">线程安全的无界双端队列。底层采用双向链表。支持 <code>FIFO</code> 和 <code>FILO</code>。</td></tr><tr><td style="text-align:center"><code>ArrayBlockingQueue</code></td><td style="text-align:center"><code>Queue</code></td><td style="text-align:center">数组实现的阻塞队列。</td></tr><tr><td style="text-align:center"><code>LinkedBlockingQueue</code></td><td style="text-align:center"><code>Queue</code></td><td style="text-align:center">链表实现的阻塞队列。</td></tr><tr><td style="text-align:center"><code>LinkedBlockingDeque</code></td><td style="text-align:center"><code>Deque</code></td><td style="text-align:center">双向链表实现的双端阻塞队列。</td></tr></tbody></table><h1 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> <code>ConcurrentHashMap</code></h1><blockquote><p><code>ConcurrentHashMap</code> 是线程安全的 <code>HashMap</code> ，用于替代 <code>Hashtable</code>。</p></blockquote><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><p><code>ConcurrentHashMap</code> 实现了 <code>ConcurrentMap</code> 接口，而 <code>ConcurrentMap</code> 接口扩展了 <code>Map</code> 接口。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p><code>ConcurrentHashMap</code> 的实现包含了 <code>HashMap</code> 所有的基本特性，如：数据结构、读写策略等。</p><p><code>ConcurrentHashMap</code> 没有实现对 <code>Map</code> 加锁以提供独占访问。因此无法通过在客户端加锁的方式来创建新的原子操作。但是，一些常见的复合操作，如：“若没有则添加”、“若相等则移除”、“若相等则替换”，都已经实现为原子操作，并且是围绕 <code>ConcurrentMap</code> 的扩展接口而实现。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-comment">// 仅当 K 没有相应的映射值才插入</span>    <span class="hljs-function">V <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(K key, V value)</span></span>;    <span class="hljs-comment">// 仅当 K 被映射到 V 时才移除</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object key, Object value)</span></span>;    <span class="hljs-comment">// 仅当 K 被映射到 oldValue 时才替换为 newValue</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">replace</span><span class="hljs-params">(K key, V oldValue, V newValue)</span></span>;    <span class="hljs-comment">// 仅当 K 被映射到某个值时才替换为 newValue</span>    <span class="hljs-function">V <span class="hljs-title">replace</span><span class="hljs-params">(K key, V value)</span></span>;&#125;</code></pre><p>不同于 <code>Hashtable</code>，<code>ConcurrentHashMap</code> 提供的迭代器不会抛出 <code>ConcurrentModificationException</code>，因此不需要在迭代过程中对容器加锁。</p><blockquote><p>🔔 注意：一些需要对整个 <code>Map</code> 进行计算的方法，如 <code>size</code> 和 <code>isEmpty</code> ，由于返回的结果在计算时可能已经过期，所以并非实时的精确值。这是一种策略上的权衡，在并发环境下，这类方法由于总在不断变化，所以获取其实时精确值的意义不大。<code>ConcurrentHashMap</code> 弱化这类方法，以换取更重要操作（如：<code>get</code>、<code>put</code>、<code>containesKey</code>、<code>remove</code> 等）的性能。</p></blockquote><h2 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法</h2><p>同 <code>HashMap</code></p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p><code>ConcurrentHashMap</code> 在 <code>Java 1.8</code> 之前和 <code>Java 1.8</code> 之后的实现有很大差异：</p><ul><li><code>Java 1.8</code> 之前采用<strong>分段锁机制</strong>细化锁粒度，降低阻塞，从而提高并发性。</li><li><code>Java 1.8</code> 之后基于 <code>CAS</code> 实现。</li></ul><h3 id="java-17-的实现"><a class="markdownIt-Anchor" href="#java-17-的实现"></a> Java 1.7 的实现</h3><p>每一个 <code>segment</code> 都是一个 <code>HashEntry&lt;K,V&gt;[] table</code>， <code>table</code> 中的每一个元素本质上都是一个 <code>HashEntry</code> 的单向队列。比如 <code>table[3]</code> 为首节点，<code>table[3]-&gt;next</code> 为节点 <code>1</code>，之后为节点 <code>2</code>，依次类推。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// 将整个 hashmap 分成几个小的 map，每个 segment 都是一个锁；与 hashtable 相比，这么设计的目的是对于 put, remove 等操作，可以减少并发冲突，对</span>    <span class="hljs-comment">// 不属于同一个片段的节点可以并发操作，大大提高了性能</span>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;    <span class="hljs-comment">// 本质上 Segment 类就是一个小的 hashmap，里面 table 数组存储了各个节点的数据，继承了 ReentrantLock, 可以作为互斥锁使用</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;    &#125;    <span class="hljs-comment">// 基本节点，存储 Key, Value 值</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;        <span class="hljs-keyword">final</span> K key;        <span class="hljs-keyword">volatile</span> V value;        <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;    &#125;&#125;</code></pre><h3 id="java-18-的实现"><a class="markdownIt-Anchor" href="#java-18-的实现"></a> Java 1.8 的实现</h3><p><code>JDK 8</code> 中主要做了 2 方面的改进</p><ul><li><p>取消 <code>segments</code> 字段，直接采用 <code>transient volatile HashEntry&lt;K,V&gt;[] table</code> 保存数据，采用 <code>table</code> 数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</p></li><li><p>将原先 <strong>数组＋单链表</strong> 的数据结构，变更为 <strong>数组＋单链表＋红黑树</strong> 的结构。对于 <code>hash</code> 表来说，最核心的能力在于将 <code>key hash</code> 之后能均匀的分布在数组中。如果 <code>hash</code> 之后散列的很均匀，那么 <code>table</code> 数组中的每个队列长度主要为 <code>0</code> 或者 <code>1</code>。但实际情况并非总是如此理想，虽然 <code>ConcurrentHashMap</code> 类默认的加载因子为 <code>0.75</code>，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为 <code>O(n)</code>；因此，对于个数超过 <code>8</code>(默认值)的列表，<code>JDK 1.8</code> 中采用了红黑树的结构，那么查询的时间复杂度可以降低到 <code>O(logN)</code>，可以改进性能。</p></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;        <span class="hljs-comment">// 如果 table 为空，初始化；否则，根据 hash 值计算得到数组索引i，如果 tab[i] 为空，直接新建节点 Node 即可。注：tab[i] 实质为链表或者红黑树的首节点。</span>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            tab = initTable();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,                         <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>        &#125;        <span class="hljs-comment">// 如果 tab[i] 不为空并且 hash 值为 MOVED，说明该链表正在进行 transfer 操作，返回扩容完成后的 table。</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)            tab = helpTransfer(tab, f);        <span class="hljs-keyword">else</span> &#123;            V oldVal = <span class="hljs-keyword">null</span>;            <span class="hljs-comment">// 针对首个节点进行加锁操作，而不是 segment，进一步减少线程冲突</span>            <span class="hljs-keyword">synchronized</span> (f) &#123;                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;                        binCount = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                            K ek;                            <span class="hljs-comment">// 如果在链表中找到值为 key 的节点 e，直接设置 e.val = value 即可。</span>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;                                oldVal = e.val;                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                    e.val = value;                                <span class="hljs-keyword">break</span>;                            &#125;                            <span class="hljs-comment">// 如果没有找到值为 key 的节点，直接新建 Node 并加入链表即可。</span>                            Node&lt;K,V&gt; pred = e;                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,                                                          value, <span class="hljs-keyword">null</span>);                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                    &#125;                    <span class="hljs-comment">// 如果首节点为 TreeBin 类型，说明为红黑树结构，执行 utTreeVal 操作。</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;                        Node&lt;K,V&gt; p;                        binCount = <span class="hljs-number">2</span>;                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                       value)) != <span class="hljs-keyword">null</span>) &#123;                            oldVal = p.val;                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                p.val = value;                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 如果节点数 &gt;＝8，那么转换链表结构为红黑树结构。</span>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> oldVal;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 计数增加1，有可能触发 transfer 操作(扩容)。</span>    addCount(<span class="hljs-number">1L</span>, binCount);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h1 id="copyonwritearraylist"><a class="markdownIt-Anchor" href="#copyonwritearraylist"></a> <code>CopyOnWriteArrayList</code></h1><p>每个 <code>CopyOnWriteArrayList</code> 对象里有一个 <code>array</code> 数组用来存放具体元素。<code>ReentrantLock</code> 独占锁用来保证同时只有一个线程对 <code>array</code> 进行修改。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200724151232.png" srcset="/img/loading.gif" alt="" /></p><h2 id="要点"><a class="markdownIt-Anchor" href="#要点"></a> 要点</h2><ul><li><p>好处：<strong>任何的读操作都不用加锁</strong>，而且保证读取到的是读那一刻 <code>List</code> 完整的快照数据。由于读操作无法感知最新正在变化的数据，所以 <code>CopyOnWriteArrayList</code> 是<strong>弱一致性</strong>的。</p></li><li><p>写时复制技术因为每次修改都需要完整拷贝一次底层数组，所以有额外的性能开销，但是特别适用于<strong>读多写少</strong>的数据访问场景。</p></li></ul><h2 id="弱一致性问题"><a class="markdownIt-Anchor" href="#弱一致性问题"></a> 弱一致性问题</h2><p>线程1在执行完步骤 <code>A</code> 后，执行步骤 <code>B</code> 前，线程2进行了 <code>remove</code> 操作。<br />虽然线程2已经删除了 <code>index</code> 处的元素，但由于 <code>array</code>指向的数组引用计数为 1 而不是 0，仍会返回 <code>index</code> 处的元素。</p><h2 id="添加元素"><a class="markdownIt-Anchor" href="#添加元素"></a> 添加元素</h2><p>先将原容器 copy 一份，然后在新副本上执行写操作，之后再切换引用。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 1.获取独占锁</span>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 2.获取 array 数组</span>        Object[] elements = getArray();        <span class="hljs-keyword">int</span> len = elements.length;        <span class="hljs-comment">// 3.复制 array 到新数组</span>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 4.添加元素到新数组</span>        newElements[len] = e;        <span class="hljs-comment">// 5.用新数组替换原数组</span>        setArray(newElements);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 6.释放锁</span>        lock.unlock();    &#125;&#125;</code></pre><h2 id="删除元素"><a class="markdownIt-Anchor" href="#删除元素"></a> 删除元素</h2><p>将除要删除元素之外的其他元素拷贝到新副本中，然后切换引用，将原容器引用指向新副本。同属写操作，需要加锁。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">// 获取独占锁</span>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        Object[] elements = getArray();        <span class="hljs-keyword">int</span> len = elements.length;        E oldValue = get(elements, index);        <span class="hljs-comment">// 需要移动的元素个数</span>        <span class="hljs-keyword">int</span> numMoved = len - index - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 若删除的是最后一个元素</span>        <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)           <span class="hljs-comment">// 拷贝前len-1个数据到新副本上，再切换引用</span>           setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));        <span class="hljs-keyword">else</span> &#123;            Object[] newElements = <span class="hljs-keyword">new</span> Object[len - <span class="hljs-number">1</span>];            <span class="hljs-comment">// 分两块复制到新数组</span>            System.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);            System.arraycopy(elements, index + <span class="hljs-number">1</span>, newElements, index,                             numMoved);            <span class="hljs-comment">// 设置新数组</span>            setArray(newElements);        &#125;        <span class="hljs-keyword">return</span> oldValue;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 释放锁</span>        lock.unlock();    &#125;&#125;</code></pre><h2 id="读操作"><a class="markdownIt-Anchor" href="#读操作"></a> 读操作</h2><p><code>E get(int index)</code><br />读操作是不用加锁的，性能很高。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">return</span> get(getArray(), index);&#125;<span class="hljs-comment">// A.获取 array 数组</span><span class="hljs-keyword">final</span> Object[] getArray() &#123;    <span class="hljs-keyword">return</span> array;&#125;<span class="hljs-comment">// B.通过下标访问指定位置的数组元素</span><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">get</span><span class="hljs-params">(Object[] a, <span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">return</span> (E) a[index];&#125;</code></pre><h2 id="修改指定元素"><a class="markdownIt-Anchor" href="#修改指定元素"></a> 修改指定元素</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;    <span class="hljs-comment">// 获取独占锁</span>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 获取 array 数组</span>        Object[] elements = getArray();        <span class="hljs-comment">// 找到原位置上的值</span>        E oldValue = get(elements, index);        <span class="hljs-keyword">if</span> (oldValue != element) &#123;            <span class="hljs-keyword">int</span> len = elements.length;            <span class="hljs-comment">// 复制 array 到新数组</span>            Object[] newElements = Arrays.copyOf(elements, len);            <span class="hljs-comment">// 设置 index 位置的元素</span>            newElements[index] = element;            <span class="hljs-comment">// 用新数组替换旧数组</span>            setArray(newElements);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// Not quite a no-op; ensures volatile write semantics</span>            setArray(elements);        &#125;        <span class="hljs-keyword">return</span> oldValue;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 释放锁</span>        lock.unlock();    &#125;&#125;</code></pre><h1 id="blockingqueue"><a class="markdownIt-Anchor" href="#blockingqueue"></a> <code>BlockingQueue</code></h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;&#125;</code></pre><p>在 <code>BlockingQueue</code> 中，如果获取队列元素但是队列为空时，会阻塞，等待队列中有元素再返回；如果添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p><p><code>BlockingQueue</code> 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：</p><p>抛出异常；</p><ul><li>返回特殊值（<code>null</code> 或 <code>true</code>/<code>false</code>，取决于具体的操作）；</li><li>阻塞等待此操作，直到这个操作成功；</li><li>阻塞等待此操作，直到成功或者超时指定时间。<br />总结如下：</li></ul><table><thead><tr><th style="text-align:center">Operation</th><th style="text-align:center">Throws exception</th><th style="text-align:center">Special value</th><th style="text-align:center">Blocks</th><th style="text-align:center">Times out</th></tr></thead><tbody><tr><td style="text-align:center">Insert</td><td style="text-align:center">add(e)</td><td style="text-align:center">offer(e)</td><td style="text-align:center">put(e)</td><td style="text-align:center">offer(e, time, unit)</td></tr><tr><td style="text-align:center">Remove</td><td style="text-align:center">remove()</td><td style="text-align:center">poll()</td><td style="text-align:center">take()</td><td style="text-align:center">poll(time, unit)</td></tr><tr><td style="text-align:center">Examine</td><td style="text-align:center">element()</td><td style="text-align:center">peek()</td><td style="text-align:center">not applicable</td><td style="text-align:center">not applicable</td></tr></tbody></table><p><code>BlockingQueue</code> 的各个实现类都遵循了这些规则。</p><p><code>BlockingQueue</code> 不接受 <code>null</code> 值元素。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发-原子类</title>
    <link href="/2020/07/21/concurrent-atomic/"/>
    <url>/2020/07/21/concurrent-atomic/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><h2 id="为何需要原子变量类"><a class="markdownIt-Anchor" href="#为何需要原子变量类"></a> 为何需要原子变量类</h2><p>保证线程安全是 <code>Java</code> 并发编程必须要解决的重要问题。<code>Java</code> 从原子性、可见性、有序性这三大特性入手，确保多线程的数据一致性。</p><ul><li><p>确保线程安全最常见的做法是利用锁机制（<code>Lock</code>、<code>sychronized</code>）来对共享数据做互斥同步，这样在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，那么操作必然是原子性的，线程安全的。互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题。</p></li><li><p><code>volatile</code> 是轻量级的锁（自然比普通锁性能要好），它保证了共享变量在多线程中的可见性，但无法保证原子性。所以，它只能在一些特定场景下使用。</p></li><li><p>为了兼顾原子性以及锁带来的性能问题，<code>Java</code> 引入了 <code>CAS</code> （主要体现在 Unsafe 类）来实现非阻塞同步（也叫乐观锁）。并基于 <code>CAS</code> ，提供了一套原子工具类。</p></li></ul><h2 id="原子变量类的作用"><a class="markdownIt-Anchor" href="#原子变量类的作用"></a> 原子变量类的作用</h2><p>原子变量类 <strong>比锁的粒度更细，更轻量级</strong>，并且对于在多处理器系统上实现高性能的并发代码来说是非常关键的。原子变量将发生竞争的范围缩小到单个变量上。</p><p>原子变量类相当于一种泛化的 <code>volatile</code> 变量，能够支持<strong>原子的、有条件的读/改/写</strong>操作。</p><p>原子类在内部使用 <code>CAS</code> 指令（基于硬件的支持）来实现同步。这些指令通常比锁更快。</p><p>原子变量类可以分为 <code>4</code> 组：</p><ul><li>基本类型<ul><li><code>AtomicBoolean</code> - 布尔类型原子类</li><li><code>AtomicInteger</code> - 整型原子类</li><li><code>AtomicLong</code> - 长整型原子类</li></ul></li><li>引用类型<ul><li><code>AtomicReference</code> - 引用类型原子类</li><li><code>AtomicMarkableReference</code> - 带有标记位的引用类型原子类</li><li><code>AtomicStampedReference</code> - 带有版本号的引用类型原子类</li></ul></li><li>数组类型<ul><li><code>AtomicIntegerArray</code> - 整形数组原子类</li><li><code>AtomicLongArray</code> - 长整型数组原子类</li><li><code>AtomicReferenceArray</code> - 引用类型数组原子类</li></ul></li><li>属性更新器类型<ul><li><code>AtomicIntegerFieldUpdater</code> - 整型字段的原子更新器。</li><li><code>AtomicLongFieldUpdater</code> - 长整型字段的原子更新器。</li><li><code>AtomicReferenceFieldUpdater</code> - 原子更新引用类型里的字段。</li></ul></li></ul><h1 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型"></a> 基本类型</h1><p>这一类型的原子类是针对 <code>Java</code> 基本类型进行操作。</p><ul><li><p><code>AtomicBoolean</code> - 布尔类型原子类</p></li><li><p><code>AtomicInteger</code> - 整型原子类</p></li><li><p><code>AtomicLong</code> - 长整型原子类</p></li></ul><p>以上类都支持 <code>CAS</code>，此外，<code>AtomicInteger</code>、<code>AtomicLong</code> 还支持算术运算。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取当前值</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span> <span class="hljs-comment">// 获取当前值，并设置新值</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span><span class="hljs-comment">// 获取当前值，并自增</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndDecrement</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取当前值，并自减</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> delta)</span> <span class="hljs-comment">// 获取当前值，并加上预期值</span></span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> <span class="hljs-comment">// 如果输入值（update）等于预期值，将该值设置为输入值</span></span><span class="hljs-function"><span class="hljs-comment">// 最终设置为 newValue，使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lazySet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span></span></code></pre><h1 id="引用类型"><a class="markdownIt-Anchor" href="#引用类型"></a> 引用类型</h1><ul><li><p><code>AtomicReference</code> - 引用类型原子类</p></li><li><p><code>AtomicMarkableReference</code> - 带有标记位的引用类型原子类</p></li><li><p><code>AtomicStampedReference</code> - 带有版本号的引用类型原子类</p></li></ul><blockquote><p><code>AtomicStampedReference</code> 类在引用类型原子类中，彻底地解决了 <code>ABA</code> 问题，其它的 <code>CAS</code> 能力与另外两个类相近，所以最具代表性。因此，本节只针对 <code>AtomicStampedReference</code> 进行说明。</p></blockquote><h2 id="atomicreference"><a class="markdownIt-Anchor" href="#atomicreference"></a> AtomicReference</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于 AtomicReference 实现自旋锁</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicRefTest.java 2020/07/21 Tue 4:00 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicRefTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpinLock lock = <span class="hljs-keyword">new</span> SpinLock();        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            executorService.execute(<span class="hljs-keyword">new</span> MyThread(lock));        &#125;        executorService.shutdown();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * SpinLock</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span> </span>&#123;        <span class="hljs-keyword">private</span> AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;            Thread current = Thread.currentThread();            <span class="hljs-comment">// 自旋，为当前线程加锁</span>            <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-keyword">null</span>, current)) &#123;            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;            Thread current = Thread.currentThread();            <span class="hljs-comment">// 只有当前线程才释放锁</span>            atomicReference.compareAndSet(current, <span class="hljs-keyword">null</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * sell ticket by spin lock</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-keyword">private</span> SpinLock lock;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(SpinLock lock)</span> </span>&#123;            <span class="hljs-keyword">this</span>.lock = lock;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;                lock.lock();                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" sell ticket "</span> + ticket);                    ticket--;                &#125;                lock.unlock();            &#125;        &#125;            &#125;&#125;</code></pre><h2 id="atomicmarkablereference"><a class="markdownIt-Anchor" href="#atomicmarkablereference"></a> AtomicMarkableReference</h2><p>原子类的实现基于 <code>CAS</code> 机制，而 <code>CAS</code> 存在 <code>ABA</code> 问题。正是为了解决 <code>ABA</code> 问题，才有了 <code>AtomicMarkableReference</code> 和 <code>AtomicStampedReference</code>。</p><p><code>AtomicMarkableReference</code> 使用一个布尔值作为标记，修改时在 <code>true</code> / <code>false</code> 之间切换。这种策略不能根本上解决 <code>ABA</code> 问题，但是可以降低 <code>ABA</code> 发生的几率。常用于缓存或者状态描述这样的场景。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AtomicMarkableReference 使用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicMarkableRefTest.java 2020/07/21 Tue 4:32 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicMarkableRefTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String INIT_TEXT = <span class="hljs-string">"abc"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> AtomicMarkableReference&lt;String&gt; amr = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(INIT_TEXT, <span class="hljs-keyword">false</span>);        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            executorService.submit(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(Math.abs((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">100</span>));                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                String name = Thread.currentThread().getName();                <span class="hljs-comment">// 若变量为 INIT &amp;&amp; 已被标记，则修改</span>                <span class="hljs-keyword">if</span> (amr.compareAndSet(INIT_TEXT, name, amr.isMarked(), !amr.isMarked())) &#123;                String name = Thread.currentThread().getName();                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 修改了对象"</span>);                    System.out.println(<span class="hljs-string">"新的对象为："</span> + amr.getReference());                &#125;            &#125;);        &#125;        executorService.shutdown();        executorService.awaitTermination(<span class="hljs-number">3</span>, TimeUnit.SECONDS);    &#125;&#125;</code></pre><h2 id="atomicstampedreference"><a class="markdownIt-Anchor" href="#atomicstampedreference"></a> AtomicStampedReference</h2><p><code>AtomicStampedReference</code> 使用一个整型值做为版本号，每次更新前先比较版本号，如果一致，才进行修改。通过这种策略，可以根本上解决 <code>ABA</code> 问题。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AtomicStampedReference 使用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicStampedRefTest.java 2020/07/21 Tue 7:02 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicStampedRefTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String INIT_REF = <span class="hljs-string">"pool-1-thread-3"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; asr = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(INIT_REF, <span class="hljs-number">0</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        System.out.println(<span class="hljs-string">"初始对象为: "</span> + asr.getReference());        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            executorService.submit(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(Math.abs((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">100</span>));                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> stamp = asr.getStamp();                String name = Thread.currentThread().getName();                <span class="hljs-comment">// 若变量为 INIT &amp;&amp; 版本号为 stamp，则修改</span>                <span class="hljs-keyword">if</span> (asr.compareAndSet(INIT_REF, name, stamp, stamp + <span class="hljs-number">1</span>)) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 修改了对象"</span>);                    System.out.println(<span class="hljs-string">"新的对象为："</span> + asr.getReference());                &#125;            &#125;);        &#125;        executorService.shutdown();        executorService.awaitTermination(<span class="hljs-number">3</span>, TimeUnit.SECONDS);    &#125;&#125;</code></pre><h1 id="数组类型"><a class="markdownIt-Anchor" href="#数组类型"></a> 数组类型</h1><ul><li><p><code>AtomicIntegerArray</code> - 整形数组原子类</p></li><li><p><code>AtomicLongArray</code> - 长整型数组原子类</p></li><li><p><code>AtomicReferenceArray</code> - 引用类型数组原子类</p></li></ul><p>数组类型的原子类为 <strong>数组元素</strong> 提供了 <code>volatile</code> 类型的访问语义，这是普通数组所不具备的特性 —— <code>volatile</code> 类型的数组仅在<strong>数组引用</strong>上具有 <code>volatile</code> 语义。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AtomicIntegerArray 使用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicIntegerArrayTest.java 2020/07/21 Tue 7:17 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerArrayTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicIntegerArray atomicIntegerArray = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        System.out.println(<span class="hljs-string">"Init Values: "</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;            atomicIntegerArray.set(i, i);            System.out.print(atomicIntegerArray.get(i) + <span class="hljs-string">" "</span>);        &#125;        System.out.println();        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Increasement());        Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Compare());        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(<span class="hljs-string">"Final Values: "</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;            System.out.print(atomicIntegerArray.get(i) + <span class="hljs-string">" "</span>);        &#125;        System.out.println();    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Increasement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 对数组的每个元素自增 1</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;                <span class="hljs-keyword">int</span> value = atomicIntegerArray.incrementAndGet(i);                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">", index = "</span> + i + <span class="hljs-string">", value = "</span> + value);            &#125;        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compare</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 找到数组值为 2 的元素，修改为 3</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;                <span class="hljs-keyword">boolean</span> swapped = atomicIntegerArray.compareAndSet(i, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);                <span class="hljs-keyword">if</span> (swapped) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" swapped, index = "</span> + i + <span class="hljs-string">", value = 3"</span>);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="属性更新器类型"><a class="markdownIt-Anchor" href="#属性更新器类型"></a> 属性更新器类型</h1><p>更新器类支持基于<strong>反射</strong>机制的更新字段值的原子操作。</p><ul><li><p><code>AtomicIntegerFieldUpdater</code> - 整型字段的原子更新器。</p></li><li><p><code>AtomicLongFieldUpdater</code> - 长整型字段的原子更新器。</p></li><li><p><code>AtomicReferenceFieldUpdater</code> - 原子更新引用类型里的字段。</p></li></ul><p>这些类的使用有一定限制：</p><ul><li>因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 <code>newUpdater()</code> 创建一个更新器，并且需要设置想要更新的类和属性。</li><li>字段必须是 <code>volatile</code> 类型的；</li><li>不能作用于静态变量（<code>static</code>）；</li><li>不能作用于常量（<code>final</code>）；</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * AtomicReferenceFieldUpdater 使用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : AtomicFieldUpdaterTest.java 2020/07/21 Tue 7:33 PM likai</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicFieldUpdaterTest</span> </span>&#123;    <span class="hljs-keyword">static</span> User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"begin"</span>);    <span class="hljs-keyword">static</span> AtomicReferenceFieldUpdater&lt;User, String&gt; updater =            AtomicReferenceFieldUpdater.newUpdater(User.class, String.class, "name");    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            executorService.submit(() -&gt; &#123;            <span class="hljs-comment">// 若 name 的值为 ”begin“，则修改为 “end“</span>                <span class="hljs-keyword">if</span> (updater.compareAndSet(user, <span class="hljs-string">"begin"</span>, <span class="hljs-string">"end"</span>)) &#123;                    <span class="hljs-keyword">try</span> &#123;                        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 已修改 name = "</span> + user.getName());                &#125; <span class="hljs-keyword">else</span> &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"已被其他线程修改"</span>);                &#125;            &#125;);        &#125;        executorService.shutdown();    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;        <span class="hljs-keyword">volatile</span> String name;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并发-锁原理</title>
    <link href="/2020/07/17/concurrent-lock/"/>
    <url>/2020/07/17/concurrent-lock/</url>
    
    <content type="html"><![CDATA[<h1 id="并发锁"><a class="markdownIt-Anchor" href="#并发锁"></a> 并发锁</h1><h2 id="乐观锁和悲观锁"><a class="markdownIt-Anchor" href="#乐观锁和悲观锁"></a> 乐观锁和悲观锁</h2><p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p><h3 id="乐观锁"><a class="markdownIt-Anchor" href="#乐观锁"></a> 乐观锁</h3><p>乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此<strong>乐观锁不会上锁</strong>，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</p><h4 id="实现方式"><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式</h4><ol><li><code>CAS</code> 机制</li></ol><p><code>CAS</code> 操作包括了 3 个操作数：<br />(1) 需要读写的内存位置(<code>V</code>)<br />(2) 进行比较的预期值(<code>A</code>)<br />(3) 拟写入的新值(<code>B</code>)</p><p><code>CAS</code> 操作逻辑如下：如果内存位置 <code>V</code> 的值等于预期的 <code>A</code> 值，则将该位置更新为新值 <code>B</code>，否则不进行任何操作。许多 <code>CAS</code> 的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。</p><blockquote><p><code>CAS</code> 是由 <code>CPU</code> 支持的原子操作，其原子性是在硬件层面进行保证的。</p></blockquote><ol start="2"><li>版本号机制<br />版本号机制的基本思路是在数据中增加一个字段 <code>version</code>，表示该数据的版本号，每当数据被修改，版本号 <code>+1</code>。</li></ol><ul><li>当某个线程查询数据时，将该数据的版本号一起查出来；</li><li>当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。</li></ul><h3 id="悲观锁"><a class="markdownIt-Anchor" href="#悲观锁"></a> 悲观锁</h3><p>悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</p><h4 id="实现方式-2"><a class="markdownIt-Anchor" href="#实现方式-2"></a> 实现方式</h4><p>悲观锁的实现方式是<strong>加锁</strong>，加锁既可以是对<strong>代码块加锁</strong>（如 <code>Java</code>的 <code>synchronized</code> 关键字和 <code>Lock</code>），也可以是对<strong>数据加锁</strong>（如 <code>MySQL</code> 中的排它锁）。</p><h2 id="公平锁与非公平锁"><a class="markdownIt-Anchor" href="#公平锁与非公平锁"></a> 公平锁与非公平锁</h2><p>根据线程获取锁的抢占机制，锁可分为公平锁与非公平锁。</p><ul><li>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。</li><li>非公平锁在运行时闯入，也就是先来不一定先得，如 <code>synchronized</code>。</li><li><code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>，默认是非公平锁，但支持公平锁。</li><li>在没有公平性需求的情况下尽量使用非公平锁，因为公平锁会带来性能开销。</li></ul><h2 id="独占锁与共享锁"><a class="markdownIt-Anchor" href="#独占锁与共享锁"></a> 独占锁与共享锁</h2><p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁可分为独占锁与共享锁。</p><ul><li>独占锁是一种悲观锁，每次访问资源都加上了互斥锁，在同一时间只允许一个线程读取数据。</li><li>共享锁是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</li></ul><h2 id="可重入锁"><a class="markdownIt-Anchor" href="#可重入锁"></a> 可重入锁</h2><p>当一个线程再次获取它已经获取的琐时，如果不被阻塞，那么该锁是可被重入的。</p><p><code>synchronized</code> 内部锁是可重入锁，在其内部维护一个标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。当一个线程获取了该锁时，计数器的值会变成 <code>1</code>，这时其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞挂起。</p><p>但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值 <code>+1</code>，当释放锁后值 <code>-1</code>。当计数器值为 <code>0</code>，线程标示被重置为 <code>null</code>，这时候被阻塞的线程会被唤醒来竞争该锁。</p><h2 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h2><p>当前线程在获取锁时，如果发现锁已被其他线程占有，它不马上阻塞自己，在不放弃 <code>CPU</code> 使用权的情况下，多次尝试获取（默认10次，可以使用 <code>-XX:PreBlockSpinsh</code> 参数设置该值），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定次数后仍没有获取到锁则当前线程才会被阻塞挂起。<br />自旋锁是使用 <code>CPU</code> 时间换取线程阻塞与调度的开销，但是很有可能这些 <code>CPU</code> 时间白白浪费了。</p><h1 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h1><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的相互等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去</p><h2 id="基本条件"><a class="markdownIt-Anchor" href="#基本条件"></a> 基本条件</h2><ol><li>互斥</li><li>请求并持有</li><li>不可剥夺</li><li>环路等待</li></ol><h2 id="避免死锁"><a class="markdownIt-Anchor" href="#避免死锁"></a> 避免死锁</h2><blockquote><p>使用申请资源的有序性，破坏请求并持有和环路等待条件。</p></blockquote><ul><li><p>避免一个线程同时获取多个锁。</p></li><li><p>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</p></li><li><p>尝试使用定时锁 <code>lock.tryLock(timeout)</code>，避免锁一直不能释放。</p></li><li><p>对于数据库锁，加锁和解锁必须在一个数据库连接中里，否则会出现解锁失败的情况。</p></li></ul><h1 id="aqs"><a class="markdownIt-Anchor" href="#aqs"></a> AQS</h1><blockquote><p><code>AbstractQueuedSynchronizer</code>（简称 <code>AQS</code>）是队列同步器，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>Semaphore</code> 等）。</p><p>因此，要想深入理解 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 等并发锁和同步工具，必须先理解 <code>AQS</code> 的要点和原理。</p></blockquote><h2 id="aqs-的要点"><a class="markdownIt-Anchor" href="#aqs-的要点"></a> <code>AQS</code> 的要点</h2><p>在 <code>java.util.concurrent.locks</code> 包中的相关锁(常用的有 <code>ReentrantLock</code>、 <code>ReadWriteLock</code>)都是基于 <code>AQS</code> 来实现。这些锁都没有直接继承 <code>AQS</code>，而是定义了一个 <code>Sync</code> 类去继承 <code>AQS</code>。为什么要这样呢？因为锁面向的是使用用户，而同步器面向的则是线程控制，那么在锁的实现中聚合同步器而不是直接继承 <code>AQS</code> 就可以很好的隔离二者所关注的事情。</p><p><strong><code>AQS</code> 提供了对独享锁与共享锁的支持。</strong></p><h3 id="独享锁-api"><a class="markdownIt-Anchor" href="#独享锁-api"></a> 独享锁 <code>API</code></h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span></code></pre><ul><li><code>acquire</code> - 获取独占锁。</li><li><code>acquireInterruptibly</code> - 获取可中断的独占锁。</li><li><code>tryAcquireNanos</code> - 尝试在指定时间内获取可中断的独占锁。在以下三种情况下回返回：<ul><li>在超时时间内，当前线程成功获取了锁；</li><li>当前线程在超时时间内被中断；</li><li>超时时间结束，仍未获得锁返回 false。</li></ul></li><li><code>release</code> - 释放独占锁。</li></ul><h3 id="共享锁-api"><a class="markdownIt-Anchor" href="#共享锁-api"></a> 共享锁 <code>API</code></h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquireSharedNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span></code></pre><ul><li><code>acquireShared</code> - 获取共享锁。</li><li><code>acquireSharedInterruptibly</code> - 获取可中断的共享锁。</li><li><code>tryAcquireSharedNanos</code> - 尝试在指定时间内获取可中断的共享锁。</li><li><code>release</code> - 释放共享锁。</li></ul><h2 id="aqs-的原理"><a class="markdownIt-Anchor" href="#aqs-的原理"></a> <code>AQS</code> 的原理</h2><h3 id="aqs-的数据结构"><a class="markdownIt-Anchor" href="#aqs-的数据结构"></a> <code>AQS</code> 的数据结构</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">/** 等待队列的队头，懒加载。只能通过 setHead 方法修改。 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;    <span class="hljs-comment">/** 等待队列的队尾，懒加载。只能通过 enq 方法添加新的等待节点。*/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;    <span class="hljs-comment">/** 同步状态 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;&#125;</code></pre><ul><li><p><code>state</code> - <code>AQS</code> 使用一个整型的 <code>volatile</code> 变量来 维护同步状态。</p><ul><li>这个整数状态的意义由子类来赋予，如 <code>ReentrantLock</code> 中该状态值表示所有者线程已经重复获取该锁的次数，<code>Semaphore</code> 中该状态值表示剩余的许可数量。</li></ul></li><li><p><code>head</code> 和 <code>tail</code> - <code>AQS</code> 维护了一个 <code>Node</code> 类型（<code>AQS</code> 的内部类）的双链表来完成同步状态的管理。这个双链表是一个双向的 <code>FIFO</code> 队列，通过 <code>head</code> 和 <code>tail</code> 指针进行访问。当有线程获取锁失败后，就被添加到队列末尾。</p></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200718161601.png" srcset="/img/loading.gif" alt="AQS结构" /></p><p><code>Node</code> 的源码</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-comment">/** 该等待同步的节点处于共享模式 */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();    <span class="hljs-comment">/** 该等待同步的节点处于独占模式 */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">/** 线程等待状态，状态值有: 0、1、-1、-2、-3 */</span>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;    <span class="hljs-comment">/** 前驱节点 */</span>    <span class="hljs-keyword">volatile</span> Node prev;    <span class="hljs-comment">/** 后继节点 */</span>    <span class="hljs-keyword">volatile</span> Node next;    <span class="hljs-comment">/** 等待锁的线程 */</span>    <span class="hljs-keyword">volatile</span> Thread thread;        <span class="hljs-comment">/** 和节点是否共享有关 */</span>    Node nextWaiter;&#125;</code></pre><p>很显然，<code>Node</code> 是一个双链表结构。</p><p><code>waitStatus</code> - <code>Node</code> 使用一个整型的 <code>volatile</code> 变量来 维护 <code>AQS</code> 同步队列中线程节点的状态。<code>waitStatus</code> 有五个状态值：</p><ul><li><p><code>CANCELLED(1)</code> - 此状态表示：该节点的线程可能由于超时或被中断而 <strong>处于被取消(作废)状态</strong>，一旦处于这个状态，表示这个节点应该从等待队列中移除。</p></li><li><p><code>SIGNAL(-1)</code> - 此状态表示：后继节点会被挂起，因此在当前节点释放锁或被取消之后，必须唤醒(<code>unparking</code>)其后继结点。</p></li><li><p><code>CONDITION(-2)</code> - 此状态表示：该节点的线程 处于等待条件状态，不会被当作是同步队列上的节点，直到被唤醒(<code>signal</code>)，设置其值为 0，再重新进入阻塞状态。</p></li><li><p><code>PROPAGATE(-3)</code> - 此状态表示：下一个 <code>acquireShared</code> 应无条件传播。</p></li><li><p><code>0</code> - 非以上状态。</p></li></ul><h3 id="独占锁的获取和释放"><a class="markdownIt-Anchor" href="#独占锁的获取和释放"></a> 独占锁的获取和释放</h3><h4 id="获取独占锁"><a class="markdownIt-Anchor" href="#获取独占锁"></a> 获取独占锁</h4><p><code>AQS</code> 中使用 <code>acquire(int arg)</code> 方法获取独占锁，其大致流程如下：</p><ol><li><p>先尝试获取同步状态，如果获取同步状态成功，则结束方法，直接返回。</p></li><li><p>如果获取同步状态不成功，<code>AQS</code> 会不断尝试利用 <code>CAS</code> 操作将当前线程插入等待同步队列的队尾，直到成功为止。</p></li><li><p>接着，不断尝试为等待队列中的线程节点获取独占锁。<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200718161748.png" srcset="/img/loading.gif" alt="获取锁前" /><br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200718162338.png" srcset="/img/loading.gif" alt="获取锁" /><br />详细流程可以用下图来表示，请结合源码来理解（一图胜千言）：<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200718162114.png" srcset="/img/loading.gif" alt="AQS获取锁工作流程" /></p></li></ol><h4 id="释放独占锁"><a class="markdownIt-Anchor" href="#释放独占锁"></a> 释放独占锁</h4><p><code>AQS</code> 中使用 <code>release(int arg)</code> 方法释放独占锁，其大致流程如下：</p><ol><li><p>先尝试获取解锁线程的同步状态，如果获取同步状态不成功，则结束方法，直接返回。</p></li><li><p>如果获取同步状态成功，<code>AQS</code> 会尝试唤醒当前线程节点的后继节点。</p></li></ol><h4 id="获取可中断的独占锁"><a class="markdownIt-Anchor" href="#获取可中断的独占锁"></a> 获取可中断的独占锁</h4><p><code>AQS</code> 中使用 <code>acquireInterruptibly(int arg)</code> 方法获取可中断的独占锁。</p><p><code>acquireInterruptibly(int arg)</code> 实现方式相较于获取独占锁方法（<code>acquire</code>）非常相似，区别仅在于它会通过 <code>Thread.interrupted</code> 检测当前线程是否被中断，如果是，则立即抛出中断异常（<code>InterruptedException</code>）。</p><h4 id="获取超时等待式的独占锁"><a class="markdownIt-Anchor" href="#获取超时等待式的独占锁"></a> 获取超时等待式的独占锁</h4><p><code>AQS</code> 中使用 <code>tryAcquireNanos(int arg)</code> 方法获取超时等待的独占锁。</p><p><code>doAcquireNanos</code> 的实现方式 相较于获取独占锁方法（ <code>acquire</code>）非常相似，区别在于它会根据超时时间和当前时间计算出截止时间。在获取锁的流程中，会不断判断是否超时，如果超时，直接返回 <code>false</code>；如果没超时，则用 <code>LockSupport.parkNanos</code> 来阻塞当前线程。</p><h3 id="共享锁的获取和释放"><a class="markdownIt-Anchor" href="#共享锁的获取和释放"></a> 共享锁的获取和释放</h3><h4 id="获取共享锁"><a class="markdownIt-Anchor" href="#获取共享锁"></a> 获取共享锁</h4><p><code>AQS</code> 中使用 <code>acquireShared(int arg)</code> 方法获取共享锁。</p><p><code>acquireShared</code> 方法和 <code>acquire</code> 方法的逻辑很相似，区别仅在于自旋的条件以及节点出队的操作有所不同。</p><p>成功获得共享锁的条件如下：</p><ul><li><p><code>tryAcquireShared(arg)</code> 返回值大于等于 <code>0</code> （这意味着共享锁的 permit 还没有用完）。</p></li><li><p>当前节点的前驱节点是头结点。</p></li></ul><h4 id="释放共享锁"><a class="markdownIt-Anchor" href="#释放共享锁"></a> 释放共享锁</h4><p><code>AQS</code> 中使用 <code>releaseShared(int arg)</code> 方法释放共享锁。</p><p><code>releaseShared</code> 首先会尝试释放同步状态，如果成功，则解锁一个或多个后继线程节点。释放共享锁和释放独享锁流程大体相似，区别在于：</p><p>对于独享模式，如果需要 <code>SIGNAL</code>，释放仅相当于调用头节点的 <code>unparkSuccessor</code>。</p><h4 id="获取可中断的共享锁"><a class="markdownIt-Anchor" href="#获取可中断的共享锁"></a> 获取可中断的共享锁</h4><p><code>AQS</code> 中使用 <code>acquireSharedInterruptibly(int arg)</code> 方法获取可中断的共享锁。</p><p><code>acquireSharedInterruptibly</code> 方法与 <code>acquireInterruptibly</code> 几乎一致，不再赘述。</p><h4 id="获取超时等待式的共享锁"><a class="markdownIt-Anchor" href="#获取超时等待式的共享锁"></a> 获取超时等待式的共享锁</h4><p><code>AQS</code> 中使用 <code>tryAcquireSharedNanos(int arg)</code> 方法获取超时等待式的共享锁。</p><p><code>tryAcquireSharedNanos</code> 方法与 <code>tryAcquireNanos</code> 几乎一致，不再赘述。</p><h1 id="reentrantlock"><a class="markdownIt-Anchor" href="#reentrantlock"></a> <code>ReentrantLock</code></h1><blockquote><p><code>ReentrantLock</code> 类是 <code>Lock</code> 接口的具体实现，它是一个可重入锁。与内置锁 <code>synchronized</code> 不同，<code>ReentrantLock</code> 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作，所有获取锁、释放锁的操作都是显式的操作。</p></blockquote><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><ul><li><p><code>ReentrantLock</code> 提供了与 <code>synchronized</code> 相同的互斥性、内存可见性和可重入性。</p></li><li><p><code>ReentrantLock</code> 支持公平锁和**非公平锁（默认）**两种模式。</p></li><li><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，支持了 <code>synchronized</code> 所不具备的灵活性。</p><ul><li><p><code>synchronized</code> 无法中断一个正在等待获取锁的线程</p></li><li><p><code>synchronized</code> 无法在请求获取一个锁时无休止地等待</p></li></ul></li></ul><p><code>Lcok</code> 接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lock</span> </span>&#123;    <span class="hljs-comment">// 获取锁</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 锁未被另一个线程持有，且线程没有被中断的情况下，才能获取锁。</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-comment">// 尝试获取锁，仅在调用时锁未被另一个线程持有的情况下，才获取该锁。</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 和 tryLock() 类似，区别仅在于限定时间，如果限定时间内未获取到锁，视为失败。</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-comment">// 释放锁</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 返回一个绑定到 Lock 对象上的 Condition 实例</span>    <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h2 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法</h2><h3 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;&#125;</code></pre><ul><li><code>ReentrantLock()</code> - 默认构造方法会初始化一个非公平锁（<code>NonfairSync</code>）；</li><li><code>ReentrantLock(boolean)</code> - <code>new ReentrantLock(true)</code> 会初始化一个公平锁（<code>FairSync</code>）。</li></ul><h3 id="lock-和-unlock-方法"><a class="markdownIt-Anchor" href="#lock-和-unlock-方法"></a> <code>lock</code> 和 <code>unlock</code> 方法</h3><ul><li><p><code>lock()</code> - <strong>无条件获取锁</strong>。如果当前线程无法获取锁，则当前线程进入休眠状态不可用，直至当前线程获取到锁。如果该锁没有被另一个线程持有，则获取该锁并立即返回，将锁的持有计数设置为 <code>1</code>。</p></li><li><p><code>unlock()</code> - 用于释放锁。</p></li></ul><blockquote><p>🔔 注意：获取锁操作 <code>lock()</code> 必须在 <code>try catch</code> 块中进行，并且将释放锁操作 <code>unlock()</code> 放在 <code>finally</code> 块中进行，以保证锁一定被被释放，防止死锁的发生。</p></blockquote><h3 id="trylock-方法"><a class="markdownIt-Anchor" href="#trylock-方法"></a> <code>tryLock</code> 方法</h3><p>与无条件获取锁相比，<code>tryLock</code> 有更完善的容错机制。</p><ul><li><p><code>tryLock()</code> - 可轮询获取锁。如果成功，则返回 <code>true</code>；如果失败，则返回 <code>false</code>。也就是说，这个方法无论成败都会<strong>立即返回</strong>，获取不到锁（锁已被其他线程获取）时不会一直等待。</p></li><li><p><code>tryLock(long, TimeUnit)</code> - 可定时获取锁。和 <code>tryLock()</code> 类似，区别仅在于这个方法在获取不到锁时会等待一定的时间，在时间期限之内如果还获取不到锁，就返回 <code>false</code>。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 <code>true</code>。</p></li></ul><h3 id="lockinterruptibly-方法"><a class="markdownIt-Anchor" href="#lockinterruptibly-方法"></a> <code>lockInterruptibly</code> 方法</h3><p><code>lockInterruptibly()</code> - 可中断获取锁。可中断获取锁可以在获得锁的同时保持对中断的响应。可中断获取锁比其它获取锁的方式稍微复杂一些，需要两个 <code>try-catch</code> 块（如果在获取锁的操作中抛出了 <code>InterruptedException</code> ，那么可以使用标准的 <code>try-finally</code> 加锁模式）。</p><p>举例来说：假设有两个线程同时通过 <code>lock.lockInterruptibly()</code> 获取某个锁时，若线程 <code>A</code> 获取到了锁，则线程 <code>B</code> 只能等待。若此时对线程 <code>B</code> 调用 <code>threadB.interrupt()</code> 方法能够中断线程 <code>B</code> 的等待过程。由于 <code>lockInterruptibly()</code> 的声明中抛出了异常，所以 <code>lock.lockInterruptibly()</code> 必须放在 <code>try</code> 块中或者在调用 <code>lockInterruptibly()</code> 的方法外声明抛出 <code>InterruptedException</code>。</p><blockquote><p>🔔 注意：当一个线程获取了锁之后，是不会被 <code>interrupt()</code> 方法中断的。单独调用 <code>interrupt()</code> 方法不能中断正在运行状态中的线程，只能中断阻塞状态中的线程。因此当通过 <code>lockInterruptibly()</code> 方法获取某个锁时，如果未获取到锁，只有在等待的状态下，才可以响应中断。</p></blockquote><h3 id="newcondition-方法"><a class="markdownIt-Anchor" href="#newcondition-方法"></a> <code>newCondition</code> 方法</h3><p><code>newCondition()</code> - 返回一个绑定到 <code>Lock</code> 对象上的 <code>Condition</code> 实例。</p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><h3 id="reentrantlock-的数据结构"><a class="markdownIt-Anchor" href="#reentrantlock-的数据结构"></a> <code>ReentrantLock</code> 的数据结构</h3><p>它有一个核心字段：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;</code></pre><p><code>sync</code> - 内部抽象类 <code>ReentrantLock.Sync</code> 对象，<code>Sync</code> 继承自 <code>AQS</code>。它有两个子类：</p><ol><li><p><code>ReentrantLock.FairSync</code> - 公平锁。</p></li><li><p><code>ReentrantLock.NonfairSync</code> - 非公平锁。</p></li></ol><h3 id="获取锁和释放锁"><a class="markdownIt-Anchor" href="#获取锁和释放锁"></a> 获取锁和释放锁</h3><p><code>ReentrantLock</code> 获取锁和释放锁的接口，从表象看，是调用 <code>ReentrantLock.FairSync</code> 或 <code>ReentrantLock.NonfairSync</code> 中各自的实现；从本质上看，是基于 <code>AQS</code> 的实现。</p><ul><li><p><code>void lock()</code> 调用 <code>Sync</code> 的 <code>lock()</code> 方法。</p></li><li><p><code>void lockInterruptibly()</code> 直接调用 <code>AQS</code> 的 获取可中断的独占锁 方法 <code>lockInterruptibly()</code>。</p></li><li><p><code>boolean tryLock()</code> 调用 <code>Sync</code> 的 <code>nonfairTryAcquire()</code> 。</p></li><li><p><code>boolean tryLock(long time, TimeUnit unit)</code> 直接调用 <code>AQS</code> 的 获取超时等待式的独占锁 方法 <code>tryAcquireNanos(int arg, long nanosTimeout)</code>。</p></li><li><p><code>void unlock()</code> 直接调用 <code>AQS</code> 的 释放独占锁 方法 <code>release(int arg)</code> 。</p></li></ul><h1 id="reentrantreadwritelock"><a class="markdownIt-Anchor" href="#reentrantreadwritelock"></a> <code>ReentrantReadWriteLock</code></h1><blockquote><p><code>ReentrantReadWriteLock</code> 类是 <code>ReadWriteLock</code> 接口的具体实现，它是一个<strong>可重入</strong>的读写锁。<code>ReentrantReadWriteLock</code> 维护了一对读写锁，将读写锁分开，有利于提高并发效率。</p></blockquote><p><code>ReentrantLock</code> 实现了一种标准的互斥锁：每次最多只有一个线程能持有 <code>ReentrantLock</code>。但对于维护数据的完整性来说，互斥通常是一种过于强硬的加锁策略，因此也就不必要地限制了并发性。大多数场景下，读操作比写操作频繁，只要保证每个线程都能读取到最新数据，并且在读数据时不会有其它线程在修改数据，那么就不会出现线程安全问题。这种策略减少了互斥同步，自然也提升了并发性能，<code>ReentrantReadWriteLock</code> 就是这种策略的具体实现。</p><h2 id="特性-2"><a class="markdownIt-Anchor" href="#特性-2"></a> 特性</h2><ul><li><p><code>ReentrantReadWriteLock</code> 适用于读多写少的场景。如果是写多读少的场景，由于 <code>ReentrantReadWriteLock</code> 其内部实现比 <code>ReentrantLock</code> 复杂，性能可能反而要差一些。如果存在这样的问题，需要具体问题具体分析。由于 <code>ReentrantReadWriteLock</code> 的读写锁（<code>ReadLock</code>、<code>WriteLock</code>）都实现了 <code>Lock</code> 接口，所以要替换为 <code>ReentrantLock</code> 也较为容易。</p></li><li><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> 接口，支持了 <code>ReentrantLock</code> 所不具备的读写锁分离。<code>ReentrantReadWriteLock</code> 维护了一对读写锁（<code>ReadLock</code>、<code>WriteLock</code>）。将读写锁分开，有利于提高并发效率。<code>ReentrantReadWriteLock</code> 的加锁策略是：<strong>允许多个读操作并发执行，但每次只允许一个写操作</strong>。</p></li><li><p><code>ReentrantReadWriteLock</code> 为读写锁都提供了可重入的加锁语义。</p></li><li><p><code>ReentrantReadWriteLock</code> 支持公平锁和非公平锁（默认）两种模式。</p></li></ul><p><code>ReadWriteLock</code> 接口定义如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReadWriteLock</span> </span>&#123;    <span class="hljs-comment">// 返回用于读操作的锁</span>    <span class="hljs-function">Lock <span class="hljs-title">readLock</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 返回用于写操作的锁</span>    <span class="hljs-function">Lock <span class="hljs-title">writeLock</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h2 id="用法-2"><a class="markdownIt-Anchor" href="#用法-2"></a> 用法</h2><h3 id="构造方法-2"><a class="markdownIt-Anchor" href="#构造方法-2"></a> 构造方法</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantReadWriteLock</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;&#125;</code></pre><ul><li><p><code>ReentrantReadWriteLock()</code> - 默认构造方法会初始化一个非公平锁（<code>NonfairSync</code>）。在非公平的锁中，线程获得锁的顺序是不确定的。写线程降级为读线程是可以的，但读线程升级为写线程是不可以的（这样会导致死锁）。</p></li><li><p><code>ReentrantReadWriteLock(boolean)</code> - <code>new ReentrantLock(true)</code> 会初始化一个公平锁（<code>FairSync</code>）。对于公平锁，等待时间最长的线程将优先获得锁。如果这个锁是读线程持有，则另一个线程请求写锁，那么其他读线程都不能获得读锁，直到写线程释放写锁。</p></li></ul><h3 id="使用实例"><a class="markdownIt-Anchor" href="#使用实例"></a> 使用实例</h3><p><code>ReentrantReadWriteLock</code> 与 <code>ReentrantLock</code> 用法上的差异，主要在于<strong>读写锁的配合使用</strong>。本文以一个典型使用场景来进行讲解。</p><p>示例：基于 <code>ReentrantReadWriteLock</code> 实现一个简单的本地缓存</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 简单的无界缓存实现</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 使用 WeakHashMap 存储键值对。WeakHashMap 中存储的对象是弱引用，JVM GC 时会自动清除没有被引用的弱引用对象。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnboundedCache</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; cacheMap = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock cacheLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;        cacheLock.readLock().lock();        V value;        <span class="hljs-keyword">try</span> &#123;            value = cacheMap.get(key);            String log = String.format(<span class="hljs-string">"%s 读数据 %s:%s"</span>, Thread.currentThread().getName(), key, value);            System.out.println(log);        &#125; <span class="hljs-keyword">finally</span> &#123;            cacheLock.readLock().unlock();        &#125;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;        cacheLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            cacheMap.put(key, value);            String log = String.format(<span class="hljs-string">"%s 写入数据 %s:%s"</span>, Thread.currentThread().getName(), key, value);            System.out.println(log);        &#125; <span class="hljs-keyword">finally</span> &#123;            cacheLock.writeLock().unlock();        &#125;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span> </span>&#123;        cacheLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> cacheMap.remove(key);        &#125; <span class="hljs-keyword">finally</span> &#123;            cacheLock.writeLock().unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        cacheLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.cacheMap.clear();        &#125; <span class="hljs-keyword">finally</span> &#123;            cacheLock.writeLock().unlock();        &#125;    &#125;&#125;</code></pre><ul><li><p>使用 <code>WeakHashMap</code> 而不是 <code>HashMap</code> 来存储键值对。<code>WeakHashMap</code> 中存储的对象是弱引用，<code>JVM GC</code> 时会自动清除没有被引用的弱引用对象。</p></li><li><p>向 Map 写数据前加写锁，写完后，释放写锁。</p></li><li><p>向 Map 读数据前加读锁，读完后，释放读锁。</p></li></ul><h2 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h2><h3 id="reentrantreadwritelock-的数据结构"><a class="markdownIt-Anchor" href="#reentrantreadwritelock-的数据结构"></a> <code>ReentrantReadWriteLock</code> 的数据结构</h3><pre><code class="hljs java"><span class="hljs-comment">/** Inner class providing readlock */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;<span class="hljs-comment">/** Inner class providing writelock */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;<span class="hljs-comment">/** Performs all synchronization mechanics */</span><span class="hljs-keyword">final</span> Sync sync;<span class="hljs-keyword">public</span> ReentrantReadWriteLock.<span class="hljs-function">WriteLock <span class="hljs-title">writeLock</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> writerLock; &#125;<span class="hljs-keyword">public</span> ReentrantReadWriteLock.<span class="hljs-function">ReadLock  <span class="hljs-title">readLock</span><span class="hljs-params">()</span>  </span>&#123; <span class="hljs-keyword">return</span> readerLock; &#125;</code></pre><ul><li><p><code>sync</code> - 内部类 <code>ReentrantReadWriteLock.Sync</code> 对象。与 <code>ReentrantLock</code> 类似，它有两个子类：<code>ReentrantReadWriteLock.FairSync</code> 和 <code>ReentrantReadWriteLock.NonfairSync</code> ，分别表示公平锁和非公平锁的实现。</p></li><li><p><code>readerLock</code> - 内部类 <code>ReentrantReadWriteLock.ReadLock</code> 对象，这是一把读锁。</p></li><li><p><code>writerLock</code> - 内部类 <code>ReentrantReadWriteLock.WriteLock</code> 对象，这是一把写锁。</p></li></ul><h3 id="获取锁和释放锁-2"><a class="markdownIt-Anchor" href="#获取锁和释放锁-2"></a> 获取锁和释放锁</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// 调用 AQS 获取共享锁方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        sync.acquireShared(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// 调用 AQS 释放共享锁方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.releaseShared(<span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// 调用 AQS 获取独占锁方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        sync.acquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// 调用 AQS 释放独占锁方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.release(<span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h1 id="condition"><a class="markdownIt-Anchor" href="#condition"></a> Condition</h1><p><code>Java 1.5</code> 之前，主要是利用 <code>Object</code> 类中的 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 配合 <code>synchronized</code> 来进行线程间通信。</p><p><code>wait</code>、<code>notify</code>、<code>notifyAll</code> 需要配合 <code>synchronized</code> 使用，不适用于 <code>Lock</code>。而使用 <code>Lock</code> 的线程，彼此间通信应该使用 <code>Condition</code>。<br />这可以理解为，什么样的锁配什么样的钥匙。内置锁（<code>synchronized</code>）配合内置条件队列（<code>wait</code>、<code>notify</code>、<code>notifyAll</code>），显式锁（<code>Lock</code>）配合显式条件队列（<code>Condition</code>）。</p><h2 id="特性-3"><a class="markdownIt-Anchor" href="#特性-3"></a> 特性</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Condition</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">awaitNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>其中，<code>await</code>、<code>signal</code>、<code>signalAll</code> 与 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 相对应，功能也相似。除此以外，<code>Condition</code> 相比内置条件队列（<code>wait</code>、<code>notify</code>、<code>notifyAll</code>），提供了更为丰富的功能：</p><ul><li><p>每个锁（<code>Lock</code>）上可以存在多个 <code>Condition</code>，这意味着锁的状态条件可以有多个。</p></li><li><p>支持公平的或非公平的队列操作。</p></li><li><p>支持可中断的条件等待，相关方法：<code>awaitUninterruptibly()</code>。</p></li><li><p>支持可定时的等待，相关方法：<code>awaitNanos(long)</code> 、<code>await(long, TimeUnit)</code>、<code>awaitUntil(Date)</code>。</p></li></ul><h2 id="用法-3"><a class="markdownIt-Anchor" href="#用法-3"></a> 用法</h2><p>这里以 <code>Condition</code> 来实现一个消费者、生产者模式。</p><blockquote><p>🔔 注意：事实上，解决此类问题使用 <code>CountDownLatch</code>、<code>Semaphore</code> 等工具更为便捷、安全。</p></blockquote><p>消息类：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition consumeCondition = lock.newCondition();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition produceCondition = lock.newCondition();    <span class="hljs-keyword">private</span> String message;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> state;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> end;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//lock</span>        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// no new message wait for new message</span>            <span class="hljs-keyword">while</span> (!state) &#123;                consumeCondition.await();            &#125;            System.out.println(<span class="hljs-string">"consume message : "</span> + message);            state = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// message consumed, notify waiting thread</span>            produceCondition.signal();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;            System.out.println(<span class="hljs-string">"Thread interrupted - viewMessage"</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(String message)</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// last message not consumed, wait for it be consumed</span>            <span class="hljs-keyword">while</span> (state) &#123;                produceCondition.await();            &#125;            System.out.println(<span class="hljs-string">"produce msg: "</span> + message);            <span class="hljs-keyword">this</span>.message = message;            state = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">// new message added, notify waiting thread</span>            consumeCondition.signal();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;            System.out.println(<span class="hljs-string">"Thread interrupted - publishMessage"</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> end;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnd</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> end)</span> </span>&#123;        <span class="hljs-keyword">this</span>.end = end;    &#125;&#125;</code></pre><p>生产者：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> Message message;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageProducer</span><span class="hljs-params">(Message msg)</span> </span>&#123;        message = msg;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        produce();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;        List&lt;String&gt; msgs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        msgs.add(<span class="hljs-string">"Begin"</span>);        msgs.add(<span class="hljs-string">"Msg1"</span>);        msgs.add(<span class="hljs-string">"Msg2"</span>);        <span class="hljs-keyword">for</span> (String msg : msgs) &#123;            message.produce(msg);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">100</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        message.produce(<span class="hljs-string">"End"</span>);        message.setEnd(<span class="hljs-keyword">true</span>);    &#125;&#125;</code></pre><p>消费者：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> Message message;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageConsumer</span><span class="hljs-params">(Message msg)</span> </span>&#123;        message = msg;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (!message.isEnd()) &#123; message.consume(); &#125;    &#125;&#125;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockConditionDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Message msg = <span class="hljs-keyword">new</span> Message();        Thread producer = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MessageProducer(msg));        Thread consumer = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MessageConsumer(msg));        producer.start();        consumer.start();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Overview</title>
    <link href="/2018/12/28/overview/"/>
    <url>/2018/12/28/overview/</url>
    
    <content type="html"><![CDATA[<p>During the past six months, I was focusing on preparing for the entrance exam of postgraduate schools, owing to that, I could barely write posts or sorting out my blog. What’s worse, I figured out that I got my server expired and lost most of my posts that I have written in the almost past three years, in which I have made some records in my study and lives, including programming thoughts and life experiences.</p><p>As you’ll find out, I plan to migrate my blog from cloud server to git pages, it’s kind of a large project. Thanks to the exam which I have mentioned above, actually I did not expect that I could spend a surprisingly large amount of time in concentrating on one thing. It’s helpful in building up a hard-working, persistent personality.</p><p>In short, now that I’ve finished my exam, I plan to get a vacation for a couple of weeks and then back to my blog’s migration.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
