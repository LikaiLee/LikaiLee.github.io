<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode 781. 森林中的兔子</title>
    <link href="/2021/04/04/LeetCode-781-rabbits-in-forest/"/>
    <url>/2021/04/04/LeetCode-781-rabbits-in-forest/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/rabbits-in-forest/" target="_blank" rel="noopener">781. 森林中的兔子</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numRabbits</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] answers)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1000</span>];    <span class="hljs-keyword">int</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1000</span>];    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ans : answers) &#123;        used[ans]++;        <span class="hljs-comment">// 出现 0 次，只有一个元素</span>        <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">0</span>) &#123;            res += <span class="hljs-number">1</span>;        &#125;         <span class="hljs-comment">// 第一次出现 ans</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (counts[ans] == <span class="hljs-number">0</span>) &#123;            counts[ans] = ans + <span class="hljs-number">1</span>;            res += counts[ans];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (counts[ans] &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// ans 已经全部出现了，需要重置</span>            <span class="hljs-keyword">if</span> (used[ans] == (ans + <span class="hljs-number">1</span>)) &#123;                counts[ans] = <span class="hljs-number">0</span>;                used[ans] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// [2,1,2,2,2,2,2,2,1,1]</span>    <span class="hljs-comment">//  3 2     3     3   2</span>    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 面试题 17.21. 直方图的水量</title>
    <link href="/2021/04/02/interview-17-21-volume-of-histogram-lcci/"/>
    <url>/2021/04/02/interview-17-21-volume-of-histogram-lcci/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/" target="_blank" rel="noopener">面试题 17.21. 直方图的水量</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = height.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    left[<span class="hljs-number">0</span>] = Integer.MIN_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        left[i] = Math.max(height[i - <span class="hljs-number">1</span>], left[i - <span class="hljs-number">1</span>]);    &#125;    right[len - <span class="hljs-number">1</span>] = Integer.MIN_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        right[i] = Math.max(height[i + <span class="hljs-number">1</span>], right[i + <span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">int</span> top = Math.min(left[i], right[i]) - height[i];        <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>) &#123;            res += top;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1006. 笨阶乘</title>
    <link href="/2021/04/01/LeetCode-1006-clumsy-factorial/"/>
    <url>/2021/04/01/LeetCode-1006-clumsy-factorial/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/clumsy-factorial/" target="_blank" rel="noopener">1006. 笨阶乘</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">clumsy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;        <span class="hljs-comment">// 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</span>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">int</span> op = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (N &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">switch</span> (op) &#123;                <span class="hljs-comment">// '*</span>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                    stack.push(stack.pop() * N);                    <span class="hljs-keyword">break</span>;                <span class="hljs-comment">// '/'</span>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                    stack.push(stack.pop() / N);                    <span class="hljs-keyword">break</span>;                <span class="hljs-comment">// '-'</span>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                    stack.push(-N);                    <span class="hljs-keyword">break</span>;                <span class="hljs-comment">// '+'</span>                <span class="hljs-keyword">default</span>:                    stack.push(N);                    <span class="hljs-keyword">break</span>;            &#125;            op = (op + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;            N--;        &#125;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;            res += stack.pop();        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 236. 二叉树的最近公共祖先</title>
    <link href="/2021/03/31/LeetCode-236-lowest-common-ancestor-of-a-binary-tree/"/>
    <url>/2021/03/31/LeetCode-236-lowest-common-ancestor-of-a-binary-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-comment">// 找到 p 或 q</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root == p || root == q) &#123;            <span class="hljs-keyword">return</span> root;        &#125;        <span class="hljs-comment">// 在左右子树中分别查找 p，q 是否存在</span>        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        <span class="hljs-comment">// 左右子树存在，则 root 为祖先</span>        <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> root;        &#125;        <span class="hljs-comment">// left 存在，right 为 null</span>        <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> left;        &#125;        <span class="hljs-comment">// right 存在，left 为 null</span>        <span class="hljs-keyword">if</span> (right != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> right;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 141. 环形链表</title>
    <link href="/2021/03/31/LeetCode-141-linked-list-cycle/"/>
    <url>/2021/03/31/LeetCode-141-linked-list-cycle/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        ListNode fast = head;        ListNode slow = head;        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;            fast = fast.next.next;            slow = slow.next;            <span class="hljs-keyword">if</span> (fast == slow) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 142. 环形链表 II</title>
    <link href="/2021/03/31/LeetCode-142-linked-list-cycle-ii/"/>
    <url>/2021/03/31/LeetCode-142-linked-list-cycle-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * slow = a</span><span class="hljs-comment">         * fast = 2 * slow = a + a = a + n * circle</span><span class="hljs-comment">         * =&gt; slow = a = n * circle</span><span class="hljs-comment">         * b              -&gt; startPoint</span><span class="hljs-comment">         * b + n * circle -&gt; startPoint</span><span class="hljs-comment">         * =&gt; slow + b == startPoint</span><span class="hljs-comment">         * =&gt; slow 再走 b 步到达入口 &lt;=&gt; 从起点走 b 步和 slow 相遇</span><span class="hljs-comment">         */</span>        ListNode slow = head;        ListNode fast = head;        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            slow = slow.next;            fast = fast.next.next;        &#125; <span class="hljs-keyword">while</span> (slow != fast);        <span class="hljs-comment">// 走 b 步直到和 slow 相遇</span>        fast = head;        <span class="hljs-keyword">while</span> (fast != slow) &#123;            slow = slow.next;            fast = fast.next;        &#125;        <span class="hljs-keyword">return</span> slow;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 173. 二叉搜索树迭代器</title>
    <link href="/2021/03/28/LeetCode-173-binary-search-tree-iterator/"/>
    <url>/2021/03/28/LeetCode-173-binary-search-tree-iterator/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">173. 二叉搜索树迭代器</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> </span>&#123;    LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BSTIterator</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;                stack.push(root);                root = root.left;            &#125;            TreeNode cur = stack.pop();            list.add(cur.val);            root = cur.right;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> list.removeFirst();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> !list.isEmpty();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 83. 删除排序链表中的重复元素</title>
    <link href="/2021/03/26/LeetCode-83-remove-duplicates-from-sorted-list/"/>
    <url>/2021/03/26/LeetCode-83-remove-duplicates-from-sorted-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">101</span>);    ListNode tail = dummy;    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (head.val != tail.val) &#123;            tail.next = head;            tail = tail.next;        &#125;        head = head.next;    &#125;    tail.next = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 82. 删除排序链表中的重复元素 II</title>
    <link href="/2021/03/25/LeetCode-82-remove-duplicates-from-sorted-list-ii/"/>
    <url>/2021/03/25/LeetCode-82-remove-duplicates-from-sorted-list-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">101</span>);    <span class="hljs-comment">// prev -&gt; tail</span>    ListNode prev = dummy;    ListNode tail = dummy;    <span class="hljs-keyword">boolean</span> rmTail = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (tail.val != head.val) &#123;            <span class="hljs-comment">// 需要删除 重复的 tail，prev 为新的 tail</span>            <span class="hljs-keyword">if</span> (rmTail) &#123;                tail = prev;                rmTail = <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 更新 prev 为当前 tail</span>            prev = tail;            <span class="hljs-comment">// tail 向后</span>            tail.next = head;            tail = tail.next;        &#125; <span class="hljs-keyword">else</span> &#123;            rmTail = <span class="hljs-keyword">true</span>;        &#125;        head = head.next;    &#125;    <span class="hljs-keyword">if</span> (rmTail) &#123;        prev.next = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 456. 132 模式</title>
    <link href="/2021/03/24/LeetCode-456-132-pattern/"/>
    <url>/2021/03/24/LeetCode-456-132-pattern/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/132-pattern/" target="_blank" rel="noopener">456. 132 模式</a></p><h1 id="暴力"><a class="markdownIt-Anchor" href="#暴力"></a> 暴力</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;     <span class="hljs-comment">// 固定</span>    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 左边最小的可以作为 1</span>    <span class="hljs-keyword">int</span> one = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 向右找 2</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;            <span class="hljs-keyword">if</span> (one &lt; nums[j] &amp;&amp; nums[i] &gt; nums[j]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        one = Math.min(nums[i], one);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-comment">// [3,5,0,3,4]</span>    Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] leftMin = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    leftMin[<span class="hljs-number">0</span>] = Integer.MAX_VALUE;    <span class="hljs-comment">// 找到左边最小的 1</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        leftMin[i] = Math.min(leftMin[i - <span class="hljs-number">1</span>], nums[i - <span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// 2 是 小于 nums[i] 的最大值</span>        <span class="hljs-keyword">int</span> rightMax = Integer.MIN_VALUE;        <span class="hljs-comment">// 单调递减栈，找到 &lt; nums[i] 的最大值</span>        <span class="hljs-comment">// pop 直到栈顶 &gt; nums[i]，说明出栈的都是比 nums[i] 小的数字</span>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i] &gt; stack.peek()) &#123;            rightMax = stack.pop();        &#125;        <span class="hljs-keyword">if</span> (leftMin[i] &lt; rightMax &amp;&amp; rightMax &lt; nums[i]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        stack.push(nums[i]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 150. 逆波兰表达式求值</title>
    <link href="/2021/03/20/LeetCode-150-evaluate-reverse-polish-notation/"/>
    <url>/2021/03/20/LeetCode-150-evaluate-reverse-polish-notation/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(String[] tokens)</span> </span>&#123;    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">for</span> (String token : tokens) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-string">"+"</span>.equals(token)) &#123;            <span class="hljs-keyword">int</span> num1 = stack.pop();            <span class="hljs-keyword">int</span> num2 = stack.pop();            stack.push(num1 + num2);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"-"</span>.equals(token)) &#123;            <span class="hljs-keyword">int</span> num1 = stack.pop();            <span class="hljs-keyword">int</span> num2 = stack.pop();            stack.push(num2 - num1);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"*"</span>.equals(token)) &#123;            <span class="hljs-keyword">int</span> num1 = stack.pop();            <span class="hljs-keyword">int</span> num2 = stack.pop();            stack.push(num1 * num2);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"/"</span>.equals(token)) &#123;            <span class="hljs-keyword">int</span> num1 = stack.pop();            <span class="hljs-keyword">int</span> num2 = stack.pop();            stack.push(num2 / num1);        &#125; <span class="hljs-keyword">else</span> &#123;            stack.push(Integer.parseInt(token));        &#125;    &#125;    <span class="hljs-keyword">return</span> stack.pop();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1603. 设计停车系统</title>
    <link href="/2021/03/19/LeetCode-1603-design-parking-system/"/>
    <url>/2021/03/19/LeetCode-1603-design-parking-system/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/design-parking-system/" target="_blank" rel="noopener">1603. 设计停车系统</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkingSystem</span> </span>&#123;        <span class="hljs-keyword">int</span> big;    <span class="hljs-keyword">int</span> medium;    <span class="hljs-keyword">int</span> small;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParkingSystem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> big, <span class="hljs-keyword">int</span> medium, <span class="hljs-keyword">int</span> small)</span> </span>&#123;        <span class="hljs-keyword">this</span>.big = big;        <span class="hljs-keyword">this</span>.medium = medium;        <span class="hljs-keyword">this</span>.small = small;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addCar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> carType)</span> </span>&#123;        <span class="hljs-keyword">if</span> (carType == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> big-- &gt; <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (carType == <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> medium-- &gt; <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> small-- &gt; <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 80. 删除排序数组中的重复项 II</title>
    <link href="/2021/03/16/LeetCode-80-remove-duplicates-from-sorted-array-ii/"/>
    <url>/2021/03/16/LeetCode-80-remove-duplicates-from-sorted-array-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">80. 删除排序数组中的重复项 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 有效位</span>    <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 有效位上数字的连续出现次数</span>    <span class="hljs-keyword">int</span> occur = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] == nums[end]) &#123;            occur++;            <span class="hljs-comment">// 出现次数 &lt;= 2，nums[i] 有效，否则 end 保持不变</span>            <span class="hljs-keyword">if</span> (occur &lt;= <span class="hljs-number">2</span>) &#123;                end++;                nums[end] = nums[i];            &#125;        &#125;        <span class="hljs-comment">// 不连续时重置</span>        <span class="hljs-keyword">else</span> &#123;            end++;            nums[end] = nums[i];            occur = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> end + <span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 73. 矩阵置零</title>
    <link href="/2021/03/16/LeetCode-73-set-matrix-zeroes/"/>
    <url>/2021/03/16/LeetCode-73-set-matrix-zeroes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">73. 矩阵置零</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">int</span> rows = matrix.length;        <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">boolean</span> row0 = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">boolean</span> col0 = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// 检查第一列含 0</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] row : matrix) &#123;            <span class="hljs-keyword">if</span> (row[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;                col0 = <span class="hljs-keyword">true</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// 检查第一行含 0</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;                row0 = <span class="hljs-keyword">true</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// 第一行和第一列作为标记位</span>        <span class="hljs-comment">// 若有 0 则该行或该列置 0</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;                    matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;                    matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 置 0</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span> || matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;                    matrix[i][j] = <span class="hljs-number">0</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 额外判断第一行和第一列</span>        <span class="hljs-keyword">if</span> (row0) &#123;            Arrays.fill(matrix[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">if</span> (col0) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 59. 螺旋矩阵 II</title>
    <link href="/2021/03/16/LeetCode-59-spiral-matrix-ii/"/>
    <url>/2021/03/16/LeetCode-59-spiral-matrix-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. 螺旋矩阵 II</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span>[][] moves = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-keyword">int</span> target;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;        target = n * n;        <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];        dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n, res);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> dir, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] res)</span> </span>&#123;        res[x][y] = num;        <span class="hljs-keyword">if</span> (++count == target) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">int</span> nx = x + moves[dir][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> ny = y + moves[dir][<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n &amp;&amp; res[nx][ny] == <span class="hljs-number">0</span>) &#123;                dfs(num + <span class="hljs-number">1</span>, nx, ny, dir, n, res);                <span class="hljs-keyword">return</span>;            &#125;            dir = (dir + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 54. 螺旋矩阵</title>
    <link href="/2021/03/15/LeetCode-54-spiral-matrix/"/>
    <url>/2021/03/15/LeetCode-54-spiral-matrix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 优先级：右 下 左 上</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] moves = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> target;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        rows = matrix.length;        cols = matrix[<span class="hljs-number">0</span>].length;        target = rows * cols;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, matrix, visited, res);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> dir, <span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">boolean</span>[][] visited, List&lt;Integer&gt; res)</span> </span>&#123;        count++;        visited[x][y] = <span class="hljs-keyword">true</span>;        res.add(matrix[x][y]);        <span class="hljs-comment">// 全部访问完则结束</span>        <span class="hljs-keyword">if</span> (count == target) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-comment">// 使用上一个方向继续找</span>            <span class="hljs-keyword">int</span> nx = x + moves[dir][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> ny = y + moves[dir][<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (inArea(nx, ny) &amp;&amp; !visited[nx][ny]) &#123;                dfs(nx, ny, dir, matrix, visited, res);                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">// 上一个方向无效，使用下一个方向</span>            dir = (dir + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 706. 设计哈希映射</title>
    <link href="/2021/03/14/LeetCode-706-design-hashmap/"/>
    <url>/2021/03/14/LeetCode-706-design-hashmap/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/design-hashmap/" target="_blank" rel="noopener">706. 设计哈希映射</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node[] buckets;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1024</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashMap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.buckets = <span class="hljs-keyword">new</span> Node[N];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * value will always be non-negative.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">int</span> idx = getIndex(key);        Node node = buckets[idx];        <span class="hljs-comment">// 检查第一个节点</span>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            buckets[idx] = <span class="hljs-keyword">new</span> Node(key, value);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 查找链表</span>        Node prev = node;        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 找到则替换值</span>            <span class="hljs-keyword">if</span> (node.key == key) &#123;                node.val = value;                <span class="hljs-keyword">return</span>;            &#125;            prev = node;            node = node.next;        &#125;        <span class="hljs-comment">// 未找到，尾插入</span>        prev.next = <span class="hljs-keyword">new</span> Node(key, value);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">int</span> idx = getIndex(key);        Node node = buckets[idx];        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (node.key == key) &#123;                <span class="hljs-keyword">return</span> node.val;            &#125;            node = node.next;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Removes the mapping of the specified value key if this map contains a mapping for the key</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">int</span> idx = getIndex(key);        Node node = buckets[idx];        <span class="hljs-comment">// 检查第一个节点</span>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (node.key == key) &#123;            buckets[idx] = node.next;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 查找链表</span>        Node prev = node;        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 找到则删除</span>            <span class="hljs-keyword">if</span> (node.key == key) &#123;                prev.next = node.next;                <span class="hljs-keyword">return</span>;            &#125;            prev = node;            node = node.next;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">int</span> h = Objects.hashCode(key);        h ^= (h &gt;&gt;&gt; <span class="hljs-number">16</span>);        <span class="hljs-keyword">return</span> h &amp; (N - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-keyword">int</span> key;        <span class="hljs-keyword">int</span> val;        Node next;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;            <span class="hljs-keyword">this</span>.key = key;            <span class="hljs-keyword">this</span>.val = val;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 705. 设计哈希集合</title>
    <link href="/2021/03/13/LeetCode-705-design-hashset/"/>
    <url>/2021/03/13/LeetCode-705-design-hashset/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashSet</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node[] map;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1024</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashSet</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> Node[N];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">int</span> idx = getIndex(key);        Node node = map[idx];        <span class="hljs-comment">// 第一个节点为空，直接插入</span>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            map[idx] = <span class="hljs-keyword">new</span> Node(key);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 查找链表</span>            Node prev = node;            <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// 链表中已存在 key，取消插入</span>                <span class="hljs-keyword">if</span> (node.key == key) &#123;                    <span class="hljs-keyword">return</span>;                &#125;                prev = node;                node = node.next;            &#125;            <span class="hljs-comment">// 链表中未找到 key，尾插入</span>            prev.next = <span class="hljs-keyword">new</span> Node(key);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">int</span> idx = getIndex(key);        Node node = map[idx];        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 第一个节点即为需要删除的节点</span>        <span class="hljs-keyword">if</span> (node.key == key) &#123;            map[idx] = node.next;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 查找链表</span>        Node prev = node;        node = node.next;        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 删除节点</span>            <span class="hljs-keyword">if</span> (node.key == key) &#123;                prev.next = node.next;                <span class="hljs-keyword">return</span>;            &#125;            prev = node;            node = node.next;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns true if this set contains the specified element</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">int</span> idx = getIndex(key);        Node node = map[idx];        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (node.key == key) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            node = node.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 借鉴 HashMap 的索引映射方式</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key the key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> index</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">int</span> h = Objects.hashCode(key);        <span class="hljs-keyword">int</span> hash = h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);        <span class="hljs-keyword">return</span> (N - <span class="hljs-number">1</span>) &amp; hash;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-keyword">int</span> key;        Node next;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;            <span class="hljs-keyword">this</span>.key = key;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 331. 验证二叉树的前序序列化</title>
    <link href="/2021/03/12/LeetCode-331-verify-preorder-serialization-of-a-binary-tree/"/>
    <url>/2021/03/12/LeetCode-331-verify-preorder-serialization-of-a-binary-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/" target="_blank" rel="noopener">331. 验证二叉树的前序序列化</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(String preorder)</span> </span>&#123;        String[] nodes = preorder.split(<span class="hljs-string">","</span>);        <span class="hljs-comment">// 边数 + 1 = 节点数</span>        <span class="hljs-keyword">int</span> edges = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> nodesCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (String node : nodes) &#123;            <span class="hljs-keyword">if</span> (edges == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 每个节点消耗一条边</span>            edges--;            <span class="hljs-comment">// 若不是叶子节点产生两条边</span>            <span class="hljs-keyword">if</span> (!<span class="hljs-string">"#"</span>.equals(node)) &#123;                edges += <span class="hljs-number">2</span>;            &#125;        &#125;        <span class="hljs-comment">// 如果是二叉树会消耗完所有的边</span>        <span class="hljs-keyword">return</span> edges == <span class="hljs-number">0</span>;    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(String preorder)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-string">"#"</span>.equals(preorder)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        String[] tree = preorder.split(<span class="hljs-string">","</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-string">"#"</span>.equals(tree[<span class="hljs-number">0</span>])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> len = tree.length;        <span class="hljs-keyword">int</span>[] children = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        Arrays.fill(children, <span class="hljs-number">2</span>);        LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        stack.push(<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            <span class="hljs-comment">// 栈顶保存父节点</span>            <span class="hljs-comment">// 若没有父节点则为无效序列</span>            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 更新父节点的孩子数量，若孩子满了需要出栈</span>            children[stack.peek()]--;            <span class="hljs-keyword">if</span> (children[stack.peek()] == <span class="hljs-number">0</span>) &#123;                stack.pop();            &#125;            <span class="hljs-comment">// 数字可以作为下一个父节点</span>            <span class="hljs-keyword">if</span> (<span class="hljs-string">"#"</span>.equals(tree[i])) &#123;                children[i] = <span class="hljs-number">0</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                stack.push(i);            &#125;        &#125;        <span class="hljs-comment">// 左右节点都需要存在，则根节点的孩子最后应 == 0</span>        <span class="hljs-keyword">return</span> children[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1047. 删除字符串中的所有相邻重复项</title>
    <link href="/2021/03/09/LeetCode-1047-remove-all-adjacent-duplicates-in-string/"/>
    <url>/2021/03/09/LeetCode-1047-remove-all-adjacent-duplicates-in-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noopener">1047. 删除字符串中的所有相邻重复项</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(String S)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] str = S.toCharArray();    <span class="hljs-keyword">int</span> len = str.length;    <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; c == res[i - <span class="hljs-number">1</span>]) &#123;            i--;        &#125; <span class="hljs-keyword">else</span> &#123;            res[i] = c;            i++;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(res, <span class="hljs-number">0</span>, i);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 132. 分割回文串 II</title>
    <link href="/2021/03/08/LeetCode-132-palindrome-partitioning-ii/"/>
    <url>/2021/03/08/LeetCode-132-palindrome-partitioning-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">132. 分割回文串 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = s.length();        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">char</span>[] str = s.toCharArray();        <span class="hljs-keyword">boolean</span>[][] check = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len][len];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;                <span class="hljs-keyword">if</span> (str[i] != str[j]) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span> (i - j &lt;= <span class="hljs-number">2</span>) &#123;                    check[j][i] = <span class="hljs-keyword">true</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    check[j][i] = check[j + <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>];                &#125;            &#125;        &#125;        <span class="hljs-comment">// dp[i]: str[0:i] 的分割次数</span>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            dp[i] = i;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            <span class="hljs-comment">// str[0:i] 为回文，不需要分割</span>            <span class="hljs-keyword">if</span> (check[<span class="hljs-number">0</span>][i]) &#123;                dp[i] = <span class="hljs-number">0</span>;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;                <span class="hljs-comment">// 0....j, j + 1, ....i</span>                <span class="hljs-comment">// str[0:j] 已经分割成回文，</span>                <span class="hljs-comment">// 若 str[j + 1:i] 也是回文，则 dp[i] = dp[j] + 1</span>                <span class="hljs-keyword">if</span> (check[j + <span class="hljs-number">1</span>][i])&#123;                    dp[i] = Math.min(dp[i], dp[j] + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>];    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 131. 分割回文串</title>
    <link href="/2021/03/07/LeetCode-131-palindrome-partitioning/"/>
    <url>/2021/03/07/LeetCode-131-palindrome-partitioning/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        dfs(<span class="hljs-number">0</span>, s.length(), s.toCharArray(), <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(), res);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">char</span>[] str, LinkedList&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;        <span class="hljs-keyword">if</span> (start == len) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (valid(str, start, i)) &#123;                path.add(<span class="hljs-keyword">new</span> String(str, start, i - start + <span class="hljs-number">1</span>));                dfs(i + <span class="hljs-number">1</span>, len, str, path, res);                path.removeLast();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">while</span> (i &lt; j) &#123;            <span class="hljs-keyword">if</span> (str[i] != str[j]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            i++;            j--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 304. 二维区域和检索 - 矩阵不可变</title>
    <link href="/2021/03/02/LeetCode-304-range-sum-query-2d-immutable/"/>
    <url>/2021/03/02/LeetCode-304-range-sum-query-2d-immutable/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">304. 二维区域和检索 - 矩阵不可变</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] sums;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">int</span> rows = matrix.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].length;        sums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows + <span class="hljs-number">1</span>][cols + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; j++) &#123;                sums[i][j] = matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + sums[i - <span class="hljs-number">1</span>][j] + sums[i][j - <span class="hljs-number">1</span>] - sums[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row1, <span class="hljs-keyword">int</span> col1, <span class="hljs-keyword">int</span> row2, <span class="hljs-keyword">int</span> col2)</span> </span>&#123;        <span class="hljs-keyword">return</span> sums[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - sums[row2 + <span class="hljs-number">1</span>][col1] - sums[row1][col2 + <span class="hljs-number">1</span>] + sums[row1][col1];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 303. 区域和检索 - 数组不可变</title>
    <link href="/2021/03/01/LeetCode-303-range-sum-query-immutable/"/>
    <url>/2021/03/01/LeetCode-303-range-sum-query-immutable/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303. 区域和检索 - 数组不可变</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] sums;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        sums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;            sums[i] = sums[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">return</span> sums[j + <span class="hljs-number">1</span>] - sums[i];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 896. 单调数列</title>
    <link href="/2021/02/28/LeetCode-896-monotonic-array/"/>
    <url>/2021/02/28/LeetCode-896-monotonic-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/monotonic-array/" target="_blank" rel="noopener">896. 单调数列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMonotonic</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">int</span> dir = A[<span class="hljs-number">1</span>] - A[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> diff = A[i] - A[i - <span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (dir == <span class="hljs-number">0</span>) &#123;            dir = diff;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span> ((dir &gt;= <span class="hljs-number">0</span> &amp;&amp; diff &lt; <span class="hljs-number">0</span>) || (dir &lt;= <span class="hljs-number">0</span> &amp;&amp; diff &gt; <span class="hljs-number">0</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 395. 至少有K个重复字符的最长子串</title>
    <link href="/2021/02/27/LeetCode-395-longest-substring-with-at-least-k-repeating-characters/"/>
    <url>/2021/02/27/LeetCode-395-longest-substring-with-at-least-k-repeating-characters/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">395. 至少有K个重复字符的最长子串</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestSubstring</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] str = s.toCharArray();        <span class="hljs-keyword">return</span> partition(<span class="hljs-number">0</span>, str.length, str, k);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-comment">// 统计 [left: right) 每个字母的出现次数</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt; right; i++) &#123;            counts[str[i] - <span class="hljs-string">'a'</span>]++;        &#125;        <span class="hljs-comment">// 记录 [left: right) 中不满足 k 次的每个位置，用来分割子串</span>        List&lt;Integer&gt; delimiters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt; right; i++) &#123;            <span class="hljs-keyword">if</span> (counts[str[i] - <span class="hljs-string">'a'</span>] &lt; k) &#123;                delimiters.add(i);            &#125;        &#125;        <span class="hljs-comment">// 每个位置都满足，返回整个长度</span>        <span class="hljs-keyword">if</span> (delimiters.isEmpty()) &#123;            <span class="hljs-keyword">return</span> right - left;        &#125;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 对每个子串递归求最大长度</span>        <span class="hljs-comment">// left .... | .... | .... right</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pos : delimiters) &#123;            res = Math.max(res, partition(left, pos, str, k));            left = pos + <span class="hljs-number">1</span>;        &#125;        res = Math.max(res, partition(left, right, str, k));        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1178. 猜字谜</title>
    <link href="/2021/02/26/LeetCode-1178-number-of-valid-words-for-each-puzzle/"/>
    <url>/2021/02/26/LeetCode-1178-number-of-valid-words-for-each-puzzle/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/" target="_blank" rel="noopener">1178. 猜字谜</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findNumOfValidWords</span><span class="hljs-params">(String[] words, String[] puzzles)</span> </span>&#123;        Map&lt;Integer, Integer&gt; wordsCount = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">// 把每个 word 压缩成数字，并统计出现次数</span>        <span class="hljs-keyword">for</span> (String word : words) &#123;            <span class="hljs-keyword">int</span> key = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 每个字母对应 1 位，用来确定字母是否出现 e.g. b -&gt; 10, c -&gt; 100</span>            <span class="hljs-comment">// key 相或两次相同字母（数字）后还是原来的值</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word.toCharArray()) &#123;                key |= <span class="hljs-number">1</span> &lt;&lt; c - <span class="hljs-string">'a'</span>;            &#125;            wordsCount.put(key, wordsCount.getOrDefault(key, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        &#125;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 计算 puzzle 的每个子集，统计其在 words 中的出现次数</span>        <span class="hljs-keyword">for</span> (String puzzle : puzzles) &#123;            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;            <span class="hljs-keyword">char</span>[] p = puzzle.toCharArray();            <span class="hljs-comment">// 对除首字母外的字符压缩成数字</span>            <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;                mask |= <span class="hljs-number">1</span> &lt;&lt; p[i] - <span class="hljs-string">'a'</span>;            &#125;            <span class="hljs-comment">// 求子集</span>            <span class="hljs-keyword">int</span> subset = mask;            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-comment">// 首字母必须出现，所以对每个子集单独与首字母相或</span>                <span class="hljs-keyword">int</span> key = subset | (<span class="hljs-number">1</span> &lt;&lt; p[<span class="hljs-number">0</span>] - <span class="hljs-string">'a'</span>);                <span class="hljs-keyword">if</span> (wordsCount.containsKey(key)) &#123;                    count += wordsCount.get(key);                &#125;                <span class="hljs-comment">// 继续求二进制的下一个子集</span>                subset = (subset - <span class="hljs-number">1</span>) &amp; mask;            &#125; <span class="hljs-keyword">while</span> (subset != mask);            res.add(count);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 867. 转置矩阵</title>
    <link href="/2021/02/25/LeetCode-867-transpose-matrix/"/>
    <url>/2021/02/25/LeetCode-867-transpose-matrix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/transpose-matrix/" target="_blank" rel="noopener">867. 转置矩阵</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] transpose(<span class="hljs-keyword">int</span>[][] A) &#123;    <span class="hljs-keyword">int</span> rows = A.length;    <span class="hljs-keyword">int</span> cols = A[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[cols][rows];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            res[j][i] = A[i][j];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 832. 翻转图像</title>
    <link href="/2021/02/24/LeetCode-832-flipping-an-image/"/>
    <url>/2021/02/24/LeetCode-832-flipping-an-image/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/flipping-an-image/" target="_blank" rel="noopener">832. 翻转图像</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] flipAndInvertImage(<span class="hljs-keyword">int</span>[][] A) &#123;        <span class="hljs-keyword">int</span> rows = A.length;        <span class="hljs-keyword">int</span> cols = A[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> k = cols - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (j &lt; k) &#123;                <span class="hljs-keyword">int</span> t = A[i][j];                A[i][j] = A[i][k];                A[i][k] = t;                j++;                k--;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                A[i][j] ^= <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> A;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 766. 托普利茨矩阵</title>
    <link href="/2021/02/22/LeetCode-766-toeplitz-matrix/"/>
    <url>/2021/02/22/LeetCode-766-toeplitz-matrix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/toeplitz-matrix/" target="_blank" rel="noopener">766. 托普利茨矩阵</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isToeplitzMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">int</span> rows = matrix.length;        <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (matrix[i][j] != matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1438. 绝对差不超过限制的最长连续子数组</title>
    <link href="/2021/02/21/LeetCode-1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/"/>
    <url>/2021/02/21/LeetCode-1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">1438. 绝对差不超过限制的最长连续子数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();        PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);        <span class="hljs-keyword">while</span> (right &lt; len) &#123;            minHeap.offer(nums[right]);            maxHeap.offer(nums[right]);            right++;            <span class="hljs-keyword">while</span> (Math.abs(minHeap.peek() - maxHeap.peek()) &gt; limit) &#123;                minHeap.remove(nums[left]);                maxHeap.remove(nums[left]);                left++;            &#125;            res = Math.max(right - left, res);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 697. 数组的度</title>
    <link href="/2021/02/20/LeetCode-697-degree-of-an-array/"/>
    <url>/2021/02/20/LeetCode-697-degree-of-an-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/degree-of-an-array/" target="_blank" rel="noopener">697. 数组的度</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findShortestSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">int</span> degree = <span class="hljs-number">1</span>;        Map&lt;Integer, Integer&gt; occur = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(len);        Map&lt;Integer, Integer&gt; first = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(len);        Map&lt;Integer, Integer&gt; last = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(len);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">int</span> count = occur.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;            degree = Math.max(count, degree);            occur.put(nums[i], count);            <span class="hljs-comment">// 第一次出现位置</span>            <span class="hljs-keyword">if</span> (!first.containsKey(nums[i])) &#123;                first.put(nums[i], i);            &#125;            <span class="hljs-comment">// 最后一次出现位置</span>            last.put(nums[i], i);        &#125;        <span class="hljs-keyword">int</span> minLen = Integer.MAX_VALUE;        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occur.entrySet()) &#123;            <span class="hljs-keyword">if</span> (entry.getValue() == degree) &#123;                <span class="hljs-keyword">int</span> num = entry.getKey();                <span class="hljs-keyword">int</span> firstPos = first.get(num);                <span class="hljs-keyword">int</span> lastPos = last.get(num);                minLen = Math.min(lastPos - firstPos + <span class="hljs-number">1</span>, minLen);            &#125;        &#125;        <span class="hljs-keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="hljs-number">1</span> : minLen;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 566. 重塑矩阵</title>
    <link href="/2021/02/17/LeetCode-566-reshape-the-matrix/"/>
    <url>/2021/02/17/LeetCode-566-reshape-the-matrix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reshape-the-matrix/" target="_blank" rel="noopener">566. 重塑矩阵</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] matrixReshape(<span class="hljs-keyword">int</span>[][] nums, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) &#123;    <span class="hljs-keyword">int</span> rows = nums.length;    <span class="hljs-keyword">int</span> cols = nums[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">if</span> (r * c != rows * cols) &#123;        <span class="hljs-keyword">return</span> nums;    &#125;    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r][c];    <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] line : nums) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            res[row][col] = line[j];            col = (col + <span class="hljs-number">1</span>) % c;            <span class="hljs-keyword">if</span> (col == <span class="hljs-number">0</span>) &#123;                row++;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 561. 数组拆分 I</title>
    <link href="/2021/02/16/LeetCode-561-array-partition-i/"/>
    <url>/2021/02/16/LeetCode-561-array-partition-i/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/array-partition-i/" target="_blank" rel="noopener">561. 数组拆分 I</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">arrayPairSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    Arrays.sort(nums);    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += <span class="hljs-number">2</span>) &#123;        sum += nums[i];    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 765. 情侣牵手</title>
    <link href="/2021/02/14/LeetCode-765-couples-holding-hands/"/>
    <url>/2021/02/14/LeetCode-765-couples-holding-hands/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/couples-holding-hands/" target="_blank" rel="noopener">765. 情侣牵手</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] row)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = row.length;        <span class="hljs-comment">// 总的情侣对数</span>        <span class="hljs-comment">// 每一对情侣看成并查集里的一个节点</span>        <span class="hljs-keyword">int</span> n = len / <span class="hljs-number">2</span>;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += <span class="hljs-number">2</span>) &#123;            uf.union(row[i] / <span class="hljs-number">2</span>, row[i + <span class="hljs-number">1</span>] / <span class="hljs-number">2</span>);        &#125;        <span class="hljs-comment">// 每个连通分量内的 k 对情侣需要交换 k - 1 次</span>        <span class="hljs-comment">// 总的交换次数 = 总的情侣对数 - 连通分量个数</span>        <span class="hljs-keyword">return</span> n - uf.getCount();    &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 119. 杨辉三角 II</title>
    <link href="/2021/02/12/LeetCode-119-pascals-triangle-ii/"/>
    <url>/2021/02/12/LeetCode-119-pascals-triangle-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">119. 杨辉三角 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>&#123;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        res.add(<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rowIndex; i++) &#123;            <span class="hljs-keyword">int</span> pre = <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;                <span class="hljs-keyword">int</span> num = pre + res.get(j);                <span class="hljs-comment">// 保存被覆盖前的 res[j]，用于下一次获取 res[j - 1]</span>                pre = res.get(j);                res.set(j, num);            &#125;            <span class="hljs-comment">// 最后一个 1</span>            res.add(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 992. K 个不同整数的子数组</title>
    <link href="/2021/02/09/LeetCode-992-subarrays-with-k-different-integers/"/>
    <url>/2021/02/09/LeetCode-992-subarrays-with-k-different-integers/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/" target="_blank" rel="noopener">992. K 个不同整数的子数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraysWithKDistinct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;        <span class="hljs-keyword">return</span> mostDistinct(A, K) - mostDistinct(A, K - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mostDistinct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = A.length;        <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 不同整数的个数</span>        <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (right &lt; len) &#123;            <span class="hljs-comment">// 未出现过的整数</span>            <span class="hljs-keyword">if</span> (counts[A[right]] == <span class="hljs-number">0</span>) &#123;                valid++;            &#125;            counts[A[right]]++;            right++;            <span class="hljs-comment">// 需要保持窗口内最多有 k 个不同整数</span>            <span class="hljs-keyword">while</span> (valid &gt; K) &#123;                <span class="hljs-comment">// 左边需要移出窗口</span>                counts[A[left]]--;                <span class="hljs-keyword">if</span> (counts[A[left]] == <span class="hljs-number">0</span>) &#123;                    valid--;                &#125;                left++;            &#125;            <span class="hljs-comment">// &lt;= k 个整数的所有可能组合数</span>            res += right - left;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 665. 非递减数列</title>
    <link href="/2021/02/07/LeetCode-665-non-decreasing-array/"/>
    <url>/2021/02/07/LeetCode-665-non-decreasing-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/non-decreasing-array/" target="_blank" rel="noopener">665. 非递减数列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            <span class="hljs-comment">// 出现递减</span>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i - <span class="hljs-number">1</span>]) &#123;                count++;                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;                <span class="hljs-comment">// nums[i - 2] &lt; nums[i - 1] 的情况下比较 nums[i - 2] 和 nums[i]</span>                <span class="hljs-keyword">if</span> (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">2</span>] &gt; nums[i]) &#123;                    nums[i] = nums[i - <span class="hljs-number">1</span>];                &#125; <span class="hljs-keyword">else</span> &#123;                    nums[i - <span class="hljs-number">1</span>] = nums[i];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 480. 滑动窗口中位数</title>
    <link href="/2021/02/03/LeetCode-480-sliding-window-median/"/>
    <url>/2021/02/03/LeetCode-480-sliding-window-median/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sliding-window-median/" target="_blank" rel="noopener">480. 滑动窗口中位数</a></p><p><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] medianSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-comment">// 存储比中位数小的元素，大顶堆</span>        <span class="hljs-comment">// 防止溢出</span>        PriorityQueue&lt;Integer&gt; small = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; Integer.compare(o2, o1));        <span class="hljs-comment">// 存储比中位数大的元素，小顶堆</span>        PriorityQueue&lt;Integer&gt; large = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[len - k + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-comment">// small - 1 = large</span>            <span class="hljs-keyword">if</span> (small.size() == large.size()) &#123;                large.offer(nums[i]);                small.offer(large.poll());            &#125; <span class="hljs-keyword">else</span> &#123;                small.offer(nums[i]);                large.offer(small.poll());            &#125;            <span class="hljs-keyword">int</span> j = i - k + <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 获取中位数</span>            res[j] = getMedian(small, large);            <span class="hljs-comment">// 删除需要移出窗口的元素</span>            <span class="hljs-keyword">int</span> erase = nums[j];            <span class="hljs-keyword">if</span> (erase &lt;= small.peek()) &#123;                small.remove(erase);            &#125; <span class="hljs-keyword">else</span> &#123;                large.remove(erase);            &#125;            <span class="hljs-comment">// 删除元素后重新维护堆</span>            balance(small, large);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">balance</span><span class="hljs-params">(PriorityQueue&lt;Integer&gt; small, PriorityQueue&lt;Integer&gt; large)</span> </span>&#123;        <span class="hljs-comment">// 保证 small 与 large 相等或比 large 多一个元素</span>        <span class="hljs-keyword">if</span> (small.size() &lt; large.size()) &#123;            small.offer(large.poll());        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (small.size() &gt; large.size() + <span class="hljs-number">1</span>) &#123;            large.offer(small.poll());        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getMedian</span><span class="hljs-params">(PriorityQueue&lt;Integer&gt; small, PriorityQueue&lt;Integer&gt; large)</span> </span>&#123;        <span class="hljs-keyword">if</span> (small.size() == large.size()) &#123;            <span class="hljs-comment">// 防止溢出</span>            <span class="hljs-keyword">return</span> small.peek() / <span class="hljs-number">2.0</span> + large.peek() / <span class="hljs-number">2.0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> small.peek();        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 888. 公平的糖果棒交换</title>
    <link href="/2021/02/01/LeetCode-888-fair-candy-swap/"/>
    <url>/2021/02/01/LeetCode-888-fair-candy-swap/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/fair-candy-swap/" target="_blank" rel="noopener">888. 公平的糖果棒交换</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] fairCandySwap(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[] B) &#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         *    sumA - a + b = sumB - b + a</span><span class="hljs-comment">         * =&gt; a = b + (sumA - sumB) / 2</span><span class="hljs-comment">         */</span>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">int</span> sumA = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a : A) &#123;            sumA += a;            set.add(a);        &#125;        <span class="hljs-keyword">int</span> sumB = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> b : B) &#123;            sumB += b;        &#125;        <span class="hljs-keyword">int</span> c = (sumA - sumB) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> b : B) &#123;            <span class="hljs-keyword">int</span> a = b + c;            <span class="hljs-keyword">if</span> (set.contains(a)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;a, b&#125;;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 839. 相似字符串组</title>
    <link href="/2021/01/31/LeetCode-839-similar-string-groups/"/>
    <url>/2021/01/31/LeetCode-839-similar-string-groups/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/similar-string-groups/" target="_blank" rel="noopener">839. 相似字符串组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSimilarGroups</span><span class="hljs-params">(String[] strs)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = strs.length;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(len);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;                <span class="hljs-keyword">if</span> (uf.isConnected(i, j)) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span> (isSimilar(strs[i], strs[j])) &#123;                    uf.union(i, j);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> uf.getCount();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSimilar</span><span class="hljs-params">(String str, String str1)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] s1 = str.toCharArray();        <span class="hljs-keyword">char</span>[] s2 = str1.toCharArray();        <span class="hljs-keyword">int</span> len = s1.length;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (s1[i] != s2[i]) &#123;                count++;                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">2</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span> || count == <span class="hljs-number">2</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 778. 水位上升的泳池中游泳</title>
    <link href="/2021/01/30/LeetCode-778-swim-in-rising-water/"/>
    <url>/2021/01/30/LeetCode-778-swim-in-rising-water/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/swim-in-rising-water/" target="_blank" rel="noopener">778. 水位上升的泳池中游泳</a></p><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">swimInWater</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> rows = grid.length;        <span class="hljs-keyword">int</span> cols = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> n = rows * cols;        List&lt;<span class="hljs-keyword">int</span>[]&gt; edges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">int</span> idx = i * cols + j;                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;                    edges.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;idx, idx - cols, Math.max(grid[i][j], grid[i - <span class="hljs-number">1</span>][j])&#125;);                &#125;                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;                    edges.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;idx, idx - <span class="hljs-number">1</span>, Math.max(grid[i][j], grid[i][j - <span class="hljs-number">1</span>])&#125;);                &#125;            &#125;        &#125;        edges.sort(Comparator.comparingInt(o -&gt; o[<span class="hljs-number">2</span>]));        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : edges) &#123;            uf.union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);            res = Math.max(res, edge[<span class="hljs-number">2</span>]);            <span class="hljs-keyword">if</span> (uf.isConnected(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>)) &#123;                <span class="hljs-keyword">return</span> res;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">swimInWater</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> rows = grid.length;        <span class="hljs-keyword">int</span> cols = grid[<span class="hljs-number">0</span>].length;        PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o[<span class="hljs-number">2</span>]));        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]&#125;);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-keyword">int</span>[] cur = queue.poll();            <span class="hljs-keyword">int</span> x = cur[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> y = cur[<span class="hljs-number">1</span>];            visited[x][y] = <span class="hljs-keyword">true</span>;            res = Math.max(res, cur[<span class="hljs-number">2</span>]);            <span class="hljs-keyword">if</span> (x == rows - <span class="hljs-number">1</span> &amp;&amp; y == cols - <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> res;            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                <span class="hljs-keyword">int</span> nx = x + dir[<span class="hljs-number">0</span>];                <span class="hljs-keyword">int</span> ny = y + dir[<span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span> (!inArea(nx, ny, rows, cols) || visited[nx][ny]) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;nx, ny, grid[nx][ny]&#125;);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1631. 最小体力消耗路径</title>
    <link href="/2021/01/29/LeetCode-1631-path-with-minimum-effort/"/>
    <url>/2021/01/29/LeetCode-1631-path-with-minimum-effort/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/" target="_blank" rel="noopener">1631. 最小体力消耗路径</a></p><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>&#123;        <span class="hljs-keyword">int</span> rows = heights.length;        <span class="hljs-keyword">int</span> cols = heights[<span class="hljs-number">0</span>].length;        List&lt;<span class="hljs-keyword">int</span>[]&gt; edges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">int</span> idx = i * cols + j;                <span class="hljs-comment">// 上方的节点构造边</span>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;                    edges.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;idx, (i - <span class="hljs-number">1</span>) * cols + j, Math.abs(heights[i][j] - heights[i - <span class="hljs-number">1</span>][j])&#125;);                &#125;                <span class="hljs-comment">// 左边的节点构造边</span>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;                    edges.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;idx, i * cols + j - <span class="hljs-number">1</span>, Math.abs(heights[i][j] - heights[i][j - <span class="hljs-number">1</span>])&#125;);                &#125;            &#125;        &#125;        edges.sort(Comparator.comparingInt(o -&gt; o[<span class="hljs-number">2</span>]));        <span class="hljs-keyword">int</span> n = rows * cols;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : edges) &#123;            uf.union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);            <span class="hljs-keyword">if</span> (uf.isConnected(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>)) &#123;                <span class="hljs-keyword">return</span> edge[<span class="hljs-number">2</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;        <span class="hljs-keyword">int</span> rows = heights.length;        <span class="hljs-keyword">int</span> cols = heights[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];        <span class="hljs-comment">// 到点 [i][j] 的最小权值</span>        <span class="hljs-keyword">int</span>[][] dijkstra = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][cols];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] row : dijkstra) &#123;            Arrays.fill(row, Integer.MAX_VALUE);        &#125;        dijkstra[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 最小堆，每次都从权值最小的点开始找下一个点</span>        PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o[<span class="hljs-number">2</span>]));        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-keyword">int</span>[] cur = queue.poll();            <span class="hljs-keyword">int</span> x = cur[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> y = cur[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (x == rows - <span class="hljs-number">1</span> &amp;&amp; y == cols - <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span> (visited[x][y]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            visited[x][y] = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">int</span> dist = cur[<span class="hljs-number">2</span>];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                <span class="hljs-keyword">int</span> nx = x + dir[<span class="hljs-number">0</span>];                <span class="hljs-keyword">int</span> ny = y + dir[<span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span> (!inArea(nx, ny, rows, cols)) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-comment">// 到达 [nx][ny] 的路径最大值</span>                <span class="hljs-keyword">int</span> height = Math.max(dist, Math.abs(heights[x][y] - heights[nx][ny]));                <span class="hljs-keyword">if</span> (height &lt; dijkstra[nx][ny]) &#123;                    dijkstra[nx][ny] = height;                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;nx, ny, height&#125;);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dijkstra[rows - <span class="hljs-number">1</span>][cols - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 29. 两数相除</title>
    <link href="/2021/01/28/LeetCode-29-divide-two-integers/"/>
    <url>/2021/01/28/LeetCode-29-divide-two-integers/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/divide-two-integers/" target="_blank" rel="noopener">29. 两数相除</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dividend, <span class="hljs-keyword">int</span> divisor)</span> </span>&#123;        <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> dividend;        &#125;        <span class="hljs-keyword">if</span> (divisor == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">if</span> (dividend == Integer.MIN_VALUE) &#123;                <span class="hljs-keyword">return</span> Integer.MAX_VALUE;            &#125;            <span class="hljs-keyword">return</span> -dividend;        &#125;        <span class="hljs-keyword">boolean</span> negative = (dividend &lt; <span class="hljs-number">0</span> &amp;&amp; divisor &gt; <span class="hljs-number">0</span>) || (divisor &lt; <span class="hljs-number">0</span> &amp;&amp; dividend &gt; <span class="hljs-number">0</span>);        <span class="hljs-keyword">long</span> a = Math.abs((<span class="hljs-keyword">long</span>) dividend);        <span class="hljs-keyword">long</span> b = Math.abs((<span class="hljs-keyword">long</span>) divisor);        <span class="hljs-keyword">int</span> res = div(a, b);        <span class="hljs-keyword">if</span> (negative) &#123;            <span class="hljs-keyword">return</span> -res;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> b)</span> </span>&#123;        <span class="hljs-keyword">if</span> (a &lt; b) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// 已经使用的 b 的总和</span>        <span class="hljs-keyword">long</span> sum = b;        <span class="hljs-comment">// 使用的 b 的个数</span>        <span class="hljs-keyword">long</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (sum &lt;= a) &#123;            count &lt;&lt;= <span class="hljs-number">1</span>;            sum &lt;&lt;= <span class="hljs-number">1</span>;        &#125;        count &gt;&gt;&gt;= <span class="hljs-number">1</span>;        sum &gt;&gt;&gt;= <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (count + div(a - sum, b));    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 24. 两两交换链表中的节点</title>
    <link href="/2021/01/28/LeetCode-24-swap-nodes-in-pairs/"/>
    <url>/2021/01/28/LeetCode-24-swap-nodes-in-pairs/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> head;        &#125;        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        ListNode tail = dummy;        ListNode next = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span> &amp;&amp; head.next != <span class="hljs-keyword">null</span>) &#123;            next = head.next.next;            tail.next = head.next;            <span class="hljs-comment">// tail 后移</span>            tail = tail.next;            tail.next = head;            <span class="hljs-comment">// tail 后移</span>            tail = tail.next;            tail.next = <span class="hljs-keyword">null</span>;            head = next;        &#125;        tail.next = next;        <span class="hljs-keyword">return</span> dummy.next;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 724. 寻找数组的中心索引</title>
    <link href="/2021/01/28/LeetCode-724-find-pivot-index/"/>
    <url>/2021/01/28/LeetCode-724-find-pivot-index/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-pivot-index/" target="_blank" rel="noopener">724. 寻找数组的中心索引</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">int</span>[] prevSums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">int</span>[] postSums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-comment">// [1, 7, 3, 6, 5, 6]</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            prevSums[i] = nums[i - <span class="hljs-number">1</span>] + prevSums[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            postSums[i] = nums[i + <span class="hljs-number">1</span>] + postSums[i + <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (prevSums[i] == postSums[i]) &#123;                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1579. 保证图可完全遍历</title>
    <link href="/2021/01/27/LeetCode-1579-remove-max-number-of-edges-to-keep-graph-fully-traversable/"/>
    <url>/2021/01/27/LeetCode-1579-remove-max-number-of-edges-to-keep-graph-fully-traversable/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/" target="_blank" rel="noopener">1579. 保证图可完全遍历</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxNumEdgesToRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] edges)</span> </span>&#123;        UnionFind alice = <span class="hljs-keyword">new</span> UnionFind(n);        UnionFind bob = <span class="hljs-keyword">new</span> UnionFind(n);        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : edges) &#123;            edge[<span class="hljs-number">1</span>]--;            edge[<span class="hljs-number">2</span>]--;            <span class="hljs-keyword">if</span> (edge[<span class="hljs-number">0</span>] == <span class="hljs-number">3</span>) &#123;                <span class="hljs-keyword">if</span> (alice.isConnected(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>])) &#123;                    count++;                &#125; <span class="hljs-keyword">else</span> &#123;                    alice.union(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]);                    bob.union(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : edges) &#123;            <span class="hljs-keyword">if</span> (edge[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">if</span> (alice.isConnected(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>])) &#123;                    count++;                &#125; <span class="hljs-keyword">else</span> &#123;                    alice.union(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]);                &#125;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (edge[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span>) &#123;                <span class="hljs-keyword">if</span> (bob.isConnected(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>])) &#123;                    count++;                &#125; <span class="hljs-keyword">else</span> &#123;                    bob.union(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]);                &#125;            &#125;        &#125;        <span class="hljs-comment">// 无法连接所有节点</span>        <span class="hljs-keyword">if</span> (alice.getCount() != <span class="hljs-number">1</span> || bob.getCount() != <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1128. 等价多米诺骨牌对的数量</title>
    <link href="/2021/01/26/LeetCode-1128-number-of-equivalent-domino-pairs/"/>
    <url>/2021/01/26/LeetCode-1128-number-of-equivalent-domino-pairs/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/" target="_blank" rel="noopener">1128. 等价多米诺骨牌对的数量</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numEquivDominoPairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] dominoes)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">101</span>];        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] domino : dominoes) &#123;            Arrays.sort(domino);            <span class="hljs-keyword">int</span> idx = domino[<span class="hljs-number">0</span>] * <span class="hljs-number">10</span> + domino[<span class="hljs-number">1</span>];            count += counts[idx];            counts[idx]++;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 959. 由斜杠划分区域</title>
    <link href="/2021/01/25/LeetCode-959-regions-cut-by-slashes/"/>
    <url>/2021/01/25/LeetCode-959-regions-cut-by-slashes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/" target="_blank" rel="noopener">959. 由斜杠划分区域</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">regionsBySlashes</span><span class="hljs-params">(String[] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = grid.length;        <span class="hljs-keyword">int</span> count = n * n * <span class="hljs-number">4</span>;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(count);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">char</span>[] row = grid[i].toCharArray();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-comment">// 当前 grid[i][j] 的起始位置</span>                <span class="hljs-comment">//  0</span>                <span class="hljs-comment">// 3 1</span>                <span class="hljs-comment">//  2</span>                <span class="hljs-keyword">int</span> idx = (i * n + j) * <span class="hljs-number">4</span>;                <span class="hljs-comment">// 合并单元格内的格子</span>                <span class="hljs-keyword">if</span> (row[j] == <span class="hljs-string">'/'</span>) &#123;                    uf.union(idx, idx + <span class="hljs-number">3</span>);                    uf.union(idx + <span class="hljs-number">1</span>, idx + <span class="hljs-number">2</span>);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (row[j] == <span class="hljs-string">'\\'</span>) &#123;                    uf.union(idx, idx + <span class="hljs-number">1</span>);                    uf.union(idx + <span class="hljs-number">2</span>, idx + <span class="hljs-number">3</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    uf.union(idx, idx + <span class="hljs-number">1</span>);                    uf.union(idx + <span class="hljs-number">1</span>, idx + <span class="hljs-number">2</span>);                    uf.union(idx + <span class="hljs-number">2</span>, idx + <span class="hljs-number">3</span>);                &#125;                <span class="hljs-comment">// 合并单元格之间的格子</span>                <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; n) &#123;                    uf.union(idx + <span class="hljs-number">1</span>, (i * n + j + <span class="hljs-number">1</span>) * <span class="hljs-number">4</span> + <span class="hljs-number">3</span>);                &#125;                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n) &#123;                    uf.union(idx + <span class="hljs-number">2</span>, ((i + <span class="hljs-number">1</span>) * n + j) * <span class="hljs-number">4</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> uf.getCount();    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 989. 数组形式的整数加法</title>
    <link href="/2021/01/22/LeetCode-989-add-to-array-form-of-integer/"/>
    <url>/2021/01/22/LeetCode-989-add-to-array-form-of-integer/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/" target="_blank" rel="noopener">989. 数组形式的整数加法</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">addToArrayForm</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;        LinkedList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">int</span> i = A.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> carry = K;        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || carry != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 把数组的每一位都加到 carry 上</span>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;                carry += A[i];                i--;            &#125;            <span class="hljs-keyword">int</span> bit = carry % <span class="hljs-number">10</span>;            carry /= <span class="hljs-number">10</span>;            res.addFirst(bit);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1489. 找到最小生成树里的关键边和伪关键边</title>
    <link href="/2021/01/21/LeetCode-1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/"/>
    <url>/2021/01/21/LeetCode-1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/" target="_blank" rel="noopener">1489. 找到最小生成树里的关键边和伪关键边</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findCriticalAndPseudoCriticalEdges(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] edges) &#123;        <span class="hljs-keyword">int</span> edgeNum = edges.length;        <span class="hljs-comment">// edge index [3]: [0] &lt;-&gt; [1] with weight [2]</span>        <span class="hljs-keyword">int</span>[][] indexedEdges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[edgeNum][<span class="hljs-number">4</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edgeNum; i++) &#123;            System.arraycopy(edges[i], <span class="hljs-number">0</span>, indexedEdges[i], <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);            <span class="hljs-comment">// 第四维为边的编号</span>            indexedEdges[i][<span class="hljs-number">3</span>] = i;        &#125;        <span class="hljs-comment">// 根据权值由小到大排序</span>        Arrays.sort(indexedEdges, Comparator.comparingInt(o -&gt; o[<span class="hljs-number">2</span>]));        <span class="hljs-comment">// 最小生成树的权值</span>        <span class="hljs-keyword">int</span> minWeight = <span class="hljs-number">0</span>;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : indexedEdges) &#123;            minWeight = attemptConnect(minWeight, uf, edge);        &#125;        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">2</span>);        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());        <span class="hljs-comment">// 对于每条边构建最小生成树，判断关键边、伪关键边</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edgeNum; i++) &#123;            <span class="hljs-comment">// 判断关键边</span>            uf = <span class="hljs-keyword">new</span> UnionFind(n);            <span class="hljs-keyword">int</span> weight = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; edgeNum; j++) &#123;                <span class="hljs-comment">// 删去第 i 条边，若权值 &gt; minWeight，则为关键边</span>                <span class="hljs-keyword">if</span> (i == j) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                weight = attemptConnect(weight, uf, indexedEdges[j]);            &#125;            <span class="hljs-keyword">if</span> (uf.getCount() != <span class="hljs-number">1</span> || (uf.getCount() == <span class="hljs-number">1</span> &amp;&amp; weight &gt; minWeight)) &#123;                res.get(<span class="hljs-number">0</span>).add(indexedEdges[i][<span class="hljs-number">3</span>]);                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 判断伪关键边</span>            uf = <span class="hljs-keyword">new</span> UnionFind(n);            <span class="hljs-comment">// 先连上该边，若权值 == minWeight，则为伪关键边</span>            uf.union(indexedEdges[i][<span class="hljs-number">0</span>], indexedEdges[i][<span class="hljs-number">1</span>]);            weight = indexedEdges[i][<span class="hljs-number">2</span>];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : indexedEdges) &#123;                weight = attemptConnect(weight, uf, edge);            &#125;            <span class="hljs-keyword">if</span> (weight == minWeight) &#123;                res.get(<span class="hljs-number">1</span>).add(indexedEdges[i][<span class="hljs-number">3</span>]);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">attemptConnect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight, UnionFind uf, <span class="hljs-keyword">int</span>[] edge)</span> </span>&#123;        <span class="hljs-keyword">if</span> (uf.isConnected(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>])) &#123;            <span class="hljs-keyword">return</span> weight;        &#125;        uf.union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);        weight += edge[<span class="hljs-number">2</span>];        <span class="hljs-keyword">return</span> weight;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] parent;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];            <span class="hljs-keyword">this</span>.count = n;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;                <span class="hljs-keyword">this</span>.parent[i] = i;            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> count;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;            <span class="hljs-keyword">int</span> rootX = find(x);            <span class="hljs-keyword">int</span> rootY = find(y);            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;                <span class="hljs-keyword">return</span>;            &#125;            parent[rootX] = rootY;            count--;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;            <span class="hljs-keyword">while</span> (x != parent[x]) &#123;                parent[x] = parent[parent[x]];                x = parent[x];            &#125;            <span class="hljs-keyword">return</span> x;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;            <span class="hljs-keyword">int</span> rootX = find(x);            <span class="hljs-keyword">int</span> rootY = find(y);            <span class="hljs-keyword">return</span> rootX == rootY;        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 628. 三个数的最大乘积</title>
    <link href="/2021/01/20/LeetCode-628-maximum-product-of-three-numbers/"/>
    <url>/2021/01/20/LeetCode-628-maximum-product-of-three-numbers/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/" target="_blank" rel="noopener">628. 三个数的最大乘积</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    Arrays.sort(nums);    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">return</span> Math.max(nums[len - <span class="hljs-number">1</span>] * nums[len - <span class="hljs-number">2</span>] * nums[len - <span class="hljs-number">3</span>], nums[<span class="hljs-number">0</span>] * nums[<span class="hljs-number">1</span>] * nums[len - <span class="hljs-number">1</span>]);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> min1 = Integer.MAX_VALUE;        <span class="hljs-keyword">int</span> min2 = Integer.MAX_VALUE;        <span class="hljs-keyword">int</span> max1 = Integer.MIN_VALUE;        <span class="hljs-keyword">int</span> max2 = Integer.MIN_VALUE;        <span class="hljs-keyword">int</span> max3 = Integer.MIN_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;            <span class="hljs-keyword">if</span> (num &lt; min1) &#123;                min2 = min1;                min1 = num;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; min2) &#123;                min2 = num;            &#125;            <span class="hljs-keyword">if</span> (num &gt; max1) &#123;                max3 = max2;                max2 = max1;                max1 = num;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; max2) &#123;                max3 = max2;                max2 = num;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; max3) &#123;                max3 = num;            &#125;        &#125;        <span class="hljs-keyword">return</span> Math.max(min1 * min2 * max1, max1 * max2 * max3);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1584. 连接所有点的最小费用</title>
    <link href="/2021/01/19/LeetCode-1584-min-cost-to-connect-all-points/"/>
    <url>/2021/01/19/LeetCode-1584-min-cost-to-connect-all-points/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/" target="_blank" rel="noopener">1584. 连接所有点的最小费用</a></p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = points.length;    <span class="hljs-comment">// 计算所有边的权值</span>    List&lt;<span class="hljs-keyword">int</span>[]&gt; edges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(n * n);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">int</span> cost = calcDist(points[i], points[j]);            edges.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i * n + j, cost&#125;);        &#125;    &#125;    <span class="hljs-comment">// 按权值排序</span>    edges.sort(Comparator.comparingInt(o -&gt; o[<span class="hljs-number">1</span>]));    UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 遍历所有边 [idx, cost]，从权值小的边开始连接节点</span>    <span class="hljs-keyword">int</span> conn = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : edges) &#123;        <span class="hljs-keyword">int</span> p1 = edge[<span class="hljs-number">0</span>] / n;        <span class="hljs-keyword">int</span> p2 = edge[<span class="hljs-number">0</span>] % n;        <span class="hljs-keyword">if</span> (uf.isConnected(p1, p2)) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        uf.union(p1, p2);        res += edge[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (++conn == n) &#123;            <span class="hljs-keyword">return</span> res;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calcDist</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] p1, <span class="hljs-keyword">int</span>[] p2)</span> </span>&#123;    <span class="hljs-keyword">return</span> Math.abs(p1[<span class="hljs-number">0</span>] - p2[<span class="hljs-number">0</span>]) + Math.abs(p1[<span class="hljs-number">1</span>] - p2[<span class="hljs-number">1</span>]);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1332. 删除回文子序列</title>
    <link href="/2021/01/18/LeetCode-1332-remove-palindromic-subsequences/"/>
    <url>/2021/01/18/LeetCode-1332-remove-palindromic-subsequences/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/" target="_blank" rel="noopener">1332. 删除回文子序列</a></p><p>真是个小机灵鬼！</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removePalindromeSub</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] str = s.toCharArray();        <span class="hljs-keyword">int</span> len = str.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> (isPalindrome(str, <span class="hljs-number">0</span>, len)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">while</span> (i &lt; j) &#123;            <span class="hljs-keyword">if</span> (str[i] != str[j]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            i++;            j--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 721. 账户合并</title>
    <link href="/2021/01/18/LeetCode-721-accounts-merge/"/>
    <url>/2021/01/18/LeetCode-721-accounts-merge/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/accounts-merge/" target="_blank" rel="noopener">721. 账户合并</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;        <span class="hljs-comment">// mail =&gt; 其所属的组号（accounts 的索引）</span>        Map&lt;String, Integer&gt; mail2GroupId = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> accountSize = accounts.size();        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(accountSize);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> groupId = <span class="hljs-number">0</span>; groupId &lt; accountSize; groupId++) &#123;            List&lt;String&gt; mails = accounts.get(groupId);            <span class="hljs-keyword">int</span> mailSize = mails.size();            <span class="hljs-comment">// 遍历该组的所有 mail</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; mailSize; j++) &#123;                String mail = mails.get(j);                <span class="hljs-keyword">if</span> (!mail2GroupId.containsKey(mail)) &#123;                    mail2GroupId.put(mail, groupId);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 若 mail 出现过，则出现过的 mail 一定属于某个组 existGroupId</span>                    <span class="hljs-comment">// 则 groupId 和 existGroupId 属于同一个账号，即它们在同一个连通分量中</span>                    <span class="hljs-keyword">int</span> existGroupId = mail2GroupId.get(mail);                    uf.union(groupId, existGroupId);                &#125;            &#125;        &#125;        <span class="hljs-comment">// 账号（组号） =&gt; 该账号的所有 mail</span>        Map&lt;Integer, List&lt;String&gt;&gt; groups = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">// 对所有的 mail 分组，同一个连通分量的组内 mail 合并进同一组</span>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : mail2GroupId.entrySet()) &#123;            String mail = entry.getKey();            <span class="hljs-keyword">int</span> groupId = entry.getValue();            <span class="hljs-keyword">int</span> root = uf.find(groupId);            groups.computeIfAbsent(root, o -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;()).add(mail);        &#125;        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : groups.entrySet()) &#123;            <span class="hljs-comment">// 组号</span>            <span class="hljs-keyword">int</span> root = entry.getKey();            <span class="hljs-comment">// 根据组号获取账号名</span>            String name = accounts.get(root).get(<span class="hljs-number">0</span>);            <span class="hljs-comment">// 账号的所有 mail</span>            List&lt;String&gt; mails = entry.getValue();            Collections.sort(mails);            <span class="hljs-comment">// 生成结果</span>            List&lt;String&gt; members = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            members.add(name);            members.addAll(mails);            res.add(members);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1232 缀点成线</title>
    <link href="/2021/01/17/LeetCode-1232-check-if-it-is-a-straight-line/"/>
    <url>/2021/01/17/LeetCode-1232-check-if-it-is-a-straight-line/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/" target="_blank" rel="noopener">1232. 缀点成线</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkStraightLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] coordinates)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = coordinates.length;        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// (x1, y1) (x2, y2) (x3, y3)</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">int</span> y2_1 = coordinates[i][<span class="hljs-number">1</span>] - coordinates[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];            <span class="hljs-keyword">int</span> x2_1 = coordinates[i][<span class="hljs-number">0</span>] - coordinates[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> y3_2 = coordinates[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - coordinates[i][<span class="hljs-number">1</span>];            <span class="hljs-keyword">int</span> x3_2 = coordinates[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - coordinates[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span> (y2_1 * x3_2 != y3_2 * x2_1) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 803. 打砖块</title>
    <link href="/2021/01/16/LeetCode-803-bricks-falling-when-hit/"/>
    <url>/2021/01/16/LeetCode-803-bricks-falling-when-hit/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/bricks-falling-when-hit/" target="_blank" rel="noopener">803. 打砖块</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[][] DIRS = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] hitBricks(<span class="hljs-keyword">int</span>[][] grid, <span class="hljs-keyword">int</span>[][] hits) &#123;        <span class="hljs-keyword">int</span> rows = grid.length;        <span class="hljs-keyword">int</span> cols = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">this</span>.rows = rows;        <span class="hljs-keyword">this</span>.cols = cols;        <span class="hljs-keyword">int</span> hitLen = hits.length;        <span class="hljs-keyword">boolean</span>[] skip = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[hitLen];        <span class="hljs-comment">/* 击碎方块，连接顶部砖块和各个连通分量 */</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; hitLen; i++) &#123;            <span class="hljs-comment">// 原来就是空白，不必击碎</span>            <span class="hljs-keyword">if</span> (grid[hits[i][<span class="hljs-number">0</span>]][hits[i][<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>) &#123;                skip[i] = <span class="hljs-keyword">true</span>;            &#125;            grid[hits[i][<span class="hljs-number">0</span>]][hits[i][<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// 顶部连通方块的根节点</span>        <span class="hljs-keyword">int</span> top = rows * cols;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(top + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 连接顶部的砖块作为一个连通分量</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) &#123;                uf.union(top, getIndex(<span class="hljs-number">0</span>, j));            &#125;        &#125;        <span class="hljs-comment">// 连接剩余砖块</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-comment">// 跳过空白部分</span>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-comment">// 上方为砖块</span>                <span class="hljs-keyword">if</span> (grid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) &#123;                    uf.union(getIndex(i - <span class="hljs-number">1</span>, j), getIndex(i, j));                &#125;                <span class="hljs-comment">// 左边为砖块</span>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;                    uf.union(getIndex(i, j - <span class="hljs-number">1</span>), getIndex(i, j));                &#125;            &#125;        &#125;        <span class="hljs-comment">/* 还原之前击碎的砖块，看能连通多少块砖块 */</span>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[hitLen];        <span class="hljs-comment">// 击碎时从前往后，还原时要逆序</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = hitLen - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">if</span> (skip[i]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">int</span> x = hits[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> y = hits[i][<span class="hljs-number">1</span>];            <span class="hljs-comment">// 击碎后与顶部连接的砖块数，即还原前的砖块数</span>            <span class="hljs-keyword">int</span> hitSize = uf.getSizeOf(top);            <span class="hljs-comment">// 还原的是顶部砖块</span>            <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;                uf.union(getIndex(x, y), top);            &#125;            <span class="hljs-comment">// 将 (x, y) 与周围的连通区域相连</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : DIRS) &#123;                <span class="hljs-keyword">int</span> nx = x + dir[<span class="hljs-number">0</span>];                <span class="hljs-keyword">int</span> ny = y + dir[<span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span> (inArea(nx, ny) &amp;&amp; grid[nx][ny] == <span class="hljs-number">1</span>) &#123;                    uf.union(getIndex(nx, ny), getIndex(x, y));                &#125;            &#125;            <span class="hljs-comment">// 击碎之前与顶部连接的砖块数，即还原后的砖块数</span>            <span class="hljs-keyword">int</span> originSize = uf.getSizeOf(top);            grid[x][y] = <span class="hljs-number">1</span>;            <span class="hljs-comment">// 需要判断还原砖块 (x, y) 后是否与顶部相连</span>            <span class="hljs-keyword">if</span> (originSize != hitSize) &#123;                res[i] = originSize - hitSize - <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">return</span> i * cols + j;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] parent;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;    UnionFind(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            parent[i] = i;            size[i] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">int</span> rx = find(x);        <span class="hljs-keyword">int</span> ry = find(y);        <span class="hljs-keyword">if</span> (rx == ry) &#123;            <span class="hljs-keyword">return</span>;        &#125;        parent[rx] = ry;        size[ry] += size[rx];    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">while</span> (x != parent[x]) &#123;            parent[x] = parent[parent[x]];            x = parent[x];        &#125;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSizeOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> root = find(x);        <span class="hljs-keyword">return</span> size[root];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1260. 二维网格迁移</title>
    <link href="/2021/01/15/LeetCode-1260-shift-2d-grid/"/>
    <url>/2021/01/15/LeetCode-1260-shift-2d-grid/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shift-2d-grid/" target="_blank" rel="noopener">1260. 二维网格迁移</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; shiftGrid(<span class="hljs-keyword">int</span>[][] grid, <span class="hljs-keyword">int</span> k) &#123;        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">int</span> rows = grid.length;        <span class="hljs-keyword">int</span> cols = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> len = rows * cols;        <span class="hljs-keyword">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 扁平化</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] row : grid) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                data[idx++] = row[j];            &#125;        &#125;        <span class="hljs-comment">// 移动到最终位置</span>        <span class="hljs-keyword">int</span>[] shift = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            shift[(i + k) % len] = data[i];        &#125;        <span class="hljs-comment">// 转成二维数组</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            res.get(i / cols).add(shift[i]);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 821. 字符的最短距离</title>
    <link href="/2021/01/15/LeetCode-821-shortest-distance-to-a-character/"/>
    <url>/2021/01/15/LeetCode-821-shortest-distance-to-a-character/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/" target="_blank" rel="noopener">821. 字符的最短距离</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] shortestToChar(String S, <span class="hljs-keyword">char</span> C) &#123;        <span class="hljs-keyword">char</span>[] chars = S.toCharArray();        <span class="hljs-keyword">int</span> len = chars.length;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">int</span> l = -len;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (chars[i] == C) &#123;                l = i;            &#125;            left[i] = l;        &#125;        <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">int</span> r = len * <span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">if</span> (chars[i] == C) &#123;                r = i;            &#125;            right[i] = r;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            res[i] = Math.min(i - left[i], right[i] - i);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 947. 移除最多的同行或同列石头</title>
    <link href="/2021/01/15/LeetCode-947-most-stones-removed-with-same-row-or-column/"/>
    <url>/2021/01/15/LeetCode-947-most-stones-removed-with-same-row-or-column/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/" target="_blank" rel="noopener">947. 移除最多的同行或同列石头</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeStones</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] stones)</span> </span>&#123;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(<span class="hljs-number">20002</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] stone : stones) &#123;            <span class="hljs-comment">// 连接行与列，在 stone[0] 行和 stone[1] 列上的节点在同一个连通分量中</span>            uf.union(stone[<span class="hljs-number">0</span>] + <span class="hljs-number">10000</span>, stone[<span class="hljs-number">1</span>]);        &#125;        Set&lt;Integer&gt; roots = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] stone : stones) &#123;            <span class="hljs-comment">// 行与列已经连接，找根节点只要找行或列</span>            roots.add(uf.find(stone[<span class="hljs-number">1</span>]));        &#125;        <span class="hljs-keyword">return</span> stones.length - roots.size();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] parent;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;                <span class="hljs-keyword">this</span>.parent[i] = i;            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;            <span class="hljs-keyword">int</span> rx = find(x);            <span class="hljs-keyword">int</span> ry = find(y);            <span class="hljs-keyword">if</span> (rx == ry) &#123;                <span class="hljs-keyword">return</span>;            &#125;            parent[rx] = ry;        &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;            <span class="hljs-keyword">while</span> (x != parent[x]) &#123;                parent[x] = parent[parent[x]];                x = parent[x];            &#125;            <span class="hljs-keyword">return</span> x;        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 575. 分糖果</title>
    <link href="/2021/01/14/LeetCode-575-distribute-candies/"/>
    <url>/2021/01/14/LeetCode-575-distribute-candies/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/distribute-candies/" target="_blank" rel="noopener">575. 分糖果</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">distributeCandies</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candyType)</span> </span>&#123;    <span class="hljs-comment">// 每种糖果都分过了，还不够 len / 2 个，糖果种类 &lt; len / 2，则所有种类都能分到</span>    <span class="hljs-comment">// 每种糖果只有一个，最多只能分 len / 2 种</span>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> type : candyType) &#123;        set.add(type);    &#125;    <span class="hljs-keyword">return</span> Math.min(set.size(), candyType.length / <span class="hljs-number">2</span>);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1018. 可被 5 整除的二进制前缀</title>
    <link href="/2021/01/14/LeetCode-1018-binary-prefix-divisible-by-5/"/>
    <url>/2021/01/14/LeetCode-1018-binary-prefix-divisible-by-5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/" target="_blank" rel="noopener">1018. 可被 5 整除的二进制前缀</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title">prefixesDivBy5</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    List&lt;Boolean&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(len);    <span class="hljs-keyword">long</span> num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> bit : A) &#123;        num = ((num &lt;&lt; <span class="hljs-number">1</span>) + bit) % <span class="hljs-number">5</span>;        res.add(num == <span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 802. 找到最终的安全状态</title>
    <link href="/2021/01/13/LeetCode-802-find-eventual-safe-states/"/>
    <url>/2021/01/13/LeetCode-802-find-eventual-safe-states/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-eventual-safe-states/" target="_blank" rel="noopener">802. 找到最终的安全状态</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">eventualSafeNodes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = graph.length;        List&lt;List&lt;Integer&gt;&gt; fromEdges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(len);        <span class="hljs-keyword">int</span>[] inDegree = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            fromEdges.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());        &#125;        <span class="hljs-comment">// 若节点 node 出度 == 0，从 node 出发不会形成环</span>        <span class="hljs-comment">// 因此可以继续看有哪些节点指向 node，继续查看这些节点出度是否 == 0</span>        <span class="hljs-comment">// 所以需要反向查找指向 node 的所有节点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> from : graph[i]) &#123;                fromEdges.get(from).add(i);                inDegree[i]++;            &#125;        &#125;        LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;                queue.offer(i);            &#125;        &#125;        <span class="hljs-keyword">boolean</span>[] safe = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-comment">// cur 表示在原图中出度为 0</span>            <span class="hljs-comment">// 因此从 cur 出发是安全的，不会形成环</span>            <span class="hljs-keyword">int</span> cur = queue.poll();            safe[cur] = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">// 对指向 cur 的节点继续寻找在反向图中入度为 0 的节点</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> to : fromEdges.get(cur)) &#123;                <span class="hljs-keyword">if</span> (--inDegree[to] == <span class="hljs-number">0</span>) &#123;                    queue.offer(to);                &#125;            &#125;        &#125;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (safe[i]) &#123;                res.add(i);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 401. 二进制手表</title>
    <link href="/2021/01/13/LeetCode-401-binary-watch/"/>
    <url>/2021/01/13/LeetCode-401-binary-watch/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-watch/" target="_blank" rel="noopener">401. 二进制手表</a></p><p>表可真好看！🤮</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">readBinaryWatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] bits = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>&#125;;        Set&lt;String&gt; res = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> hourNum = <span class="hljs-number">0</span>; hourNum &lt;= <span class="hljs-number">4</span>; hourNum++) &#123;            <span class="hljs-keyword">int</span> minuteNum = num - hourNum;            <span class="hljs-keyword">if</span> (minuteNum &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            List&lt;Integer&gt; hours = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            dfs(hourNum, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, hours, bits);            List&lt;Integer&gt; minutes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            dfs(minuteNum, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, minutes, bits);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> hour : hours) &#123;                <span class="hljs-keyword">if</span> (hour &gt; <span class="hljs-number">11</span>) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> minute : minutes) &#123;                    <span class="hljs-keyword">if</span> (minute &gt; <span class="hljs-number">59</span>) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    StringBuilder time = <span class="hljs-keyword">new</span> StringBuilder();                    time.append(hour);                    time.append(<span class="hljs-string">":"</span>);                    <span class="hljs-keyword">if</span> (minute &lt; <span class="hljs-number">10</span>) &#123;                        time.append(<span class="hljs-string">"0"</span>);                    &#125;                    time.append(minute);                    res.add(time.toString());                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(res);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> sum, List&lt;Integer&gt; res, <span class="hljs-keyword">int</span>[] bits)</span> </span>&#123;        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;            res.add(sum);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin; i &lt;= end; i++) &#123;            sum += bits[i];            dfs(num - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, end, sum, res, bits);            sum -= bits[i];        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 371. 两整数之和</title>
    <link href="/2021/01/13/LeetCode-371-sum-of-two-integers/"/>
    <url>/2021/01/13/LeetCode-371-sum-of-two-integers/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">371. 两整数之和</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-comment">// 无进位加法</span>    <span class="hljs-keyword">int</span> sum = a ^ b;    <span class="hljs-comment">// 计算进位</span>    <span class="hljs-keyword">int</span> withCarry = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (withCarry != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">int</span> t = sum ^ withCarry;        withCarry = (sum &amp; withCarry) &lt;&lt; <span class="hljs-number">1</span>;        sum = t;    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 310. 最小高度树</title>
    <link href="/2021/01/12/LeetCode-310-minimum-height-trees/"/>
    <url>/2021/01/12/LeetCode-310-minimum-height-trees/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-height-trees/" target="_blank" rel="noopener">310. 最小高度树</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] edges)</span> </span>&#123;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;            res.add(<span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> res;        &#125;        List&lt;List&lt;Integer&gt;&gt; neighbors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(n);        <span class="hljs-keyword">int</span>[] degree = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            neighbors.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : edges) &#123;            <span class="hljs-comment">// 更新度</span>            degree[edge[<span class="hljs-number">0</span>]]++;            degree[edge[<span class="hljs-number">1</span>]]++;            <span class="hljs-comment">// 更新图</span>            neighbors.get(edge[<span class="hljs-number">0</span>]).add(edge[<span class="hljs-number">1</span>]);            neighbors.get(edge[<span class="hljs-number">1</span>]).add(edge[<span class="hljs-number">0</span>]);        &#125;        LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-comment">// 度为 1 表示可以删除</span>            <span class="hljs-keyword">if</span> (degree[i] == <span class="hljs-number">1</span>) &#123;                queue.offer(i);            &#125;        &#125;        <span class="hljs-keyword">boolean</span>[] deleted = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];        <span class="hljs-keyword">int</span> count = n;        <span class="hljs-comment">// 最后剩 0 个或 1 个节点</span>        <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">int</span> size = queue.size();            count -= size;            <span class="hljs-comment">// 队列里的节点进行统一删除</span>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">int</span> cur = queue.poll();                deleted[cur] = <span class="hljs-keyword">true</span>;                degree[cur] = -<span class="hljs-number">1</span>;                <span class="hljs-comment">// 删除 度为 1 的邻居节点</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> neighbor : neighbors.get(cur)) &#123;                    degree[neighbor]--;                    <span class="hljs-keyword">if</span> (degree[neighbor] == <span class="hljs-number">1</span>) &#123;                        queue.offer(neighbor);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (!deleted[i]) &#123;                res.add(i);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1203. 项目管理</title>
    <link href="/2021/01/12/LeetCode-1203-sort-items-by-groups-respecting-dependencies/"/>
    <url>/2021/01/12/LeetCode-1203-sort-items-by-groups-respecting-dependencies/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/" target="_blank" rel="noopener">1203. 项目管理</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortItems(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] group, List&lt;List&lt;Integer&gt;&gt; beforeItems) &#123;        <span class="hljs-comment">// 对没有分配组的项目分配组，保证 -1 不会映射成一个组</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> item = <span class="hljs-number">0</span>; item &lt; n; item++) &#123;            <span class="hljs-keyword">if</span> (group[item] == -<span class="hljs-number">1</span>) &#123;                group[item] = m;                m++;            &#125;        &#125;        <span class="hljs-comment">// 若项目已经预先分配过组，则同一组的项目要相邻，意味着项目为拓扑序 且 组也为拓扑序</span>        <span class="hljs-comment">// 1. 建立 组的图 和 项目的图，并分别进行拓扑排序</span>        <span class="hljs-comment">// 2. 项目排序后，对项目分组，然后按组的拓扑序输出</span>        List&lt;Integer&gt;[] fromGroup = <span class="hljs-keyword">new</span> ArrayList[m];        <span class="hljs-keyword">int</span>[] inDegreeGroup = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            fromGroup[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        &#125;        List&lt;Integer&gt;[] fromItem = <span class="hljs-keyword">new</span> ArrayList[n];        <span class="hljs-keyword">int</span>[] inDegreeItem = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            fromItem[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> item = <span class="hljs-number">0</span>; item &lt; n; item++) &#123;            <span class="hljs-keyword">int</span> curGroup = group[item];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> beforeItem : beforeItems.get(item)) &#123;                <span class="hljs-comment">// 建立组之间的拓扑关系 beforeGroup -&gt; curGroup</span>                <span class="hljs-keyword">int</span> beforeGroup = group[beforeItem];                <span class="hljs-comment">// 二者不能相等，否则自身依赖自身</span>                <span class="hljs-keyword">if</span> (curGroup != beforeGroup) &#123;                    fromGroup[beforeGroup].add(curGroup);                    <span class="hljs-comment">// curGroup 入度</span>                    inDegreeGroup[curGroup]++;                &#125;                <span class="hljs-comment">// 建立项目之间的拓扑关系 beforeItem -&gt; curItem</span>                fromItem[beforeItem].add(item);                inDegreeItem[item]++;            &#125;        &#125;        <span class="hljs-comment">// 分别进行拓扑排序，若存在循环依赖直接返回</span>        List&lt;Integer&gt; sortedGroups = topSort(fromGroup, inDegreeGroup);        <span class="hljs-keyword">if</span> (sortedGroups.isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        &#125;        List&lt;Integer&gt; sortedItems = topSort(fromItem, inDegreeItem);        <span class="hljs-keyword">if</span> (sortedItems.isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-comment">// 对排序后的项目分组</span>        Map&lt;Integer, List&lt;Integer&gt;&gt; group2Items = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(m);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> item : sortedItems) &#123;            group2Items.computeIfAbsent(group[item], o -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;()).add(item);        &#125;        <span class="hljs-comment">// 根据组的拓扑序输出</span>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> g : sortedGroups) &#123;            List&lt;Integer&gt; items = group2Items.getOrDefault(g, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());            res.addAll(items);        &#125;        <span class="hljs-keyword">return</span> res.stream().mapToInt(Integer::valueOf).toArray();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">topSort</span><span class="hljs-params">(List&lt;Integer&gt;[] from, <span class="hljs-keyword">int</span>[] inDegree)</span> </span>&#123;        LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-comment">// 入度为 0 加入队列</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inDegree.length; i++) &#123;            <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;                queue.offer(i);            &#125;        &#125;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-keyword">int</span> cur = queue.poll();            res.add(cur);            <span class="hljs-comment">// 入度为 0 进入下一轮排序</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> to : from[cur]) &#123;                inDegree[to]--;                <span class="hljs-keyword">if</span> (inDegree[to] == <span class="hljs-number">0</span>) &#123;                    queue.offer(to);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res.size() == inDegree.length ? res : <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 342. 4的幂</title>
    <link href="/2021/01/11/LeetCode-342-power-of-four/"/>
    <url>/2021/01/11/LeetCode-342-power-of-four/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener">342. 4的幂</a></p><p>num 是否为 2 的幂：<code>x &gt; 0 and x &amp; (x - 1) == 0</code><br />当 x 是 4 的幂时，<code>1</code> 处于偶数位置：第 <code>0</code> 位、第 <code>2</code>位、第 <code>4</code> 位等；否则 <code>1</code> 处于奇数位置。</p><p>因此 4 的幂与数字 (<code>101010...10</code>)相 <strong>与</strong> 会得到 0。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20210111191115.png" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfFour</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">return</span> num &gt; <span class="hljs-number">0</span> &amp;&amp; (num &amp; (num - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> &amp;&amp; (num &amp; <span class="hljs-number">0xaaaaaaaa</span>) == <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 263. 丑数</title>
    <link href="/2021/01/11/LeetCode-263-ugly-number/"/>
    <url>/2021/01/11/LeetCode-263-ugly-number/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/ugly-number/" target="_blank" rel="noopener">263. 丑数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isUgly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> isUgly(num / <span class="hljs-number">2</span>);    &#125;    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> isUgly(num / <span class="hljs-number">3</span>);    &#125;    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> isUgly(num / <span class="hljs-number">5</span>);    &#125;    <span class="hljs-keyword">return</span> num == <span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1202. 交换字符串中的元素</title>
    <link href="/2021/01/11/LeetCode-1202-smallest-string-with-swaps/"/>
    <url>/2021/01/11/LeetCode-1202-smallest-string-with-swaps/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/" target="_blank" rel="noopener">1202. 交换字符串中的元素</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">smallestStringWithSwaps</span><span class="hljs-params">(String s, List&lt;List&lt;Integer&gt;&gt; pairs)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-keyword">int</span> len = str.length;    UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(len);    <span class="hljs-keyword">for</span> (List&lt;Integer&gt; pair : pairs) &#123;        uf.union(pair.get(<span class="hljs-number">0</span>), pair.get(<span class="hljs-number">1</span>));    &#125;    <span class="hljs-comment">// root =&gt; 每个节点索引</span>    Map&lt;Integer, List&lt;Integer&gt;&gt; indices = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(len);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> root = uf.find(i);        indices.computeIfAbsent(root, o -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;()).add(i);    &#125;    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry : indices.entrySet()) &#123;        List&lt;Integer&gt; members = entry.getValue();        <span class="hljs-comment">// 每个连通分量对应的字符集合</span>        <span class="hljs-keyword">int</span> size = members.size();        <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[size];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            chars[i] = str[members.get(i)];        &#125;        <span class="hljs-comment">// 排序后插入原字符串</span>        Arrays.sort(chars);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            str[members.get(i)] = chars[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(str);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1772. 执行交换操作后的最小汉明距离</title>
    <link href="/2021/01/10/LeetCode-1772-minimize-hamming-distance-after-swap-operations/"/>
    <url>/2021/01/10/LeetCode-1772-minimize-hamming-distance-after-swap-operations/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimize-hamming-distance-after-swap-operations/" target="_blank" rel="noopener">1772. 执行交换操作后的最小汉明距离</a></p><p><a href="https://leetcode-cn.com/problems/minimize-hamming-distance-after-swap-operations/solution/bing-cha-ji-ha-xi-biao-java-shuang-bai-5-viq6/" target="_blank" rel="noopener">题解</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumHammingDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] source, <span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span>[][] allowedSwaps)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = source.length;    UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(len);    <span class="hljs-comment">// 建立连通图</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] allowedSwap : allowedSwaps) &#123;        uf.union(allowedSwap[<span class="hljs-number">0</span>], allowedSwap[<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * &gt;&gt; 同一个连通分量的所有节点在 source 中可以任意交换位置 &lt;&lt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 对于 target[i] 对应的连通分量，找到 i 的根节点 root</span><span class="hljs-comment">     * 若 target[i] 存在于 groups[root]，则 source 中第 i 个位置可以通过交换，使得 source[i] == target[i]</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">// key: root =&gt; value: root 对应的连通分量中，所有子节点在 source 中的对应值的出现次数</span>    Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; groups = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(len);    <span class="hljs-comment">// 找到 i 的根节点，将 source[i] 加入根节点对应的 Map 中</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 获取 i 对应连通分量的根节点</span>        <span class="hljs-keyword">int</span> root = uf.find(i);        <span class="hljs-comment">// 把 source[i] 加入 root 对应的集合 groups[root]</span>        Map&lt;Integer, Integer&gt; members = groups.getOrDefault(root, <span class="hljs-keyword">new</span> HashMap&lt;&gt;());        <span class="hljs-comment">// 更新 source[i] 出现次数</span>        <span class="hljs-keyword">int</span> occur = members.getOrDefault(source[i], <span class="hljs-number">0</span>);        members.put(source[i], occur + <span class="hljs-number">1</span>);        groups.put(root, members);    &#125;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 获取 i 对应连通分量的根节点</span>        <span class="hljs-keyword">int</span> root = uf.find(i);        Map&lt;Integer, Integer&gt; members = groups.get(root);        <span class="hljs-keyword">int</span> occur = members.getOrDefault(target[i], <span class="hljs-number">0</span>);        <span class="hljs-comment">// source[i] 还有未被使用的才能继续进行交换</span>        <span class="hljs-keyword">if</span> (occur &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 交换过后出现次数 - 1</span>            members.put(target[i], occur - <span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// source[i] 已用完</span>            <span class="hljs-comment">// 或 source 中不存在 target[i]，无法交换</span>            count++;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[count];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;            parent[i] = i;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">int</span> rootX = find(x);        <span class="hljs-keyword">int</span> rootY = find(y);        <span class="hljs-keyword">if</span> (rootX == rootY) &#123;            <span class="hljs-keyword">return</span>;        &#125;        parent[rootX] = rootY;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">while</span> (parent[x] != x) &#123;            parent[x] = parent[parent[x]];            x = parent[x];        &#125;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 5652. 交换链表中的节点</title>
    <link href="/2021/01/10/LeetCode-5652-swapping-nodes-in-a-linked-list/"/>
    <url>/2021/01/10/LeetCode-5652-swapping-nodes-in-a-linked-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/" target="_blank" rel="noopener">5652. 交换链表中的节点</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapNodes</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    ListNode slow = head;    ListNode fast = head;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++) &#123;        fast = fast.next;    &#125;    ListNode frontK = fast;    <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span>) &#123;        fast = fast.next;        slow = slow.next;    &#125;    <span class="hljs-keyword">int</span> t = frontK.val;    frontK.val = slow.val;    slow.val = t;    <span class="hljs-keyword">return</span> head;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 5649. 解码异或后的数组</title>
    <link href="/2021/01/10/LeetCode-5649-decode-xored-array/"/>
    <url>/2021/01/10/LeetCode-5649-decode-xored-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/decode-xored-array/" target="_blank" rel="noopener">5649. 解码异或后的数组</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] decode(<span class="hljs-keyword">int</span>[] encoded, <span class="hljs-keyword">int</span> first) &#123;    <span class="hljs-comment">// 1,0,2,1</span>    <span class="hljs-comment">//   1,2,3</span>    <span class="hljs-keyword">int</span> len = encoded.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    res[<span class="hljs-number">0</span>] = first;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        res[i] = res[i - <span class="hljs-number">1</span>] ^ encoded[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 228. 汇总区间</title>
    <link href="/2021/01/10/LeetCode-228-summary-ranges/"/>
    <url>/2021/01/10/LeetCode-228-summary-ranges/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/summary-ranges/" target="_blank" rel="noopener">228. 汇总区间</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">summaryRanges</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        <span class="hljs-keyword">if</span> (i == len || nums[i] != nums[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">if</span> (start == i - <span class="hljs-number">1</span>) &#123;                res.add(nums[start] + <span class="hljs-string">""</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                res.add(nums[start] + <span class="hljs-string">"-&gt;"</span> + nums[i - <span class="hljs-number">1</span>]);            &#125;            start = i;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 203. 移除链表元素</title>
    <link href="/2021/01/08/LeetCode-203-remove-linked-list-elements/"/>
    <url>/2021/01/08/LeetCode-203-remove-linked-list-elements/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. 移除链表元素</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    dummy.next = head;    ListNode tail = dummy;    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// -1 1 x 3 4</span>        <span class="hljs-keyword">if</span> (head.val == val) &#123;            <span class="hljs-comment">// tail 连到 head 的下一个节点</span>            <span class="hljs-comment">// 下一次遍历 head 就是 tail.next</span>            tail.next = head.next;        &#125; <span class="hljs-keyword">else</span> &#123;            tail = tail.next;        &#125;        head = head.next;    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 172. 阶乘后的零</title>
    <link href="/2021/01/07/LeetCode-172-factorial-trailing-zeroes/"/>
    <url>/2021/01/07/LeetCode-172-factorial-trailing-zeroes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">172. 阶乘后的零</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (n &gt;= <span class="hljs-number">5</span>) &#123;        count += n / <span class="hljs-number">5</span>;        n /= <span class="hljs-number">5</span>;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 399. 除法求值</title>
    <link href="/2021/01/06/LeetCode-399-evaluate-division/"/>
    <url>/2021/01/06/LeetCode-399-evaluate-division/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">399. 除法求值</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;    <span class="hljs-comment">// 每个 equation 两个字母，映射到并查集 2 * size 个元素</span>    <span class="hljs-keyword">int</span> size = equations.size();    Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(size * <span class="hljs-number">2</span>);    UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(size * <span class="hljs-number">2</span>);    <span class="hljs-comment">// equation 中的字母在并查集中的索引</span>    <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;        List&lt;String&gt; equation = equations.get(i);        String x = equation.get(<span class="hljs-number">0</span>);        String y = equation.get(<span class="hljs-number">1</span>);        map.putIfAbsent(x, id++);        map.putIfAbsent(y, id++);        <span class="hljs-comment">// x / y = values[i]</span>        uf.union(map.get(x), map.get(y), values[i]);    &#125;    <span class="hljs-keyword">int</span> querySize = queries.size();    <span class="hljs-keyword">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[querySize];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; querySize; i++) &#123;        List&lt;String&gt; query = queries.get(i);        String x = query.get(<span class="hljs-number">0</span>);        String y = query.get(<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (!map.containsKey(x) || !map.containsKey(y)) &#123;            res[i] = -<span class="hljs-number">1.0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">double</span> divide = uf.connected(map.get(x), map.get(y));            res[i] = divide;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span>[] weight;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;        <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];        <span class="hljs-keyword">this</span>.weight = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[size];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            parent[i] = i;            weight[i] = <span class="hljs-number">1.0</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">double</span> value)</span> </span>&#123;        <span class="hljs-keyword">int</span> rootX = findRoot(x);        <span class="hljs-keyword">int</span> rootY = findRoot(y);        <span class="hljs-keyword">if</span> (rootX == rootY) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// x 的根节点连到 y 的根节点</span>        <span class="hljs-comment">// x 和 y 之间没有直接连接</span>        parent[rootX] = rootY;        <span class="hljs-comment">// x -&gt; rootX -&gt; rootY</span>        <span class="hljs-comment">// x &gt;(value) y -&gt; rootY</span>        <span class="hljs-comment">// 两条路径的权值相等</span>        weight[rootX] = value * weight[y] / weight[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRoot</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">while</span> (x != parent[x]) &#123;            <span class="hljs-keyword">int</span> p = parent[x];            <span class="hljs-comment">// 路径压缩，所有节点都能连到根节点</span>            parent[x] = findRoot(parent[x]);            <span class="hljs-comment">// 更新权值</span>            <span class="hljs-comment">// 从   x -&gt; parent[x] -&gt; p[p[x]]</span>            <span class="hljs-comment">// 变为  x -&gt; p[p[x]]</span>            weight[x] *= weight[p];            x = parent[x];        &#125;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">int</span> rootX = findRoot(x);        <span class="hljs-keyword">int</span> rootY = findRoot(y);        <span class="hljs-comment">// 根节点相同说明能转为同一个字母，才能相除</span>        <span class="hljs-keyword">return</span> rootX == rootY ? weight[x] / weight[y] : -<span class="hljs-number">1.0</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 540. 有序数组中的单一元素</title>
    <link href="/2021/01/05/LeetCode-540-single-element-in-a-sorted-array/"/>
    <url>/2021/01/05/LeetCode-540-single-element-in-a-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/" target="_blank" rel="noopener">540. 有序数组中的单一元素</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-comment">// [3,3,7,7,10,11,11]</span>        <span class="hljs-keyword">boolean</span> isOdd = (right - mid) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>;        <span class="hljs-comment">// mid 和 左边相等，查看左边</span>        <span class="hljs-keyword">if</span> (nums[mid] == nums[mid - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// 左边偶数个</span>            <span class="hljs-comment">// 3,3,7,7(mid), 10,11,11</span>            <span class="hljs-keyword">if</span> ((mid - left + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">// 左边奇数个，target 在左边</span>            <span class="hljs-comment">// 3,3,7(mid), 10,11,11</span>            <span class="hljs-keyword">else</span> &#123;                right = mid - <span class="hljs-number">2</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == nums[mid + <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">if</span> ((right - mid + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;                right = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid + <span class="hljs-number">2</span>;            &#125;        &#125;        <span class="hljs-comment">// nums[mid] 和左右都不等</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> nums[mid];        &#125;    &#125;    <span class="hljs-keyword">return</span> nums[left];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 945. 使数组唯一的最小增量</title>
    <link href="/2021/01/05/LeetCode-945-minimum-increment-to-make-array-unique/"/>
    <url>/2021/01/05/LeetCode-945-minimum-increment-to-make-array-unique/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/" target="_blank" rel="noopener">945. 使数组唯一的最小增量</a></p><h1 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minIncrementForUnique</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    Arrays.sort(A);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (A[i] &lt;= A[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">int</span> t = A[i];            <span class="hljs-comment">// 在前一个元素的基础上加</span>            A[i] = A[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;            res += A[i] - t;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><p>空间换时间</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minIncrementForUnique</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// position[i] 为最后一个存放元素的位置，若冲突则往后找</span>    <span class="hljs-keyword">int</span>[] position = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">80000</span>];    Arrays.fill(position, -<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : A) &#123;        <span class="hljs-keyword">int</span> targetIdx = findPos(num, position);        res += targetIdx - num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findPos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>[] position)</span> </span>&#123;    <span class="hljs-keyword">int</span> next = position[i];    <span class="hljs-comment">// position[i] 没有元素，可以放置 i</span>    <span class="hljs-keyword">if</span> (next == -<span class="hljs-number">1</span>) &#123;        position[i] = i;        <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-comment">// 往后找空位</span>    next = findPos(next + <span class="hljs-number">1</span>, position);    <span class="hljs-comment">// 若下次和 i 冲突，直接从 next 开始找空位</span>    position[i] = next;    <span class="hljs-keyword">return</span> next;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 830. 较大分组的位置</title>
    <link href="/2021/01/05/LeetCode-830-positions-of-large-groups/"/>
    <url>/2021/01/05/LeetCode-830-positions-of-large-groups/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/positions-of-large-groups/" target="_blank" rel="noopener">830. 较大分组的位置</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-keyword">int</span> len = str.length;    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (str[i] != str[start]) &#123;            <span class="hljs-keyword">if</span> (i - start &gt;= <span class="hljs-number">3</span>) &#123;                res.add(Arrays.asList(start, i - <span class="hljs-number">1</span>));            &#125;            start = i;        &#125;    &#125;    <span class="hljs-keyword">if</span> (len - start &gt;= <span class="hljs-number">3</span>) &#123;        res.add(Arrays.asList(start, len - <span class="hljs-number">1</span>));    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1319. 连通网络的操作次数</title>
    <link href="/2021/01/04/LeetCode-1319-number-of-operations-to-make-network-connected/"/>
    <url>/2021/01/04/LeetCode-1319-number-of-operations-to-make-network-connected/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/" target="_blank" rel="noopener">1319. 连通网络的操作次数</a></p><blockquote><p>不能使用 <code>connected[i]</code> 数组判断，因为不知道 <code>i</code> 连接的是哪个连通分量。可能存在多个连通分量，如：</p></blockquote><pre><code class="hljs json"><span class="hljs-number">6</span>[[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]</code></pre><p>所有的结点都已经被访问过了，会 <code>return 0</code>，实际上需要 <code>return 1</code>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">makeConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] connections)</span> </span>&#123;    UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);    <span class="hljs-keyword">int</span> canRelease = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] c : connections) &#123;        <span class="hljs-comment">// 已经连接，可以拔下它们之间的线</span>        <span class="hljs-keyword">if</span> (uf.isConnected(c[<span class="hljs-number">0</span>], c[<span class="hljs-number">1</span>])) &#123;            canRelease++;        &#125; <span class="hljs-keyword">else</span> &#123;            uf.union(c[<span class="hljs-number">0</span>], c[<span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-comment">// 未连接的个数</span>    <span class="hljs-keyword">int</span> require = uf.getCount() - <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> require &gt; canRelease ? -<span class="hljs-number">1</span> : require;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 684. 冗余连接</title>
    <link href="/2021/01/04/LeetCode-684-redundant-connection/"/>
    <url>/2021/01/04/LeetCode-684-redundant-connection/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684. 冗余连接</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findRedundantConnection(<span class="hljs-keyword">int</span>[][] edges) &#123;    <span class="hljs-keyword">int</span> len = edges.length;    UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(len + <span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (uf.isConnected(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) &#123;            idx = i;        &#125; <span class="hljs-keyword">else</span> &#123;            uf.union(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> edges[idx];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 990. 等式方程的可满足性</title>
    <link href="/2021/01/04/LeetCode-990-satisfiability-of-equality-equations/"/>
    <url>/2021/01/04/LeetCode-990-satisfiability-of-equality-equations/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">990. 等式方程的可满足性</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equationsPossible</span><span class="hljs-params">(String[] equations)</span> </span>&#123;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(<span class="hljs-number">26</span>);        <span class="hljs-keyword">for</span> (String equation : equations) &#123;            <span class="hljs-keyword">char</span>[] eq = equation.toCharArray();            <span class="hljs-comment">// 连接所有等号</span>            <span class="hljs-keyword">if</span> (eq[<span class="hljs-number">1</span>] == <span class="hljs-string">'='</span>) &#123;                uf.union(eq[<span class="hljs-number">0</span>] - <span class="hljs-string">'a'</span>, eq[<span class="hljs-number">3</span>] - <span class="hljs-string">'a'</span>);            &#125;        &#125;        <span class="hljs-keyword">for</span> (String equation : equations) &#123;            <span class="hljs-keyword">char</span>[] eq = equation.toCharArray();            <span class="hljs-comment">// 查看所有不等号，若它们在并查集中已连接，则存在冲突</span>            <span class="hljs-keyword">if</span> (eq[<span class="hljs-number">1</span>] == <span class="hljs-string">'!'</span> &amp;&amp; uf.isConnected(eq[<span class="hljs-number">0</span>] - <span class="hljs-string">'a'</span>, eq[<span class="hljs-number">3</span>] - <span class="hljs-string">'a'</span>)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[count];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;            parent[i] = i;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">int</span> rootX = findRoot(x);        <span class="hljs-keyword">int</span> rootY = findRoot(y);        <span class="hljs-keyword">if</span> (rootX == rootY) &#123;            <span class="hljs-keyword">return</span>;        &#125;        parent[rootY] = rootX;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> findRoot(x) == findRoot(y);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRoot</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">while</span> (parent[x] != x) &#123;            parent[x] = parent[parent[x]];            x = parent[x];        &#125;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 86. 分隔链表</title>
    <link href="/2021/01/03/LeetCode-86-partition-list/"/>
    <url>/2021/01/03/LeetCode-86-partition-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;    ListNode dummyLessThan = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    ListNode lessThanTail = dummyLessThan;    ListNode dummyGreaterThan = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    ListNode greaterThanTail = dummyGreaterThan;    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (head.val &lt; x) &#123;            lessThanTail.next = head;            lessThanTail = lessThanTail.next;        &#125; <span class="hljs-keyword">else</span> &#123;            greaterThanTail.next = head;            greaterThanTail = greaterThanTail.next;        &#125;        head = head.next;    &#125;    <span class="hljs-comment">// &gt; x 尾部置空</span>    greaterThanTail.next = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 连接两端</span>    lessThanTail.next = dummyGreaterThan.next;    <span class="hljs-keyword">return</span> dummyLessThan.next;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 605. 种花问题</title>
    <link href="/2021/01/01/LeetCode-605-can-place-flowers/"/>
    <url>/2021/01/01/LeetCode-605-can-place-flowers/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/can-place-flowers/" target="_blank" rel="noopener">605. 种花问题</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] flowerbed, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = flowerbed.length;    <span class="hljs-keyword">int</span>[] flower = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">2</span>];    System.arraycopy(flowerbed, <span class="hljs-number">0</span>, flower, <span class="hljs-number">1</span>, len);    len += <span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;       <span class="hljs-keyword">if</span> (flower[i - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; flower[i] == <span class="hljs-number">0</span> &amp;&amp; flower[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;           n--;           flower[i] = <span class="hljs-number">1</span>;        &#125;     &#125;    <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 435. 无重叠区间</title>
    <link href="/2020/12/31/LeetCode-435-non-overlapping-intervals/"/>
    <url>/2020/12/31/LeetCode-435-non-overlapping-intervals/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a></p><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. 用最少数量的箭引爆气球</a></p><p>12 月勋章<br /><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201231165036.png" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;    <span class="hljs-comment">// [[0,2],[1,3],[2,4],[3,5],[4,6]]</span>    <span class="hljs-keyword">int</span> len = intervals.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    Arrays.sort(intervals, ((o1, o2) -&gt; o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]));    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 重叠</span>        <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt; end) &#123;            count++;            <span class="hljs-comment">// 移除覆盖范围更大的区间，即保留右端点更小的区间</span>            end = Math.min(end, intervals[i][<span class="hljs-number">1</span>]);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 不重叠，下一次比较的为本次的右端点</span>            end = intervals[i][<span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;    <span class="hljs-comment">// [[0,2],[1,3],[2,4],[3,5],[4,6]]</span>    <span class="hljs-keyword">int</span> len = intervals.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 按右端点排序</span>    Arrays.sort(intervals, (o1, o2) -&gt; o1[<span class="hljs-number">1</span>] == o2[<span class="hljs-number">1</span>] ? o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>] : o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 不重叠</span>        <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= end) &#123;            count++;            <span class="hljs-comment">// 移除覆盖范围更大的区间，即保留右端点更小的区间</span>            end = intervals[i][<span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> len - count - <span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 101. 对称二叉树</title>
    <link href="/2020/12/30/LeetCode-101-symmetric-tree/"/>
    <url>/2020/12/30/LeetCode-101-symmetric-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *     1</span><span class="hljs-comment">     *    / \</span><span class="hljs-comment">     *   2   2</span><span class="hljs-comment">     *  / \ / \</span><span class="hljs-comment">     * 3  4 4  3</span><span class="hljs-comment">     */</span>    LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(root.left);    queue.add(root.right);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        TreeNode left = queue.poll();        TreeNode right = queue.poll();        <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 有一个为 null || 结点值不等</span>        <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> || right == <span class="hljs-keyword">null</span> || left.val != right.val) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 左左 3, 右右 3</span>        queue.add(left.left);        queue.add(right.right);        <span class="hljs-comment">// 左右 4, 右左 4</span>        queue.add(left.right);        queue.add(right.left);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(root.left, root.right);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> || right == <span class="hljs-keyword">null</span> || left.val != right.val) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 160. 相交链表</title>
    <link href="/2020/12/30/LeetCode-160-intersection-of-two-linked-lists/"/>
    <url>/2020/12/30/LeetCode-160-intersection-of-two-linked-lists/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;    ListNode pa = headA;    ListNode pb = headB;    <span class="hljs-comment">// 在交点相遇</span>    <span class="hljs-keyword">while</span> (pa != pb) &#123;        <span class="hljs-comment">// a + c + b</span>        pa = pa == <span class="hljs-keyword">null</span> ? headB : pa.next;        <span class="hljs-comment">// b + c + a</span>        pb = pb == <span class="hljs-keyword">null</span> ? headA : pb.next;    &#125;    <span class="hljs-keyword">return</span> pa;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1046. 最后一块石头的重量</title>
    <link href="/2020/12/30/LeetCode-1046-last-stone-weight/"/>
    <url>/2020/12/30/LeetCode-1046-last-stone-weight/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/last-stone-weight/" target="_blank" rel="noopener">1046. 最后一块石头的重量</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastStoneWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] stones)</span> </span>&#123;    PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> stone : stones) &#123;        maxHeap.add(stone);    &#125;    <span class="hljs-keyword">while</span> (maxHeap.size() &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> x = maxHeap.poll();        <span class="hljs-keyword">int</span> y = maxHeap.poll();        <span class="hljs-keyword">int</span> diff = x - y;        <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>) &#123;            maxHeap.add(diff);        &#125;    &#125;    <span class="hljs-keyword">return</span> maxHeap.isEmpty() ? <span class="hljs-number">0</span> : maxHeap.poll();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 330. 按要求补齐数组</title>
    <link href="/2020/12/29/LeetCode-330-patching-array/"/>
    <url>/2020/12/29/LeetCode-330-patching-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/patching-array/" target="_blank" rel="noopener">330. 按要求补齐数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPatches</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 需要覆盖到的数</span>    <span class="hljs-keyword">long</span> x = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 当前使用的数组元素个数</span>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 数组的原始长度：未添加新元素</span>    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">while</span> (x &lt;= n) &#123;        <span class="hljs-comment">// 数组的和可以组成 x</span>        <span class="hljs-keyword">if</span> (index &lt; len &amp;&amp; nums[index] &lt;= x) &#123;            <span class="hljs-comment">// 更新 x，可覆盖 [1, x + nums[index])</span>            x += nums[index];            index++;        &#125;        <span class="hljs-comment">// 数组的和无法组成 x</span>        <span class="hljs-comment">// [1, 5, 20] x = 2 无法覆盖</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 往数组中添加 x</span>            <span class="hljs-comment">// 覆盖范围翻倍 [1, 2 * x)</span>            x *= <span class="hljs-number">2</span>;            count++;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 21. 合并两个有序链表</title>
    <link href="/2020/12/28/LeetCode-21-merge-two-sorted-lists/"/>
    <url>/2020/12/28/LeetCode-21-merge-two-sorted-lists/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    ListNode tail = dummy;    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;            tail.next = l1;            l1 = l1.next;        &#125; <span class="hljs-keyword">else</span> &#123;            tail.next = l2;            l2 = l2.next;        &#125;        tail = tail.next;    &#125;    <span class="hljs-keyword">if</span> (l1 != <span class="hljs-keyword">null</span>) &#123;        tail.next = l1;    &#125;    <span class="hljs-keyword">if</span> (l2 != <span class="hljs-keyword">null</span>) &#123;        tail.next = l2;    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题 17.12. BiNode</title>
    <link href="/2020/12/28/interview-17-12-binode-lcci/"/>
    <url>/2020/12/28/interview-17-12-binode-lcci/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binode-lcci/" target="_blank" rel="noopener">面试题 17.12. BiNode</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">convertBiNode</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    TreeNode dummy = <span class="hljs-keyword">new</span> TreeNode(-<span class="hljs-number">1</span>);    TreeNode tail = dummy;    LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">while</span> (!stack.isEmpty() || root != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;            stack.push(root);            root = root.left;        &#125;        TreeNode top = stack.pop();        <span class="hljs-comment">// 左子树置空，避免形成环</span>        top.left = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 连接链表</span>        tail.right = top;        <span class="hljs-comment">// 更新 tail</span>        tail = tail.right;        root = top.right;    &#125;    <span class="hljs-keyword">return</span> dummy.right;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 61. 旋转链表</title>
    <link href="/2020/12/25/LeetCode-61-rotate-list/"/>
    <url>/2020/12/25/LeetCode-61-rotate-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">61. 旋转链表</a></p><h1 id="找新起点"><a class="markdownIt-Anchor" href="#找新起点"></a> 找新起点</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || k == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> head;        &#125;        <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;        ListNode tail = head;        <span class="hljs-comment">// 计算链表长度</span>        <span class="hljs-keyword">while</span> (tail.next != <span class="hljs-keyword">null</span>) &#123;            len++;            tail = tail.next;        &#125;        <span class="hljs-comment">// 建环</span>        tail.next = head;        <span class="hljs-comment">// 新的头部位置</span>        <span class="hljs-comment">// 把后 k 个移到前面，倒数第 k 个节点为新的头部</span>        <span class="hljs-comment">// 即从前往后数第 len - k 个</span>        k = len - k % len;        tail = head;        <span class="hljs-comment">// 找到新的尾部</span>        <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">1</span>) &#123;            tail = tail.next;        &#125;        ListNode newHead = tail.next;        tail.next = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> newHead;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> head;    &#125;    ListNode p = head;    <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 计算长度</span>    <span class="hljs-keyword">while</span> (p.next != <span class="hljs-keyword">null</span>) &#123;        p = p.next;        len++;    &#125;    ListNode tail = p;    p = head;    ListNode pre = <span class="hljs-keyword">null</span>;    ListNode newHead = head;    <span class="hljs-comment">// 找新的 head</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> ((i + k) % len == <span class="hljs-number">0</span>) &#123;            newHead = p;            <span class="hljs-keyword">break</span>;        &#125;        pre = p;        p = p.next;    &#125;    <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-comment">// 连接新 head</span>    pre.next = <span class="hljs-keyword">null</span>;    tail.next = head;    <span class="hljs-keyword">return</span> newHead;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 9. 回文数</title>
    <link href="/2020/12/25/LeetCode-9-palindrome-number/"/>
    <url>/2020/12/25/LeetCode-9-palindrome-number/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9. 回文数</a></p><h1 id="翻转"><a class="markdownIt-Anchor" href="#翻转"></a> 翻转</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-comment">// 末尾 = 0，肯定不是回文数</span>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x != <span class="hljs-number">0</span> &amp;&amp; x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">int</span> num = x;    <span class="hljs-keyword">int</span> reverseNum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// x 全部翻转</span>    <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;        reverseNum = reverseNum * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;        x /= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> num == reverseNum;&#125;</code></pre><h1 id="逐位判断"><a class="markdownIt-Anchor" href="#逐位判断"></a> 逐位判断</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">int</span> div = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 直到 div 能够取首位</span>    <span class="hljs-keyword">while</span> (x / div &gt;= <span class="hljs-number">10</span>) &#123;        div *= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">int</span> left = x / div;        <span class="hljs-keyword">int</span> right = x % <span class="hljs-number">10</span>;        <span class="hljs-keyword">if</span> (left != right) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 去除首尾</span>        x = x % div / <span class="hljs-number">10</span>;        <span class="hljs-comment">// 缩小除数</span>        div /= <span class="hljs-number">100</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 128. 最长连续序列</title>
    <link href="/2020/12/25/LeetCode-128-longest-consecutive-sequence/"/>
    <url>/2020/12/25/LeetCode-128-longest-consecutive-sequence/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a></p><h1 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        set.add(num);    &#125;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : set) &#123;        <span class="hljs-comment">// x, x + 1, x + 2....</span>        <span class="hljs-comment">// 当 x - 1 存在时，以 x 开始的序列长度肯定 &lt; x - 1 开始的序列长度</span>        <span class="hljs-comment">// 所以当 x - 1 不存在时，尝试更新长度</span>        <span class="hljs-keyword">if</span> (!set.contains(num - <span class="hljs-number">1</span>)) &#123;            <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (set.contains(num + <span class="hljs-number">1</span>)) &#123;                len++;                num++;            &#125;            max = Math.max(max, len);        &#125;    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><h1 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-comment">// 0 1 1 2</span>    <span class="hljs-comment">// 0 0 1 2</span>    Arrays.sort(nums);    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> diff = nums[i] - nums[i - <span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (diff == <span class="hljs-number">1</span>) &#123;            count++;        &#125;        <span class="hljs-comment">// 差值 &gt; 1，无法连续</span>        <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">1</span>) &#123;            res = Math.max(res, count);            count = <span class="hljs-number">1</span>;        &#125;    &#125;    res = Math.max(res, count);    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 135. 分发糖果</title>
    <link href="/2020/12/24/LeetCode-135-candy/"/>
    <url>/2020/12/24/LeetCode-135-candy/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/candy/" target="_blank" rel="noopener">135. 分发糖果</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ratings)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = ratings.length;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] candies = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    Arrays.fill(candies, <span class="hljs-number">1</span>);    <span class="hljs-comment">// i, i + 1 ，更新 i + 1</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">if</span> (ratings[i] &lt; ratings[i + <span class="hljs-number">1</span>]) &#123;            candies[i + <span class="hljs-number">1</span>] = candies[i] + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">// i - 1, i，更新 i - 1</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;        <span class="hljs-keyword">if</span> (ratings[i] &lt; ratings[i - <span class="hljs-number">1</span>]) &#123;            candies[i - <span class="hljs-number">1</span>] = Math.max(candies[i - <span class="hljs-number">1</span>], candies[i] + <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : candies) &#123;        count += i;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 6. Z 字形变换</title>
    <link href="/2020/12/23/LeetCode-6-zigzag-conversion/"/>
    <url>/2020/12/23/LeetCode-6-zigzag-conversion/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. Z 字形变换</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">convert</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> numRows)</span> </span>&#123;    <span class="hljs-keyword">if</span> (numRows &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> s;    &#125;    List&lt;StringBuilder&gt; rows = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(numRows);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;        rows.add(<span class="hljs-keyword">new</span> StringBuilder());    &#125;    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> dir = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;        rows.get(row).append(c);        <span class="hljs-comment">// 到达最后一行，需要往上排列</span>        <span class="hljs-comment">// 到达第一行，需要向下排列</span>        <span class="hljs-keyword">if</span> (row == numRows - <span class="hljs-number">1</span> || row == <span class="hljs-number">0</span>) &#123;            dir = -dir;        &#125;        row += dir;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (StringBuilder rowBuilder : rows) &#123;        sb.append(rowBuilder);    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">convert</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> numRows)</span> </span>&#123;    <span class="hljs-keyword">if</span> (numRows == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> s;    &#125;    List&lt;List&lt;Character&gt;&gt; rows = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(numRows);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;        rows.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());    &#125;    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;    <span class="hljs-keyword">boolean</span> reverse = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;        rows.get(row).add(c);        <span class="hljs-comment">// 到达最后一行，需要往上排列</span>        <span class="hljs-keyword">if</span> (row == numRows - <span class="hljs-number">1</span>) &#123;            reverse = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 到达第一行，需要往下排列</span>        <span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span>) &#123;            reverse = <span class="hljs-keyword">false</span>;        &#125;        row = reverse ? row - <span class="hljs-number">1</span> : row + <span class="hljs-number">1</span>;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (List&lt;Character&gt; rowList : rows) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : rowList) &#123;            sb.append(c);        &#125;    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 238. 除自身以外数组的乘积</title>
    <link href="/2020/12/23/LeetCode-238-product-of-array-except-self/"/>
    <url>/2020/12/23/LeetCode-238-product-of-array-except-self/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. 除自身以外数组的乘积</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 从前往后，nums[i] 之前的乘积</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        res[i] = nums[i - <span class="hljs-number">1</span>] * res[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-comment">// 从后往前，nums[i] 之后的乘积</span>    <span class="hljs-keyword">int</span> rightProduct = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// res[i]: nums[i] 左边乘积，rightProduct 保存右边乘积</span>        res[i] = res[i] * rightProduct;        rightProduct *= nums[i];    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] forward = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] backward = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    forward[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 从前往后，nums[i] 之前的乘积</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        forward[i] = nums[i - <span class="hljs-number">1</span>] * forward[i - <span class="hljs-number">1</span>];    &#125;    backward[len - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 从后往前，nums[i] 之后的乘积</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        backward[i] = nums[i + <span class="hljs-number">1</span>] * backward[i + <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        res[i] = forward[i] * backward[i];    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 103. 二叉树的锯齿形层序遍历</title>
    <link href="/2020/12/22/LeetCode-103-binary-tree-zigzag-level-order-traversal/"/>
    <url>/2020/12/22/LeetCode-103-binary-tree-zigzag-level-order-traversal/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层序遍历</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;    LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(root);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-keyword">int</span> size = queue.size();        List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            TreeNode cur = queue.poll();            <span class="hljs-comment">// 奇数，逆序</span>            <span class="hljs-keyword">if</span> (depth % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;                level.add(<span class="hljs-number">0</span>, cur.val);            &#125; <span class="hljs-keyword">else</span> &#123;                level.add(cur.val);            &#125;            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;                queue.add(cur.left);            &#125;            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;                queue.add(cur.right);            &#125;        &#125;        res.add(level);        depth++;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 312. 戳气球</title>
    <link href="/2020/12/21/LeetCode-312-burst-balloons/"/>
    <url>/2020/12/21/LeetCode-312-burst-balloons/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> newLen = len + <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span>[] nums1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[newLen];    System.arraycopy(nums, <span class="hljs-number">0</span>, nums1, <span class="hljs-number">1</span>, len);    nums1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    nums1[len + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[][] cache = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[newLen][newLen];    <span class="hljs-comment">// 戳破 nums[begin + 1, end - 1] 之间的气球</span>    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, newLen - <span class="hljs-number">1</span>, cache, nums1);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span>[][] cache, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-comment">// begin, end 之间没有气球</span>    <span class="hljs-keyword">if</span> (begin + <span class="hljs-number">1</span> &gt;= end) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (cache[begin][end] != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> cache[begin][end];    &#125;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 每次选择 nums[i] 最后戳破</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin + <span class="hljs-number">1</span>; i &lt; end; i++) &#123;        <span class="hljs-keyword">int</span> cur = dfs(begin, i, cache, nums)                + dfs(i, end, cache, nums)                + nums[begin] * nums[i] * nums[end];        max = Math.max(max, cur);    &#125;    <span class="hljs-comment">// 缓存</span>    cache[begin][end] = max;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 136. 只出现一次的数字</title>
    <link href="/2020/12/18/LeetCode-136-single-number/"/>
    <url>/2020/12/18/LeetCode-136-single-number/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        res ^= num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 389. 找不同</title>
    <link href="/2020/12/18/LeetCode-389-find-the-difference/"/>
    <url>/2020/12/18/LeetCode-389-find-the-difference/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-the-difference/" target="_blank" rel="noopener">389. 找不同</a></p><ul><li><code>0 ^ n = n</code></li><li><code>n ^ n = 0</code></li><li><code>a ^ b ^ c = a ^ c ^ b</code></li></ul><p><code>t</code> 比 <code>s</code> 多一个字母，则其他的字母都出现了偶数次，只有 <code>1</code> 个字母出现了奇数次。相当于找到那个出现奇数次的字母。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">findTheDifference</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">char</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;        res ^= c;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t.toCharArray()) &#123;        res ^= c;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 365. 水壶问题</title>
    <link href="/2020/12/17/LeetCode-365-water-and-jug-problem/"/>
    <url>/2020/12/17/LeetCode-365-water-and-jug-problem/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">365. 水壶问题</a></p><p>BFS 超时了。</p><h1 id="数学"><a class="markdownIt-Anchor" href="#数学"></a> 数学</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canMeasureWater</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x + y &lt; z) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> || y == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> z == <span class="hljs-number">0</span> || x + y == z;    &#125;    <span class="hljs-comment">// ax + by = z, z 是 x, y 的最大公约数</span>    <span class="hljs-keyword">return</span> z % gcd(x, y) == <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">int</span> reminder = x % y;    <span class="hljs-keyword">while</span> (reminder != <span class="hljs-number">0</span>) &#123;        x = y;        y = reminder;        reminder = x % y;    &#125;    <span class="hljs-keyword">return</span> y;&#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canMeasureWater</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;        Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        LinkedList&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);        visited.add(<span class="hljs-string">"0,0"</span>);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-keyword">int</span>[] cur = queue.poll();            <span class="hljs-comment">// 两个水壶容量满足要求</span>            <span class="hljs-keyword">if</span> (cur[<span class="hljs-number">0</span>] + cur[<span class="hljs-number">1</span>] == z) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            List&lt;<span class="hljs-keyword">int</span>[]&gt; nextStates = getNextStates(cur, x, y);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] state : nextStates) &#123;                String key = getIdentifier(state);                <span class="hljs-keyword">if</span> (visited.contains(key)) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                visited.add(key);                queue.add(state);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getIdentifier</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] state)</span> </span>&#123;        <span class="hljs-keyword">return</span> state[<span class="hljs-number">0</span>] + <span class="hljs-string">","</span> + state[<span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-keyword">int</span>[]&gt; getNextStates(<span class="hljs-keyword">int</span>[] cur, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) &#123;        List&lt;<span class="hljs-keyword">int</span>[]&gt; states = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 装满任意一个水壶</span>        <span class="hljs-keyword">int</span>[] s1 = &#123;x, cur[<span class="hljs-number">1</span>]&#125;;        <span class="hljs-keyword">int</span>[] s2 = &#123;cur[<span class="hljs-number">0</span>], y&#125;;        <span class="hljs-comment">// 清空任意一个水壶</span>        <span class="hljs-keyword">int</span>[] s3 = &#123;<span class="hljs-number">0</span>, cur[<span class="hljs-number">1</span>]&#125;;        <span class="hljs-keyword">int</span>[] s4 = &#123;cur[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">// 从一个水壶向另外一个水壶倒水，直到装满或者倒空 3(1) 5(4)</span>        <span class="hljs-keyword">int</span> canPour1 = Math.min(x - cur[<span class="hljs-number">0</span>], cur[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">int</span>[] s5 = &#123;cur[<span class="hljs-number">0</span>] + canPour1, cur[<span class="hljs-number">1</span>] - canPour1&#125;;        <span class="hljs-keyword">int</span> canPour2 = Math.min(y - cur[<span class="hljs-number">1</span>], cur[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">int</span>[] s6 = &#123;cur[<span class="hljs-number">0</span>] - canPour2, cur[<span class="hljs-number">1</span>] + canPour2&#125;;        states.add(s1);        states.add(s2);        states.add(s3);        states.add(s4);        states.add(s5);        states.add(s6);        <span class="hljs-keyword">return</span> states;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 690. 员工的重要性</title>
    <link href="/2020/12/16/LeetCode-690-employee-importance/"/>
    <url>/2020/12/16/LeetCode-690-employee-importance/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">690. 员工的重要性</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getImportance</span><span class="hljs-params">(List&lt;Employee&gt; employees, <span class="hljs-keyword">int</span> id)</span> </span>&#123;    Map&lt;Integer, Employee&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (Employee e : employees) &#123;        map.put(e.id, e);    &#125;    dfs(id, map);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, Map&lt;Integer, Employee&gt; map)</span> </span>&#123;    Employee cur = map.get(id);    res += cur.importance;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> subId : cur.subordinates) &#123;        dfs(subId, map);    &#125;&#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getImportance</span><span class="hljs-params">(List&lt;Employee&gt; employees, <span class="hljs-keyword">int</span> id)</span> </span>&#123;    Map&lt;Integer, Employee&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (Employee e : employees) &#123;        map.put(e.id, e);    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    LinkedList&lt;Employee&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(map.get(id));    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        Employee cur = queue.poll();        res += cur.importance;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> subId : cur.subordinates) &#123;            queue.add(map.get(subId));        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 290. 单词规律</title>
    <link href="/2020/12/16/LeetCode-290-word-pattern/"/>
    <url>/2020/12/16/LeetCode-290-word-pattern/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-pattern/" target="_blank" rel="noopener">290. 单词规律</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(String pattern, String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] patterns = pattern.toCharArray();    <span class="hljs-keyword">int</span> lenPat = patterns.length;    String[] words = s.split(<span class="hljs-string">" "</span>);    <span class="hljs-keyword">int</span> lenWords = words.length;    <span class="hljs-keyword">if</span> (lenPat != lenWords) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    Map&lt;Character, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    Set&lt;String&gt; used = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lenPat; i++) &#123;        <span class="hljs-comment">// pattern 没有对应的单词</span>        <span class="hljs-keyword">if</span> (!map.containsKey(patterns[i])) &#123;            <span class="hljs-comment">// 当前的单词已经被用过</span>            <span class="hljs-keyword">if</span> (used.contains(words[i])) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            map.put(patterns[i], words[i]);            used.add(words[i]);            <span class="hljs-keyword">continue</span>;        &#125;        String target = map.get(patterns[i]);        <span class="hljs-keyword">if</span> (!target.equals(words[i])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 993. 二叉树的堂兄弟节点</title>
    <link href="/2020/12/15/LeetCode-993-cousins-in-binary-tree/"/>
    <url>/2020/12/15/LeetCode-993-cousins-in-binary-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/" target="_blank" rel="noopener">993. 二叉树的堂兄弟节点</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCousins</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(root);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-keyword">int</span> foundX = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> foundY = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            TreeNode cur = queue.poll();            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (cur.left.val == x) &#123;                    foundX = cur.val;                &#125;                <span class="hljs-keyword">if</span> (cur.left.val == y) &#123;                    foundY = cur.val;                &#125;                queue.add(cur.left);            &#125;            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (cur.right.val == x) &#123;                    foundX = cur.val;                &#125;                <span class="hljs-keyword">if</span> (cur.right.val == y) &#123;                    foundY = cur.val;                &#125;                queue.add(cur.right);            &#125;        &#125;        <span class="hljs-keyword">if</span> (foundX != -<span class="hljs-number">1</span> &amp;&amp; foundY != -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> foundX != foundY;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 210. 课程表 II</title>
    <link href="/2020/12/15/LeetCode-210-course-schedule-ii/"/>
    <url>/2020/12/15/LeetCode-210-course-schedule-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">210. 课程表 II</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findOrder(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites) &#123;    List&lt;Set&lt;Integer&gt;&gt; adj = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;        adj.add(<span class="hljs-keyword">new</span> HashSet&lt;&gt;());    &#125;    <span class="hljs-keyword">int</span>[] require = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] p : prerequisites) &#123;        <span class="hljs-comment">// p[0] 依赖 p[1]，当 p[1] 没有依赖时，可以消除 p[0] 的一个依赖</span>        adj.get(p[<span class="hljs-number">1</span>]).add(p[<span class="hljs-number">0</span>]);        <span class="hljs-comment">// p[0] 的依赖总数</span>        require[p[<span class="hljs-number">0</span>]]++;    &#125;    <span class="hljs-comment">// 队列中保存的都是没有依赖的节点</span>    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;        <span class="hljs-comment">// 让没有依赖的节点入队，消除其他节点的依赖</span>        <span class="hljs-keyword">if</span> (require[i] == <span class="hljs-number">0</span>) &#123;            queue.add(i);        &#125;    &#125;    <span class="hljs-keyword">int</span> solved = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-keyword">int</span> cur = queue.poll();        res[solved] = cur;        solved++;        <span class="hljs-comment">// cur 没有依赖，可以消除对 cur 有依赖的其他节点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> to : adj.get(cur)) &#123;            require[to]--;            <span class="hljs-keyword">if</span> (require[to] == <span class="hljs-number">0</span>) &#123;                queue.add(to);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> solved == numCourses ? res : <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 738. 单调递增的数字</title>
    <link href="/2020/12/15/LeetCode-738-monotone-increasing-digits/"/>
    <url>/2020/12/15/LeetCode-738-monotone-increasing-digits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/" target="_blank" rel="noopener">738. 单调递增的数字</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] digits = (N + <span class="hljs-string">""</span>).toCharArray();    <span class="hljs-keyword">int</span> len = digits.length;    <span class="hljs-comment">// 最大数</span>    <span class="hljs-keyword">int</span> max = -<span class="hljs-number">1</span>;    <span class="hljs-comment">// 最大数的最小位置</span>    <span class="hljs-keyword">int</span> idx = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">if</span> (digits[i] &gt; max) &#123;            max = digits[i];            idx = i;        &#125;        <span class="hljs-comment">// 1244443</span>        <span class="hljs-keyword">if</span> (max &gt; digits[i + <span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// 当前最大数数 - 1</span>            digits[idx]--;            <span class="hljs-comment">// 把最大数后面的数变成 9</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = idx + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;                digits[j] = <span class="hljs-string">'9'</span>;            &#125;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> Integer.parseInt(<span class="hljs-keyword">new</span> String(digits));&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 207. 课程表</title>
    <link href="/2020/12/14/LeetCode-207-course-schedule/"/>
    <url>/2020/12/14/LeetCode-207-course-schedule/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] inDegree = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];    List&lt;Set&lt;Integer&gt;&gt; adj = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(numCourses);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;        adj.add(<span class="hljs-keyword">new</span> HashSet&lt;&gt;());    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] p : prerequisites) &#123;        adj.get(p[<span class="hljs-number">1</span>]).add(p[<span class="hljs-number">0</span>]);        <span class="hljs-comment">// 统计入度</span>        inDegree[p[<span class="hljs-number">0</span>]]++;    &#125;    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;        <span class="hljs-comment">// 入度 == 0，作为起点</span>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;            queue.add(i);        &#125;    &#125;    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-keyword">int</span> from = queue.poll();        <span class="hljs-comment">// numCourses 表示已经未访问的节点数</span>        numCourses--;        <span class="hljs-comment">// 把与 from 连接的所有点入度 - 1</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> to : adj.get(from)) &#123;            inDegree[to]--;            <span class="hljs-comment">// 若节点入度为 0，则可作为下一次的起点</span>            <span class="hljs-keyword">if</span> (inDegree[to] == <span class="hljs-number">0</span>) &#123;                queue.add(to);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> numCourses == <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 13. 机器人的运动范围</title>
    <link href="/2020/12/11/LeetCode-offer-13-ji-qi-ren-de-yun-dong-fan-wei-lcof/"/>
    <url>/2020/12/11/LeetCode-offer-13-ji-qi-ren-de-yun-dong-fan-wei-lcof/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">剑指 Offer 13. 机器人的运动范围</a></p><pre><code class="hljs java"><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];    dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m, n, k, visited, dirs);    <span class="hljs-keyword">return</span> count;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curX, <span class="hljs-keyword">int</span> curY, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">boolean</span>[][] visited, <span class="hljs-keyword">int</span>[][] dirs)</span> </span>&#123;    count++;    <span class="hljs-comment">// 标记访问</span>    visited[curX][curY] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// 四个方向游走</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;        <span class="hljs-keyword">int</span> x = curX + dir[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> y = curY + dir[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (notInArea(x, y, m, n) || visited[x][y] || !canReach(x, y, k)) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        dfs(x, y, m, n, k, visited, dirs);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">notInArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> || x &gt;= m || y &lt; <span class="hljs-number">0</span> || y &gt;= n;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canReach</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">return</span> x / <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span> + y / <span class="hljs-number">10</span> + y % <span class="hljs-number">10</span> &lt;= k;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>剑指 Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 649. Dota2 参议院</title>
    <link href="/2020/12/11/LeetCode-649-dota2-senate/"/>
    <url>/2020/12/11/LeetCode-649-dota2-senate/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/dota2-senate/" target="_blank" rel="noopener">649. Dota2 参议院</a></p><p>需要禁止的是后续最先投票的对方阵营的人。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">predictPartyVictory</span><span class="hljs-params">(String senate)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] senates = senate.toCharArray();    <span class="hljs-keyword">int</span> len = senates.length;    LinkedList&lt;Integer&gt; r = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; d = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-comment">// 从前往后按原始顺序排列</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (senates[i] == <span class="hljs-string">'R'</span>) &#123;            r.addLast(i);        &#125; <span class="hljs-keyword">else</span> &#123;            d.addLast(i);        &#125;    &#125;    <span class="hljs-keyword">while</span> (!r.isEmpty() &amp;&amp; !d.isEmpty()) &#123;        <span class="hljs-comment">// r &lt; d, r 先行使权力</span>        <span class="hljs-keyword">if</span> (r.getFirst() &lt; d.getFirst()) &#123;            <span class="hljs-comment">// 禁止最近的 d</span>            d.removeFirst();            <span class="hljs-comment">// 当前 r 进入最后面</span>            r.addLast(r.pollFirst() + len);        &#125; <span class="hljs-keyword">else</span> &#123;            r.removeFirst();            d.addLast(d.pollFirst() + len);        &#125;    &#125;    <span class="hljs-keyword">return</span> r.isEmpty() ? <span class="hljs-string">"Dire"</span> : <span class="hljs-string">"Radiant"</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 974. 和可被 K 整除的子数组</title>
    <link href="/2020/12/10/LeetCode-974-subarray-sums-divisible-by-k/"/>
    <url>/2020/12/10/LeetCode-974-subarray-sums-divisible-by-k/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/" target="_blank" rel="noopener">974. 和可被 K 整除的子数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraysDivByK</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;    <span class="hljs-comment">// [4,5,0,-2,-3,1], K = 5</span>    <span class="hljs-comment">//  0 4 9  9  7 4 5</span>    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] mods = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[K];    mods[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[] sums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    sums[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        <span class="hljs-comment">//     sums[i] - sums[j] % k == 0</span>        <span class="hljs-comment">// =&gt;  sums[i] % k == sums[j] % k</span>        sums[i] = sums[i - <span class="hljs-number">1</span>] + A[i - <span class="hljs-number">1</span>];        <span class="hljs-comment">// 找到 mod 相等 的出现次数</span>        <span class="hljs-keyword">int</span> targetMod = (sums[i] % K + K) % K;        res += mods[targetMod];        mods[targetMod]++;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1248. 统计「优美子数组」</title>
    <link href="/2020/12/10/LeetCode-1248-count-number-of-nice-subarrays/"/>
    <url>/2020/12/10/LeetCode-1248-count-number-of-nice-subarrays/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></p><h1 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberOfSubarrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// [1,1,2,1,1], k = 3</span>    <span class="hljs-comment">//  1 2 2 3 4</span>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// counts[i]: 包含 i 个奇数的子数组个数</span>    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    counts[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-comment">// nums[i] 的奇数个数</span>        sum += num &amp; <span class="hljs-number">1</span>;        counts[sum]++;        <span class="hljs-comment">// 与 k 个奇数的距离</span>        <span class="hljs-keyword">int</span> target = sum - k;        <span class="hljs-keyword">if</span> (target &gt;= <span class="hljs-number">0</span>) &#123;            res += counts[target];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberOfSubarrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// [2,2,2,1,2,2,1,2,2,2], k = 2</span>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> oddCount = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        oddCount += nums[right] &amp; <span class="hljs-number">1</span>;        right++;        <span class="hljs-comment">// nums[left:right - 1] 有 k 个奇数</span>        <span class="hljs-keyword">if</span> (oddCount == k) &#123;            <span class="hljs-keyword">int</span> start = right;            <span class="hljs-comment">// 向右找偶数</span>            <span class="hljs-keyword">while</span> (right &lt; len &amp;&amp; (nums[right] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;                right++;            &#125;            <span class="hljs-comment">// nums[start:right] 的偶数可以作为子数组的终点</span>            <span class="hljs-keyword">int</span> rightEvenCount = right - start + <span class="hljs-number">1</span>;            <span class="hljs-comment">// 从 left 到 right 找偶数，作为起点</span>            <span class="hljs-keyword">int</span> leftEvenCount = <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> ((nums[left] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;                left++;                leftEvenCount++;            &#125;            res += leftEvenCount * rightEvenCount;            left++;            oddCount--;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 202. 快乐数</title>
    <link href="/2020/12/10/LeetCode-202-happy-number/"/>
    <url>/2020/12/10/LeetCode-202-happy-number/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> slow = n, fast = getNextNum(n);    <span class="hljs-comment">// 快慢指针找环</span>    <span class="hljs-keyword">while</span> (slow != fast) &#123;        slow = getNextNum(slow);        fast = getNextNum(fast);        fast = getNextNum(fast);    &#125;    <span class="hljs-keyword">return</span> slow == <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNextNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> next = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">int</span> digit = n % <span class="hljs-number">10</span>;        next += digit * digit;        n /= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> next;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span> &amp;&amp; !seen.contains(n)) &#123;        seen.add(n);        <span class="hljs-keyword">int</span> next = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> digit = n % <span class="hljs-number">10</span>;            next += digit * digit;            n /= <span class="hljs-number">10</span>;        &#125;        n = next;    &#125;    <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 376. 摆动序列</title>
    <link href="/2020/12/09/LeetCode-376-wiggle-subsequence/"/>
    <url>/2020/12/09/LeetCode-376-wiggle-subsequence/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. 摆动序列</a></p><blockquote><p>艰难的 300</p></blockquote><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201209212401.png" srcset="/img/loading.gif" alt="" /></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-comment">// dp[i][0]: nums[i] - nums[i - 1] &lt; 0，nums[i] 的差为负数</span>    <span class="hljs-comment">// dp[i][1]: nums[i] - nums[i - 1] &gt; 0，nums[i] 的差为正数</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 差为负数</span>        <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// 尝试连在差为正数的前一个数后</span>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);            dp[i][<span class="hljs-number">1</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];        &#125; <span class="hljs-keyword">else</span> &#123;            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];            dp[i][<span class="hljs-number">1</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;&#125;</code></pre><h1 id="贪心"><a class="markdownIt-Anchor" href="#贪心"></a> 贪心</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> preDiff = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 当前差值</span>        <span class="hljs-keyword">int</span> curDiff = nums[i] - nums[i - <span class="hljs-number">1</span>];        <span class="hljs-comment">// 只要找到和 curDiff 不同的 preDiff，就可将 nums[i] 添加到摆动序列</span>        <span class="hljs-keyword">if</span> ((curDiff &gt; <span class="hljs-number">0</span> &amp;&amp; preDiff &lt;= <span class="hljs-number">0</span>) || (curDiff &lt; <span class="hljs-number">0</span> &amp;&amp; preDiff &gt;= <span class="hljs-number">0</span>)) &#123;            res++;            preDiff = curDiff;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-comment">// 以 nums[i] 结尾的最长摆动序列的差</span>    <span class="hljs-keyword">int</span>[] diffs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-comment">// dp[i]: 以 nums[i] 结尾的最长摆动序列</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 去除前面的重复元素</span>    <span class="hljs-keyword">while</span> (i + <span class="hljs-number">1</span> &lt; len &amp;&amp; nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;        i++;    &#125;    <span class="hljs-keyword">int</span> start = i;    dp[start] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 从起点的下一点计算差</span>    i++;    <span class="hljs-keyword">while</span> (i &lt; len) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;            <span class="hljs-keyword">int</span> diff = nums[i] - nums[j];            <span class="hljs-comment">// 摆动 || 到起点</span>            <span class="hljs-keyword">if</span> (diff * diffs[j] &lt; <span class="hljs-number">0</span> || j == start) &#123;                <span class="hljs-keyword">if</span> (dp[j] + <span class="hljs-number">1</span> &gt; dp[i]) &#123;                    dp[i] = dp[j] + <span class="hljs-number">1</span>;                    res = Math.max(res, dp[i]);                    diffs[i] = diff;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        i++;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 842. 将数组拆分成斐波那契序列</title>
    <link href="/2020/12/08/LeetCode-842-split-array-into-fibonacci-sequence/"/>
    <url>/2020/12/08/LeetCode-842-split-array-into-fibonacci-sequence/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/" target="_blank" rel="noopener">842. 将数组拆分成斐波那契序列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">splitIntoFibonacci</span><span class="hljs-params">(String S)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = S.length();    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    backtrack(<span class="hljs-number">0</span>, len, res, S);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> len, List&lt;Integer&gt; path, String s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (start == len &amp;&amp; path.size() &gt;= <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> end = start + <span class="hljs-number">1</span>; end &lt;= len; end++) &#123;        <span class="hljs-comment">// 首位为 0 &amp;&amp; 截取的不止一位，不符合规则</span>        <span class="hljs-keyword">if</span> (s.charAt(start) == <span class="hljs-string">'0'</span> &amp;&amp; end &gt; start + <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">long</span> num = Long.parseLong(s.substring(start, end));        <span class="hljs-keyword">if</span> (num &gt;= Integer.MAX_VALUE) &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">int</span> size = path.size();        <span class="hljs-comment">// num 已经 &gt; 前两个之和，再往后截取会变大</span>        <span class="hljs-keyword">if</span> (size &gt;= <span class="hljs-number">2</span> &amp;&amp; num &gt; path.get(size - <span class="hljs-number">1</span>) + path.get(size - <span class="hljs-number">2</span>)) &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-comment">// 可以组成 Fibonacci</span>        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">1</span> || num == path.get(size - <span class="hljs-number">1</span>) + path.get(size - <span class="hljs-number">2</span>)) &#123;            path.add((<span class="hljs-keyword">int</span>) num);            <span class="hljs-keyword">if</span> (backtrack(end, len, path, s)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            path.remove(path.size() - <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 12. 整数转罗马数字</title>
    <link href="/2020/12/07/LeetCode-12-integer-to-roman/"/>
    <url>/2020/12/07/LeetCode-12-integer-to-roman/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">12. 整数转罗马数字</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] nums = &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;;    String[] romans = &#123;<span class="hljs-string">"M"</span>, <span class="hljs-string">"CM"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"CD"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"XC"</span>, <span class="hljs-string">"L"</span>, <span class="hljs-string">"XL"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"IX"</span>, <span class="hljs-string">"V"</span>, <span class="hljs-string">"IV"</span>, <span class="hljs-string">"I"</span>&#125;;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">int</span> romanNum = nums[i];            <span class="hljs-keyword">if</span> (num - romanNum &gt;= <span class="hljs-number">0</span>) &#123;                sb.append(romans[i]);                num -= romanNum;                <span class="hljs-comment">// 不断使用 i 位置上的数减去 num</span>                start = i;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 861. 翻转矩阵后的得分</title>
    <link href="/2020/12/07/LeetCode-861-score-after-flipping-matrix/"/>
    <url>/2020/12/07/LeetCode-861-score-after-flipping-matrix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/" target="_blank" rel="noopener">861. 翻转矩阵后的得分</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">matrixScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] A)</span> </span>&#123;    <span class="hljs-comment">// [0,0,1,1]     [1,1,1,1]</span>    <span class="hljs-comment">// [1,0,1,0] =&gt;  [1,0,0,1]</span>    <span class="hljs-comment">// [1,1,0,0]     [1,1,1,1]</span>    <span class="hljs-comment">// 要保证结果最大，每列的首位 == 1</span>    <span class="hljs-keyword">int</span> rows = A.length;    <span class="hljs-keyword">int</span> cols = A[<span class="hljs-number">0</span>].length;    <span class="hljs-comment">// 计算每列首位 = 1 时的第一列元素之和</span>    <span class="hljs-keyword">int</span> res = rows * (<span class="hljs-number">1</span> &lt;&lt; (cols - <span class="hljs-number">1</span>));    <span class="hljs-comment">// 按列计算 1 的个数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; cols; j++) &#123;        <span class="hljs-keyword">int</span> ones = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] row : A) &#123;            <span class="hljs-comment">// 该行首位 = 0，需要翻转行</span>            <span class="hljs-keyword">if</span> (row[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;                ones += row[j] ^ <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                ones += row[j];            &#125;        &#125;        <span class="hljs-comment">// ones &lt; zeros，需要翻转列，使 `0` =&gt; `1`</span>        res += Math.max(ones, rows - ones) * (<span class="hljs-number">1</span> &lt;&lt; (cols - j - <span class="hljs-number">1</span>));    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 118. 杨辉三角</title>
    <link href="/2020/12/06/LeetCode-118-pascals-triangle/"/>
    <url>/2020/12/06/LeetCode-118-pascals-triangle/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">118. 杨辉三角</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="hljs-keyword">int</span> numRows) &#123;  List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= numRows; i++) &#123;      List&lt;Integer&gt; row = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(i);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;         <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || j == i - <span class="hljs-number">1</span>) &#123;             row.add(<span class="hljs-number">1</span>);         &#125; <span class="hljs-keyword">else</span> &#123;             row.add(res.get(i - <span class="hljs-number">2</span>).get(j - <span class="hljs-number">1</span>) + res.get(i - <span class="hljs-number">2</span>).get(j));         &#125;      &#125;      res.add(row);  &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 659. 分割数组为连续子序列</title>
    <link href="/2020/12/04/LeetCode-659-split-array-into-consecutive-subsequences/"/>
    <url>/2020/12/04/LeetCode-659-split-array-into-consecutive-subsequences/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/" target="_blank" rel="noopener">659. 分割数组为连续子序列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPossible</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-comment">// 每个数字的出现次数</span>    Map&lt;Integer, Integer&gt; occur = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">// 以 key 结尾的子序列个数</span>    Map&lt;Integer, Integer&gt; tail = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">int</span> count = occur.getOrDefault(num, <span class="hljs-number">0</span>);        occur.put(num, count + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">int</span> numCount = occur.get(num);        <span class="hljs-comment">// num 已经用完</span>        <span class="hljs-keyword">if</span> (numCount &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 是否可以连在前一个数字后面</span>        <span class="hljs-keyword">int</span> prevCount = tail.getOrDefault(num - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (prevCount &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 使用一个 num</span>            occur.put(num, numCount - <span class="hljs-number">1</span>);            <span class="hljs-comment">// num - 1 结尾的子序列 - 1</span>            tail.put(num - <span class="hljs-number">1</span>, prevCount - <span class="hljs-number">1</span>);            <span class="hljs-comment">// num 结尾的子序列 + 1</span>            tail.put(num, tail.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 是否往后可以组成三个连续序列</span>            <span class="hljs-keyword">int</span> next1Count = occur.getOrDefault(num + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);            <span class="hljs-keyword">int</span> next2Count = occur.getOrDefault(num + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span> (next1Count &gt; <span class="hljs-number">0</span> &amp;&amp; next2Count &gt; <span class="hljs-number">0</span>) &#123;                occur.put(num, numCount - <span class="hljs-number">1</span>);                occur.put(num + <span class="hljs-number">1</span>, next1Count - <span class="hljs-number">1</span>);                occur.put(num + <span class="hljs-number">2</span>, next2Count - <span class="hljs-number">1</span>);                tail.put(num + <span class="hljs-number">2</span>, tail.getOrDefault(num + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);            &#125;            <span class="hljs-comment">// 往前往后都不能组成连续序列</span>            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 204. 计数质数</title>
    <link href="/2020/12/03/LeetCode-204-count-primes/"/>
    <url>/2020/12/03/LeetCode-204-count-primes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">204. 计数质数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">boolean</span>[] primes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];    Arrays.fill(primes, <span class="hljs-keyword">true</span>);    <span class="hljs-comment">// [2, sqrt(n)]</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt; n; i++) &#123;        <span class="hljs-keyword">if</span> (primes[i]) &#123;            <span class="hljs-comment">// i 是质数，则 i 的倍数都不是质数</span>            <span class="hljs-comment">// for (int j = i + i; j &lt; n; j += i) &#123;</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt; n; j += i) &#123;                primes[j] = <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">if</span> (primes[i]) &#123;            count++;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 321. 拼接最大数</title>
    <link href="/2020/12/02/LeetCode-321-create-maximum-number/"/>
    <url>/2020/12/02/LeetCode-321-create-maximum-number/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/create-maximum-number/" target="_blank" rel="noopener">321. 拼接最大数</a></p><p><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxNumber(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> k) &#123;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];    <span class="hljs-keyword">int</span> len1 = nums1.length, len2 = nums2.length;    <span class="hljs-comment">// nums1 最多可取 k 个或全部取 (k &gt;= len1)</span>    <span class="hljs-keyword">int</span> end = Math.min(k, len1);    <span class="hljs-comment">// nums1 最少可取 k - len2 个或一个都不取 (k - len2 &lt;= 0)</span>    <span class="hljs-keyword">int</span> start = Math.max(<span class="hljs-number">0</span>, k - len2);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;        <span class="hljs-comment">// 从 nums1 取 i 个，num2 取 k - i 个</span>        <span class="hljs-keyword">int</span>[] subSeq1 = maxSubsequence(nums1, i);        <span class="hljs-keyword">int</span>[] subSeq2 = maxSubsequence(nums2, k - i);        <span class="hljs-comment">// 合并两个子序列</span>        <span class="hljs-keyword">int</span>[] tmp = merge(subSeq1, subSeq2);        <span class="hljs-comment">// 取最终结果</span>        <span class="hljs-keyword">if</span> (compare(tmp, <span class="hljs-number">0</span>, res, <span class="hljs-number">0</span>)) &#123;            System.arraycopy(tmp, <span class="hljs-number">0</span>, res, <span class="hljs-number">0</span>, k);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 合并两个子序列</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> subSeq1</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> subSeq2</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] merge(<span class="hljs-keyword">int</span>[] subSeq1, <span class="hljs-keyword">int</span>[] subSeq2) &#123;    <span class="hljs-keyword">int</span> len1 = subSeq1.length, len2 = subSeq2.length;    <span class="hljs-keyword">int</span> len = len1 + len2;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++) &#123;        <span class="hljs-keyword">if</span> (compare(subSeq1, i, subSeq2, j)) &#123;            res[k] = subSeq1[i++];        &#125; <span class="hljs-keyword">else</span> &#123;            res[k] = subSeq2[j++];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 比较两个数组</span><span class="hljs-comment"> * 对应位置上的元素大的数组更大，否则长度长的那个数组大</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums1</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> start1</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums2</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> start2</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true if nums1 &gt; nums2</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> start1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> start2)</span> </span>&#123;    <span class="hljs-keyword">int</span> len1 = nums1.length, len2 = nums2.length;    <span class="hljs-keyword">while</span> (start1 &lt; len1 &amp;&amp; start2 &lt; len2) &#123;        <span class="hljs-keyword">if</span> (nums1[start1] &gt; nums2[start2]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[start1] &lt; nums2[start2]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            start1++;            start2++;        &#125;    &#125;    <span class="hljs-keyword">return</span> len1 - start1 &gt; len2 - start2;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 求 nums 中 n 个最大子序列</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> n</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] maxSubsequence(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> n) &#123;    <span class="hljs-comment">// 需要删除的位数</span>    <span class="hljs-keyword">int</span> dropNum = nums.length - n;    <span class="hljs-keyword">int</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];    <span class="hljs-comment">// 栈顶元素的位置</span>    <span class="hljs-keyword">int</span> top = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-comment">// 栈顶 &lt; nums[i] &amp;&amp; 可删除，则出栈</span>        <span class="hljs-keyword">while</span> (top &gt;= <span class="hljs-number">0</span> &amp;&amp; dropNum &gt; <span class="hljs-number">0</span> &amp;&amp; stack[top] &lt; num) &#123;            top--;            dropNum--;        &#125;        stack[++top] = num;    &#125;    <span class="hljs-comment">// 删除的位数不够</span>    <span class="hljs-keyword">while</span> (dropNum-- &gt; <span class="hljs-number">0</span>) &#123;        top--;    &#125;    <span class="hljs-comment">// 返回 n 个子序列</span>    <span class="hljs-keyword">return</span> Arrays.copyOfRange(stack, <span class="hljs-number">0</span>, n);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 124. 二叉树中的最大路径和</title>
    <link href="/2020/12/01/LeetCode-124-binary-tree-maximum-path-sum/"/>
    <url>/2020/12/01/LeetCode-124-binary-tree-maximum-path-sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></p><pre><code class="hljs java"><span class="hljs-keyword">int</span> res = Integer.MIN_VALUE;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    dfs(root);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 分别计算左右子树的最大路径和</span>    <span class="hljs-keyword">int</span> leftMax = dfs(root.left);    <span class="hljs-keyword">int</span> rightMax = dfs(root.right);    <span class="hljs-comment">// 计算以 root 为根的子树路径和</span>    res = Math.max(res, leftMax + rightMax + root.val);    <span class="hljs-comment">// 提供给父节点的路径和，若为负数返回 0</span>    <span class="hljs-keyword">int</span> sum = Math.max(leftMax, rightMax) + root.val;    <span class="hljs-keyword">return</span> Math.max(<span class="hljs-number">0</span>, sum);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 646. 最长数对链</title>
    <link href="/2020/12/01/LeetCode-646-maximum-length-of-pair-chain/"/>
    <url>/2020/12/01/LeetCode-646-maximum-length-of-pair-chain/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/" target="_blank" rel="noopener">646. 最长数对链</a></p><p>和 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a> 类似。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLongestChain</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] pairs)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = pairs.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    Arrays.sort(pairs, Comparator.comparingInt(o -&gt; o[<span class="hljs-number">0</span>]));    <span class="hljs-comment">// dp[i]: 以 pairs[i] 结尾的最长数对长度</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;            <span class="hljs-keyword">if</span> (pairs[j][<span class="hljs-number">1</span>] &lt; pairs[i][<span class="hljs-number">0</span>]) &#123;                max = Math.max(max, dp[j] + <span class="hljs-number">1</span>);            &#125;        &#125;        dp[i] = max;        res = Math.max(res, dp[i]);    &#125;    <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 354. 俄罗斯套娃信封问题</title>
    <link href="/2020/12/01/LeetCode-354-russian-doll-envelopes/"/>
    <url>/2020/12/01/LeetCode-354-russian-doll-envelopes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. 俄罗斯套娃信封问题</a></p><p>和 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a> 类似。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] envelopes)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = envelopes.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    Arrays.sort(envelopes, Comparator.comparingInt(o -&gt; o[<span class="hljs-number">0</span>]));    <span class="hljs-comment">// dp[i]: 以第 i 个信封结尾的最大深度</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;            <span class="hljs-comment">// 前面的比 envelopes[i] 小，则可放入</span>            <span class="hljs-keyword">if</span> (envelopes[j][<span class="hljs-number">0</span>] &lt; envelopes[i][<span class="hljs-number">0</span>] &amp;&amp; envelopes[j][<span class="hljs-number">1</span>] &lt; envelopes[i][<span class="hljs-number">1</span>]) &#123;                max = Math.max(max, dp[j] + <span class="hljs-number">1</span>);            &#125;        &#125;        dp[i] = max;        res = Math.max(res, dp[i]);    &#125;    <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 767. 重构字符串</title>
    <link href="/2020/11/30/LeetCode-767-reorganize-string/"/>
    <url>/2020/11/30/LeetCode-767-reorganize-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reorganize-string/" target="_blank" rel="noopener">767. 重构字符串</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reorganizeString</span><span class="hljs-params">(String S)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = S.length();    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">char</span>[] str = S.toCharArray();    <span class="hljs-comment">// 找到出现次数最多的字符</span>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxCharPos = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;        <span class="hljs-keyword">if</span> (++counts[c - <span class="hljs-string">'a'</span>] &gt; max) &#123;            max = counts[c - <span class="hljs-string">'a'</span>];            maxCharPos = c - <span class="hljs-string">'a'</span>;            <span class="hljs-comment">// 出现次数超过一半，无效</span>            <span class="hljs-keyword">if</span> (max &gt; (len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 出现次数最多的字符依次放入偶数位置</span>    <span class="hljs-keyword">while</span> (counts[maxCharPos]-- &gt; <span class="hljs-number">0</span>) &#123;        res[i] = (<span class="hljs-keyword">char</span>) (maxCharPos + <span class="hljs-string">'a'</span>);        i += <span class="hljs-number">2</span>;    &#125;    <span class="hljs-comment">// 其他字符放入奇数位置</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; counts.length; j++) &#123;        <span class="hljs-keyword">while</span> (counts[j]-- &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (i &gt;= len) &#123;                i = <span class="hljs-number">1</span>;            &#125;            res[i] = (<span class="hljs-keyword">char</span>) (j + <span class="hljs-string">'a'</span>);            i += <span class="hljs-number">2</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(res);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 976. 三角形的最大周长</title>
    <link href="/2020/11/29/LeetCode-976-largest-perimeter-triangle/"/>
    <url>/2020/11/29/LeetCode-976-largest-perimeter-triangle/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/" target="_blank" rel="noopener">976. 三角形的最大周长</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestPerimeter</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    quickSort(A, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">if</span> (A[i] &lt; A[i - <span class="hljs-number">1</span>] + A[i - <span class="hljs-number">2</span>]) &#123;            <span class="hljs-keyword">return</span> A[i] + A[i - <span class="hljs-number">1</span>] + A[i - <span class="hljs-number">2</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 454. 四数相加 II</title>
    <link href="/2020/11/27/LeetCode-454-4sum-ii/"/>
    <url>/2020/11/27/LeetCode-454-4sum-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[] B, <span class="hljs-keyword">int</span>[] C, <span class="hljs-keyword">int</span>[] D)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">// 枚举前两个数组的和 的出现次数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value1 : A) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value2 : B) &#123;            <span class="hljs-keyword">int</span> sum = value1 + value2;            <span class="hljs-keyword">int</span> occur = map.getOrDefault(sum, <span class="hljs-number">0</span>);            map.put(sum, occur + <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value3 : C) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value4 : D) &#123;            <span class="hljs-comment">// 需要 value3 + value4 的相反数才能使和 == 0</span>            <span class="hljs-keyword">int</span> require = -(value3 + value4);            <span class="hljs-keyword">int</span> occur = map.getOrDefault(require, <span class="hljs-number">0</span>);            count += occur;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 48. 旋转图像</title>
    <link href="/2020/11/26/LeetCode-48-rotate-image/"/>
    <url>/2020/11/26/LeetCode-48-rotate-image/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">48. 旋转图像</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = matrix.length;    <span class="hljs-comment">// 转置</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// j 从 i 开始</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; len; j++) &#123;            <span class="hljs-keyword">int</span> t = matrix[i][j];            matrix[i][j] = matrix[j][i];            matrix[j][i] = t;        &#125;    &#125;    <span class="hljs-comment">// 翻转每行</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len / <span class="hljs-number">2</span>; j++) &#123;            <span class="hljs-keyword">int</span> t = matrix[i][j];            matrix[i][j] = matrix[i][len - j - <span class="hljs-number">1</span>];            matrix[i][len - j - <span class="hljs-number">1</span>] = t;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 164. 最大间距</title>
    <link href="/2020/11/26/LeetCode-164-maximum-gap/"/>
    <url>/2020/11/26/LeetCode-164-maximum-gap/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-gap/" target="_blank" rel="noopener">164. 最大间距</a></p><h1 id="基数排序"><a class="markdownIt-Anchor" href="#基数排序"></a> 基数排序</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumGap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> max = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;            max = Math.max(max, num);        &#125;        List&lt;List&lt;Integer&gt;&gt; buckets = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            buckets.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());        &#125;        <span class="hljs-keyword">int</span> exp = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (max &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 把数据放入桶</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;                buckets.get(num / exp % <span class="hljs-number">10</span>).add(num);            &#125;            <span class="hljs-comment">// 从桶里取出数据</span>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : bucket) &#123;                    nums[i++] = num;                &#125;                <span class="hljs-comment">// 清空桶，用于下一次排序</span>                bucket.clear();            &#125;            max /= <span class="hljs-number">10</span>;            exp *= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">int</span> res = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            res = Math.max(nums[i] - nums[i - <span class="hljs-number">1</span>], res);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 114. 二叉树展开为链表</title>
    <link href="/2020/11/25/LeetCode-114-flatten-binary-tree-to-linked-list/"/>
    <url>/2020/11/25/LeetCode-114-flatten-binary-tree-to-linked-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    dfs(root);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    TreeNode right = dfs(root.right);    TreeNode left = dfs(root.left);    <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span>) &#123;        TreeNode tail = left;        <span class="hljs-comment">// 找到左子树的尾部</span>        <span class="hljs-keyword">while</span> (tail.right != <span class="hljs-keyword">null</span>) &#123;            tail = tail.right;        &#125;        <span class="hljs-comment">// 连上右子树</span>        tail.right = right;        <span class="hljs-comment">// 左子树连到 root</span>        root.right = left;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 左子树为空，root 直接连 右子树</span>        root.right = right;    &#125;    <span class="hljs-comment">// 左子树断开</span>    root.left = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">return</span> root;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1370. 上升下降字符串</title>
    <link href="/2020/11/25/LeetCode-1370-increasing-decreasing-string/"/>
    <url>/2020/11/25/LeetCode-1370-increasing-decreasing-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/increasing-decreasing-string/" target="_blank" rel="noopener">1370. 上升下降字符串</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sortString</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-keyword">int</span> len = str.length;    <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;        count[c - <span class="hljs-string">'a'</span>]++;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">int</span> used = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (used &lt; len) &#123;        <span class="hljs-comment">// 从前往后取</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;            <span class="hljs-keyword">if</span> (count[i] &gt; <span class="hljs-number">0</span>) &#123;                count[i]--;                used++;                sb.append((<span class="hljs-keyword">char</span>) (i + <span class="hljs-string">'a'</span>));            &#125;        &#125;        <span class="hljs-comment">// 从后往前取</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">25</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">if</span> (count[i] &gt; <span class="hljs-number">0</span>) &#123;                count[i]--;                used++;                sb.append((<span class="hljs-keyword">char</span>) (i + <span class="hljs-string">'a'</span>));            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 394. 字符串解码</title>
    <link href="/2020/11/24/LeetCode-394-decode-string/"/>
    <url>/2020/11/24/LeetCode-394-decode-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decodeString</span><span class="hljs-params">(String s)</span> </span>&#123;    StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();    LinkedList&lt;Integer&gt; numStack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    LinkedList&lt;String&gt; strStack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;        <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;            <span class="hljs-comment">// 更新数字</span>            num = num * <span class="hljs-number">10</span> + c - <span class="hljs-string">'0'</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'['</span>) &#123;            numStack.push(num);            strStack.push(res.toString());            <span class="hljs-comment">// 重新记录 数字 和 字符串</span>            num = <span class="hljs-number">0</span>;            res.setLength(<span class="hljs-number">0</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">']'</span>) &#123;            <span class="hljs-keyword">int</span> k = numStack.pop();            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();            <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">0</span>) &#123;                sb.append(res);            &#125;            <span class="hljs-comment">// 拼接 [...] 子串和原来的串</span>            res = <span class="hljs-keyword">new</span> StringBuilder(strStack.pop() + sb.toString());        &#125; <span class="hljs-keyword">else</span> &#123;            res.append(c);        &#125;    &#125;    <span class="hljs-keyword">return</span> res.toString();&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decodeString</span><span class="hljs-params">(String s)</span> </span>&#123;    LinkedList&lt;String&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-keyword">int</span> len = str.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 3[a2[c]]</span>    <span class="hljs-keyword">while</span> (i &lt; len) &#123;        <span class="hljs-keyword">char</span> c = str[i];        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">']'</span>) &#123;            LinkedList&lt;String&gt; strList = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; !<span class="hljs-string">"["</span>.equals(stack.peekLast())) &#123;                strList.addFirst(stack.pollLast());            &#125;            <span class="hljs-comment">// `[` 出栈</span>            stack.pollLast();            String encodeStr = String.join(<span class="hljs-string">""</span>, strList);            <span class="hljs-comment">// 重复 k 次 [] 内的 字符串</span>            <span class="hljs-keyword">int</span> k = Integer.parseInt(stack.pollLast());            <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">1</span>) &#123;                strList.addFirst(encodeStr);            &#125;            stack.addLast(String.join(<span class="hljs-string">""</span>, strList));            i++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;            <span class="hljs-comment">// 处理是否连续数字</span>            StringBuilder num = <span class="hljs-keyword">new</span> StringBuilder();            <span class="hljs-keyword">while</span> (i &lt; len &amp;&amp; Character.isDigit(str[i])) &#123;                num.append(str[i]);                i++;            &#125;            stack.addLast(num.toString());        &#125; <span class="hljs-keyword">else</span> &#123;            stack.addLast(c + <span class="hljs-string">""</span>);            i++;        &#125;    &#125;    <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">""</span>, stack);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 222. 完全二叉树的节点个数</title>
    <link href="/2020/11/24/LeetCode-222-count-complete-tree-nodes/"/>
    <url>/2020/11/24/LeetCode-222-count-complete-tree-nodes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> leftDepth = countDepth(root.left);    <span class="hljs-keyword">int</span> rightDepth = countDepth(root.right);    <span class="hljs-keyword">if</span> (leftDepth == rightDepth) &#123;        <span class="hljs-comment">// 完全二叉树，左右子树高度相同，则左边一定是满二叉树</span>        <span class="hljs-comment">// 2 ^ leftDepth - 1 + 1 (root) = 2 ^ leftDepth</span>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; leftDepth) + countNodes(root.right);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 右子树比左子树少一层，右边一定是满二叉树</span>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; rightDepth) + countNodes(root.left);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;        depth++;        <span class="hljs-comment">// 完全二叉树叶子节点都在左边</span>        <span class="hljs-comment">// 深度取决于左子树的深度</span>        root = root.left;    &#125;    <span class="hljs-keyword">return</span> depth;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 538. 把二叉搜索树转换为累加树</title>
    <link href="/2020/11/23/LeetCode-538-convert-bst-to-greater-tree/"/>
    <url>/2020/11/23/LeetCode-538-convert-bst-to-greater-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">538. 把二叉搜索树转换为累加树</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    dfs(root, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> sum;    &#125;    sum = dfs(root.right, sum);    <span class="hljs-comment">// System.out.println(sum + " " + root.val);</span>    sum += root.val;    root.val = sum;    sum = dfs(root.left, sum);    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 343. 整数拆分</title>
    <link href="/2020/11/23/LeetCode-343-integer-break/"/>
    <url>/2020/11/23/LeetCode-343-integer-break/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">343. 整数拆分</a></p><p>差一点😭😭😭</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;            dp[i] = Math.max(Math.max(j * (i - j), j * dp[i - j]), dp[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[n];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 452. 用最少数量的箭引爆气球</title>
    <link href="/2020/11/23/LeetCode-452-minimum-number-of-arrows-to-burst-balloons/"/>
    <url>/2020/11/23/LeetCode-452-minimum-number-of-arrows-to-burst-balloons/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. 用最少数量的箭引爆气球</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points)</span> </span>&#123;    <span class="hljs-comment">// 不能用减法来比较 &amp;&amp; 子区间内也要重合</span>    Arrays.sort(points, (o1, o2) -&gt; Integer.compare(o1[<span class="hljs-number">1</span>], o2[<span class="hljs-number">1</span>]));    <span class="hljs-comment">// System.out.println(Arrays.deepToString(points));</span>    <span class="hljs-keyword">int</span> len = points.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; len) &#123;        count++;        <span class="hljs-keyword">int</span> end = points[i][<span class="hljs-number">1</span>];        <span class="hljs-comment">// 比较的是下一个区间</span>        <span class="hljs-keyword">while</span> (i &lt; len - <span class="hljs-number">1</span> &amp;&amp; end &gt;= points[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) &#123;            i++;        &#125;        <span class="hljs-comment">// 确保更新 新的边界</span>        i++;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = points.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-comment">// 按左端点升序</span>    Arrays.sort(points, Comparator.comparingInt(o -&gt; o[<span class="hljs-number">0</span>]));    System.out.println(Arrays.deepToString(points));    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; len) &#123;        count++;        <span class="hljs-keyword">int</span> end = points[i][<span class="hljs-number">1</span>];        <span class="hljs-keyword">while</span> (i &lt; len - <span class="hljs-number">1</span> &amp;&amp; end &gt;= points[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) &#123;            <span class="hljs-comment">// 收缩右端点才能完全覆盖</span>            end = Math.min(end, points[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);            i++;        &#125;        i++;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 148. 排序链表</title>
    <link href="/2020/11/21/LeetCode-148-sort-list/"/>
    <url>/2020/11/21/LeetCode-148-sort-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-comment">// [4,2,1,3]</span>    ListNode slow = head;    ListNode fast = head.next;    <span class="hljs-comment">// 快慢指针找中点</span>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;        slow = slow.next;        fast = fast.next.next;    &#125;    <span class="hljs-comment">// 切分两条链表</span>    ListNode next = slow.next;    slow.next = <span class="hljs-keyword">null</span>;    ListNode left = sortList(head);    ListNode right = sortList(next);    <span class="hljs-comment">// 合并链表</span>    <span class="hljs-keyword">return</span> merge(left, right);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode left, ListNode right)</span> </span>&#123;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    ListNode head = dummy;    <span class="hljs-keyword">while</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (left.val &lt; right.val) &#123;            head.next = left;            left = left.next;        &#125; <span class="hljs-keyword">else</span> &#123;            head.next = right;            right = right.next;        &#125;        head = head.next;    &#125;    <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span>) &#123;        head.next = left;    &#125; <span class="hljs-keyword">else</span> &#123;        head.next = right;    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>排序</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 279. 完全平方数</title>
    <link href="/2020/11/20/LeetCode-279-perfect-squares/"/>
    <url>/2020/11/20/LeetCode-279-perfect-squares/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];    Arrays.fill(dp, Integer.MAX_VALUE);    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-comment">// dp[i]: 组成 i 所需的最少完全平方数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j * j &lt;= i; j++) &#123;            <span class="hljs-keyword">int</span> diff = i - j * j;            dp[i] = Math.min(dp[i], dp[diff] + <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[n];&#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(n);    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>];    visited[n] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        count++;        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> num = queue.poll();            <span class="hljs-comment">// 到达终点</span>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> count - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">// 尝试减去每一个平方数</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= num; i++) &#123;                <span class="hljs-keyword">int</span> diff = num - i * i;                <span class="hljs-keyword">if</span> (!visited[diff]) &#123;                    queue.add(diff);                    visited[diff] = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 147. 对链表进行插入排序</title>
    <link href="/2020/11/20/LeetCode-147-insertion-sort-list/"/>
    <url>/2020/11/20/LeetCode-147-insertion-sort-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank" rel="noopener">147. 对链表进行插入排序</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    dummy.next = head;    <span class="hljs-comment">// 指向以排序的最后一个节点</span>    ListNode tail = head;    <span class="hljs-comment">// 当前需要排序的节点</span>    ListNode cur = head;    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// cur &lt; tail，则 cur 的位置在 tail 之前</span>        <span class="hljs-keyword">if</span> (cur.val &lt; tail.val) &#123;            ListNode p = dummy;            <span class="hljs-comment">// p , p.next 之间插入 cur</span>            <span class="hljs-keyword">while</span> (p.next.val &lt; cur.val) &#123;                p = p.next;            &#125;            tail.next = cur.next;            <span class="hljs-comment">// 插入 cur</span>            cur.next = p.next;            p.next = cur;            <span class="hljs-comment">// 更新 cur</span>            cur = tail.next;        &#125;        <span class="hljs-comment">// cur &gt; tail，则 cur 直接连在 tail 后</span>        <span class="hljs-keyword">else</span> &#123;            tail = cur;            cur = cur.next;        &#125;    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>排序</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 104. 二叉树的最大深度</title>
    <link href="/2020/11/19/LeetCode-104-maximum-depth-of-binary-tree/"/>
    <url>/2020/11/19/LeetCode-104-maximum-depth-of-binary-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> leftDepth = maxDepth(root.left);    <span class="hljs-keyword">int</span> rightDepth = maxDepth(root.right);    <span class="hljs-keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 543. 二叉树的直径</title>
    <link href="/2020/11/19/LeetCode-543-diameter-of-binary-tree/"/>
    <url>/2020/11/19/LeetCode-543-diameter-of-binary-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. 二叉树的直径</a></p><pre><code class="hljs java"><span class="hljs-keyword">int</span> diameter = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    depth(root);    <span class="hljs-keyword">return</span> diameter;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> left = depth(root.left);    <span class="hljs-keyword">int</span> right = depth(root.right);    <span class="hljs-comment">// 更新直径为左右子树的和</span>    diameter = Math.max(diameter, left + right);    <span class="hljs-comment">// System.out.println(root.val + " " + left + " " + right + " " + diameter);</span>    <span class="hljs-keyword">return</span> Math.max(left, right) + <span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 581. 最短无序连续子数组</title>
    <link href="/2020/11/18/LeetCode-581-shortest-unsorted-continuous-subarray/"/>
    <url>/2020/11/18/LeetCode-581-shortest-unsorted-continuous-subarray/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a></p><h1 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] origin = Arrays.copyOf(nums, len);    Arrays.sort(nums);    <span class="hljs-keyword">int</span> left = len, right = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 排序后比较每个位置</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] != origin[i]) &#123;            left = Math.min(left, i);            right = Math.max(right, i);        &#125;    &#125;    <span class="hljs-keyword">return</span> right &lt; left ? <span class="hljs-number">0</span> : right - left + <span class="hljs-number">1</span>;&#125;</code></pre><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> left = len, right = <span class="hljs-number">0</span>;    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-comment">// [2, 6, 4, 8, 10, 9, 15]</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 找降序，则为左起点</span>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &gt; nums[i]) &#123;            left = Math.min(left, stack.pop());        &#125;        stack.push(i);    &#125;    stack.clear();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// 从右往左找升序，则为右起点</span>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i]) &#123;            right = Math.max(right, stack.pop());        &#125;        stack.push(i);    &#125;    <span class="hljs-keyword">return</span> right &lt; left ? <span class="hljs-number">0</span> : right - left + <span class="hljs-number">1</span>;&#125;</code></pre><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> left = len, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> leftMax = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> rightMin = nums[len - <span class="hljs-number">1</span>];    <span class="hljs-comment">// [2, 6, 4, 8, 10, 9, 15]</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 从左往右升序，则更新最大值</span>        <span class="hljs-keyword">if</span> (nums[i] &gt;= leftMax) &#123;            leftMax = nums[i];        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 降序</span>            right = i;        &#125;        <span class="hljs-comment">// 从右往左降序，则更新最小值</span>        <span class="hljs-keyword">if</span> (nums[len - i - <span class="hljs-number">1</span>] &lt;= rightMin) &#123;            rightMin = nums[len - i - <span class="hljs-number">1</span>];        &#125; <span class="hljs-keyword">else</span> &#123;            left = len - i - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> right &lt; left ? <span class="hljs-number">0</span> : right - left + <span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>栈</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 134. 加油站</title>
    <link href="/2020/11/18/LeetCode-134-gas-station/"/>
    <url>/2020/11/18/LeetCode-134-gas-station/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] gas, <span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = gas.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (dfs(i, i, <span class="hljs-number">0</span>, len, gas, cost)) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> volume, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span>[] gas, <span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;    <span class="hljs-comment">// 到达新起点，加油</span>    volume += gas[start];    <span class="hljs-comment">// 前往下一个点</span>    <span class="hljs-keyword">int</span> newVolume = volume - cost[start];    <span class="hljs-comment">// 油不够，无法到达下一个点</span>    <span class="hljs-keyword">if</span> (newVolume &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// 下一个点为终点</span>    <span class="hljs-keyword">int</span> next = (start + <span class="hljs-number">1</span>) % len;    <span class="hljs-keyword">if</span> (next == end) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(next, end, newVolume, len, gas, cost);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 617. 合并二叉树</title>
    <link href="/2020/11/17/LeetCode-617-merge-two-binary-trees/"/>
    <url>/2020/11/17/LeetCode-617-merge-two-binary-trees/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> </span>&#123;    <span class="hljs-keyword">if</span> (t1 == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> t2;    &#125;    <span class="hljs-keyword">if</span> (t2 == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> t1;    &#125;    <span class="hljs-comment">// t1, t2 都不为 null</span>    <span class="hljs-comment">// 合并根节点，左右子树</span>    t1.val += t2.val;    t1.left = mergeTrees(t1.left, t2.left);    t1.right = mergeTrees(t1.right, t2.right);    <span class="hljs-keyword">return</span> t1;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 647. 回文子串</title>
    <link href="/2020/11/17/LeetCode-647-palindromic-substrings/"/>
    <url>/2020/11/17/LeetCode-647-palindromic-substrings/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-keyword">int</span> len = str.length;    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len][len];    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 按列填 dp table</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= j; i++) &#123;            <span class="hljs-comment">// 一个字符</span>            <span class="hljs-keyword">if</span> (i == j) &#123;                dp[i][j] = <span class="hljs-keyword">true</span>;                count++;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j - i == <span class="hljs-number">1</span> &amp;&amp; str[i] == str[j]) &#123;                <span class="hljs-comment">// 两个字符</span>                dp[i][j] = <span class="hljs-keyword">true</span>;                count++;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == str[j] &amp;&amp; dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-comment">// 超过两字符，首尾相同 &amp;&amp; 子串也为回文串</span>                count++;                dp[i][j] = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1030. 距离顺序排列矩阵单元格</title>
    <link href="/2020/11/17/LeetCode-1030-matrix-cells-in-distance-order/"/>
    <url>/2020/11/17/LeetCode-1030-matrix-cells-in-distance-order/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/" target="_blank" rel="noopener">1030. 距离顺序排列矩阵单元格</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] allCellsDistOrder(<span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> C, <span class="hljs-keyword">int</span> r0, <span class="hljs-keyword">int</span> c0) &#123;    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[R * C][<span class="hljs-number">2</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[R][C];    LinkedList&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-comment">// 加入队列</span>    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;r0, c0&#125;);    <span class="hljs-comment">// 标记访问</span>    visited[r0][c0] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// 加入结果集</span>    res[i++] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;r0, c0&#125;;    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span>[] cur = queue.poll();            <span class="hljs-comment">// 四个方向游走</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                <span class="hljs-keyword">int</span> newX = cur[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];                <span class="hljs-keyword">int</span> newY = cur[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span> (!inArea(newX, newY, R, C) || visited[newX][newY]) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                visited[newX][newY] = <span class="hljs-keyword">true</span>;                <span class="hljs-keyword">int</span>[] newPos = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;newX, newY&#125;;                queue.add(newPos);                res[i++] = newPos;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; r &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; c;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 406. 根据身高重建队列</title>
    <link href="/2020/11/16/LeetCode-406-queue-reconstruction-by-height/"/>
    <url>/2020/11/16/LeetCode-406-queue-reconstruction-by-height/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">406. 根据身高重建队列</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] reconstructQueue(<span class="hljs-keyword">int</span>[][] people) &#123;        <span class="hljs-comment">// Arrays.sort(people, (o1, o2) -&gt; o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]);</span>        <span class="hljs-comment">// 从大到小排序</span>        quickSort(people, <span class="hljs-number">0</span>, people.length - <span class="hljs-number">1</span>);        <span class="hljs-comment">// System.out.println(Arrays.deepToString(people));</span>        <span class="hljs-comment">// 依次将 p 插入到对应位置</span>        <span class="hljs-comment">// 未插入的元素比已插入的元素小，不会影响相对位置</span>        LinkedList&lt;<span class="hljs-keyword">int</span>[]&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] p : people) &#123;            list.add(p[<span class="hljs-number">1</span>], p);        &#125;        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()][<span class="hljs-number">2</span>]);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] people, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;        <span class="hljs-keyword">if</span> (low &lt; high) &#123;            <span class="hljs-keyword">int</span> pivotPos = partition(people, low, high);            quickSort(people, low, pivotPos - <span class="hljs-number">1</span>);            quickSort(people, pivotPos + <span class="hljs-number">1</span>, high);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] people, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] pivot = people[low];        <span class="hljs-keyword">while</span> (low &lt; high) &#123;            <span class="hljs-keyword">while</span> (low &lt; high) &#123;                <span class="hljs-keyword">if</span> (people[high][<span class="hljs-number">0</span>] &lt; pivot[<span class="hljs-number">0</span>] || (people[high][<span class="hljs-number">0</span>] == pivot[<span class="hljs-number">0</span>] &amp;&amp; people[high][<span class="hljs-number">1</span>] &gt; pivot[<span class="hljs-number">1</span>])) &#123;                    high--;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            people[low] = people[high];            <span class="hljs-keyword">while</span> (low &lt; high) &#123;                <span class="hljs-keyword">if</span> (people[low][<span class="hljs-number">0</span>] &gt; pivot[<span class="hljs-number">0</span>] || (people[low][<span class="hljs-number">0</span>] == pivot[<span class="hljs-number">0</span>] &amp;&amp; people[low][<span class="hljs-number">1</span>] &lt; pivot[<span class="hljs-number">1</span>])) &#123;                    low++;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            people[high] = people[low];        &#125;        people[low] = pivot;        <span class="hljs-keyword">return</span> low;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 784. 字母大小写全排列</title>
    <link href="/2020/11/14/LeetCode-784-letter-case-permutation/"/>
    <url>/2020/11/14/LeetCode-784-letter-case-permutation/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/letter-case-permutation/" target="_blank" rel="noopener">784. 字母大小写全排列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCasePermutation</span><span class="hljs-params">(String S)</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = S.length();    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">char</span>[] str = S.toCharArray();    <span class="hljs-comment">// 要点：str[i] 可以改变大小写，也可以不改变</span>    backtrack(str, len, <span class="hljs-number">0</span>, res);    res.add(S);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> start, List&lt;String&gt; res)</span> </span>&#123;    <span class="hljs-keyword">if</span> (start == len) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 不改变 str[start] 回溯</span>    backtrack(str, len, start + <span class="hljs-number">1</span>, res);    <span class="hljs-comment">// 改变 str[start] 回溯</span>    <span class="hljs-keyword">if</span> (Character.isLetter(str[start])) &#123;        <span class="hljs-keyword">char</span> oldChar = str[start];        <span class="hljs-keyword">if</span> (Character.isUpperCase(oldChar)) &#123;            <span class="hljs-comment">// 大写 =&gt; 小写</span>            str[start] = Character.toLowerCase(oldChar);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 小写 =&gt; 大写</span>            str[start] = Character.toUpperCase(oldChar);        &#125;        res.add(<span class="hljs-keyword">new</span> String(str));        backtrack(str, len, start + <span class="hljs-number">1</span>, res);        str[start] = oldChar;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 93. 复原IP地址</title>
    <link href="/2020/11/14/LeetCode-93-restore-ip-addresses/"/>
    <url>/2020/11/14/LeetCode-93-restore-ip-addresses/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原IP地址</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(String s)</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">4</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    backtrack(s, len, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(), res);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> start, LinkedList&lt;String&gt; path, List&lt;String&gt; res)</span> </span>&#123;    <span class="hljs-keyword">if</span> (start == len) &#123;        <span class="hljs-comment">// 四个整数才是有效 IP</span>        <span class="hljs-keyword">if</span> (path.size() == <span class="hljs-number">4</span>) &#123;            res.add(String.join(<span class="hljs-string">"."</span>, path));        &#125;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 还没切分完，但是已经切分的数字数目 &gt;= 4，剩下的数字不可切分</span>    <span class="hljs-keyword">if</span> (path.size() &gt;= <span class="hljs-number">4</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (s.charAt(start) == <span class="hljs-string">'0'</span>) &#123;        path.addLast(String.valueOf(s.charAt(start)));        backtrack(s, len, start + <span class="hljs-number">1</span>, path, res);        path.removeLast();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// [0:255] =&gt; 位数：[1:3]</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">int</span> end = start + i;            <span class="hljs-keyword">if</span> (end &gt; len) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            String num = s.substring(start, end);            <span class="hljs-comment">// 超出 255，不是有效 IP</span>            <span class="hljs-keyword">if</span> (Integer.parseInt(num) &gt; <span class="hljs-number">255</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            path.addLast(num);            backtrack(s, len, end, path, res);            path.removeLast();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 328. 奇偶链表</title>
    <link href="/2020/11/13/LeetCode-328-odd-even-linked-list/"/>
    <url>/2020/11/13/LeetCode-328-odd-even-linked-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">328. 奇偶链表</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">// 1 2 3 4 5 6</span>    <span class="hljs-comment">// o e</span>    ListNode odd = head;    ListNode even = head.next;    ListNode evenHead = even;    <span class="hljs-comment">// even 总是连接剩余的节点</span>    <span class="hljs-keyword">while</span> (even != <span class="hljs-keyword">null</span> &amp;&amp; even.next != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 1 -&gt; 3 -&gt; 4...</span>        odd.next = even.next;        <span class="hljs-comment">// odd = 3</span>        odd = odd.next;        <span class="hljs-comment">// 2 -&gt; 4...</span>        even.next = odd.next;        <span class="hljs-comment">// even = 4</span>        even = even.next;    &#125;    odd.next = evenHead;    <span class="hljs-keyword">return</span> head;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 437. 路径总和 III</title>
    <link href="/2020/11/12/LeetCode-437-path-sum-iii/"/>
    <url>/2020/11/12/LeetCode-437-path-sum-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. 路径总和 III</a></p><p>前缀和。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    <span class="hljs-comment">// key: 前缀和，value：该前缀和的出现次数</span>    Map&lt;Integer, Integer&gt; preSums = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">// 前缀和为 0 的路径有一条</span>    preSums.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> backtrack(root, <span class="hljs-number">0</span>, preSums, sum);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> curSum, Map&lt;Integer, Integer&gt; preSums, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 更新当前路径和</span>    curSum += root.val;    <span class="hljs-comment">// curSum - x = sum，计算 x 的出现次数</span>    count += preSums.getOrDefault(curSum - sum, <span class="hljs-number">0</span>);    <span class="hljs-comment">// 将 curSum 放入前缀和</span>    preSums.put(curSum, preSums.getOrDefault(curSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);    <span class="hljs-comment">// 进入下一层</span>    count += backtrack(root.left, curSum, preSums, sum) + backtrack(root.right, curSum, preSums, sum);    <span class="hljs-comment">// 回溯</span>    preSums.put(curSum, preSums.get(curSum) - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> count;&#125;</code></pre><p>以每个节点为根节点依次计算。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> pathSumFrom(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSumFrom</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    sum -= root.val;    <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;        count++;    &#125;    <span class="hljs-keyword">return</span> count + pathSumFrom(root.left, sum) + pathSumFrom(root.right, sum);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 113. 路径总和 II</title>
    <link href="/2020/11/12/LeetCode-113-path-sum-ii/"/>
    <url>/2020/11/12/LeetCode-113-path-sum-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    backtrack(root, sum, path, res);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum, LinkedList&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 添加路径</span>    path.addLast(root.val);    <span class="hljs-comment">// 减去当前节点的值</span>    sum -= root.val;    <span class="hljs-comment">// 终止</span>    <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));    &#125;    backtrack(root.left, sum, path, res);    backtrack(root.right, sum, path, res);    <span class="hljs-comment">// 回溯</span>    path.removeLast();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 922. 按奇偶排序数组 II</title>
    <link href="/2020/11/12/LeetCode-922-sort-array-by-parity-ii/"/>
    <url>/2020/11/12/LeetCode-922-sort-array-by-parity-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/" target="_blank" rel="noopener">922. 按奇偶排序数组 II</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortArrayByParityII(<span class="hljs-keyword">int</span>[] A) &#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (i &lt; len &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 找到不满足的偶数</span>        <span class="hljs-keyword">while</span> (i &lt; len &amp;&amp; A[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;            i += <span class="hljs-number">2</span>;        &#125;        <span class="hljs-comment">// 找到不满足的奇数</span>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; A[j] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;            j -= <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">if</span> (i &lt; len &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;            swap(A, i, j);        &#125;    &#125;    <span class="hljs-keyword">return</span> A;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = a[i];    a[i] = a[j];    a[j] = t;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 905. 按奇偶排序数组</title>
    <link href="/2020/11/12/LeetCode-905-sort-array-by-parity/"/>
    <url>/2020/11/12/LeetCode-905-sort-array-by-parity/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-array-by-parity/" target="_blank" rel="noopener">905. 按奇偶排序数组</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortArrayByParity(<span class="hljs-keyword">int</span>[] A) &#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = A.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (i &lt; j) &#123;        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; A[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;            i++;        &#125;        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; A[j] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;            j--;        &#125;        swap(A, i++, j--);    &#125;    <span class="hljs-keyword">return</span> A;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = a[i];    a[i] = a[j];    a[j] = t;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 60. 排列序列</title>
    <link href="/2020/11/11/LeetCode-60-permutation-sequence/"/>
    <url>/2020/11/11/LeetCode-60-permutation-sequence/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutation-sequence/" target="_blank" rel="noopener">60. 排列序列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span>[] factorial = calcFact(n);    StringBuilder path = <span class="hljs-keyword">new</span> StringBuilder();    dfs(<span class="hljs-number">0</span>, k, n, used, path, factorial);    <span class="hljs-keyword">return</span> path.toString();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> selectedCount, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">boolean</span>[] used, StringBuilder path, <span class="hljs-keyword">int</span>[] factorial)</span> </span>&#123;    <span class="hljs-keyword">if</span> (path.length() == n) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 当前分支的排列数：(总数 - 已选择的个数 - 1)!</span>    <span class="hljs-keyword">int</span> count = factorial[n - selectedCount - <span class="hljs-number">1</span>];    <span class="hljs-comment">// 1, 2, 3, 4, ... , n</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">if</span> (used[i]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 当前分支的排列数 达不到 k 个</span>        <span class="hljs-comment">// 则第 k 个排列一定在后面，跳过当前 i</span>        <span class="hljs-keyword">if</span> (count &lt; k) &#123;            k -= count;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 第 k 个排列 在 i 的分支上</span>        <span class="hljs-comment">// 选择 i 进入递归</span>        used[i] = <span class="hljs-keyword">true</span>;        path.append(i);        dfs(selectedCount + <span class="hljs-number">1</span>, k, n, used, path, factorial);        <span class="hljs-comment">// 后面的数若进行排列已经超出 k，无须遍历</span>        <span class="hljs-keyword">return</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 计算 1...n 的全排列数</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> n</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] calcFact(<span class="hljs-keyword">int</span> n) &#123;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];    res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        res[i] = i * res[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数学</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 90. 子集 II</title>
    <link href="/2020/11/11/LeetCode-90-subsets-ii/"/>
    <url>/2020/11/11/LeetCode-90-subsets-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="hljs-keyword">int</span>[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    Arrays.sort(nums);    backtrack(nums, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(), res);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, LinkedList&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;    res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length; i++) &#123;        <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        path.addLast(nums[i]);        backtrack(nums, i + <span class="hljs-number">1</span>, path, res);        path.removeLast();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 78. 子集</title>
    <link href="/2020/11/11/LeetCode-78-subsets/"/>
    <url>/2020/11/11/LeetCode-78-subsets/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    backtrack(nums, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(), res);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, LinkedList&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;    res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length; i++) &#123;        path.addLast(nums[i]);        backtrack(nums, i + <span class="hljs-number">1</span>, path, res);        path.removeLast();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 2. 两数相加</title>
    <link href="/2020/11/11/LeetCode-2-add-two-numbers/"/>
    <url>/2020/11/11/LeetCode-2-add-two-numbers/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></p><h1 id="新建链表"><a class="markdownIt-Anchor" href="#新建链表"></a> 新建链表</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    ListNode cur = dummy;    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">int</span> x = l1 == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : l1.val;        <span class="hljs-keyword">int</span> y = l2 == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : l2.val;        <span class="hljs-keyword">int</span> sum = x + y + carry;        <span class="hljs-comment">// 进位</span>        carry = sum / <span class="hljs-number">10</span>;        <span class="hljs-comment">// 需要保存的数</span>        sum %= <span class="hljs-number">10</span>;        cur.next = <span class="hljs-keyword">new</span> ListNode(sum);        cur = cur.next;        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-keyword">null</span>) &#123;            l1 = l1.next;        &#125;        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-keyword">null</span>) &#123;            l2 = l2.next;        &#125;    &#125;    <span class="hljs-keyword">if</span> (carry != <span class="hljs-number">0</span>) &#123;        cur.next = <span class="hljs-keyword">new</span> ListNode(carry);    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre><h1 id="使用原链表"><a class="markdownIt-Anchor" href="#使用原链表"></a> 使用原链表</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;    ListNode head = l1;    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        <span class="hljs-keyword">int</span> sum = l1.val + l2.val + carry;        l1.val = sum % <span class="hljs-number">10</span>;        carry = sum / <span class="hljs-number">10</span>;        <span class="hljs-keyword">if</span> (l1.next == <span class="hljs-keyword">null</span> || l2.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        l1 = l1.next;        l2 = l2.next;    &#125;    <span class="hljs-comment">// l2 还有则接到 l1 后面</span>    <span class="hljs-keyword">if</span> (l2.next != <span class="hljs-keyword">null</span>) &#123;        l1.next = l2.next;    &#125;    <span class="hljs-keyword">while</span> (l1.next != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">int</span> sum = l1.next.val + carry;        l1.next.val = sum % <span class="hljs-number">10</span>;        carry = sum / <span class="hljs-number">10</span>;        l1 = l1.next;        <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-comment">// 还有进位</span>    <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;        l1.next = <span class="hljs-keyword">new</span> ListNode(carry);    &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 31. 下一个排列</title>
    <link href="/2020/11/10/LeetCode-31-next-permutation/"/>
    <url>/2020/11/10/LeetCode-31-next-permutation/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 从后往前找第一个升序的位置</span>        <span class="hljs-keyword">int</span> ascPos = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;                ascPos = i;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// ascPos....len - 1 降序</span>        <span class="hljs-comment">// 找到第一个 &gt; nums[ascPos] 的位置，并交换</span>        <span class="hljs-keyword">if</span> (ascPos &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> largePos = binarySearch(nums, ascPos + <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>, nums[ascPos]);            swap(nums, ascPos, largePos);            <span class="hljs-comment">/*for (int i = len - 1; i &gt; ascPos; i--) &#123;</span><span class="hljs-comment">                if (nums[i] &gt; nums[ascPos]) &#123;</span><span class="hljs-comment">                    swap(nums, i, ascPos);</span><span class="hljs-comment">                    break;</span><span class="hljs-comment">                &#125;</span><span class="hljs-comment">            &#125;*/</span>        &#125;        <span class="hljs-comment">// 翻转 [ascPos + 1:len - 1]，使其变为升序</span>        reverse(nums, ascPos + <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;                left = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                right = mid - <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">while</span> (i &lt; j) &#123;            swap(nums, i++, j--);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> t = nums[i];        nums[i] = nums[j];        nums[j] = t;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 77. 组合</title>
    <link href="/2020/11/09/LeetCode-77-combinations/"/>
    <url>/2020/11/09/LeetCode-77-combinations/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    backtrack(<span class="hljs-number">1</span>, n, k, <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(), res);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> k, LinkedList&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;    <span class="hljs-keyword">if</span> (path.size() == k) &#123;        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 还需要搜索 = k - size 个元素</span>    <span class="hljs-comment">// 最后的起点 = n - (k - size) + 1</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin; i &lt;= end - (k - path.size()) + <span class="hljs-number">1</span>; i++) &#123;        path.addLast(i);        backtrack(i + <span class="hljs-number">1</span>, end, k, path, res);        path.removeLast();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 40. 组合总和 II</title>
    <link href="/2020/11/09/LeetCode-40-combination-sum-ii/"/>
    <url>/2020/11/09/LeetCode-40-combination-sum-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = candidates.length;    Arrays.sort(candidates);    backtrack(candidates, <span class="hljs-number">0</span>, len, target, <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(), res);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> target, LinkedList&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;    <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; len; i++) &#123;        <span class="hljs-comment">// start 和 i 重复，start 排列完之后，i 剪枝</span>        <span class="hljs-comment">// i &gt; 0 &amp;&amp; candidates[i - 1] == candidates[i] &amp;&amp; !used[i - 1]</span>        <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i - <span class="hljs-number">1</span>] == candidates[i]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        path.addLast(candidates[i]);        <span class="hljs-comment">// target 每次都减去 candidate[i]，直到 == 0</span>        backtrack(candidates, i + <span class="hljs-number">1</span>, len, target - candidates[i], path, res);        path.removeLast();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 47. 全排列 II</title>
    <link href="/2020/11/09/LeetCode-47-permutations-ii/"/>
    <url>/2020/11/09/LeetCode-47-permutations-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="hljs-keyword">int</span>[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];    <span class="hljs-comment">// 排序，辅助判断重复</span>    Arrays.sort(nums);    backtrack(nums, used, len, <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(), res);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">boolean</span>[] used, <span class="hljs-keyword">int</span> len, LinkedList&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;    <span class="hljs-keyword">if</span> (path.size() == len) &#123;        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (used[i]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 若当前元素和上一元素相同 &amp;&amp; 上一元素未使用</span>        <span class="hljs-comment">// 表示上一元素已经完成排列，当前元素无须再次排列</span>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        used[i] = <span class="hljs-keyword">true</span>;        path.addLast(nums[i]);        backtrack(nums, used, len, path, res);        path.removeLast();        used[i] = <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 46. 全排列</title>
    <link href="/2020/11/09/LeetCode-46-permutations/"/>
    <url>/2020/11/09/LeetCode-46-permutations/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    backtrack(nums, nums.length, <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(), res);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> len, LinkedList&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;    <span class="hljs-keyword">if</span> (path.size() == len) &#123;        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (path.contains(nums[i])) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        path.addLast(nums[i]);        backtrack(nums, len, path, res);        path.removeLast();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 327. 区间和的个数</title>
    <link href="/2020/11/07/LeetCode-327-count-of-range-sum/"/>
    <url>/2020/11/07/LeetCode-327-count-of-range-sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-of-range-sum/" target="_blank" rel="noopener">327. 区间和的个数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countRangeSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">long</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[len + <span class="hljs-number">1</span>];    preSum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-comment">//  0  1   2  3</span>    <span class="hljs-comment">// -2, 5, -1</span>    <span class="hljs-comment">//  0 -2   3  2</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= len; j++) &#123;            <span class="hljs-keyword">long</span> sum = preSum[j] - preSum[i];            <span class="hljs-keyword">if</span> (lower &lt;= sum &amp;&amp; sum &lt;= upper) &#123;                count++;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1356. 根据数字二进制下 1 的数目排序</title>
    <link href="/2020/11/06/LeetCode-1356-sort-integers-by-the-number-of-1-bits/"/>
    <url>/2020/11/06/LeetCode-1356-sort-integers-by-the-number-of-1-bits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/" target="_blank" rel="noopener">1356. 根据数字二进制下 1 的数目排序</a></p><h1 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortByBits(<span class="hljs-keyword">int</span>[] arr) &#123;    <span class="hljs-keyword">int</span> len = arr.length;    Integer[] nums = <span class="hljs-keyword">new</span> Integer[len];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        nums[i] = arr[i];    &#125;    Arrays.sort(nums, (o1, o2) -&gt; &#123;        <span class="hljs-keyword">int</span> count1 = Integer.bitCount(o1);        <span class="hljs-keyword">int</span> count2 = Integer.bitCount(o2);        <span class="hljs-keyword">return</span> count1 == count2 ? o1 - o2 : count1 - count2;    &#125;);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        arr[i] = nums[i];    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><h1 id="优先队列"><a class="markdownIt-Anchor" href="#优先队列"></a> 优先队列</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortByBits(<span class="hljs-keyword">int</span>[] arr) &#123;    <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-comment">// int[2]: 0 -&gt; 1 的个数，1 -&gt; arr[i]</span>    PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="hljs-number">0</span>] == o2[<span class="hljs-number">0</span>] ? o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>] : o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;        <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;countOnes(num), num&#125;;        minHeap.add(map);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        arr[i] = minHeap.poll()[<span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countOnes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123;        num = num &amp; (num - <span class="hljs-number">1</span>);        count++;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 230. 二叉搜索树中第K小的元素</title>
    <link href="/2020/11/06/LeetCode-230-kth-smallest-element-in-a-bst/"/>
    <url>/2020/11/06/LeetCode-230-kth-smallest-element-in-a-bst/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. 二叉搜索树中第K小的元素</a></p><h1 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;            stack.push(root);            root = root.left;        &#125;        TreeNode top = stack.pop();        <span class="hljs-keyword">if</span> (++count == k) &#123;            <span class="hljs-keyword">return</span> top.val;        &#125;        root = top.right;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 226. 翻转二叉树</title>
    <link href="/2020/11/06/LeetCode-226-invert-binary-tree/"/>
    <url>/2020/11/06/LeetCode-226-invert-binary-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    TreeNode tmp = root.left;    root.left = root.right;    root.right = tmp;    invertTree(root.left);    invertTree(root.right);    <span class="hljs-keyword">return</span> root;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 92. 反转链表 II</title>
    <link href="/2020/11/05/LeetCode-92-reverse-linked-list-ii/"/>
    <url>/2020/11/05/LeetCode-92-reverse-linked-list-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    dummy.next = head;    ListNode holder = dummy;    ListNode sentinel = dummy.next;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; left; i++) &#123;        holder = holder.next;        sentinel = sentinel.next;    &#125;    <span class="hljs-comment">// # -&gt; holder -&gt; sentinel -&gt; 3 -&gt; 2 -&gt; 1 -&gt; #</span>    <span class="hljs-comment">// 每次移动 sentinel 后的元素到 holder 后</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt; right; i++) &#123;        ListNode target = sentinel.next;        <span class="hljs-comment">// 取出 target</span>        sentinel.next = target.next;        <span class="hljs-comment">// 将 target 链接到 holder 后</span>        target.next = holder.next;        holder.next = target;    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 206. 反转链表</title>
    <link href="/2020/11/05/LeetCode-206-reverse-linked-list/"/>
    <url>/2020/11/05/LeetCode-206-reverse-linked-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    ListNode pre = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;        ListNode next = head.next;        head.next = pre;        pre = head;        head = next;    &#125;    <span class="hljs-keyword">return</span> pre;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 199. 二叉树的右视图</title>
    <link href="/2020/11/05/LeetCode-199-binary-tree-right-side-view/"/>
    <url>/2020/11/05/LeetCode-199-binary-tree-right-side-view/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(root);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            TreeNode curNode = queue.poll();            <span class="hljs-comment">// 每层的最后一个结点</span>            <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;                res.add(curNode.val);            &#125;            <span class="hljs-keyword">if</span> (curNode.left != <span class="hljs-keyword">null</span>) &#123;                queue.add(curNode.left);            &#125;            <span class="hljs-keyword">if</span> (curNode.right != <span class="hljs-keyword">null</span>) &#123;                queue.add(curNode.right);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    dfs(root, <span class="hljs-number">0</span>, res);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> depth, List&lt;Integer&gt; res)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 当深度 == 保存的最右数目，表示该层的最右结点还没访问过</span>    <span class="hljs-keyword">if</span> (depth == res.size()) &#123;        res.add(root.val);    &#125;    depth++;    <span class="hljs-comment">// 先右后左，保证每次访问的都是最右结点</span>    dfs(root.right, depth, res);    dfs(root.left, depth, res);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 108. 将有序数组转换为二叉搜索树</title>
    <link href="/2020/11/05/LeetCode-108-convert-sorted-array-to-binary-search-tree/"/>
    <url>/2020/11/05/LeetCode-108-convert-sorted-array-to-binary-search-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. 将有序数组转换为二叉搜索树</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">return</span> buildTree(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">if</span> (begin &gt; end) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">int</span> rootIdx = begin + (end - begin + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[rootIdx]);    root.left = buildTree(nums, begin, rootIdx - <span class="hljs-number">1</span>);    root.right = buildTree(nums, rootIdx + <span class="hljs-number">1</span>, end);    <span class="hljs-keyword">return</span> root;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>树</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 109. 有序链表转换二叉搜索树</title>
    <link href="/2020/11/05/LeetCode-109-convert-sorted-list-to-binary-search-tree/"/>
    <url>/2020/11/05/LeetCode-109-convert-sorted-list-to-binary-search-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a></p><h1 id="数组分割"><a class="markdownIt-Anchor" href="#数组分割"></a> 数组分割</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;        list.add(head.val);        head = head.next;    &#125;    <span class="hljs-keyword">return</span> buildTree(list, <span class="hljs-number">0</span>, list.size() - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(List&lt;Integer&gt; list, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">if</span> (begin &gt; end) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">// 找到中点</span>    <span class="hljs-keyword">int</span> rootIdx = begin + (end - begin + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> rootVal = list.get(rootIdx);    System.out.println(rootVal + <span class="hljs-string">" begin: "</span> + begin + <span class="hljs-string">" end: "</span> + end);    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(rootVal);    <span class="hljs-comment">// 划分左右子树</span>    root.left = buildTree(list, begin, rootIdx - <span class="hljs-number">1</span>);    root.right = buildTree(list, rootIdx + <span class="hljs-number">1</span>, end);    <span class="hljs-keyword">return</span> root;&#125;</code></pre><h1 id="快慢指针"><a class="markdownIt-Anchor" href="#快慢指针"></a> 快慢指针</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    ListNode pre = <span class="hljs-keyword">null</span>;    ListNode slow = head;    ListNode fast = head;    <span class="hljs-comment">// 快慢指针结束时，slow 即为 root 对应的值</span>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;        pre = slow;        slow = slow.next;        fast = fast.next.next;    &#125;    <span class="hljs-comment">// head -&gt; ... -&gt; pre    slow -&gt; slow.next</span>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(slow.val);    <span class="hljs-comment">// pre 有值才存在左子树</span>    <span class="hljs-keyword">if</span> (pre != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 切断 pre 和 slow 之前的联系</span>        pre.next = <span class="hljs-keyword">null</span>;        root.left = sortedListToBST(head);    &#125;    root.right = sortedListToBST(slow.next);    <span class="hljs-keyword">return</span> root;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>树</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 106. 从中序与后序遍历序列构造二叉树</title>
    <link href="/2020/11/04/LeetCode-106-construct-binary-tree-from-inorder-and-postorder-traversal/"/>
    <url>/2020/11/04/LeetCode-106-construct-binary-tree-from-inorder-and-postorder-traversal/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;        map.put(inorder[i], i);    &#125;    <span class="hljs-keyword">return</span> build(inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>, map);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> iStart, <span class="hljs-keyword">int</span> iEnd, <span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> pStart, <span class="hljs-keyword">int</span> pEnd, Map&lt;Integer, Integer&gt; map)</span> </span>&#123;    <span class="hljs-keyword">if</span> (iStart &gt; iEnd) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">// 以 后序的终点 作为 root</span>    <span class="hljs-keyword">int</span> rootVal = postorder[pEnd];    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(rootVal);    <span class="hljs-comment">// 划分 root 的左右子树</span>    <span class="hljs-keyword">int</span> rootInOrder = map.get(rootVal);    <span class="hljs-keyword">int</span> leftNodesNum = rootInOrder - iStart;    <span class="hljs-comment">// [9,  3,  15,20,7]</span>    <span class="hljs-comment">// [9,  15,7,20,  3]</span>    root.left = build(inorder, iStart, rootInOrder - <span class="hljs-number">1</span>, postorder, pStart, pStart + leftNodesNum - <span class="hljs-number">1</span>, map);    root.right = build(inorder, rootInOrder + <span class="hljs-number">1</span>, iEnd, postorder, pStart + leftNodesNum, pEnd - <span class="hljs-number">1</span>, map);    <span class="hljs-keyword">return</span> root;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
      <tag>递归</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 57. 插入区间</title>
    <link href="/2020/11/04/LeetCode-57-insert-interval/"/>
    <url>/2020/11/04/LeetCode-57-insert-interval/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">57. 插入区间</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] insert(<span class="hljs-keyword">int</span>[][] intervals, <span class="hljs-keyword">int</span>[] newInterval) &#123;    <span class="hljs-keyword">int</span> len = intervals.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;newInterval&#125;;    &#125;    LinkedList&lt;<span class="hljs-keyword">int</span>[]&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 添加不重叠的区间：newInterval 起点 &gt; start 终点</span>    <span class="hljs-comment">// ...... start</span>    <span class="hljs-comment">//        ....... newInterval</span>    <span class="hljs-keyword">while</span> (start &lt; len &amp;&amp; newInterval[<span class="hljs-number">0</span>] &gt; intervals[start][<span class="hljs-number">1</span>]) &#123;        list.addLast(intervals[start]);        start++;    &#125;    <span class="hljs-comment">// 添加重叠区间：newInterval 终点 &gt;= start 起点</span>    <span class="hljs-comment">// ......  .......    ........</span>    <span class="hljs-comment">//    .................</span>    <span class="hljs-keyword">while</span> (start &lt; len &amp;&amp; intervals[start][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">1</span>]) &#123;        <span class="hljs-comment">// 起点取 min</span>        newInterval[<span class="hljs-number">0</span>] = Math.min(newInterval[<span class="hljs-number">0</span>], intervals[start][<span class="hljs-number">0</span>]);        <span class="hljs-comment">// 终点取 max</span>        newInterval[<span class="hljs-number">1</span>] = Math.max(newInterval[<span class="hljs-number">1</span>], intervals[start][<span class="hljs-number">1</span>]);        start++;    &#125;    <span class="hljs-comment">// 添加合并后的新区间</span>    list.addLast(newInterval);    <span class="hljs-comment">// 添加剩余的不重叠区间</span>    <span class="hljs-keyword">while</span> (start &lt; len) &#123;        list.addLast(intervals[start]);        start++;    &#125;    <span class="hljs-keyword">int</span> size = list.size();    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size][<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;        res[i] = list.get(i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 105. 从前序与中序遍历序列构造二叉树</title>
    <link href="/2020/11/03/LeetCode-105-construct-binary-tree-from-preorder-and-inorder-traversal/"/>
    <url>/2020/11/03/LeetCode-105-construct-binary-tree-from-preorder-and-inorder-traversal/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;    <span class="hljs-comment">// preorder = [3  ,9,  20,15,7]</span>    <span class="hljs-comment">// inorder = [9, 3,  15,20,7]</span>    <span class="hljs-comment">// 缓存 每个结点在 inorder 出现的位置，快速划分左右子树</span>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;        map.put(inorder[i], i);    &#125;    <span class="hljs-keyword">return</span> build(preorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, map);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> pStart, <span class="hljs-keyword">int</span> pEnd, <span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> iStart, <span class="hljs-keyword">int</span> iEnd, Map&lt;Integer, Integer&gt; map)</span> </span>&#123;    <span class="hljs-comment">// 起点 &gt; 终点，不存在结点</span>    <span class="hljs-keyword">if</span> (pStart &gt; pEnd) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">// 每次都以 pStart 构造根节点</span>    <span class="hljs-keyword">int</span> rootVal = preorder[pStart];    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(rootVal);    <span class="hljs-comment">// 以 rootVal 分界，划分左右子树</span>    <span class="hljs-keyword">int</span> rootPosInOrder = map.get(rootVal);    <span class="hljs-keyword">int</span> leftNodesNum = rootPosInOrder - iStart;    <span class="hljs-comment">// 左子树（9）：        [pStart + 1, pStart + leftNodesNum], [iStart, rootPosInOrder - 1]</span>    <span class="hljs-comment">// 右子树（20, 15, 7）：[pStart + leftNodesNum + 1, pEnd],       [rootPosInOrder + 1, iEnd]</span>    root.left = build(preorder, pStart + <span class="hljs-number">1</span>, pStart + leftNodesNum, inorder, iStart, rootPosInOrder - <span class="hljs-number">1</span>, map);    root.right = build(preorder, pStart + leftNodesNum + <span class="hljs-number">1</span>, pEnd, inorder, rootPosInOrder + <span class="hljs-number">1</span>, iEnd, map);    <span class="hljs-keyword">return</span> root;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
      <tag>递归</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 257. 二叉树的所有路径</title>
    <link href="/2020/11/03/LeetCode-257-binary-tree-paths/"/>
    <url>/2020/11/03/LeetCode-257-binary-tree-paths/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. 二叉树的所有路径</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    dfs(root, String.valueOf(root.val), res);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, String path, List&lt;String&gt; res)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 添加当前结点</span>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(path);    sb.append(root.val);    <span class="hljs-comment">// 叶子结点</span>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;        res.add(sb.toString());        <span class="hljs-keyword">return</span>;    &#125;    sb.append(<span class="hljs-string">"-&gt;"</span>);    dfs(root.left, sb.toString(), res);    dfs(root.right, sb.toString(), res);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>树</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 941. 有效的山脉数组</title>
    <link href="/2020/11/03/LeetCode-941-valid-mountain-array/"/>
    <url>/2020/11/03/LeetCode-941-valid-mountain-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-mountain-array/" target="_blank" rel="noopener">941. 有效的山脉数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validMountainArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = len - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 从左往右，i 最多只能到 len - 2，因为要形成山脉</span>    <span class="hljs-keyword">while</span> (i + <span class="hljs-number">1</span> &lt; len &amp;&amp; A[i] &lt; A[i + <span class="hljs-number">1</span>]) &#123;        i++;    &#125;    <span class="hljs-comment">// 从右往左，j 最小只能到 1</span>    <span class="hljs-keyword">while</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; A[j] &lt; A[j- <span class="hljs-number">1</span>]) &#123;        j--;    &#125;    <span class="hljs-keyword">return</span> i &lt; len - <span class="hljs-number">1</span> &amp;&amp; j &gt; <span class="hljs-number">0</span> &amp;&amp; i == j;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 39. 组合总和</title>
    <link href="/2020/11/02/LeetCode-39-combination-sum/"/>
    <url>/2020/11/02/LeetCode-39-combination-sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    backtrack(candidates, <span class="hljs-number">0</span>, candidates.length, target, <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(), res);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> target, LinkedList&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;    <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; len; i++) &#123;        path.addLast(candidates[i]);        <span class="hljs-comment">// target 每次都减去 candidate[i]，直到 == 0</span>        backtrack(candidates, i, len, target - candidates[i], path, res);        path.removeLast();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 296. 划分数组为连续数字的集合</title>
    <link href="/2020/11/02/LeetCode-296-divide-array-in-sets-of-k-consecutive-numbers/"/>
    <url>/2020/11/02/LeetCode-296-divide-array-in-sets-of-k-consecutive-numbers/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/" target="_blank" rel="noopener">296. 划分数组为连续数字的集合</a></p><h1 id="优先队列"><a class="markdownIt-Anchor" href="#优先队列"></a> 优先队列</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPossibleDivide</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len % k != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        minHeap.add(num);    &#125;    <span class="hljs-keyword">while</span> (!minHeap.isEmpty()) &#123;        <span class="hljs-keyword">int</span> top = minHeap.poll();        <span class="hljs-comment">// 需要移除的元素： i + 1, i + 2, ... i + k - 1</span>        <span class="hljs-comment">// 如果移除失败则说明无法划分</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; k; i++) &#123;            <span class="hljs-keyword">if</span> (!minHeap.remove(i + top)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h1 id="哈希计数"><a class="markdownIt-Anchor" href="#哈希计数"></a> 哈希计数</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPossibleDivide</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len % k != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    Map&lt;Integer, Integer&gt; occur = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">int</span> count = occur.getOrDefault(num, <span class="hljs-number">0</span>);        occur.put(num, count + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">int</span> batch = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> batchCount = len / k;    Arrays.sort(nums);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> start : nums) &#123;        <span class="hljs-keyword">int</span> startCount = occur.getOrDefault(start, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (startCount == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 更新 start 的出现次数</span>        occur.put(start, startCount - <span class="hljs-number">1</span>);        <span class="hljs-comment">// 取 [start : start + k - 1]</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; k; i++) &#123;            <span class="hljs-keyword">int</span> next = start + i;            <span class="hljs-keyword">int</span> expectCount = occur.getOrDefault(next, <span class="hljs-number">0</span>);            <span class="hljs-comment">// 不出现 || 次数不够</span>            <span class="hljs-keyword">if</span> (expectCount == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 删除一个 next</span>            occur.put(next, expectCount - <span class="hljs-number">1</span>);        &#125;        batch++;        <span class="hljs-keyword">if</span> (batch == batchCount) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 973. 最接近原点的 K 个点</title>
    <link href="/2020/11/02/LeetCode-973-k-closest-points-to-origin/"/>
    <url>/2020/11/02/LeetCode-973-k-closest-points-to-origin/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. 最接近原点的 K 个点</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] kClosest(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> K) &#123;    PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2[<span class="hljs-number">0</span>] * o2[<span class="hljs-number">0</span>] + o2[<span class="hljs-number">1</span>] * o2[<span class="hljs-number">1</span>] - o1[<span class="hljs-number">0</span>] * o1[<span class="hljs-number">0</span>] - o1[<span class="hljs-number">1</span>] * o1[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[K][<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] point : points) &#123;        minHeap.add(point);        <span class="hljs-keyword">if</span> (minHeap.size() &gt; K) &#123;            minHeap.poll();        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; K; i++) &#123;        res[i] = minHeap.poll();    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 140. 单词拆分 II</title>
    <link href="/2020/11/01/LeetCode-140-word-break-ii/"/>
    <url>/2020/11/01/LeetCode-140-word-break-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-break-ii/" target="_blank" rel="noopener">140. 单词拆分 II</a></p><h1 id="动态规划-回溯"><a class="markdownIt-Anchor" href="#动态规划-回溯"></a> 动态规划 + 回溯</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = s.length();    Set&lt;String&gt; dict = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordDict);    <span class="hljs-comment">// dp[i] : s[0:i-1] 可拆分</span>    <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;            String suffix = s.substring(j, i);            <span class="hljs-comment">// 0...j...i</span>            <span class="hljs-comment">// dp[i] = dp[j] &amp;&amp; s[j:i] in dict</span>            <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; dict.contains(suffix)) &#123;                dp[i] = <span class="hljs-keyword">true</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (dp[len]) &#123;        ArrayDeque&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        backtrack(len, dp, path, s, dict, res);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len, <span class="hljs-keyword">boolean</span>[] dp, ArrayDeque&lt;String&gt; path, String s, Set&lt;String&gt; dict, List&lt;String&gt; res)</span> </span>&#123;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        res.add(String.join(<span class="hljs-string">" "</span>, path));        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        String suffix = s.substring(i, len);        <span class="hljs-comment">// 0....i...len</span>        <span class="hljs-comment">// s[i:len] in dict &amp;&amp; dp[i] 可拆分</span>        <span class="hljs-keyword">if</span> (dp[i] &amp;&amp; dict.contains(suffix)) &#123;            <span class="hljs-comment">// 后缀往后放</span>            path.addFirst(suffix);            backtrack(i, dp, path, s, dict, res);            path.removeFirst();        &#125;    &#125;&#125;</code></pre><h1 id="回溯-记忆化"><a class="markdownIt-Anchor" href="#回溯-记忆化"></a> 回溯 + 记忆化</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = s.length();        Set&lt;String&gt; dict = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordDict);        Map&lt;Integer, List&lt;String&gt;&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">return</span> backtrack(<span class="hljs-number">0</span>, len, s, dict, cache);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> len, String s, Set&lt;String&gt; dict, Map&lt;Integer, List&lt;String&gt;&gt; cache)</span> </span>&#123;        <span class="hljs-comment">// 从 start 开始形成的路径</span>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (start == len) &#123;            <span class="hljs-comment">// "" 标记可以到达终点</span>            res.add(<span class="hljs-string">""</span>);            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-keyword">if</span> (cache.containsKey(start)) &#123;            <span class="hljs-keyword">return</span> cache.get(start);        &#125;        <span class="hljs-comment">// start....i....len</span>        <span class="hljs-comment">// "catsanddog"</span>        <span class="hljs-comment">// ["cat","cats","and","sand","dog"]</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;            String prefix = s.substring(start, i);            <span class="hljs-keyword">if</span> (dict.contains(prefix)) &#123;                <span class="hljs-comment">// 从 i 开始形成的路径</span>                List&lt;String&gt; rest = backtrack(i, len, s, dict, cache);                System.out.println(prefix + <span class="hljs-string">" "</span> + rest);                <span class="hljs-keyword">for</span> (String path : rest) &#123;                    <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(path)) &#123;                        res.add(prefix);                    &#125; <span class="hljs-keyword">else</span> &#123;                        res.add(prefix + <span class="hljs-string">" "</span> + path);                    &#125;                &#125;            &#125;        &#125;        cache.put(start, res);        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 139. 单词拆分</title>
    <link href="/2020/11/01/LeetCode-139-word-break/"/>
    <url>/2020/11/01/LeetCode-139-word-break/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></p><h1 id="记忆化搜索"><a class="markdownIt-Anchor" href="#记忆化搜索"></a> 记忆化搜索</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;    <span class="hljs-comment">// s = "leetcode", wordDict = ["leet", "code"]</span>    Set&lt;String&gt; wordSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordDict);    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-comment">// 记忆化搜索，保存 start 对应的结果</span>    Map&lt;Integer, Boolean&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">return</span> backtrack(<span class="hljs-number">0</span>, len, s, wordSet, cache);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> len, String s, Set&lt;String&gt; wordSet, Map&lt;Integer, Boolean&gt; cache)</span> </span>&#123;    <span class="hljs-comment">// 字符串全部找到</span>    <span class="hljs-keyword">if</span> (start == len) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span> (cache.containsKey(start)) &#123;        <span class="hljs-keyword">return</span> cache.get(start);    &#125;    <span class="hljs-comment">// 从 start 开始尝试获取前缀</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        String prefix = s.substring(start, i);        <span class="hljs-comment">// s[start:i] 若在 wordSet 中出现，则找下一个位置</span>        <span class="hljs-keyword">if</span> (wordSet.contains(prefix)) &#123;            <span class="hljs-keyword">if</span> (backtrack(i, len, s, wordSet, cache)) &#123;                cache.put(i, <span class="hljs-keyword">true</span>);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                cache.put(i, <span class="hljs-keyword">false</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;    <span class="hljs-comment">// s = "leetcode", wordDict = ["leet", "code"]</span>    Set&lt;String&gt; wordSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordDict);    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len + <span class="hljs-number">1</span>];    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(<span class="hljs-number">0</span>);    visited[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-keyword">int</span> start = queue.poll();        <span class="hljs-keyword">if</span> (start == len) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> end = start + <span class="hljs-number">1</span>; end &lt;= len; end++) &#123;            String prefix = s.substring(start, end);            <span class="hljs-comment">// s[start:end] 是有效前缀，则下次可以从 end 开始搜索</span>            <span class="hljs-keyword">if</span> (wordSet.contains(prefix) &amp;&amp; !visited[end]) &#123;                visited[end] = <span class="hljs-keyword">true</span>;                queue.add(end);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;    <span class="hljs-comment">// s = "leetcode", wordDict = ["leet", "code"]</span>    Set&lt;String&gt; wordSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordDict);    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-comment">// dp[i]: s[0:i-1] 是否能拆分</span>    <span class="hljs-comment">// dp[i] = dp[i - 1] == true &amp;&amp; s[i:len] 在 wordDict 中</span>    <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;            String suffix = s.substring(j, i);            <span class="hljs-comment">// s[0:j - 1] 可拆分 &amp;&amp; s[j:i] 在 dict 中</span>            <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(suffix)) &#123;                dp[i] = <span class="hljs-keyword">true</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[len];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 381. O(1) 时间插入、删除和获取随机元素 - 允许重复</title>
    <link href="/2020/10/31/LeetCode-381-insert-delete-getrandom-o1-duplicates-allowed/"/>
    <url>/2020/10/31/LeetCode-381-insert-delete-getrandom-o1-duplicates-allowed/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/" target="_blank" rel="noopener">381. O(1) 时间插入、删除和获取随机元素 - 允许重复</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomizedCollection</span> </span>&#123;    List&lt;Integer&gt; nums;    Map&lt;Integer, Set&lt;Integer&gt;&gt; numsIdx;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RandomizedCollection</span><span class="hljs-params">()</span> </span>&#123;        nums = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        numsIdx = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Inserts a value to the collection. Returns true if the collection did not already contain the specified element.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;        nums.add(val);        Set&lt;Integer&gt; idxSet = numsIdx.getOrDefault(val, <span class="hljs-keyword">new</span> HashSet&lt;&gt;());        <span class="hljs-comment">// 新增元素在 list 末尾</span>        idxSet.add(nums.size() - <span class="hljs-number">1</span>);        numsIdx.put(val, idxSet);        <span class="hljs-comment">// size == 1 说明第一次出现 val</span>        <span class="hljs-keyword">return</span> idxSet.size() == <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Removes a value from the collection. Returns true if the collection contained the specified element.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!numsIdx.containsKey(val)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        Iterator&lt;Integer&gt; iterator = numsIdx.get(val).iterator();        <span class="hljs-comment">// 获取 val 的其中一个位置</span>        <span class="hljs-keyword">int</span> valIdx = iterator.next();        <span class="hljs-comment">// 最后一个元素位置</span>        <span class="hljs-keyword">int</span> lastPos = nums.size() - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 要删除的元素正好在末尾</span>        <span class="hljs-keyword">if</span> (valIdx == lastPos) &#123;            numsIdx.get(val).remove(valIdx);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> tail = nums.get(lastPos);            <span class="hljs-comment">// O(1): 把 tail 设置到 val 的位置，然后删除 tail</span>            nums.set(valIdx, tail);            <span class="hljs-comment">// 删除 val 的原始索引</span>            numsIdx.get(val).remove(valIdx);            <span class="hljs-comment">// 更新 tail 的索引信息</span>            numsIdx.get(tail).remove(lastPos);            numsIdx.get(tail).add(valIdx);        &#125;        <span class="hljs-comment">// 删除最后一个元素</span>        nums.remove(lastPos);        <span class="hljs-comment">// 原来的 list 里 val 只出现了一次，删除后则出现 0 次</span>        <span class="hljs-keyword">if</span> (numsIdx.get(val).size() == <span class="hljs-number">0</span>) &#123;            numsIdx.remove(val);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get a random element from the collection.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> idx = (<span class="hljs-keyword">int</span>)(Math.random() * nums.size());        <span class="hljs-keyword">return</span> nums.get(idx);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 703. 数据流中的第 K 大元素</title>
    <link href="/2020/10/30/LeetCode-703-kth-largest-element-in-a-stream/"/>
    <url>/2020/10/30/LeetCode-703-kth-largest-element-in-a-stream/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">703. 数据流中的第 K 大元素</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KthLargest</span> </span>&#123;        <span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> k;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;            <span class="hljs-keyword">this</span>.k = k;            <span class="hljs-keyword">this</span>.minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;                minHeap.add(num);            &#125;            <span class="hljs-comment">// 使堆中只存在 k 个元素，则堆顶为第 k 大的元素</span>            <span class="hljs-keyword">while</span> (minHeap.size() &gt; k) &#123;                minHeap.poll();            &#125;        &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;            minHeap.add(val);            <span class="hljs-keyword">if</span> (minHeap.size() &gt; k) &#123;                minHeap.poll();            &#125;            <span class="hljs-keyword">return</span> minHeap.peek();        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 347. 前 K 个高频元素</title>
    <link href="/2020/10/30/LeetCode-347-top-k-frequent-elements/"/>
    <url>/2020/10/30/LeetCode-347-top-k-frequent-elements/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. 前 K 个高频元素</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]);    <span class="hljs-comment">// 统计每个元素出现次数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">int</span> occur = map.getOrDefault(num, <span class="hljs-number">0</span>);        map.put(num, occur + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// 维护 size = k 的最小堆</span>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;        minHeap.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);        <span class="hljs-keyword">if</span> (minHeap.size() &gt; k) &#123;            minHeap.poll();        &#125;    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;        res[i] = minHeap.poll()[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 295. 数据流的中位数</title>
    <link href="/2020/10/30/LeetCode-295-find-median-from-data-stream/"/>
    <url>/2020/10/30/LeetCode-295-find-median-from-data-stream/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></p><p><a href="https://leetcode-cn.com/problems/sliding-window-median/" target="_blank" rel="noopener">480. 滑动窗口中位数</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 总的数据个数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> count;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 左边保存大顶堆，奇数时中位数即堆顶</span><span class="hljs-comment">     */</span>    PriorityQueue&lt;Integer&gt; maxHeap;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 右边保存小顶堆，偶数时，取堆顶求均值</span><span class="hljs-comment">     */</span>    PriorityQueue&lt;Integer&gt; minHeap;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;        count = <span class="hljs-number">0</span>;        maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);        minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        count++;        <span class="hljs-comment">// 1 2 3    4 5</span>        <span class="hljs-comment">// 1 2 3    4 5 6</span>        <span class="hljs-comment">// 大顶堆的堆顶 &lt;= 小顶堆堆顶，</span>        <span class="hljs-comment">// 所以要取大的值加入小顶堆，小的值加入大顶堆</span>        maxHeap.add(num);        minHeap.add(maxHeap.poll());        <span class="hljs-comment">// 当总数为奇数时，大顶堆比小顶堆多一个元素</span>        <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;            maxHeap.add(minHeap.poll());        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>) (maxHeap.peek() + minHeap.peek()) / <span class="hljs-number">2</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>) maxHeap.peek();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 463. 岛屿的周长</title>
    <link href="/2020/10/30/LeetCode-463-island-perimeter/"/>
    <url>/2020/10/30/LeetCode-463-island-perimeter/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/island-perimeter/" target="_blank" rel="noopener">463. 岛屿的周长</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">islandPerimeter</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = grid.length;    <span class="hljs-keyword">int</span> cols = grid[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> backtrack(i, j, rows, cols, grid);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;    <span class="hljs-comment">// 越界 || 水面</span>    <span class="hljs-keyword">if</span> (!inArea(i, j, rows, cols) || grid[i][j] == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 已经遍历过</span>    <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    grid[i][j] = <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 四个方向遍历</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;        res += backtrack(i + dir[<span class="hljs-number">0</span>], j + dir[<span class="hljs-number">1</span>], rows, cols, grid);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;&#125;</code></pre><h1 id="遍历计算"><a class="markdownIt-Anchor" href="#遍历计算"></a> 遍历计算</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">islandPerimeter</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = grid.length;    <span class="hljs-keyword">int</span> cols = grid[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            res += <span class="hljs-number">4</span>;            <span class="hljs-comment">// 左边为陆地</span>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;                res -= <span class="hljs-number">2</span>;            &#125;            <span class="hljs-comment">// 上边为陆地</span>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) &#123;                res -= <span class="hljs-number">2</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 112. 路径总和</title>
    <link href="/2020/10/29/LeetCode-112-path-sum/"/>
    <url>/2020/10/29/LeetCode-112-path-sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> root.val == sum;    &#125;    <span class="hljs-keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> hasPath = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    getSum(root, root.val, sum);    <span class="hljs-keyword">return</span> hasPath;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (sum == target) &#123;            hasPath = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;        sum += root.left.val;        getSum(root.left, sum, target);        sum -= root.left.val;    &#125;    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;        sum += root.right.val;        getSum(root.right, sum, target);        sum -= root.right.val;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>树</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 129. 求根到叶子节点数字之和</title>
    <link href="/2020/10/29/LeetCode-129-sum-root-to-leaf-numbers/"/>
    <url>/2020/10/29/LeetCode-129-sum-root-to-leaf-numbers/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. 求根到叶子节点数字之和</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">return</span> preOrder(root, <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    sum = sum * <span class="hljs-number">10</span> + root.val;    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> sum;    &#125;    <span class="hljs-keyword">return</span> preOrder(root.left, sum) + preOrder(root.right, sum);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    List&lt;List&lt;TreeNode&gt;&gt; paths = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    List&lt;TreeNode&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    path.add(root);    preOrder(root, path, paths);    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (List&lt;TreeNode&gt; p : paths) &#123;        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (TreeNode node : p) &#123;            num = num * <span class="hljs-number">10</span> + node.val;        &#125;        res += num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root, List&lt;TreeNode&gt; path, List&lt;List&lt;TreeNode&gt;&gt; paths)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;        paths.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;        path.add(root.left);        preOrder(root.left, path, paths);        path.remove(root.left);    &#125;    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;        path.add(root.right);        preOrder(root.right, path, paths);        path.remove(root.right);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>树</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 220. 存在重复元素 III</title>
    <link href="/2020/10/29/LeetCode-220-contains-duplicate-iii/"/>
    <url>/2020/10/29/LeetCode-220-contains-duplicate-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. 存在重复元素 III</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> t)</span> </span>&#123;    TreeSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;        <span class="hljs-comment">// |nums[i] - nums[j]| &lt;= t</span>        <span class="hljs-comment">// nums[i] - nums[j] &lt;= t or nums[i] - nums[j] &gt;= -t</span>        <span class="hljs-comment">// nums[i] &lt;= nums[j] + t and nums[i] &gt;= nums[j] - t</span>        Long bound = set.ceiling((<span class="hljs-keyword">long</span>) nums[i] - (<span class="hljs-keyword">long</span>) t);        <span class="hljs-keyword">if</span> (bound != <span class="hljs-keyword">null</span> &amp;&amp; bound &lt;= (<span class="hljs-keyword">long</span>) nums[i] + (<span class="hljs-keyword">long</span>) t) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        set.add((<span class="hljs-keyword">long</span>) nums[i]);        <span class="hljs-comment">// 保持窗口大小 = k</span>        <span class="hljs-keyword">if</span> (set.size() &gt; k) &#123;            set.remove((<span class="hljs-keyword">long</span>) nums[i - k]);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1552. 两球之间的磁力</title>
    <link href="/2020/10/29/LeetCode-1552-magnetic-force-between-two-balls/"/>
    <url>/2020/10/29/LeetCode-1552-magnetic-force-between-two-balls/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/" target="_blank" rel="noopener">1552. 两球之间的磁力</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] position, <span class="hljs-keyword">int</span> m)</span> </span>&#123;    <span class="hljs-comment">// distance in [1, max - min]</span>    <span class="hljs-keyword">int</span> len = position.length;    Arrays.sort(position);    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = (position[len - <span class="hljs-number">1</span>] - position[<span class="hljs-number">0</span>]) / (m - <span class="hljs-number">1</span>);    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> numOfBalls = calcBallsByDistance(position, mid);        System.out.println(mid + <span class="hljs-string">" "</span> + numOfBalls);        <span class="hljs-keyword">if</span> (numOfBalls &gt;= m) &#123;            left = mid;            <span class="hljs-comment">// 球的个数太少，需要增加球，此时应该减小距离</span>        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 以最小距离 distance 来切分数组</span><span class="hljs-comment"> * 获取球的个数</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> position</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> minDistance</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calcBallsByDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] position, <span class="hljs-keyword">int</span> minDistance)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> distance = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; position.length; i++) &#123;        distance += position[i] - position[i - <span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (distance &gt;= minDistance) &#123;            count++;            distance = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 219. 存在重复元素 II</title>
    <link href="/2020/10/28/LeetCode-219-contains-duplicate-ii/"/>
    <url>/2020/10/28/LeetCode-219-contains-duplicate-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219. 存在重复元素 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (map.containsKey(nums[i])) &#123;            <span class="hljs-keyword">int</span> idx = map.get(nums[i]);            <span class="hljs-keyword">if</span> (Math.abs(idx - i) &lt;= k) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        map.put(nums[i], i);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 23. 合并K个升序链表</title>
    <link href="/2020/10/28/LeetCode-23-merge-k-sorted-lists/"/>
    <url>/2020/10/28/LeetCode-23-merge-k-sorted-lists/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个升序链表</a></p><h1 id="小顶堆"><a class="markdownIt-Anchor" href="#小顶堆"></a> 小顶堆</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;     ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);     ListNode tail = dummy;     PriorityQueue&lt;ListNode&gt; minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o.val));     <span class="hljs-keyword">for</span> (ListNode list : lists) &#123;         <span class="hljs-comment">// 每个节点放入小顶堆中</span>         <span class="hljs-keyword">while</span> (list != <span class="hljs-keyword">null</span>) &#123;             ListNode head = list;             minHeap.add(head);             list = list.next;             head.next = <span class="hljs-keyword">null</span>;         &#125;     &#125;     <span class="hljs-keyword">while</span> (!minHeap.isEmpty()) &#123;         tail.next = minHeap.poll();         tail = tail.next;     &#125;     <span class="hljs-keyword">return</span> dummy.next; &#125;</code></pre><h1 id="k-个指针后移"><a class="markdownIt-Anchor" href="#k-个指针后移"></a> K 个指针后移</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = lists.length;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    ListNode tail = dummy;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        <span class="hljs-comment">// 每次找到 lists 中最小的结点</span>        ListNode minNode = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 最小结点对应在 lists 中的位置</span>        <span class="hljs-keyword">int</span> minIdx = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (lists[i] == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 每次都比较头结点</span>            <span class="hljs-keyword">if</span> (minNode == <span class="hljs-keyword">null</span> || lists[i].val &lt; minNode.val) &#123;                minNode = lists[i];                minIdx = i;            &#125;        &#125;        <span class="hljs-keyword">if</span> (minIdx == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        tail.next = minNode;        tail = tail.next;        <span class="hljs-comment">// 移动头结点：把本次最小的那条链表后移</span>        lists[minIdx] = lists[minIdx].next;    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre><h1 id="两两合并"><a class="markdownIt-Anchor" href="#两两合并"></a> 两两合并</h1><p>大的合并小的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;    ListNode head = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">for</span> (ListNode node : lists) &#123;        head = merge2Lists(head, node);    &#125;    <span class="hljs-keyword">return</span> head;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">merge2Lists</span><span class="hljs-params">(ListNode node1, ListNode node2)</span> </span>&#123;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    ListNode tail = dummy;    <span class="hljs-keyword">while</span> (node1 != <span class="hljs-keyword">null</span> &amp;&amp; node2 != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (node1.val &lt; node2.val) &#123;            tail.next = node1;            node1 = node1.next;        &#125; <span class="hljs-keyword">else</span> &#123;            tail.next = node2;            node2 = node2.next;        &#125;        tail = tail.next;    &#125;    tail.next = node1 == <span class="hljs-keyword">null</span> ? node2 : node1;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre><p>两两合并，小的合成大的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = lists.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">// 合并完成后的链表数</span>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span> (i == len - <span class="hljs-number">1</span>) &#123;                lists[idx] = lists[i];            &#125; <span class="hljs-keyword">else</span> &#123;                lists[idx] = merge2Lists(lists[i], lists[i + <span class="hljs-number">1</span>]);            &#125;            idx++;        &#125;        <span class="hljs-comment">// 对合并完成后的 idx 条链表再合并，直到合成一条</span>        len = idx;    &#125;    <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>优先队列</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1306. 跳跃游戏 III</title>
    <link href="/2020/10/28/LeetCode-1306-jump-game-iii/"/>
    <url>/2020/10/28/LeetCode-1306-jump-game-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jump-game-iii/" target="_blank" rel="noopener">1306. 跳跃游戏 III</a></p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canReach</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(start);    visited[start] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-keyword">int</span> curPos = queue.poll();        <span class="hljs-keyword">if</span> (arr[curPos] == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 向前后搜索</span>        <span class="hljs-keyword">int</span> forward = curPos + arr[curPos];        <span class="hljs-keyword">int</span> backward = curPos - arr[curPos];        <span class="hljs-keyword">if</span> (forward &lt; len &amp;&amp; !visited[forward]) &#123;            visited[forward] = <span class="hljs-keyword">true</span>;            queue.add(forward);        &#125;        <span class="hljs-keyword">if</span> (backward &gt;= <span class="hljs-number">0</span> &amp;&amp; !visited[backward]) &#123;            visited[backward] = <span class="hljs-keyword">true</span>;            queue.add(backward);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canReach</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];    <span class="hljs-keyword">return</span> dfs(arr, len, start, visited);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">boolean</span>[] visited)</span> </span>&#123;    <span class="hljs-comment">// 越过边界 || 访问过</span>    <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span> || start &gt;= len || visited[start]) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// 终点</span>    <span class="hljs-keyword">if</span> (arr[start] == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 标记访问位</span>    visited[start] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// 向前</span>    <span class="hljs-keyword">int</span> forward = start + arr[start];    <span class="hljs-comment">// 向后</span>    <span class="hljs-keyword">int</span> backward = start - arr[start];    <span class="hljs-keyword">return</span> dfs(arr, len, forward, visited) || dfs(arr, len, backward, visited);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1207. 独一无二的出现次数</title>
    <link href="/2020/10/28/LeetCode-1207-unique-number-of-occurrences/"/>
    <url>/2020/10/28/LeetCode-1207-unique-number-of-occurrences/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/unique-number-of-occurrences/" target="_blank" rel="noopener">1207. 独一无二的出现次数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">uniqueOccurrences</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;        <span class="hljs-keyword">int</span> occur = map.getOrDefault(num, <span class="hljs-number">0</span>);        map.put(num, occur + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> occur : map.values()) &#123;        <span class="hljs-keyword">if</span> (counts[occur] &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        counts[occur]++;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 145. 二叉树的后序遍历</title>
    <link href="/2020/10/27/LeetCode-145-binary-tree-postorder-traversal/"/>
    <url>/2020/10/27/LeetCode-145-binary-tree-postorder-traversal/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    stack.add(root);    <span class="hljs-comment">// 前序：根左右 ——&gt; 后序：左右根</span>    <span class="hljs-comment">// 前序：根右左  reverse: 左右根</span>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        root = stack.pop();        res.add(root.val);        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;            stack.push(root.left);        &#125;        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;            stack.push(root.right);        &#125;    &#125;    Collections.reverse(res);    <span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    LinkedList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 头插法</span>            res.addFirst(root.val);            stack.push(root);            <span class="hljs-comment">// 先遍历右子树</span>            root = root.right;        &#125; <span class="hljs-keyword">else</span> &#123;            root = stack.pop();            root = root.left;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 94. 二叉树的中序遍历</title>
    <link href="/2020/10/27/LeetCode-94-binary-tree-inorder-traversal/"/>
    <url>/2020/10/27/LeetCode-94-binary-tree-inorder-traversal/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !stack.isEmpty()) &#123;        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;            stack.push(root);            root = root.left;        &#125;        root = stack.pop();        res.add(root.val);        root = root.right;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 144. 二叉树的前序遍历</title>
    <link href="/2020/10/27/LeetCode-144-binary-tree-preorder-traversal/"/>
    <url>/2020/10/27/LeetCode-144-binary-tree-preorder-traversal/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    stack.add(root);    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        root = stack.pop();        res.add(root.val);        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;            stack.push(root.right);        &#125;        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;            stack.push(root.left);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 641. 设计循环双端队列</title>
    <link href="/2020/10/26/LeetCode-641-design-circular-deque/"/>
    <url>/2020/10/26/LeetCode-641-design-circular-deque/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircularDeque</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 指向队头存储元素的位置</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> front;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 指向队尾存储元素的下一个位置</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rear;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] queue;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here. Set the size of the deque to be k.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCircularDeque</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.capacity = k + <span class="hljs-number">1</span>;        <span class="hljs-keyword">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[capacity];        <span class="hljs-comment">/**</span><span class="hljs-comment">         * insert: front-- , set value</span><span class="hljs-comment">         * delete: front++</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">this</span>.front = <span class="hljs-number">0</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * insert: set value, rear++</span><span class="hljs-comment">         * delete: rear--</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">this</span>.rear = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Adds an item at the front of Deque. Return true if the operation is successful.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertFront</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (isFull()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        front = (front - <span class="hljs-number">1</span> + capacity) % capacity;        queue[front] = value;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Adds an item at the rear of Deque. Return true if the operation is successful.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertLast</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (isFull()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        queue[rear] = value;        rear = (rear + <span class="hljs-number">1</span>) % capacity;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Deletes an item from the front of Deque. Return true if the operation is successful.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteFront</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        front = (front + <span class="hljs-number">1</span>) % capacity;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Deletes an item from the rear of Deque. Return true if the operation is successful.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteLast</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        rear = (rear - <span class="hljs-number">1</span> + capacity) % capacity;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get the front item from the deque.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFront</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> queue[front];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get the last item from the deque.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRear</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> queue[(rear - <span class="hljs-number">1</span> + capacity) % capacity];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Checks whether the circular deque is empty or not.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> front == rear;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Checks whether the circular deque is full or not.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (rear + <span class="hljs-number">1</span>) % capacity == front;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 622. 设计循环队列</title>
    <link href="/2020/10/26/LeetCode-622-design-circular-queue/"/>
    <url>/2020/10/26/LeetCode-622-design-circular-queue/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. 设计循环队列</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircularQueue</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 指向队头存储元素的位置</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> front;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 指向队尾存储元素的下一个位置</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rear;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] queue;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here. Set the size of the queue to be k.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCircularQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.capacity = k + <span class="hljs-number">1</span>;        <span class="hljs-keyword">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[capacity];        <span class="hljs-keyword">this</span>.front = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.rear = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Insert an element into the circular queue. Return true if the operation is successful.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (isFull()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        queue[rear] = value;        rear = (rear + <span class="hljs-number">1</span>) % capacity;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Delete an element from the circular queue. Return true if the operation is successful.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        front = (front + <span class="hljs-number">1</span>) % capacity;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get the front item from the queue.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> queue[front];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get the last item from the queue.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> queue[(rear - <span class="hljs-number">1</span> + capacity) % capacity];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Checks whether the circular queue is empty or not.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> front == rear;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Checks whether the circular queue is full or not.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (rear + <span class="hljs-number">1</span>) % capacity == front;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 621. 任务调度器</title>
    <link href="/2020/10/26/LeetCode-621-task-scheduler/"/>
    <url>/2020/10/26/LeetCode-621-task-scheduler/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">621. 任务调度器</a></p><h1 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tasks, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-comment">// 统计每个任务的数量</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> task : tasks) &#123;        counts[task - <span class="hljs-string">'A'</span>]++;    &#125;    <span class="hljs-comment">// 找到任务数最多的任务</span>    Arrays.sort(counts);    <span class="hljs-keyword">int</span> maxCount = counts[<span class="hljs-number">25</span>];    <span class="hljs-comment">// 需要几个任务队列取决于数量最多的那个任务</span>    <span class="hljs-keyword">int</span> time = (maxCount - <span class="hljs-number">1</span>) * (n + <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">25</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// 有其他任务和 max 一样，则多花一个时间</span>        <span class="hljs-keyword">if</span> (counts[i] == maxCount) &#123;            time++;        &#125;    &#125;    <span class="hljs-comment">// 若有空闲时间，res = time</span>    <span class="hljs-comment">// 若没有空闲时间，表示 n 个序列都已用完，需要扩充 n，res = len</span>    <span class="hljs-keyword">return</span> Math.max(time, tasks.length);&#125;</code></pre><h1 id="优先队列"><a class="markdownIt-Anchor" href="#优先队列"></a> 优先队列</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tasks, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">// 最小时间只和任务数量最多的那个任务有关</span>    <span class="hljs-comment">// 在 n + 1 时间内的任务都不重复</span>    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-comment">// 统计每个任务的出现次数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> task : tasks) &#123;        counts[task - <span class="hljs-string">'A'</span>]++;    &#125;    <span class="hljs-comment">// 大顶堆</span>    PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> count : counts) &#123;        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;            maxHeap.add(count);        &#125;    &#125;    <span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (!maxHeap.isEmpty()) &#123;        List&lt;Integer&gt; next = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 每轮安排 n + 1 个任务</span>        <span class="hljs-keyword">int</span> taskNum = n + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (taskNum-- &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (!maxHeap.isEmpty()) &#123;                <span class="hljs-comment">// 每次优先安排任务数最多的任务</span>                <span class="hljs-keyword">int</span> max = maxHeap.poll();                <span class="hljs-keyword">if</span> (max &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-comment">// 更新当前的任务数，用于下一轮</span>                    next.add(max - <span class="hljs-number">1</span>);                &#125;            &#125;            <span class="hljs-comment">// 下一轮和堆里没有可以安排的任务</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next.isEmpty()) &#123;                <span class="hljs-keyword">return</span> time;            &#125;            time++;        &#125;        maxHeap.addAll(next);    &#125;    <span class="hljs-keyword">return</span> time;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1365. 有多少小于当前数字的数字</title>
    <link href="/2020/10/26/LeetCode-1365-how-many-numbers-are-smaller-than-the-current-number/"/>
    <url>/2020/10/26/LeetCode-1365-how-many-numbers-are-smaller-than-the-current-number/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/" target="_blank" rel="noopener">1365. 有多少小于当前数字的数字</a></p><h1 id="排序-哈希"><a class="markdownIt-Anchor" href="#排序-哈希"></a> 排序 + 哈希</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] smallerNumbersThanCurrent(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] origin = Arrays.copyOf(nums, len);    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">101</span>];    Arrays.sort(nums);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 去重</span>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] == nums[i]) &#123;            j--;        &#125;        counts[nums[i]] = j + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        res[i] = counts[origin[i]];    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="计数排序"><a class="markdownIt-Anchor" href="#计数排序"></a> 计数排序</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] smallerNumbersThanCurrent(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">101</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        counts[num]++;    &#125;    <span class="hljs-comment">// 统计出现频次</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; counts.length; i++) &#123;        counts[i] = counts[i - <span class="hljs-number">1</span>] + counts[i];    &#125;    <span class="hljs-comment">// 计算在 nums[i] 之前出现了几个数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;            res[i] = counts[nums[i] - <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 674. 最长连续递增序列</title>
    <link href="/2020/10/25/LeetCode-674-longest-continuous-increasing-subsequence/"/>
    <url>/2020/10/25/LeetCode-674-longest-continuous-increasing-subsequence/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (right &lt; len) &#123;            <span class="hljs-keyword">if</span> (nums[right] &lt;= nums[right - <span class="hljs-number">1</span>]) &#123;                max = Math.max(max, right - left);                left = right;            &#125;            right++;        &#125;        max = Math.max(max, right - left);        <span class="hljs-keyword">return</span> max;    &#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] rights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    Arrays.fill(rights, <span class="hljs-number">1</span>);    <span class="hljs-comment">// 从右边开始找最大递增数</span>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; len &amp;&amp; nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;            rights[i] = rights[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        &#125;        max = Math.max(max, rights[i]);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 845. 数组中的最长山脉</title>
    <link href="/2020/10/25/LeetCode-845-longest-mountain-in-array/"/>
    <url>/2020/10/25/LeetCode-845-longest-mountain-in-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/" target="_blank" rel="noopener">845. 数组中的最长山脉</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestMountain</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[] leftMin = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] rightMin = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-comment">// 找到左边比 A[i] 小的连续个数 </span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; A[i - <span class="hljs-number">1</span>] &lt; A[i]) &#123;            leftMin[i] = leftMin[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            leftMin[i] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-comment">// 找到右边比 A[i] 小的连续个数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; len &amp;&amp; A[i] &gt; A[i + <span class="hljs-number">1</span>]) &#123;            rightMin[i] = rightMin[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            rightMin[i] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (leftMin[i] != <span class="hljs-number">0</span> &amp;&amp; rightMin[i] != <span class="hljs-number">0</span>) &#123;            max = Math.max(max, leftMin[i] + rightMin[i] + <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1024. 视频拼接</title>
    <link href="/2020/10/24/LeetCode-1024-video-stitching/"/>
    <url>/2020/10/24/LeetCode-1024-video-stitching/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/video-stitching/" target="_blank" rel="noopener">1024. 视频拼接</a></p><p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">videoStitching</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] clips, <span class="hljs-keyword">int</span> T)</span> </span>&#123;    <span class="hljs-comment">/* dp[i]: 覆盖区间 [0, i] 所需要的最少子区间数量</span><span class="hljs-comment">    e.g.   0..|.....i|</span><span class="hljs-comment">              |a_j...|...b_j</span><span class="hljs-comment">      if i in [a_j, b_j]:</span><span class="hljs-comment">        [a_j, b_j] 可以覆盖 [0, i] 的后半部分</span><span class="hljs-comment">        后半部分：dp[i] = 1 (加上区间 [a_j, b_j])，前半部分：dp[a_j]</span><span class="hljs-comment">        整个区间：dp[i] = min(dp[a_j] + 1, dp[i])</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T + <span class="hljs-number">1</span>];    Arrays.fill(dp, Integer.MAX_VALUE - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= T; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] clip : clips) &#123;            <span class="hljs-keyword">if</span> (clip[<span class="hljs-number">0</span>] &lt;= i &amp;&amp; i &lt;= clip[<span class="hljs-number">1</span>]) &#123;                dp[i] = Math.min(dp[i], dp[clip[<span class="hljs-number">0</span>]] + <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[T] == Integer.MAX_VALUE - <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : dp[T];&#125;</code></pre><h1 id="贪心"><a class="markdownIt-Anchor" href="#贪心"></a> 贪心</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">videoStitching</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] clips, <span class="hljs-keyword">int</span> T)</span> </span>&#123;    <span class="hljs-comment">// dp[i]: 以 i 为起点能到达的最远位置</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">101</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] clip : clips) &#123;        <span class="hljs-comment">// 取 clip[0] 最远的位置，即取能覆盖最远的区间</span>        dp[clip[<span class="hljs-number">0</span>]] = Math.max(dp[clip[<span class="hljs-number">0</span>]], clip[<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-comment">// 所需要的片段数</span>    <span class="hljs-keyword">int</span> clipCount = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前的最远位置</span>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 上一次起跳的终点</span>    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) &#123;        <span class="hljs-comment">// 更新当前能到达的最远位置</span>        max = Math.max(max, dp[i]);        <span class="hljs-comment">// 当前最远只能到 i 位置，到不了下一个位置</span>        <span class="hljs-keyword">if</span> (max == i) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 到达上一次的终点，取一个新片段</span>        <span class="hljs-keyword">if</span> (i == pre) &#123;            clipCount++;            pre = max;        &#125;    &#125;    <span class="hljs-keyword">return</span> clipCount;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1267. 统计参与通信的服务器</title>
    <link href="/2020/10/23/LeetCode-1267-count-servers-that-communicate/"/>
    <url>/2020/10/23/LeetCode-1267-count-servers-that-communicate/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-servers-that-communicate/" target="_blank" rel="noopener">1267. 统计参与通信的服务器</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countServers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = grid.length;    <span class="hljs-keyword">int</span> cols = grid[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">int</span>[] rowCount = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows];    <span class="hljs-keyword">int</span>[] colCount = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[cols];    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            rowCount[i] += grid[i][j];            colCount[j] += grid[i][j];        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">if</span> (rowCount[i] &gt; <span class="hljs-number">1</span> || colCount[j] &gt; <span class="hljs-number">1</span>) &#123;                    res++;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1588. 所有奇数长度子数组的和</title>
    <link href="/2020/10/23/LeetCode-1588-sum-of-all-odd-length-subarrays/"/>
    <url>/2020/10/23/LeetCode-1588-sum-of-all-odd-length-subarrays/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/" target="_blank" rel="noopener">1588. 所有奇数长度子数组的和</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumOddLengthSubarrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] preSums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    preSums[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 1 4 2 5 3</span>    <span class="hljs-comment">// 0 1 5 7 12 15</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        preSums[i] = preSums[i - <span class="hljs-number">1</span>] + arr[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= len; j += <span class="hljs-number">2</span>) &#123;            <span class="hljs-comment">// preSums right index = i + &#123;0, 2, 4, ...&#125; + 1</span>            <span class="hljs-comment">// preSums left index = i</span>            <span class="hljs-keyword">int</span> right = i + j;            <span class="hljs-keyword">if</span> (right &lt;= len) &#123;                <span class="hljs-comment">// System.out.println(arr[i] + " sum = " + (preSums[right] - preSums[i]));</span>                res += preSums[right] - preSums[i];            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 234. 回文链表</title>
    <link href="/2020/10/23/LeetCode-234-palindrome-linked-list/"/>
    <url>/2020/10/23/LeetCode-234-palindrome-linked-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 1-&gt;2-&gt;2-&gt;1</span>        <span class="hljs-comment">// 1-&gt;0-&gt;1</span>        ListNode slow = head;        ListNode fast = head;        ListNode reverseHead = <span class="hljs-keyword">null</span>;        ListNode slowTmp;        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;            slowTmp = slow;            <span class="hljs-comment">// 快慢指针先移动，防止丢失节点</span>            slow = slow.next;            fast = fast.next.next;            <span class="hljs-comment">// 反转先前的 slow</span>            slowTmp.next = reverseHead;            reverseHead = slowTmp;        &#125;        <span class="hljs-comment">// 此时 slow 为中点，slow 之前的节点已经反转</span>        <span class="hljs-comment">// 奇数个节点，中点不需要比较</span>        <span class="hljs-keyword">if</span> (fast != <span class="hljs-keyword">null</span>) &#123;            slow = slow.next;        &#125;        <span class="hljs-comment">// slow 代表后半部分，reverseHead 代表反转后的前半部分</span>        <span class="hljs-keyword">while</span> (slow != <span class="hljs-keyword">null</span> &amp;&amp; reverseHead != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (slow.val != reverseHead.val) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            slow = slow.next;            reverseHead = reverseHead.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 763. 划分字母区间</title>
    <link href="/2020/10/22/LeetCode-763-partition-labels/"/>
    <url>/2020/10/22/LeetCode-763-partition-labels/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/partition-labels/" target="_blank" rel="noopener">763. 划分字母区间</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(String S)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = S.length();    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">char</span>[] str = S.toCharArray();    <span class="hljs-keyword">int</span>[] occur = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        occur[str[i] - <span class="hljs-string">'a'</span>] = i;    &#125;    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 每次遍历 [start, curWindowEnd]</span>    <span class="hljs-comment">// curWindowEnd 表示 start 对应字母的最后出现位置</span>    <span class="hljs-comment">// 取区间内每个字母最后出现位置的最大值</span>    <span class="hljs-keyword">while</span> (start &lt; len) &#123;        <span class="hljs-keyword">int</span> curWindowEnd = occur[str[start] - <span class="hljs-string">'a'</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; curWindowEnd; i++) &#123;            <span class="hljs-comment">// [start, curWindowEnd] 区间内取字母最后出现的位置</span>            curWindowEnd = Math.max(curWindowEnd, occur[str[i] - <span class="hljs-string">'a'</span>]);        &#125;        res.add(curWindowEnd - start + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 下一轮位置</span>        start = curWindowEnd + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 925. 长按键入</title>
    <link href="/2020/10/21/LeetCode-925-long-pressed-name/"/>
    <url>/2020/10/21/LeetCode-925-long-pressed-name/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/long-pressed-name/" target="_blank" rel="noopener">925. 长按键入</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLongPressedName</span><span class="hljs-params">(String name, String typed)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] names = name.toCharArray();    <span class="hljs-keyword">char</span>[] types = typed.toCharArray();    <span class="hljs-keyword">int</span> len1 = names.length;    <span class="hljs-keyword">int</span> len2 = types.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;        <span class="hljs-keyword">if</span> (names[i] == types[j]) &#123;            i++;            j++;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 第一个字符就不相等</span>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// types[j] 不是长按产生的</span>            <span class="hljs-keyword">boolean</span> jumped = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">while</span> (j &lt; len2 &amp;&amp; names[i - <span class="hljs-number">1</span>] == types[j]) &#123;                j++;                jumped = <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">if</span> (!jumped) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// types 后面还有重复</span>    <span class="hljs-keyword">while</span> (j &lt; len2) &#123;        <span class="hljs-keyword">if</span> (types[j] != names[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        j++;    &#125;    <span class="hljs-keyword">return</span> i == len1 &amp;&amp; j == len2;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 901. 股票价格跨度</title>
    <link href="/2020/10/20/LeetCode-901-online-stock-span/"/>
    <url>/2020/10/20/LeetCode-901-online-stock-span/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/online-stock-span/" target="_blank" rel="noopener">901. 股票价格跨度</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StockSpanner</span> </span>&#123;    ArrayDeque&lt;Integer&gt; stack;    ArrayDeque&lt;Integer&gt; weights;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StockSpanner</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 同步保存 price 之前有多少个比 price 小</span>        weights = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> price)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; price &gt;= stack.peek()) &#123;            <span class="hljs-comment">// 比 price 低的出栈</span>            stack.pop();            <span class="hljs-comment">// 加上对应的数目</span>            count += weights.pop();        &#125;        stack.push(price);        weights.push(count);        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 503. 下一个更大元素 II</title>
    <link href="/2020/10/20/LeetCode-503-next-greater-element-ii/"/>
    <url>/2020/10/20/LeetCode-503-next-greater-element-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. 下一个更大元素 II</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] nextGreaterElements(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    Arrays.fill(res, -<span class="hljs-number">1</span>);    ArrayDeque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-comment">// 两倍长度遍历</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len * <span class="hljs-number">2</span>; i++) &#123;        <span class="hljs-keyword">int</span> j = i % len;        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[j] &gt; nums[stack.peek()]) &#123;            res[stack.pop()] = nums[j];        &#125;        stack.push(j);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 143. 重排链表</title>
    <link href="/2020/10/20/LeetCode-143-reorder-list/"/>
    <url>/2020/10/20/LeetCode-143-reorder-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 1 2 3 4 5  1 2 3  5 4  1 5 2 4 3</span>    ListNode slow = head;    ListNode fast = head;    <span class="hljs-comment">// 快慢指针找中点</span>    <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>) &#123;        slow = slow.next;        fast = fast.next.next;    &#125;    ListNode newHead = slow.next;    slow.next = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 逆转链表</span>    newHead = reverseList(newHead);    <span class="hljs-comment">// 交替插入</span>    ListNode p = head;    ListNode q = newHead;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; q != <span class="hljs-keyword">null</span>) &#123;        ListNode t = p.next;        p.next = q;        ListNode t2 = q.next;        q.next = t;        p = t;        q = t2;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">// 1 2 3 4 5 6 7</span>    ListNode cur = head.next;    ListNode newHead = head;    newHead.next = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;        ListNode nextCur = cur.next;        cur.next = newHead;        newHead = cur;        cur = nextCur;    &#125;    <span class="hljs-keyword">return</span> newHead;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 496. 下一个更大元素 I</title>
    <link href="/2020/10/19/LeetCode-496-next-greater-element-i/"/>
    <url>/2020/10/19/LeetCode-496-next-greater-element-i/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] nextGreaterElement(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    ArrayDeque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums2) &#123;        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; num &gt; stack.peek()) &#123;            <span class="hljs-keyword">int</span> top = stack.pop();            map.put(top, num);        &#125;        stack.push(num);    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums1.length];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;        res[i] = map.getOrDefault(nums1[i], -<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 739. 每日温度</title>
    <link href="/2020/10/19/LeetCode-739-daily-temperatures/"/>
    <url>/2020/10/19/LeetCode-739-daily-temperatures/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></p><h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;    ArrayDeque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> len = T.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 单调递减栈</span>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;            <span class="hljs-keyword">int</span> top = stack.pop();            res[top] = i - top;        &#125;        stack.push(i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 844. 比较含退格的字符串</title>
    <link href="/2020/10/19/LeetCode-844-backspace-string-compare/"/>
    <url>/2020/10/19/LeetCode-844-backspace-string-compare/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">844. 比较含退格的字符串</a></p><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] s = S.toCharArray();    <span class="hljs-keyword">char</span>[] t = T.toCharArray();    <span class="hljs-keyword">return</span> getString(s).equals(getString(t));&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getString</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s)</span> </span>&#123;    ArrayDeque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s) &#123;        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'#'</span>) &#123;            <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;                stack.pop();            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            stack.push(c);        &#125;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        sb.append(stack.pop());    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] s = S.toCharArray();        <span class="hljs-keyword">char</span>[] t = T.toCharArray();        <span class="hljs-keyword">int</span> i = s.length - <span class="hljs-number">1</span>, j = t.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> skipS = <span class="hljs-number">0</span>, skipT = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 消除 s 中的 `#`</span>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">'#'</span>) &#123;                    skipS++;                    i--;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// s[i] 为字母</span>                    <span class="hljs-keyword">if</span> (skipS &gt; <span class="hljs-number">0</span>) &#123;                        skipS--;                        i--;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// 不需要跳过，比较此时的 s[i]</span>                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (t[j] == <span class="hljs-string">'#'</span>) &#123;                    skipT++;                    j--;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (skipT &gt; <span class="hljs-number">0</span>) &#123;                        skipT--;                        j--;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 比较 s[i] t[j]</span>            <span class="hljs-comment">// 只有一个遍历结束</span>            <span class="hljs-keyword">if</span> ((i &lt; <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) || (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; <span class="hljs-number">0</span>)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// s, t 都遍历结束</span>            <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">if</span> (s[i] != t[j]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            i--;            j--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1111. 有效括号的嵌套深度</title>
    <link href="/2020/10/18/LeetCode-1111-maximum-nesting-depth-of-two-valid-parentheses-strings/"/>
    <url>/2020/10/18/LeetCode-1111-maximum-nesting-depth-of-two-valid-parentheses-strings/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/" target="_blank" rel="noopener">1111. 有效括号的嵌套深度</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxDepthAfterSplit(String seq) &#123;    <span class="hljs-keyword">char</span>[] chars = seq.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 连续的 `((` 尽量不要分配在同一组</span>        <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">'('</span>) &#123;            <span class="hljs-comment">// 遇到 `(` 嵌套深度才增加</span>            depth++;            <span class="hljs-comment">// 按当前嵌套深度根据奇偶数分组</span>            res[i] = depth % <span class="hljs-number">2</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// `)` 与栈顶的 `(` 分配在同一组</span>            res[i] = depth % <span class="hljs-number">2</span>;            <span class="hljs-comment">// 减小嵌套深度</span>            depth--;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 19. 删除链表的倒数第N个节点</title>
    <link href="/2020/10/18/LeetCode-19-remove-nth-node-from-end-of-list/"/>
    <url>/2020/10/18/LeetCode-19-remove-nth-node-from-end-of-list/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    <span class="hljs-comment">// 走 n + 1 步</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;        fast = fast.next;    &#125;    <span class="hljs-comment">// 当 fast == null，slow 在倒数第 n + 1 个节点</span>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span>) &#123;        slow = slow.next;        fast = fast.next;    &#125;        <span class="hljs-comment">// 删除倒数第 n 个节点</span>        slow.next = slow.next.next;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 946. 验证栈序列</title>
    <link href="/2020/10/17/LeetCode-946-validate-stack-sequences/"/>
    <url>/2020/10/17/LeetCode-946-validate-stack-sequences/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">946. 验证栈序列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pushed, <span class="hljs-keyword">int</span>[] popped)</span> </span>&#123;    ArrayDeque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : pushed) &#123;        stack.push(num);        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i]) &#123;            stack.pop();            i++;        &#125;    &#125;    <span class="hljs-keyword">return</span> stack.isEmpty();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 341. 扁平化嵌套列表迭代器</title>
    <link href="/2020/10/16/LeetCode-341-flatten-nested-list-iterator/"/>
    <url>/2020/10/16/LeetCode-341-flatten-nested-list-iterator/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/" target="_blank" rel="noopener">341. 扁平化嵌套列表迭代器</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NestedIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> ArrayDeque&lt;Integer&gt; deque;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NestedIterator</span><span class="hljs-params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;        deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        flatten(nestedList, deque);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> deque.pollFirst();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> !deque.isEmpty();    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(List&lt;NestedInteger&gt; nestedList, Deque&lt;Integer&gt; deque)</span> </span>&#123;        <span class="hljs-keyword">for</span> (NestedInteger ni : nestedList) &#123;            <span class="hljs-keyword">if</span> (ni.isInteger()) &#123;                deque.addLast(ni.getInteger());            &#125; <span class="hljs-keyword">else</span> &#123;                flatten(ni.getList(), deque);            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 316. 去除重复字母</title>
    <link href="/2020/10/16/LeetCode-316-remove-duplicate-letters/"/>
    <url>/2020/10/16/LeetCode-316-remove-duplicate-letters/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">316. 去除重复字母</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-comment">// 计算所有字符的出现次数</span>    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;        counts[c - <span class="hljs-string">'a'</span>]++;    &#125;    ArrayDeque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) &#123;        <span class="hljs-keyword">if</span> (!stack.contains(c)) &#123;            <span class="hljs-comment">// c &lt; 栈顶 &amp;&amp; 栈顶的剩余出现次数 &gt;= 1</span>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; c &lt; stack.peek() &amp;&amp; counts[stack.peek() - <span class="hljs-string">'a'</span>] &gt; <span class="hljs-number">0</span>) &#123;                stack.pop();            &#125;            stack.push(c);        &#125;        <span class="hljs-comment">// 更新剩余出现次数</span>        counts[c - <span class="hljs-string">'a'</span>]--;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        sb.append(stack.pollLast());    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>贪心</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 402. 移掉K位数字</title>
    <link href="/2020/10/16/LeetCode-402-remove-k-digits/"/>
    <url>/2020/10/16/LeetCode-402-remove-k-digits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeKdigits</span><span class="hljs-params">(String num, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-comment">// "1432219" "10200" "10"</span>    <span class="hljs-keyword">char</span>[] nums = num.toCharArray();    ArrayDeque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> dropped = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : nums) &#123;        <span class="hljs-comment">// 可以丢弃 &amp;&amp; 栈顶 &gt; current</span>        <span class="hljs-comment">// 丢弃栈顶，使得整个序列变小 =&gt; 递增栈</span>        <span class="hljs-keyword">while</span> (dropped &lt; k &amp;&amp; !deque.isEmpty() &amp;&amp; deque.peekLast() &gt; c) &#123;            dropped++;            deque.removeLast();        &#125;        deque.addLast(c);    &#125;    <span class="hljs-comment">// 去除前导 0</span>    <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() == <span class="hljs-string">'0'</span>) &#123;        deque.removeFirst();    &#125;    <span class="hljs-comment">// 已丢弃的数字不足 k 个</span>    <span class="hljs-comment">// 则丢弃队列后面的数字</span>    <span class="hljs-keyword">while</span> (dropped &lt; k) &#123;        dropped++;        <span class="hljs-keyword">if</span> (deque.isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"0"</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            deque.removeLast();        &#125;    &#125;    <span class="hljs-keyword">if</span> (deque.isEmpty()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"0"</span>;    &#125;    StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">while</span> (!deque.isEmpty()) &#123;        stringBuilder.append(deque.removeFirst());    &#125;    <span class="hljs-keyword">return</span> stringBuilder.toString();&#125;</code></pre><p>数组模拟：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeKdigits</span><span class="hljs-params">(String num, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = num.length();    <span class="hljs-keyword">char</span>[] str = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len];    <span class="hljs-keyword">char</span>[] nums = num.toCharArray();    <span class="hljs-comment">// right 指向 str 的有效位置</span>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : nums) &#123;        <span class="hljs-comment">// 模拟单调递增栈</span>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; right &gt; <span class="hljs-number">0</span> &amp;&amp; str[right - <span class="hljs-number">1</span>] &gt; c) &#123;            k--;            right--;        &#125;        str[right++] = c;    &#125;    <span class="hljs-comment">// 删除位数不足 k 位</span>    <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">0</span> &amp;&amp; right &gt; <span class="hljs-number">0</span>) &#123;        right--;    &#125;    <span class="hljs-comment">// 删除前导 0</span>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; str[left] == <span class="hljs-string">'0'</span>) &#123;        left++;    &#125;    <span class="hljs-keyword">if</span> (right == left) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"0"</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(str, left, right - left);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 284. 顶端迭代器</title>
    <link href="/2020/10/16/LeetCode-284-peeking-iterator/"/>
    <url>/2020/10/16/LeetCode-284-peeking-iterator/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/peeking-iterator/" target="_blank" rel="noopener">284. 顶端迭代器</a></p><h1 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeekingIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; queue;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PeekingIterator</span><span class="hljs-params">(Iterator&lt;Integer&gt; iterator)</span> </span>&#123;        <span class="hljs-comment">// initialize any member here.</span>        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-comment">// 把 iterator 中的所有元素放到队列中</span>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            queue.add(iterator.next());        &#125;    &#125;    <span class="hljs-comment">// Returns the next element in the iteration without advancing the iterator.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> queue.peek();    &#125;    <span class="hljs-comment">// hasNext() and next() should behave the same as in the Iterator interface.</span>    <span class="hljs-comment">// Override them if needed.</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> queue.poll();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> !queue.isEmpty();    &#125;&#125;</code></pre><h1 id="缓存-top"><a class="markdownIt-Anchor" href="#缓存-top"></a> 缓存 top</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeekingIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    Iterator&lt;Integer&gt; iter;    Integer top;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PeekingIterator</span><span class="hljs-params">(Iterator&lt;Integer&gt; iterator)</span> </span>&#123;        <span class="hljs-comment">// initialize any member here.</span>        iter = iterator;        <span class="hljs-comment">// top != null 表示已经调用过 peek()，top 就是 iterator 的顶部元素</span>        <span class="hljs-comment">// top == null 表示还没调用过 peek()，此时应该使 top = iterator 的顶部元素</span>        top = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">// Returns the next element in the iteration without advancing the iterator.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (top != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> top;        &#125;        <span class="hljs-comment">// top == null，表示调用过了 next()，使原来的 top 丢失了</span>        top = iter.next();        <span class="hljs-keyword">return</span> top;    &#125;    <span class="hljs-comment">// hasNext() and next() should behave the same as in the Iterator interface.</span>    <span class="hljs-comment">// Override them if needed.</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (top == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> iter.next();        &#125;        <span class="hljs-comment">// 原来的 top 已经在 peek() 的时候删除了</span>        <span class="hljs-comment">// 这时不能再调用 next()</span>        <span class="hljs-keyword">int</span> res = top;        <span class="hljs-comment">// 新的 top 此时还没更新，要由 peek() 赋值</span>        top = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> top != <span class="hljs-keyword">null</span> &amp;&amp; iter.hasNext();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 977. 有序数组的平方</title>
    <link href="/2020/10/16/LeetCode-977-squares-of-a-sorted-array/"/>
    <url>/2020/10/16/LeetCode-977-squares-of-a-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">977. 有序数组的平方</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortedSquares(<span class="hljs-keyword">int</span>[] A) &#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> i = right;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">int</span> l = A[left] * A[left];        <span class="hljs-keyword">int</span> r = A[right] * A[right];        <span class="hljs-keyword">if</span> (l &gt; r) &#123;            res[i] = l;            left++;        &#125; <span class="hljs-keyword">else</span> &#123;            res[i] = r;            right--;        &#125;        i--;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 116. 填充每个节点的下一个右侧节点指针</title>
    <link href="/2020/10/15/LeetCode-116-populating-next-right-pointers-in-each-node/"/>
    <url>/2020/10/15/LeetCode-116-populating-next-right-pointers-in-each-node/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">connect</span><span class="hljs-params">(Node root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    Node levelStart = root;    <span class="hljs-keyword">while</span> (levelStart.left != <span class="hljs-keyword">null</span>) &#123;        Node cur = levelStart;        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 子节点连接，只要 left 存在，right 一定存在</span>            cur.left.next = cur.right;            <span class="hljs-comment">// 向右连接</span>            <span class="hljs-keyword">if</span> (cur.next != <span class="hljs-keyword">null</span>) &#123;                cur.right.next = cur.next.left;            &#125;            <span class="hljs-comment">// 横向连接</span>            cur = cur.next;        &#125;        <span class="hljs-comment">// 进入下一层</span>        levelStart = levelStart.left;    &#125;    <span class="hljs-keyword">return</span> root;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 232. 用栈实现队列</title>
    <link href="/2020/10/15/LeetCode-232-implement-queue-using-stacks/"/>
    <url>/2020/10/15/LeetCode-232-implement-queue-using-stacks/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></p><p>一个栈用来入栈，一个栈用来出栈，<code>pop()</code> 或 <code>peek()</code> 时返回出栈的栈顶，若出栈为空，将入栈的所有元素压入出栈。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用于入栈</span><span class="hljs-comment">     */</span>    ArrayDeque&lt;Integer&gt; addStack;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用于出栈（出队）</span><span class="hljs-comment">     */</span>    ArrayDeque&lt;Integer&gt; popStack;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;        addStack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        popStack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Push element x to the back of queue.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        addStack.push(x);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Removes the element from in front of queue and returns that element.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 若 popStack 为空，则将 addStack 的所有元素压入 popStack</span>        <span class="hljs-keyword">if</span> (popStack.isEmpty()) &#123;            <span class="hljs-keyword">int</span> size = addStack.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">int</span> top = addStack.pop();                popStack.push(top);            &#125;        &#125;        <span class="hljs-comment">// 栈顶即为队头</span>        <span class="hljs-keyword">return</span> popStack.pop();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get the front element.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 若 popStack 为空，则将 addStack 的所有元素压入 popStack</span>        <span class="hljs-keyword">if</span> (popStack.isEmpty()) &#123;            <span class="hljs-keyword">int</span> size = addStack.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">int</span> top = addStack.pop();                popStack.push(top);            &#125;        &#125;        <span class="hljs-comment">// 栈顶即为队头</span>        <span class="hljs-keyword">return</span> popStack.peek();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns whether the queue is empty.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> addStack.isEmpty() &amp;&amp; popStack.isEmpty();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 225. 用队列实现栈</title>
    <link href="/2020/10/15/LeetCode-225-implement-stack-using-queues/"/>
    <url>/2020/10/15/LeetCode-225-implement-stack-using-queues/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></p><p>翻转入队前的元素。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> </span>&#123;    LinkedList&lt;Integer&gt; queue;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Push element x onto stack.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> size = queue.size();        queue.offer(x);        <span class="hljs-comment">// x 之前的元素重新入队，x 变为队头，即栈顶</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            queue.offer(queue.poll());        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Removes the element on top of the stack and returns that element.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> queue.poll();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Get the top element.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> queue.peek();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns whether the stack is empty.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> queue.isEmpty();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 155. 最小栈</title>
    <link href="/2020/10/15/LeetCode-155-min-stack/"/>
    <url>/2020/10/15/LeetCode-155-min-stack/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></p><h1 id="同步栈"><a class="markdownIt-Anchor" href="#同步栈"></a> 同步栈</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    LinkedList&lt;Integer&gt; stack;    LinkedList&lt;Integer&gt; minStack;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        minStack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        stack.push(x);        <span class="hljs-keyword">if</span> (!minStack.isEmpty()) &#123;            <span class="hljs-comment">// 栈不为空，取最小值</span>            minStack.push(Math.min(x, getMin()));        &#125;        <span class="hljs-comment">// 栈空，x 就是最小的</span>        <span class="hljs-keyword">else</span> &#123;            minStack.push(x);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        stack.pop();        minStack.pop();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> stack.peek();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> minStack.peek();    &#125;&#125;</code></pre><h1 id="不同步栈"><a class="markdownIt-Anchor" href="#不同步栈"></a> 不同步栈</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    Deque&lt;Integer&gt; dataStack;    Deque&lt;Integer&gt; minStack;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        dataStack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        minStack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;        dataStack.push(val);        <span class="hljs-comment">// 入栈元素 &lt;= 最小值</span>        <span class="hljs-comment">// [0, 1, 0] 需要重复最小值，否则 0 pop() 后栈为空</span>        <span class="hljs-keyword">if</span> (minStack.isEmpty() || val &lt;= getMin()) &#123;            minStack.push(val);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> top = dataStack.pop();        <span class="hljs-comment">// 出栈的即为最小值</span>        <span class="hljs-keyword">if</span> (!minStack.isEmpty() &amp;&amp; top == getMin()) &#123;            minStack.pop();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> dataStack.peek();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> minStack.peek();    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 71. 简化路径</title>
    <link href="/2020/10/15/LeetCode-71-simplify-path/"/>
    <url>/2020/10/15/LeetCode-71-simplify-path/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">simplifyPath</span><span class="hljs-params">(String path)</span> </span>&#123;    ArrayDeque&lt;String&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">int</span> len = path.length();    <span class="hljs-comment">// 多分配一个空间，处理不是以 '/' 结尾的情况</span>    <span class="hljs-keyword">char</span>[] str = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len + <span class="hljs-number">1</span>];    System.arraycopy(path.toCharArray(), <span class="hljs-number">0</span>, str, <span class="hljs-number">0</span>, len);    <span class="hljs-comment">// 尾部多分配 '/'</span>    str[len] = <span class="hljs-string">'/'</span>;    stack.push(<span class="hljs-string">""</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'/'</span>) &#123;            String folder = sb.toString();            sb.setLength(<span class="hljs-number">0</span>);            <span class="hljs-comment">// 0 或 1 个 '.' 还在当前目录</span>            <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(folder) || <span class="hljs-string">"."</span>.equals(folder)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 2 个点返回上一级目录</span>            <span class="hljs-keyword">if</span> (<span class="hljs-string">".."</span>.equals(folder)) &#123;                <span class="hljs-comment">// 当前目录不是根目录才可返回上一级</span>                <span class="hljs-keyword">if</span> (!<span class="hljs-string">""</span>.equals(stack.peek())) &#123;                    stack.pop();                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 进入下一级目录</span>                stack.push(folder);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            sb.append(str[i]);        &#125;    &#125;    List&lt;String&gt; folders = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        folders.add(stack.pop());    &#125;    <span class="hljs-comment">// 目录长度 == 1，此时只有根目录 = ''</span>    <span class="hljs-keyword">if</span> (folders.size() &gt; <span class="hljs-number">1</span>) &#123;        folders.remove(folders.size() - <span class="hljs-number">1</span>);    &#125;    Collections.reverse(folders);    sb.setLength(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (String folder : folders) &#123;        sb.append(<span class="hljs-string">"/"</span>);        sb.append(folder);    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 410. 分割数组的最大值</title>
    <link href="/2020/10/14/LeetCode-410-split-array-largest-sum/"/>
    <url>/2020/10/14/LeetCode-410-split-array-largest-sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> m)</span> </span>&#123;    <span class="hljs-comment">/* 子数组的最大值 maxOfSub in [max(nums), sum(nums)]</span><span class="hljs-comment">         当分成 nums.length 个子数组时，maxOfSub 最小 = max(nums)</span><span class="hljs-comment">         当分成 1 个子数组时，maxOfSub 最大 = sum(nums)</span><span class="hljs-comment">       分割方案越多，则 maxOfSub 越小，反之越大</span><span class="hljs-comment">       若 maxOfSub 对应的分割方案 &gt; m，说明 此时方案数应减少，maxOfSub 太小，则应增大 maxOfSub</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> left = nums[<span class="hljs-number">0</span>], right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        left = Math.max(left, num);        right += num;    &#125;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-comment">// 尝试以 mid 为子数组的最大和划分数组</span>        <span class="hljs-keyword">int</span> numOfSplit = splitBySubArraySum(mid, nums);        <span class="hljs-keyword">if</span> (numOfSplit &gt; m) &#123;            <span class="hljs-comment">// 子数组个数太多，则减少个数，增大子树数组和</span>            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据子数组的和获取划分的子数组个数</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> maxSum 子数组的最大和</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">splitBySubArraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSum, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-comment">// 至少可以划分成一个数组</span>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 当前子数组的和</span>    <span class="hljs-keyword">int</span> curSum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        curSum += num;        <span class="hljs-comment">// 若当前数 + 子数组的和 &gt; 最大和，则划分一个新的子数组</span>        <span class="hljs-keyword">if</span> (curSum &gt; maxSum) &#123;            count++;            <span class="hljs-comment">// 重新开始划分子数组</span>            curSum = num;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 875. 爱吃香蕉的珂珂</title>
    <link href="/2020/10/14/LeetCode-875-koko-eating-bananas/"/>
    <url>/2020/10/14/LeetCode-875-koko-eating-bananas/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a><br />可真能吃，不仅吃得多，还吃得久，还吃超时了。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles, <span class="hljs-keyword">int</span> H)</span> </span>&#123;    <span class="hljs-keyword">int</span> maxSpeed = piles[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : piles) &#123;        maxSpeed = Math.max(maxSpeed, num);    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = maxSpeed;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-comment">// 计算 speed = mid 时的耗时</span>        <span class="hljs-keyword">int</span> eatTime = eatInSpeed(mid, piles);        <span class="hljs-comment">// System.out.println("left=" + left + " mid = " + mid + " right=" + right + " time=" + eatTime);</span>        <span class="hljs-keyword">if</span> (eatTime &gt; H) &#123;            <span class="hljs-comment">// 吃太久了，加快速度 [mid + 1, right]</span>            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eatInSpeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> speed, <span class="hljs-keyword">int</span>[] piles)</span> </span>&#123;    <span class="hljs-comment">// 耗时</span>    <span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pile : piles) &#123;        <span class="hljs-comment">// 向上取整</span>        time += (pile + speed - <span class="hljs-number">1</span>) / speed;    &#125;    <span class="hljs-keyword">return</span> time;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1292. 元素和小于等于阈值的正方形的最大边长</title>
    <link href="/2020/10/13/LeetCode-1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/"/>
    <url>/2020/10/13/LeetCode-1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/" target="_blank" rel="noopener">1292. 元素和小于等于阈值的正方形的最大边长</a></p><h1 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSideLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] mat, <span class="hljs-keyword">int</span> threshold)</span> </span>&#123;    <span class="hljs-keyword">int</span> m = mat.length, n = mat[<span class="hljs-number">0</span>].length;    <span class="hljs-comment">// 计算前缀和</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;            dp[i][j] = mat[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>] - dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 最大的正方形边长</span>    <span class="hljs-keyword">int</span> maxSideLen = Math.min(m, n);    <span class="hljs-comment">// 遍历每个可能的边长所组成的正方形</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= maxSideLen; k++) &#123;        <span class="hljs-comment">// 以 dp[i][j]为右下角 计算正方形</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;                <span class="hljs-comment">// 无法组成正方形</span>                <span class="hljs-keyword">if</span> (k &gt; i || k &gt; j) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">int</span> rect = dp[i][j] - dp[i - k][j] - dp[i][j - k] + dp[i - k][j - k];                <span class="hljs-comment">// 更新最大边长</span>                <span class="hljs-keyword">if</span> (rect &lt;= threshold) &#123;                    res = Math.max(k, res);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="前缀和-二分"><a class="markdownIt-Anchor" href="#前缀和-二分"></a> 前缀和 + 二分</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSideLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] mat, <span class="hljs-keyword">int</span> threshold)</span> </span>&#123;    <span class="hljs-keyword">int</span> m = mat.length, n = mat[<span class="hljs-number">0</span>].length;    <span class="hljs-comment">// 计算前缀和</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;            dp[i][j] = mat[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>] - dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-comment">// 最大的正方形边长</span>    <span class="hljs-keyword">int</span> right = Math.min(m, n);    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">boolean</span> canIncrease = verifyRect(dp, threshold, mid, m, n);        <span class="hljs-keyword">if</span> (canIncrease) &#123;            <span class="hljs-comment">// mid 对应的正方形满足要求，可以增大</span>            left = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 判断以 len 为边长的正方形是否能满足 threshold</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dp</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> threshold</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> len</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> m</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> n</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyRect</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] dp, <span class="hljs-keyword">int</span> threshold, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">// 以 dp[i][j] 为右下角 计算正方形</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;            <span class="hljs-comment">// 无法组成正方形</span>            <span class="hljs-keyword">if</span> (len &gt; i || len &gt; j) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">int</span> sum = dp[i][j] - dp[i - len][j] - dp[i][j - len] + dp[i - len][j - len];            <span class="hljs-keyword">if</span> (sum &lt;= threshold) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1283. 使结果不超过阈值的最小除数</title>
    <link href="/2020/10/13/LeetCode-1283-find-the-smallest-divisor-given-a-threshold/"/>
    <url>/2020/10/13/LeetCode-1283-find-the-smallest-divisor-given-a-threshold/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/" target="_blank" rel="noopener">1283. 使结果不超过阈值的最小除数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">smallestDivisor</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> threshold)</span> </span>&#123;    <span class="hljs-keyword">int</span> right = Integer.MIN_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        right = Math.max(right, num);    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> sum = calcSum(nums, mid);        <span class="hljs-keyword">if</span> (sum &gt; threshold) &#123;            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calcSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> divider)</span> </span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-comment">// 向上取整技巧，快得很！</span>        sum += (num + divider - <span class="hljs-number">1</span>) / divider;    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 287. 寻找重复数</title>
    <link href="/2020/10/13/LeetCode-287-find-the-duplicate-number/"/>
    <url>/2020/10/13/LeetCode-287-find-the-duplicate-number/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></p><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// [2, 4, 5, 2, 3, 1, 6, 7]</span>    <span class="hljs-comment">// mid = 4, 若 [left, mid] 不存在重复元素</span>    <span class="hljs-comment">// 则 [left, mid] 中 &lt;= mid 的元素个数最多为 mid 个</span>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 计算 数组里小于等于 mid 的个数</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;            <span class="hljs-keyword">if</span> (num &lt;= mid) &#123;                count += <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-comment">// 若 count &gt; mid，则 [left, mid] 存在重复元素</span>        <span class="hljs-keyword">if</span> (count &gt; mid) &#123;            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><h1 id="快慢指针"><a class="markdownIt-Anchor" href="#快慢指针"></a> 快慢指针</h1><p>原地哈希和环形链表找入口的思路结合。<br /><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a><br /><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        fast = nums[nums[fast]];        slow = nums[slow];        <span class="hljs-comment">// fast = 2 * slow = slow + n * circle</span>        <span class="hljs-comment">// slow = n * circle</span>        <span class="hljs-keyword">if</span> (fast == slow) &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-comment">// 从起点同时走 a 步，在环的入口相遇</span>    <span class="hljs-comment">// n * circle + a &lt;=&gt; 0 + a</span>    fast = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (fast != slow) &#123;        fast = nums[fast];        slow = nums[slow];    &#125;    <span class="hljs-keyword">return</span> slow;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 530. 二叉搜索树的最小绝对差</title>
    <link href="/2020/10/12/LeetCode-530-minimum-absolute-difference-in-bst/"/>
    <url>/2020/10/12/LeetCode-530-minimum-absolute-difference-in-bst/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. 二叉搜索树的最小绝对差</a></p><h1 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h1><p>中序遍历</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    ArrayDeque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    TreeNode curNode = root;    <span class="hljs-keyword">int</span> pre = Integer.MAX_VALUE, res = Integer.MAX_VALUE;    <span class="hljs-keyword">while</span> (!stack.isEmpty() || curNode != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">while</span> (curNode != <span class="hljs-keyword">null</span>) &#123;            stack.push(curNode);            curNode = curNode.left;        &#125;        TreeNode top = stack.pop();        <span class="hljs-comment">// 计算当前结点和上一个结点的差值</span>        res = Math.min(Math.abs(top.val - pre), res);        <span class="hljs-comment">// 当前值作为 pre</span>        pre = top.val;        <span class="hljs-comment">// 遍历右子树</span>        curNode = top.right;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span> res = Integer.MAX_VALUE;TreeNode prevNode;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    inOrder(root);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 遍历左子树</span>    inOrder(root.left);    <span class="hljs-comment">// 计算最小差值</span>    <span class="hljs-keyword">if</span> (prevNode != <span class="hljs-keyword">null</span>) &#123;        res = Math.min(res, root.val - prevNode.val);    &#125;    <span class="hljs-comment">// 更新前一个结点</span>    prevNode = root;    <span class="hljs-comment">// 遍历右子树</span>    inOrder(root.right);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 4. 寻找两个正序数组的中位数</title>
    <link href="/2020/10/12/LeetCode-4-median-of-two-sorted-arrays/"/>
    <url>/2020/10/12/LeetCode-4-median-of-two-sorted-arrays/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;    <span class="hljs-keyword">int</span> m = nums1.length, n = nums2.length;    <span class="hljs-keyword">int</span> len = m + n;    <span class="hljs-comment">// nums1, nums2 对应指针</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 上一次遍历到的数，当前遍历到的数</span>    <span class="hljs-keyword">int</span> prev = -<span class="hljs-number">1</span>, cur = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= len / <span class="hljs-number">2</span>; k++) &#123;        prev = cur;        <span class="hljs-comment">// 在两个数组中取小的数往后移</span>        <span class="hljs-keyword">if</span> (i == m) &#123;            <span class="hljs-comment">// nums1 遍历完成</span>            cur = nums2[j++];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n) &#123;            <span class="hljs-comment">// nums2 遍历完成</span>            cur = nums1[i++];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;            cur = nums1[i++];        &#125; <span class="hljs-keyword">else</span> &#123;            cur = nums2[j++];        &#125;    &#125;    <span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> (prev + cur) / <span class="hljs-number">2.0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> cur;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1300. 转变数组后最接近目标值的数组和</title>
    <link href="/2020/10/12/LeetCode-1300-sum-of-mutated-array-closest-to-target/"/>
    <url>/2020/10/12/LeetCode-1300-sum-of-mutated-array-closest-to-target/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">1300. 转变数组后最接近目标值的数组和</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findBestValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;        max = Math.max(max, num);    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = max;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> sum = getSum(arr, mid);        <span class="hljs-keyword">if</span> (sum == target) &#123;            <span class="hljs-keyword">return</span> mid;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 看 mid 和 mid - 1 哪个的和更接近 target</span>            <span class="hljs-keyword">int</span> prev = Math.abs(getSum(arr, mid - <span class="hljs-number">1</span>) - target);            <span class="hljs-keyword">int</span> midVal = Math.abs(sum - target);            <span class="hljs-keyword">if</span> (prev &lt;= midVal) &#123;                right = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> val)</span> </span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;        sum += Math.min(num, val);    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1237. 找出给定方程的正整数解</title>
    <link href="/2020/10/10/LeetCode-1237-find-positive-integer-solution-for-a-given-equation/"/>
    <url>/2020/10/10/LeetCode-1237-find-positive-integer-solution-for-a-given-equation/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/" target="_blank" rel="noopener">1237. 找出给定方程的正整数解</a></p><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSolution(CustomFunction customfunction, <span class="hljs-keyword">int</span> z) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// x: 1 -&gt; z</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= z; i++) &#123;        <span class="hljs-comment">// x: 1 -&gt; z 二分</span>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = z;        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (customfunction.f(i, mid) == z) &#123;                List&lt;Integer&gt; pair = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                pair.add(i);                pair.add(mid);                res.add(pair);                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (customfunction.f(i, mid) &gt; z) &#123;                right = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSolution(CustomFunction customfunction, <span class="hljs-keyword">int</span> z) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> low = <span class="hljs-number">1</span>, high = z;    <span class="hljs-keyword">while</span> (low &lt;= z &amp;&amp; high &gt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">int</span> r = customfunction.f(low, high);        <span class="hljs-keyword">if</span> (r &gt; z) &#123;            high--;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r &lt; z) &#123;            low++;        &#125; <span class="hljs-keyword">else</span> &#123;            List&lt;Integer&gt; pair = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            pair.add(low);            pair.add(high);            res.add(pair);            low++;            high--;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1095. 山脉数组中查找目标值</title>
    <link href="/2020/10/10/LeetCode-1095-find-in-mountain-array/"/>
    <url>/2020/10/10/LeetCode-1095-find-in-mountain-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findInMountainArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = mountainArr.length();        <span class="hljs-comment">// 获取山顶</span>        <span class="hljs-keyword">int</span> top = getTop(len, mountainArr);        <span class="hljs-comment">// 在左边查找</span>        <span class="hljs-keyword">int</span> ascPos = findInAsc(<span class="hljs-number">0</span>, top, target, mountainArr);        <span class="hljs-keyword">if</span> (ascPos != -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> ascPos;        &#125;        <span class="hljs-comment">// 在右边查找</span>        <span class="hljs-keyword">return</span> findInDesc(top, len - <span class="hljs-number">1</span>, target, mountainArr);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findInAsc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">int</span> midVal = mountainArr.get(mid);            <span class="hljs-keyword">if</span> (midVal == target) &#123;                <span class="hljs-keyword">return</span> mid;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midVal &gt; target) &#123;                right = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> mountainArr.get(left) == target ? left : -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findInDesc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">int</span> midVal = mountainArr.get(mid);            <span class="hljs-keyword">if</span> (midVal == target) &#123;                <span class="hljs-keyword">return</span> mid;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midVal &gt; target) &#123;                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                right = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> mountainArr.get(left) == target ? left : -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len, MountainArray mountainArr)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-comment">// 3, 4, 5, 2, 1</span>            <span class="hljs-keyword">if</span> (mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="hljs-number">1</span>)) &#123;                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                right = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 436. 寻找右区间</title>
    <link href="/2020/10/10/LeetCode-436-find-right-interval/"/>
    <url>/2020/10/10/LeetCode-436-find-right-interval/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-right-interval/" target="_blank" rel="noopener">436. 寻找右区间</a></p><ul><li>区间的终点总是大于它的起始点 =&gt; 只需要比较起点。</li><li>区间都不具有相同的起始点 =&gt; 可以保存排序前的<strong>起点</strong>和<strong>索引</strong>的关系。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findRightInterval(<span class="hljs-keyword">int</span>[][] intervals) &#123;    <span class="hljs-keyword">int</span> len = intervals.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] starts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 存储起点</span>        starts[i] = intervals[i][<span class="hljs-number">0</span>];        <span class="hljs-comment">// 存储每个起点的原始位置</span>        map.put(intervals[i][<span class="hljs-number">0</span>], i);    &#125;    Arrays.sort(starts);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 在起点数组中查找起点，该起点 &gt;= 区间 i 的终点</span>        <span class="hljs-keyword">int</span> index = binarySearch(starts, intervals[i][<span class="hljs-number">1</span>]);        res[i] = index == -<span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : map.get(starts[index]);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 查找第一个 &gt;= end 的区间起点</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> starts</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> end</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] starts, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = starts.length;    <span class="hljs-keyword">if</span> (starts[len - <span class="hljs-number">1</span>] &lt; end) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (starts[mid] &lt; end) &#123;            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 275. H 指数 II</title>
    <link href="/2020/10/09/LeetCode-275-h-index-ii/"/>
    <url>/2020/10/09/LeetCode-275-h-index-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/h-index-ii/" target="_blank" rel="noopener">275. H 指数 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] citations)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = citations.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span> || citations[len - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-comment">// 引用次数：citations[h]</span>        <span class="hljs-comment">// 论文数：len - h</span>        <span class="hljs-comment">// h index : (引用次数 &gt;= h 的论文数) &gt;= h 篇</span>        <span class="hljs-keyword">if</span> (citations[mid] &gt;= len - mid) &#123;            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> len - left;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 57 - II. 和为s的连续正数序列</title>
    <link href="/2020/10/09/LeetCode-offer-57-II-he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/"/>
    <url>/2020/10/09/LeetCode-offer-57-II-he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 57 - II. 和为s的连续正数序列</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;    List&lt;<span class="hljs-keyword">int</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = target / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (right &lt;= len) &#123;        sum += right;        right++;        <span class="hljs-keyword">while</span> (sum &gt; target) &#123;            sum -= left;            left++;        &#125;        <span class="hljs-keyword">if</span> (sum == target) &#123;            <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left, j = <span class="hljs-number">0</span>; i &lt; right; i++) &#123;                arr[j++] = i;            &#125;            list.add(arr);        &#125;    &#125;    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()][];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] arr : list) &#123;        res[i++] = arr;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
      <tag>剑指 Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="/2020/10/07/LeetCode-34-find-first-and-last-position-of-element-in-sorted-array/"/>
    <url>/2020/10/07/LeetCode-34-find-first-and-last-position-of-element-in-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;        &#125;        <span class="hljs-keyword">int</span> first = findFirstPos(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>, target);        <span class="hljs-keyword">if</span> (first == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;        &#125;        <span class="hljs-keyword">int</span> last = findLastPos(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>, target);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;first, last&#125;;    &#125;    <span class="hljs-comment">// 1 2 3</span>    <span class="hljs-comment">// 0 1 2</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findFirstPos</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-comment">// 搜索开始位置：更新左边界</span>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;                <span class="hljs-comment">// [mid + 1, right]</span>                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// nums[mid] &gt;= target</span>                <span class="hljs-comment">// [left, mid]</span>                right = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 5 7 7 8 8 10</span>    <span class="hljs-comment">// 0 1 2 3 4  5</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLastPos</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;            <span class="hljs-comment">// 搜索结束位置：更新右边界</span>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;                <span class="hljs-comment">// [left, mid - 1]</span>                right = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// nums[mid] &lt;= target</span>                <span class="hljs-comment">// [mid, right]</span>                left = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 167. 两数之和 II - 输入有序数组</title>
    <link href="/2020/10/06/LeetCode-167-two-sum-ii-input-array-is-sorted/"/>
    <url>/2020/10/06/LeetCode-167-two-sum-ii-input-array-is-sorted/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></p><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> target) &#123;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = numbers.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> sum = numbers[left] + numbers[right];        <span class="hljs-keyword">if</span> (target &gt; sum) &#123;            left++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; sum) &#123;            right--;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];&#125;</code></pre><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> target) &#123;    <span class="hljs-keyword">int</span> len = numbers.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> right = binarySearch(numbers, i + <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>, target - numbers[i]);        <span class="hljs-keyword">if</span> (right != -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;            <span class="hljs-keyword">return</span> mid;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 18. 四数之和</title>
    <link href="/2020/10/05/LeetCode-18-4sum/"/>
    <url>/2020/10/05/LeetCode-18-4sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a><br />固定一个数进行三数之和的查找。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;    Arrays.sort(nums);    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">3</span>; i++) &#123;        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 查找 三数之和</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len - <span class="hljs-number">2</span>; j++) &#123;            <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">int</span> left = j + <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (left &lt; right) &#123;                <span class="hljs-keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];                <span class="hljs-keyword">if</span> (sum == target) &#123;                    res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));                    <span class="hljs-comment">// 跳过重复数字</span>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;                        left++;                    &#125;                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;                        right--;                    &#125;                    left++;                    right--;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;                    right--;                &#125; <span class="hljs-keyword">else</span> &#123;                    left++;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 42. 接雨水</title>
    <link href="/2020/10/05/LeetCode-42-trapping-rain-water/"/>
    <url>/2020/10/05/LeetCode-42-trapping-rain-water/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></p><h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = height.length;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 单调递减栈</span>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;            <span class="hljs-comment">// 栈顶元素本次计算的水，新的栈顶为左边界，i 为右边界</span>            <span class="hljs-comment">// peek() &lt; heightOfTop &lt; i</span>            <span class="hljs-keyword">int</span> top = height[stack.pop()];            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">// 计算 top 上面能放多少水</span>            <span class="hljs-keyword">int</span> h = Math.min(height[i], height[stack.peek()]) - top;            <span class="hljs-keyword">int</span> w = i - stack.peek() - <span class="hljs-number">1</span>;            res += h * w;        &#125;        stack.push(i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><p>分别找到当前列的左右最高点，计算积水。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = height.length;    <span class="hljs-comment">// 最左边和最右边无法保存水，可跳过</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// 找出左边最高的列</span>        <span class="hljs-keyword">int</span> leftMax = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;            leftMax = Math.max(leftMax, height[j]);        &#125;        <span class="hljs-comment">// 找出右边最高的列</span>        <span class="hljs-keyword">int</span> rightMax = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;            rightMax = Math.max(rightMax, height[j]);        &#125;        <span class="hljs-comment">// 当前列均小于 左边和右边时，当前列才能保存水</span>        <span class="hljs-keyword">int</span> minHeight = Math.min(leftMax, rightMax);        <span class="hljs-keyword">if</span> (minHeight &gt; height[i]) &#123;            res += minHeight - height[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = height.length;    <span class="hljs-keyword">int</span>[] leftMax = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-comment">// 计算左边最高</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        leftMax[i] = Math.max(leftMax[i - <span class="hljs-number">1</span>], height[i - <span class="hljs-number">1</span>]);    &#125;    <span class="hljs-comment">// 计算右边最高</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        rightMax[i] = Math.max(rightMax[i + <span class="hljs-number">1</span>], height[i + <span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">int</span> minHeight = Math.min(leftMax[i], rightMax[i]);        <span class="hljs-keyword">if</span> (minHeight &gt; height[i]) &#123;            res += minHeight - height[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>双指针</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 16. 最接近的三数之和</title>
    <link href="/2020/10/04/LeetCode-16-3sum-closest/"/>
    <url>/2020/10/04/LeetCode-16-3sum-closest/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    Arrays.sort(nums);    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> sum = nums[i] + nums[left] + nums[right];            <span class="hljs-keyword">if</span> (sum == target) &#123;                <span class="hljs-keyword">return</span> res;            &#125;            <span class="hljs-keyword">if</span> (Math.abs(target - sum) &lt; Math.abs(target - res)) &#123;                res = sum;            &#125;            <span class="hljs-keyword">if</span> (sum &gt; target) &#123;                right--;            &#125; <span class="hljs-keyword">else</span> &#123;                left++;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 15. 三数之和</title>
    <link href="/2020/10/03/LeetCode-15-3sum/"/>
    <url>/2020/10/03/LeetCode-15-3sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = nums.length;    Arrays.sort(nums);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 重复数字</span>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 当前为正数，则之后都为正数，和不可能为 0</span>        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> sum = nums[left] + nums[right] + nums[i];            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;                res.add(Arrays.asList(nums[i], nums[left], nums[right]));                <span class="hljs-comment">// 去重</span>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;                    left++;                &#125;                <span class="hljs-comment">// 去重</span>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;                    right--;                &#125;                <span class="hljs-comment">// 查找下一个可行解</span>                left++;                right--;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 右值偏大</span>                right--;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 左值偏小</span>                left++;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 11. 盛最多水的容器</title>
    <link href="/2020/10/02/LeetCode-11-container-with-most-water/"/>
    <url>/2020/10/02/LeetCode-11-container-with-most-water/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a><br />面积取决于最低的柱子高度，而每次向内移动宽度一定减小，因此要达到尽可能大的面积，新柱子的最低高度不能小于当前柱子的最低高度。</p><ul><li>若移动高的柱子，高度一定不会超过当前的最低点，面积反而可能减小。</li><li>若移动低的柱子，新的最低高度可能会超过当前最低点，面积才有可能增大。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> area = Math.min(height[left], height[right]) * (right - left);        max = Math.max(max, area);        <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;            left++;        &#125; <span class="hljs-keyword">else</span> &#123;            right--;        &#125;    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 48. 最长不含重复字符的子字符串</title>
    <link href="/2020/09/30/LeetCode-offer-48-zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/"/>
    <url>/2020/09/30/LeetCode-offer-48-zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 48. 最长不含重复字符的子字符串</a></p><h1 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h1><p>记录字符是否出现。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = chars.length;    Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">char</span> c = chars[right];        right++;        <span class="hljs-keyword">while</span> (set.contains(c)) &#123;            set.remove(chars[left]);            left++;        &#125;        set.add(c);        maxLen = Math.max(maxLen, right - left);    &#125;    <span class="hljs-keyword">return</span> maxLen;&#125;</code></pre><h1 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h1><p>记录字符的最后一次出现位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = chars.length;    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">char</span> c = chars[right];        <span class="hljs-keyword">if</span> (map.containsKey(c)) &#123;            left = Math.max(map.get(c) + <span class="hljs-number">1</span>, left);        &#125;        map.put(c, right);        maxLen = Math.max(maxLen, right - left + <span class="hljs-number">1</span>);        right++;    &#125;    <span class="hljs-keyword">return</span> maxLen;&#125;</code></pre><h1 id="数组哈希"><a class="markdownIt-Anchor" href="#数组哈希"></a> 数组哈希</h1><p>记录字符出现次数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];    <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">char</span> c = chars[right];        right++;        <span class="hljs-comment">// 收缩左边界，直到 right 对应字符未出现</span>        <span class="hljs-keyword">while</span> (freq[c] &gt; <span class="hljs-number">0</span>) &#123;            freq[chars[left]]--;            left++;        &#125;        freq[c]++;        maxLen = Math.max(maxLen, right - left);    &#125;    <span class="hljs-keyword">return</span> maxLen;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 995. K 连续位的最小翻转次数</title>
    <link href="/2020/09/30/LeetCode-995-minimum-number-of-k-consecutive-bit-flips/"/>
    <url>/2020/09/30/LeetCode-995-minimum-number-of-k-consecutive-bit-flips/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/" target="_blank" rel="noopener">995. K 连续位的最小翻转次数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (A[i] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// A[i] == 0，但后面没有 K 位，无法翻转</span>        <span class="hljs-keyword">if</span> (i + K &gt; len) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 遇到 0 就反转</span>        count++;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; i + K; j++) &#123;            A[j] ^= <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 以队头元素为起点的子区间无法覆盖到 A[i]</span>        <span class="hljs-keyword">if</span> (!queue.isEmpty() &amp;&amp; queue.peekFirst() + K == i) &#123;            queue.poll();        &#125;        <span class="hljs-comment">// 第 i 个元素需要翻转，往后翻转 K 个元素</span>        <span class="hljs-keyword">if</span> (queue.size() % <span class="hljs-number">2</span> == A[i]) &#123;            <span class="hljs-comment">// 从 A[i] 开始不足 K 个元素</span>            <span class="hljs-keyword">if</span> (i + K &gt; len) &#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;            res++;            queue.offer(i);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1208. 尽可能使字符串相等</title>
    <link href="/2020/09/29/LeetCode-1208-get-equal-substrings-within-budget/"/>
    <url>/2020/09/29/LeetCode-1208-get-equal-substrings-within-budget/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/" target="_blank" rel="noopener">1208. 尽可能使字符串相等</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">equalSubstring</span><span class="hljs-params">(String s, String t, <span class="hljs-keyword">int</span> maxCost)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] sChars = s.toCharArray();    <span class="hljs-keyword">char</span>[] tChars = t.toCharArray();    <span class="hljs-keyword">int</span> len = sChars.length;    <span class="hljs-keyword">int</span>[] costs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        costs[i] = Math.abs(sChars[i] - tChars[i]);    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> cost = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        cost += costs[right];        right++;        <span class="hljs-keyword">if</span> (cost &gt; maxCost) &#123;            cost -= costs[left];            left++;        &#125;        res = Math.max(res, right - left);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1052. 爱生气的书店老板</title>
    <link href="/2020/09/29/LeetCode-1052-grumpy-bookstore-owner/"/>
    <url>/2020/09/29/LeetCode-1052-grumpy-bookstore-owner/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/" target="_blank" rel="noopener">1052. 爱生气的书店老板</a></p><p>计算可补偿的最大值。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSatisfied</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] customers, <span class="hljs-keyword">int</span>[] grumpy, <span class="hljs-keyword">int</span> X)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = customers.length;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> windowComplement = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxComp = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">if</span> (grumpy[right] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 可补充的值</span>            windowComplement += customers[right];        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 原始值</span>            sum += customers[right];        &#125;        right++;        <span class="hljs-comment">// 窗口大小 = X</span>        <span class="hljs-keyword">if</span> (right - left &gt;= X) &#123;            maxComp = Math.max(maxComp, windowComplement);            <span class="hljs-keyword">if</span> (grumpy[left] == <span class="hljs-number">1</span>) &#123;                windowComplement -= customers[left];            &#125;            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> sum + maxComp;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSatisfied</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] customers, <span class="hljs-keyword">int</span>[] grumpy, <span class="hljs-keyword">int</span> X)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = customers.length;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> windowComplement = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxComp = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (grumpy[i] == <span class="hljs-number">0</span>) &#123;            sum += customers[i];            customers[i] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        windowComplement += customers[right];        right++;        <span class="hljs-comment">// 窗口大小 = X</span>        <span class="hljs-keyword">if</span> (right - left &gt;= X) &#123;            maxComp = Math.max(maxComp, windowComplement);            windowComplement -= customers[left];            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> sum + maxComp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1423. 可获得的最大点数</title>
    <link href="/2020/09/29/LeetCode-1423-maximum-points-you-can-obtain-from-cards/"/>
    <url>/2020/09/29/LeetCode-1423-maximum-points-you-can-obtain-from-cards/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/" target="_blank" rel="noopener">1423. 可获得的最大点数</a></p><p>左边取 <code>i</code> 个，则右边取 <code>k - i</code> 个，依次比较最大值。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cardPoints, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = cardPoints.length;    <span class="hljs-keyword">int</span> leftSum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> rightSum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 右边 k 个之和</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= len - k; i--) &#123;        rightSum += cardPoints[i];    &#125;    <span class="hljs-comment">// 左边取 0 个</span>    <span class="hljs-keyword">int</span> max = rightSum;    <span class="hljs-comment">// 从左边开始取 1 ~ k 个</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;        leftSum += cardPoints[i];        <span class="hljs-comment">// 减去右边多的部分: 1 -&gt; k - 1, 2 -&gt; k - 2......</span>        rightSum -= cardPoints[len - k + i];        max = Math.max(max, leftSum + rightSum);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cardPoints, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p : cardPoints) &#123;            sum += p;        &#125;        <span class="hljs-keyword">int</span> len = cardPoints.length;        <span class="hljs-keyword">int</span> curSum = <span class="hljs-number">0</span>;        <span class="hljs-comment">// len - k 为需要排除的元素个数，剩下的即为需要的元素</span>        <span class="hljs-keyword">int</span> windowSize = len - k;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; windowSize; i++) &#123;            curSum += cardPoints[i];        &#125;        <span class="hljs-keyword">int</span> res = sum - curSum;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = windowSize; i &lt; len; i++) &#123;            <span class="hljs-comment">// 每次取 right，移除 left</span>            curSum = curSum + cardPoints[i] - cardPoints[i - windowSize];            <span class="hljs-comment">// 对除了 window 内的元素求和，取最大值</span>            res = Math.max(res, sum - curSum);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 59 - II. 队列的最大值</title>
    <link href="/2020/09/29/LeetCode-offer-59-II-dui-lie-de-zui-da-zhi-lcof/"/>
    <url>/2020/09/29/LeetCode-offer-59-II-dui-lie-de-zui-da-zhi-lcof/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - II. 队列的最大值</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> </span>&#123;    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; queue;    <span class="hljs-keyword">private</span> ArrayDeque&lt;Integer&gt; deque;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 保存入队元素</span>        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-comment">// 最大值队列</span>        deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> deque.isEmpty() ? -<span class="hljs-number">1</span> : deque.peekFirst();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        queue.addLast(value);        <span class="hljs-comment">// 更新最大值</span>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value) &#123;            deque.pollLast();        &#125;        deque.addLast(value);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> front = queue.isEmpty() ? -<span class="hljs-number">1</span> : queue.pollFirst();        <span class="hljs-comment">// 出队元素为最大值，则从最大值队列中出队</span>        <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst().equals(front)) &#123;            deque.pollFirst();        &#125;        <span class="hljs-keyword">return</span> front;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
      <tag>队列</tag>
      
      <tag>剑指 Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1004. 最大连续1的个数 III</title>
    <link href="/2020/09/28/LeetCode-1004-max-consecutive-ones-iii/"/>
    <url>/2020/09/28/LeetCode-1004-max-consecutive-ones-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener">1004. 最大连续1的个数 III</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestOnes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> windowCount = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">if</span> (A[right] == <span class="hljs-number">1</span>) &#123;            windowCount++;        &#125;        right++;        <span class="hljs-comment">// 可替换的 0 个数 &gt; K, 收缩左边界</span>        <span class="hljs-keyword">while</span> (right - left - windowCount &gt; K) &#123;            <span class="hljs-keyword">if</span> (A[left] == <span class="hljs-number">1</span>) &#123;                windowCount--;            &#125;            left++;        &#125;        max = Math.max(max, right - left);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 485. 最大连续1的个数</title>
    <link href="/2020/09/28/LeetCode-485-max-consecutive-ones/"/>
    <url>/2020/09/28/LeetCode-485-max-consecutive-ones/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">485. 最大连续1的个数</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxConsecutiveOnes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;            res = Math.max(res, i - left - <span class="hljs-number">1</span>);            left = i;        &#125;    &#125;    res = Math.max(res, len - left - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1456. 定长子串中元音的最大数目</title>
    <link href="/2020/09/28/LeetCode-1456-maximum-number-of-vowels-in-a-substring-of-given-length/"/>
    <url>/2020/09/28/LeetCode-1456-maximum-number-of-vowels-in-a-substring-of-given-length/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">1456. 定长子串中元音的最大数目</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxVowels</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span> validLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">char</span>[] vowels = &#123;<span class="hljs-string">'a'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'u'</span>&#125;;    <span class="hljs-keyword">int</span>[] needs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : vowels) &#123;        needs[c - <span class="hljs-string">'a'</span>]++;    &#125;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">int</span> cur = chars[right] - <span class="hljs-string">'a'</span>;        <span class="hljs-comment">// 当前字符为元音</span>        <span class="hljs-keyword">if</span> (needs[cur] &gt; <span class="hljs-number">0</span>) &#123;            validLen++;        &#125;        right++;        <span class="hljs-comment">// 长度满足要求，寻找最优解，收缩左边界</span>        <span class="hljs-keyword">if</span> (right - left == k) &#123;            max = Math.max(max, validLen);            <span class="hljs-keyword">int</span> leftPos = chars[left] - <span class="hljs-string">'a'</span>;            <span class="hljs-comment">// 当前字符为元音</span>            <span class="hljs-keyword">if</span> (needs[leftPos] &gt; <span class="hljs-number">0</span>) &#123;                validLen--;            &#125;            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
    <link href="/2020/09/28/LeetCode-offer-59-I-hua-dong-chuang-kou-de-zui-da-zhi-lcof/"/>
    <url>/2020/09/28/LeetCode-offer-59-I-hua-dong-chuang-kou-de-zui-da-zhi-lcof/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;&#125;;    &#125;    ArrayDeque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len - k + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt; nums[i]) &#123;            queue.removeLast();        &#125;        queue.addLast(i);        <span class="hljs-keyword">if</span> (queue.peekFirst() &lt;= i - k) &#123;            queue.removeFirst();        &#125;        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;            res[j++] = nums[queue.peekFirst()];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
      <tag>队列</tag>
      
      <tag>剑指 Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 978. 最长湍流子数组</title>
    <link href="/2020/09/27/LeetCode-978-longest-turbulent-subarray/"/>
    <url>/2020/09/27/LeetCode-978-longest-turbulent-subarray/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/" target="_blank" rel="noopener">978. 最长湍流子数组</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxTurbulenceSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;    <span class="hljs-comment">// [9,4,2,10,7,8,8,1,9]</span>    <span class="hljs-comment">// dp[i]: 以第 i 个元素结尾的最大子数组长度</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">      if A[i] == A[i - 1]</span><span class="hljs-comment">        dp[i] = 1</span><span class="hljs-comment">      if A[i - 2], A[i - 1] 上升（下降）</span><span class="hljs-comment">        if A[i - 1], A[i] 下降（上升）</span><span class="hljs-comment">           dp[i] = dp[i - 1] + 1</span><span class="hljs-comment">        else if A[i - 1], A[i] 上升（下降）</span><span class="hljs-comment">           dp[i] = 2</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    Arrays.fill(dp, <span class="hljs-number">1</span>);    dp[<span class="hljs-number">1</span>] = A[<span class="hljs-number">1</span>] == A[<span class="hljs-number">0</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> max = dp[<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 上升</span>        <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">2</span>] &lt; A[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// 下降</span>            <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] &gt; A[i]) &#123;                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] &lt; A[i]) &#123;                dp[i] = <span class="hljs-number">2</span>;            &#125;        &#125;        <span class="hljs-comment">// 下降</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">2</span>] &gt; A[i - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// 上升</span>            <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] &lt; A[i]) &#123;                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>] &gt; dp[i]) &#123;                dp[i] = <span class="hljs-number">2</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// A[i - 2] == A[i - 1]</span>            dp[i] = (A[i] == A[i - <span class="hljs-number">1</span>]) ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;        &#125;        max = Math.max(max, dp[i]);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxTurbulenceSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = arr.length;        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> len;        &#125;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>] = arr[<span class="hljs-number">0</span>] == arr[<span class="hljs-number">1</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> res = dp[<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">boolean</span> downUp = arr[i - <span class="hljs-number">2</span>] &gt; arr[i - <span class="hljs-number">1</span>] &amp;&amp; arr[i - <span class="hljs-number">1</span>] &lt; arr[i];            <span class="hljs-keyword">boolean</span> upDown = arr[i - <span class="hljs-number">2</span>] &lt; arr[i - <span class="hljs-number">1</span>] &amp;&amp; arr[i - <span class="hljs-number">1</span>] &gt; arr[i];            <span class="hljs-keyword">if</span> (downUp || upDown) &#123;                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">// 相等时只能为 1，其他情况不满足湍流定义时为 2</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i - <span class="hljs-number">1</span>] == arr[i]) &#123;                dp[i] = <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                dp[i] = <span class="hljs-number">2</span>;            &#125;            res = Math.max(res, dp[i]);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><h1 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxTurbulenceSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> maxLen = A[<span class="hljs-number">0</span>] == A[<span class="hljs-number">1</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-keyword">if</span> (A[right] == A[right - <span class="hljs-number">1</span>]) &#123;            left = right;            right++;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// up</span>        <span class="hljs-keyword">if</span> (A[right - <span class="hljs-number">2</span>] &lt; A[right - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// up</span>            <span class="hljs-keyword">if</span> (A[right - <span class="hljs-number">1</span>] &lt; A[right]) &#123;                left = right - <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-comment">// down</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[right - <span class="hljs-number">2</span>] &gt; A[right - <span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// down</span>            <span class="hljs-keyword">if</span> (A[right - <span class="hljs-number">1</span>] &gt; A[right]) &#123;                left = right - <span class="hljs-number">1</span>;            &#125;        &#125;        right++;        maxLen = Math.max(maxLen, right - left);    &#125;    <span class="hljs-keyword">return</span> maxLen;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 643. 子数组最大平均数 I</title>
    <link href="/2020/09/25/LeetCode-643-maximum-average-subarray-i/"/>
    <url>/2020/09/25/LeetCode-643-maximum-average-subarray-i/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener">643. 子数组最大平均数 I</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMaxAverage</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 计算前 k 个子数组和</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;        sum += nums[i];    &#125;    <span class="hljs-keyword">int</span> res = sum;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; nums.length; i++) &#123;        sum = sum - nums[i - k] + nums[i];        res = Math.max(res, sum);    &#125;    <span class="hljs-keyword">return</span> res * <span class="hljs-number">1.0</span> / k;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 567. 字符串的排列</title>
    <link href="/2020/09/25/LeetCode-567-permutation-in-string/"/>
    <url>/2020/09/25/LeetCode-567-permutation-in-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] s1Char = s1.toCharArray();        <span class="hljs-keyword">char</span>[] s2Char = s2.toCharArray();        <span class="hljs-keyword">int</span> len1 = s1Char.length;        <span class="hljs-keyword">int</span> len2 = s2Char.length;        <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-comment">// 统计需要出现的字符频率</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s1Char) &#123;            counts[c - <span class="hljs-string">'a'</span>]++;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (right &lt; len2) &#123;            <span class="hljs-keyword">int</span> i = s2Char[right] - <span class="hljs-string">'a'</span>;            counts[i]--;            right++;            <span class="hljs-comment">// 若 counts[i] &lt; 0，表示 i 出现的次数过多</span>            <span class="hljs-comment">// 左移窗口，直到 counts[i] == 0</span>            <span class="hljs-keyword">while</span> (counts[i] &lt; <span class="hljs-number">0</span>) &#123;                counts[s2Char[left] - <span class="hljs-string">'a'</span>]++;                left++;            &#125;            <span class="hljs-keyword">if</span> (right - left == len1) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 424. 替换后的最长重复字符</title>
    <link href="/2020/09/24/LeetCode-424-longest-repeating-character-replacement/"/>
    <url>/2020/09/24/LeetCode-424-longest-repeating-character-replacement/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">424. 替换后的最长重复字符</a></p><p>实际上，窗口始终增大，因为要求最长子串，窗口内的字符出现次数在窗口收缩一位后，没有必要进行更新。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-keyword">int</span> len = str.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 窗口内字符的出现次数</span>    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-comment">// 窗口内同一个字符的最多出现次数</span>    <span class="hljs-keyword">int</span> maxCount = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        counts[str[right] - <span class="hljs-string">'A'</span>]++;        <span class="hljs-comment">// 只增不减，窗口内字符不一定满足要求，但窗口长度一定最长</span>        <span class="hljs-comment">// 只有当 maxCount 变大时，才会增大窗口长度</span>        maxCount = Math.max(maxCount, counts[str[right] - <span class="hljs-string">'A'</span>]);        right++;        <span class="hljs-comment">// 若窗口内 c 字符出现 maxCount，最多只能替换 k 个其他字符为 c</span>        <span class="hljs-comment">// 则最大长度 maxCount + k &lt; 窗口大小时（其他字符出现次数 &gt; k）需要左移</span>        <span class="hljs-comment">// if (right - left - maxCount &gt; k) &#123;</span>        <span class="hljs-keyword">if</span> (maxCount + k &lt; right - left) &#123;            counts[str[left] - <span class="hljs-string">'A'</span>]--;            left++;        &#125;        res = Math.max(res, right - left);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 239. 滑动窗口最大值</title>
    <link href="/2020/09/24/LeetCode-239-sliding-window-maximum/"/>
    <url>/2020/09/24/LeetCode-239-sliding-window-maximum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len - k + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 单调递减队列：队首 &gt; 队尾</span>    <span class="hljs-comment">// 维护窗口内的最大值，当队首不在窗口内时则移除</span>    ArrayDeque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 移除队列中比当前值小的元素</span>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt; nums[i]) &#123;            queue.removeLast();        &#125;        <span class="hljs-comment">// 添加当前元素</span>        queue.add(i);        <span class="hljs-comment">// 判断队首值是否在窗口内，若不在则移除</span>        <span class="hljs-keyword">if</span> (queue.getFirst() &lt;= i - k) &#123;            queue.removeFirst();        &#125;        <span class="hljs-comment">// 形成有效窗口大小</span>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;            res[j++] = nums[queue.getFirst()];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="大顶堆超时"><a class="markdownIt-Anchor" href="#大顶堆超时"></a> 大顶堆（超时）</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = nums.length;    PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len - k + <span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-comment">// 可形成窗口</span>        <span class="hljs-keyword">if</span> (maxHeap.size() &gt;= k) &#123;            <span class="hljs-comment">// 删除不在窗口内的左边界</span>            maxHeap.remove(nums[right - k]);        &#125;        <span class="hljs-comment">// 添加当前元素</span>        maxHeap.add(nums[right]);        <span class="hljs-keyword">if</span> (right &gt;= k - <span class="hljs-number">1</span>) &#123;            res[i++] = maxHeap.peek();        &#125;        right++;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 209. 长度最小的子数组</title>
    <link href="/2020/09/24/LeetCode-209-minimum-size-subarray-sum/"/>
    <url>/2020/09/24/LeetCode-209-minimum-size-subarray-sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></p><h1 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> minLen = Integer.MAX_VALUE;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; len) &#123;        <span class="hljs-comment">// 计算前缀和</span>        sum += nums[right];        right++;        <span class="hljs-comment">// 当前缀和 &gt; target，尝试右移 left</span>        <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;            <span class="hljs-comment">// 更新最小长度</span>            <span class="hljs-keyword">if</span> (right - left &lt; minLen) &#123;                minLen = right - left;            &#125;            <span class="hljs-comment">// 右移 left 之前要减去 left 对应的值</span>            sum -= nums[left];            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : minLen;&#125;</code></pre><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 计算前缀和数组</span>    <span class="hljs-keyword">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    preSum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        preSum[i] = nums[i] + preSum[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">int</span> minLen = Integer.MAX_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> s1 = s - nums[i];        <span class="hljs-comment">// preSum[i.....j]</span>        <span class="hljs-comment">// 找到一个 preSum[j]，使得 preSum[j] - preSum[i] &gt;= s</span>        <span class="hljs-keyword">int</span> j = binarySearch(preSum, i, len - <span class="hljs-number">1</span>, s1 + preSum[i]);        <span class="hljs-keyword">if</span> (j != -<span class="hljs-number">1</span>) &#123;            minLen = Math.min(minLen, j - i + <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : minLen;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preSum, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">int</span> mid = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;        mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (preSum[mid] == target) &#123;            <span class="hljs-keyword">return</span> mid;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (preSum[mid] &gt; target) &#123;            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">// 找不到 == target 的 preSum[j]，则返回第一个 &gt; target 的元素</span>    <span class="hljs-keyword">return</span> preSum[mid] &gt; target ? mid : -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 76. 最小覆盖子串</title>
    <link href="/2020/09/23/LeetCode-76-minimum-window-substring/"/>
    <url>/2020/09/23/LeetCode-76-minimum-window-substring/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></p><p>使用一个计数器统计窗口内目标字符的出现次数，当满足要求时，移动 left，并更新最小长度，若移除的字符为目标字符，则计数器也要减小。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] sChar = s.toCharArray();    <span class="hljs-keyword">char</span>[] tChar = t.toCharArray();    <span class="hljs-keyword">int</span> sLen = s.length();    <span class="hljs-keyword">int</span> tLen = t.length();    <span class="hljs-comment">// 只统计窗口内目标字符的出现次数</span>    <span class="hljs-keyword">int</span>[] window = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];    <span class="hljs-keyword">int</span>[] needs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : tChar) &#123;        needs[c]++;    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, begin = <span class="hljs-number">0</span>, minLen = sLen + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 滑动窗口内包含 t 中字符的个数</span>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; sLen) &#123;        <span class="hljs-keyword">char</span> c = sChar[right];        <span class="hljs-comment">// 当前字符不在 t 中，right 向右移动</span>        <span class="hljs-keyword">if</span> (needs[c] == <span class="hljs-number">0</span>) &#123;            right++;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 统计窗口中目标字符的长度</span>        <span class="hljs-keyword">if</span> (window[c] &lt; needs[c]) &#123;            count++;        &#125;        <span class="hljs-comment">// 更新窗口中目标字符出现次数</span>        window[c]++;        right++;        <span class="hljs-comment">// 有效字符个数满足要求</span>        <span class="hljs-comment">// [left, right)</span>        <span class="hljs-keyword">while</span> (count == tLen) &#123;            <span class="hljs-comment">// 更新最小长度</span>            <span class="hljs-keyword">if</span> (right - left &lt; minLen) &#123;                minLen = right - left;                begin = left;            &#125;            <span class="hljs-comment">// 左边需要移除的字符</span>            <span class="hljs-keyword">char</span> leftChar = sChar[left];            <span class="hljs-comment">// 移除的字符不在目标字符中，则直接移动 left</span>            <span class="hljs-keyword">if</span> (needs[leftChar] == <span class="hljs-number">0</span>) &#123;                left++;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 移除的字符出现的目标字符中，则减少有效字符长度</span>            <span class="hljs-keyword">if</span> (window[leftChar] == needs[leftChar]) &#123;                count--;            &#125;            window[leftChar]--;            left++;        &#125;    &#125;    <span class="hljs-keyword">if</span> (minLen == sLen + <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    <span class="hljs-keyword">return</span> s.substring(begin, begin + minLen);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 283. 移动零</title>
    <link href="/2020/09/22/LeetCode-283-move-zeroes/"/>
    <url>/2020/09/22/LeetCode-283-move-zeroes/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a><br />统计非 0 元素的个数，若 <code>nums[i] != 0</code> 则进行交换。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">// 非 0 元素的个数，nums[0:j) != 0</span>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">int</span> t = nums[i];                nums[i] = nums[j];                nums[j] = t;                j++;            &#125;        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 75. 颜色分类</title>
    <link href="/2020/09/22/LeetCode-75-sort-colors/"/>
    <url>/2020/09/22/LeetCode-75-sort-colors/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 0,0,0,.zero.1,1,1,1,1.two.2,2,2,2,2,len</span>    <span class="hljs-comment">// [0, zero) 0</span>    <span class="hljs-comment">// [zero, i) 1</span>    <span class="hljs-comment">// [two, len) 2</span>    <span class="hljs-comment">// `0` 的边界从 0 开始</span>    <span class="hljs-keyword">int</span> zero = <span class="hljs-number">0</span>;    <span class="hljs-comment">// `2` 的边界从最后一个元素开始</span>    <span class="hljs-keyword">int</span> two = len - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 遍历起点</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-comment">// two 位置上的元素还不确定，&gt; two 的元素都是 `2`</span>    <span class="hljs-comment">// 所以 i 需要遍历到 two</span>    <span class="hljs-keyword">while</span> (i &lt;= two) &#123;        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;            swap(nums, i, zero);            zero++;            i++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;            i++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">2</span>) &#123;            <span class="hljs-comment">// 此时不需要 i++，否则交换过来的 nums[i] 未判断</span>            swap(nums, i, two);            two--;        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 451. 根据字符出现频率排序</title>
    <link href="/2020/09/21/LeetCode-451-sort-characters-by-frequency/"/>
    <url>/2020/09/21/LeetCode-451-sort-characters-by-frequency/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">451. 根据字符出现频率排序</a></p><h1 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">frequencySort</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    List&lt;Character&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        <span class="hljs-keyword">if</span> (!list.contains(c)) &#123;            list.add(c);        &#125;        map.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);    &#125;    list.sort((o1, o2) -&gt; map.get(o2) - map.get(o1));    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : list) &#123;        <span class="hljs-keyword">int</span> count = map.get(c);        <span class="hljs-keyword">while</span> (count-- &gt; <span class="hljs-number">0</span>) &#123;            sb.append(c);        &#125;    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre><h1 id="大顶堆"><a class="markdownIt-Anchor" href="#大顶堆"></a> 大顶堆</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">frequencySort</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        map.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);    &#125;    PriorityQueue&lt;Character&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; map.get(o2) - map.get(o1));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        <span class="hljs-keyword">if</span> (!maxHeap.contains(c)) &#123;            maxHeap.add(c);        &#125;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">while</span> (!maxHeap.isEmpty()) &#123;        <span class="hljs-keyword">char</span> key = maxHeap.poll();        <span class="hljs-keyword">int</span> count = map.get(key);        <span class="hljs-keyword">while</span> (count-- &gt; <span class="hljs-number">0</span>) &#123;            sb.append(key);        &#125;    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 189. 旋转数组</title>
    <link href="/2020/09/21/LeetCode-189-rotate-array/"/>
    <url>/2020/09/21/LeetCode-189-rotate-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. 旋转数组</a></p><h1 id="三次翻转"><a class="markdownIt-Anchor" href="#三次翻转"></a> 三次翻转</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 每次反转都有 k % n 个 数字被移动到前部</span>    k = k % len;    <span class="hljs-comment">// 全部反转</span>    reverse(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 反转前 k 个</span>    reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 反转 len - k 个</span>    reverse(nums, k, len - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">while</span> (start &lt; end) &#123;        <span class="hljs-keyword">int</span> t = nums[start];        nums[start] = nums[end];        nums[end] = t;        start++;        end--;    &#125;&#125;</code></pre><h1 id="依次移动"><a class="markdownIt-Anchor" href="#依次移动"></a> 依次移动</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;        <span class="hljs-keyword">int</span> end = nums[len - <span class="hljs-number">1</span>];        <span class="hljs-comment">// 每个元素依次后移</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = len - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--) &#123;            nums[j] = nums[j - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-comment">// 末尾元素移到前面</span>        nums[<span class="hljs-number">0</span>] = end;    &#125;&#125;</code></pre><h1 id="环形移动"><a class="markdownIt-Anchor" href="#环形移动"></a> 环形移动</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> placed = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (placed &lt; len) &#123;        <span class="hljs-keyword">int</span> cur = start;        <span class="hljs-keyword">int</span> curVal = nums[cur];        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-comment">// cur 的目标位置</span>            <span class="hljs-keyword">int</span> next = (cur + k) % len;            <span class="hljs-keyword">int</span> nextVal = nums[next];            nums[next] = curVal;            <span class="hljs-comment">// 下一轮放置 next</span>            cur = next;            curVal = nextVal;            placed++;        &#125; <span class="hljs-keyword">while</span> (cur != start);        <span class="hljs-comment">// cur == start，放置下一个位置</span>        start++;        System.out.println(start);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 88. 合并两个有序数组</title>
    <link href="/2020/09/20/LeetCode-88-merge-sorted-array/"/>
    <url>/2020/09/20/LeetCode-88-merge-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> k = m + n - <span class="hljs-number">1</span>;    m--;    n--;    <span class="hljs-keyword">while</span> (m &gt;= <span class="hljs-number">0</span> &amp;&amp; n &gt;= <span class="hljs-number">0</span>) &#123;        nums1[k--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];    &#125;    <span class="hljs-keyword">while</span> (n &gt;= <span class="hljs-number">0</span>) &#123;        nums1[k--] = nums2[n--];    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            nums1[m++] = nums2[i];        &#125;        Arrays.sort(nums1);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 66. 加一</title>
    <link href="/2020/09/19/LeetCode-66-plus-one/"/>
    <url>/2020/09/19/LeetCode-66-plus-one/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. 加一</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] plusOne(<span class="hljs-keyword">int</span>[] digits) &#123;    <span class="hljs-keyword">int</span> len = digits.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        digits[i]++;        <span class="hljs-comment">// 超过 10，则对 10 取余，下一位进位</span>        <span class="hljs-keyword">if</span> (digits[i] &gt;= <span class="hljs-number">10</span>) &#123;            digits[i] = digits[i] % <span class="hljs-number">10</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 不超过 10，返回结果</span>            <span class="hljs-keyword">return</span> digits;        &#125;    &#125;    <span class="hljs-comment">// 第一位也超过 10，则长度 + 1，如 999</span>    <span class="hljs-keyword">int</span>[] newDigits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    newDigits[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> newDigits;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 27. 移除元素</title>
    <link href="/2020/09/18/LeetCode-27-remove-element/"/>
    <url>/2020/09/18/LeetCode-27-remove-element/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; len) &#123;        <span class="hljs-keyword">if</span> (nums[i] != val) &#123;            nums[j++] = nums[i];        &#125;        i++;    &#125;    <span class="hljs-keyword">return</span> j;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 26. 删除排序数组中的重复项</title>
    <link href="/2020/09/18/LeetCode-26-remove-duplicates-from-sorted-array/"/>
    <url>/2020/09/18/LeetCode-26-remove-duplicates-from-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (i &lt; len) &#123;        <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;            i++;        &#125; <span class="hljs-keyword">else</span> &#123;            nums[j++] = nums[i++];        &#125;    &#125;    <span class="hljs-keyword">return</span> j;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 315. 计算右侧小于当前元素的个数</title>
    <link href="/2020/09/17/LeetCode-315-count-of-smaller-numbers-after-self/"/>
    <url>/2020/09/17/LeetCode-315-count-of-smaller-numbers-after-self/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></p><p>利用索引数组，对索引数组排序，就可根据索引保存对应位置的逆序数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">countSmaller</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-comment">// 索引数组</span>    <span class="hljs-keyword">int</span>[] indexes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-comment">// 保存每个位置的逆序数</span>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        indexes[i] = i;    &#125;    mergeSort(indexes, nums, res, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> count : res) &#123;        list.add(count);    &#125;    <span class="hljs-keyword">return</span> list;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] indexes, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span>[] res, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;    mergeSort(indexes, nums, res, left, mid);    mergeSort(indexes, nums, res, mid + <span class="hljs-number">1</span>, right);    <span class="hljs-keyword">if</span> (nums[indexes[mid]] &lt;= nums[indexes[mid + <span class="hljs-number">1</span>]]) &#123;        <span class="hljs-keyword">return</span>;    &#125;    mergeAndCountSmaller(indexes, nums, res, left, mid, right);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeAndCountSmaller</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] indexes, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span>[] res, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = right - left + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        <span class="hljs-comment">// 比较索引对应位置上的数</span>        <span class="hljs-keyword">if</span> (nums[indexes[i]] &lt;= nums[indexes[j]]) &#123;            <span class="hljs-comment">// 更新比 nums[idx[i]] 小的数</span>            res[indexes[i]] += j - mid - <span class="hljs-number">1</span>;            tmp[k++] = indexes[i++];        &#125; <span class="hljs-keyword">else</span> &#123;            tmp[k++] = indexes[j++];        &#125;    &#125;    <span class="hljs-comment">// 合并剩下的数</span>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        <span class="hljs-comment">// 左边还有剩余，说明右边比它小的都已经归并回去了</span>        res[indexes[i]] += j - mid - <span class="hljs-number">1</span>;        tmp[k++] = indexes[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= right) &#123;        tmp[k++] = indexes[j++];    &#125;    System.arraycopy(tmp, <span class="hljs-number">0</span>, indexes, left, len);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 442. 数组中重复的数据</title>
    <link href="/2020/09/16/LeetCode-442-find-all-duplicates-in-an-array/"/>
    <url>/2020/09/16/LeetCode-442-find-all-duplicates-in-an-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">442. 数组中重复的数据</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">while</span> (nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) &#123;            swap(nums, i, nums[i] - <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;            res.add(nums[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = nums[i];    nums[i] = nums[j];    nums[j] = t;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 448. 找到所有数组中消失的数字</title>
    <link href="/2020/09/16/LeetCode-448-find-all-numbers-disappeared-in-an-array/"/>
    <url>/2020/09/16/LeetCode-448-find-all-numbers-disappeared-in-an-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = nums.length;    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        counts[num - <span class="hljs-number">1</span>]++;    &#125;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">if</span> (counts[i] == <span class="hljs-number">0</span>) &#123;            res.add(i + <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 41. 缺失的第一个正数</title>
    <link href="/2020/09/16/LeetCode-41-first-missing-positive/"/>
    <url>/2020/09/16/LeetCode-41-first-missing-positive/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a></p><h1 id="哈希"><a class="markdownIt-Anchor" href="#哈希"></a> 哈希</h1><p>空间不符合</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        map.put(num, <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len + <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">if</span> (!map.containsKey(i)) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><p>时间不符合</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    quickSort(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;        <span class="hljs-keyword">int</span> pos = binarySearch(i, nums);        <span class="hljs-keyword">if</span> (pos == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;&#125;</code></pre><h1 id="原地哈希"><a class="markdownIt-Anchor" href="#原地哈希"></a> 原地哈希</h1><p>第 i 个位置存放的数 = i + 1</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// nums[i] = i + 1</span>        <span class="hljs-comment">// 未出现的数一定在 [1, len + 1]</span>        <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) &#123;            swap(nums, i, nums[i] - <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-comment">// 当 第 i 个位置上的数不是 i + 1 时，说明 i + 1 没有出现过</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = nums[i];    nums[i] = nums[j];    nums[j] = t;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 215. 数组中的第K个最大元素</title>
    <link href="/2020/09/15/LeetCode-215-kth-largest-element-in-an-array/"/>
    <url>/2020/09/15/LeetCode-215-kth-largest-element-in-an-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></p><h1 id="快排"><a class="markdownIt-Anchor" href="#快排"></a> 快排</h1><p>思想：排序后第 <code>k</code> 个最大元素位置 <code>= len - k</code>，每次 <code>partition</code> 后，都会将 <code>pivot</code> 移动到其最终位置，此时就可比较该位置是否是目标位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 排序后第 k 大的数所在位置</span>    <span class="hljs-keyword">int</span> target = len - k;    <span class="hljs-keyword">return</span> quickSort(nums, target, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> pivotPos = partition(nums, left, right);    <span class="hljs-comment">// 找到目标位置，返回</span>    <span class="hljs-keyword">if</span> (pivotPos == target) &#123;        <span class="hljs-keyword">return</span> nums[target];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivotPos &gt; target) &#123;        <span class="hljs-comment">// 比目标位置大，则往前查找</span>        <span class="hljs-keyword">return</span> quickSort(nums, target, left, pivotPos - <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> quickSort(nums, target, pivotPos + <span class="hljs-number">1</span>, right);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> pivot = nums[left];    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= pivot) &#123;            right--;        &#125;        nums[left] = nums[right];        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= pivot) &#123;            left++;        &#125;        nums[right] = nums[left];    &#125;    nums[left] = pivot;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><h1 id="优先队列"><a class="markdownIt-Anchor" href="#优先队列"></a> 优先队列</h1><p>小顶堆</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-comment">// 小顶堆 =&gt; 弹出比 目标小的 len - k 个元素，堆顶即为第 k 大</span>    PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        minHeap.add(num);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - k; i++) &#123;        minHeap.poll();    &#125;    <span class="hljs-keyword">return</span> minHeap.peek();&#125;</code></pre><p>大顶堆</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">// 大顶堆 =&gt; 弹出比 目标大的 k - 1 个元素，堆顶即为第 k 大</span>    PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(len, (a, b) -&gt; b - a);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        maxHeap.add(num);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++) &#123;        maxHeap.poll();    &#125;    <span class="hljs-keyword">return</span> maxHeap.peek();&#125;</code></pre><h1 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h1><p>每次调整都把最大的元素放到后面，因此要找到第 <code>K</code> 大的元素只需要遍历 <code>K</code> 次。</p><p>或者：使用小顶堆</p><ol><li>对 <code>K</code> 个元素先建堆</li><li>遍历剩下的元素，若大于堆顶，则加入堆并调整。</li><li>堆顶元素即为第 <code>K</code> 大的元素</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-comment">// 只要排序到倒数第 K 个元素</span>    heapSort(nums, nums.length - <span class="hljs-number">1</span>, nums.length - k);    <span class="hljs-keyword">return</span> nums[nums.length - k];&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-comment">// 建立初始堆</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = end / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        shiftDown(nums, i, end);    &#125;    <span class="hljs-comment">// 对 [target:end] 建立大顶堆</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = end; i &gt;= target; i--) &#123;        <span class="hljs-comment">// 堆顶为当前最大，交换到后面</span>        swap(nums, i, <span class="hljs-number">0</span>);        <span class="hljs-comment">// 每次调整堆顶</span>        shiftDown(nums, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shiftDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-comment">// 向下调整</span>    <span class="hljs-keyword">while</span> (i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= end) &#123;        <span class="hljs-comment">// 左孩子</span>        <span class="hljs-keyword">int</span> child = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        <span class="hljs-comment">// 左孩子 &lt; 右孩子，比较右孩子</span>        <span class="hljs-keyword">if</span> (child + <span class="hljs-number">1</span> &lt;= end &amp;&amp; nums[child] &lt; nums[child + <span class="hljs-number">1</span>]) &#123;            child++;        &#125;        <span class="hljs-comment">// 当前元素 &lt; 某个孩子节点，则交换并调整交换后的孩子节点</span>        <span class="hljs-keyword">if</span> (nums[i] &lt; nums[child]) &#123;            swap(nums, i, child);        &#125;        <span class="hljs-comment">// 当前元素已经有序，不需要调整</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;        i = child;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = nums[i];    nums[i] = nums[j];    nums[j] = t;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 51. 数组中的逆序对</title>
    <link href="/2020/09/14/LeetCode-offer-51-shu-zu-zhong-de-ni-xu-dui-lcof/"/>
    <url>/2020/09/14/LeetCode-offer-51-shu-zu-zhong-de-ni-xu-dui-lcof/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">剑指 Offer 51. 数组中的逆序对</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">return</span> reverse(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> leftPairs = reverse(nums, left, mid);    <span class="hljs-keyword">int</span> rightPairs = reverse(nums, mid + <span class="hljs-number">1</span>, right);    <span class="hljs-keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="hljs-number">1</span>]) &#123;        <span class="hljs-keyword">return</span> leftPairs + rightPairs;    &#125;    <span class="hljs-comment">// 在右区间的元素合并时，计算大于该元素的个数</span>    <span class="hljs-comment">// 左区间的所有元素都大于该元素，则逆序数 = 左区间长度 = mid - i + 1</span>    <span class="hljs-keyword">int</span> crossPairs = mergeAndCount(nums, left, mid, right);    <span class="hljs-keyword">return</span> leftPairs + crossPairs + rightPairs;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mergeAndCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = right - left + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;    <span class="hljs-comment">// [left, mid] [mid + 1, right]</span>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;            tmp[k++] = nums[j++];            <span class="hljs-comment">// 计算左区间长度</span>            count += mid - i + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            tmp[k++] = nums[i++];        &#125;    &#125;    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        tmp[k++] = nums[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= right) &#123;        tmp[k++] = nums[j++];    &#125;    System.arraycopy(tmp, <span class="hljs-number">0</span>, nums, left, len);    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>剑指 Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 912. 排序数组</title>
    <link href="/2020/09/14/LeetCode-912-sort-an-array/"/>
    <url>/2020/09/14/LeetCode-912-sort-an-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">912. 排序数组</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortArray(<span class="hljs-keyword">int</span>[] nums) &#123;    mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;        mergeSort(nums, low, mid);        mergeSort(nums, mid + <span class="hljs-number">1</span>, high);        merge(nums, low, mid, high);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = high - low + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-comment">// [low...mid] [mid + 1, high]</span>    <span class="hljs-keyword">int</span> i = low, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;        tmp[k++] = nums[i] &gt; nums[j] ? nums[j++] : nums[i++];    &#125;    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        tmp[k++] = nums[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= high) &#123;        tmp[k++] = nums[j++];    &#125;    System.arraycopy(tmp, <span class="hljs-number">0</span>, nums, low, len);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-keyword">int</span> pivotPos = partition(nums, low, high);        quickSort(nums, low, pivotPos - <span class="hljs-number">1</span>);        quickSort(nums, pivotPos + <span class="hljs-number">1</span>, high);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> cur = nums[low];    <span class="hljs-keyword">while</span> (low &lt; high) &#123;        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; cur &lt;= nums[high]) &#123;            high--;        &#125;        nums[low] = nums[high];        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; cur &gt;= nums[low]) &#123;            low++;        &#125;        nums[high] = nums[low];    &#125;    nums[low] = cur;    <span class="hljs-keyword">return</span> low;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 350. 两个数组的交集 II</title>
    <link href="/2020/09/13/LeetCode-350-intersection-of-two-arrays-ii/"/>
    <url>/2020/09/13/LeetCode-350-intersection-of-two-arrays-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></p><h1 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// map 中存储每个数的出现次数</span>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums1) &#123;        map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> key : nums2) &#123;        <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">int</span> count = map.get(key);        <span class="hljs-comment">// 出现次数大于 1 才有效</span>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;            list.add(key);            <span class="hljs-comment">// 更新剩下的次数</span>            map.put(key, count - <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : list) &#123;        res[k++] = num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    Arrays.sort(nums1);    Arrays.sort(nums2);    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;        <span class="hljs-keyword">if</span> (nums1[i] == nums2[j]) &#123;            list.add(nums1[i]);            i++;            j++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;            j++;        &#125; <span class="hljs-keyword">else</span> &#123;            i++;        &#125;    &#125;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : list) &#123;        res[k++] = num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 349. 两个数组的交集</title>
    <link href="/2020/09/13/LeetCode-349-intersection-of-two-arrays/"/>
    <url>/2020/09/13/LeetCode-349-intersection-of-two-arrays/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a></p><h1 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums1) &#123;        map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> key : nums2) &#123;        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            set.add(key);        &#125;    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[set.size()];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : set) &#123;        res[i++] = num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><p>两个数组排序后，分别查找相等的数。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    Arrays.sort(nums1);    Arrays.sort(nums2);    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;        <span class="hljs-comment">// 相等，加入集合</span>        <span class="hljs-keyword">if</span> (nums1[i] == nums2[j]) &#123;            set.add(nums1[i]);            i++;            j++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;            <span class="hljs-comment">// num2[j] 太小，往后查找</span>            j++;        &#125; <span class="hljs-keyword">else</span> &#123;            i++;        &#125;    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[set.size()];    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : set) &#123;        res[k++] = num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    Arrays.sort(nums2);    <span class="hljs-comment">// 在 num2 中查找 nums1 中的每个元素是否出现</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : nums1) &#123;        <span class="hljs-keyword">if</span> (binarySearch(value, nums2) &amp;&amp; !set.contains(value)) &#123;            set.add(value);        &#125;    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[set.size()];    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : set) &#123;        res[k++] = num;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;        <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 227. 基本计算器 II</title>
    <link href="/2020/09/12/LeetCode-227-basic-calculator-ii/"/>
    <url>/2020/09/12/LeetCode-227-basic-calculator-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. 基本计算器 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        <span class="hljs-comment">// 每个数字前的符号</span>        <span class="hljs-keyword">char</span> sign = <span class="hljs-string">'+'</span>;        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> len = chars.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">char</span> c = chars[i];            <span class="hljs-comment">// 数字累加</span>            <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;                num = num * <span class="hljs-number">10</span> + (c - <span class="hljs-string">'0'</span>);            &#125;            <span class="hljs-comment">// // 栈中存的是上一个表达式的结果即第一个操作数，num 为第二个操作数</span>            <span class="hljs-keyword">if</span> ((!Character.isDigit(c) &amp;&amp; c != <span class="hljs-string">' '</span>) || i == len - <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">switch</span> (sign) &#123;                    <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:                        stack.push(num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:                        stack.push(-num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:                        stack.push(stack.pop() * num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:                        stack.push(stack.pop() / num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">default</span>:                        <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">// 更新 c 为下一个操作符</span>                sign = c;                <span class="hljs-comment">// 重置数字</span>                num = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;            res += stack.pop();        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1. 两数之和</title>
    <link href="/2020/09/12/LeetCode-1-two-sum/"/>
    <url>/2020/09/12/LeetCode-1-two-sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;        <span class="hljs-keyword">int</span> another = target - nums[i];        <span class="hljs-keyword">if</span> (map.containsKey(another)) &#123;            res[<span class="hljs-number">0</span>] = i;            res[<span class="hljs-number">1</span>] = map.get(another);            <span class="hljs-keyword">break</span>;        &#125;        map.put(nums[i], i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 560. 和为K的子数组</title>
    <link href="/2020/09/12/LeetCode-560-subarray-sum-equals-k/"/>
    <url>/2020/09/12/LeetCode-560-subarray-sum-equals-k/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前前缀和 sum, 之前的某个前缀和 preSum</span>    <span class="hljs-comment">// sum - preSum = k，preSum 出现的次数就是当前位置和为 k 的个数</span>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// key: 前缀和 value: 该前缀和出现的次数</span>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        sum += num;        <span class="hljs-keyword">int</span> preSum = sum - k;        <span class="hljs-comment">// 获取 有多少个 preSum，使得 sum - preSum = k</span>        <span class="hljs-keyword">if</span> (map.containsKey(preSum)) &#123;            count += map.get(preSum);        &#125;        <span class="hljs-comment">// 更新前缀和</span>        map.put(sum, map.getOrDefault(sum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 224. 基本计算器</title>
    <link href="/2020/09/12/LeetCode-224-basic-calculator/"/>
    <url>/2020/09/12/LeetCode-224-basic-calculator/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">224. 基本计算器</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span> </span>&#123;        LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">char</span>[] str = s.toCharArray();        <span class="hljs-keyword">int</span> len = str.length;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">char</span> c = str[i];            <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;                <span class="hljs-keyword">int</span> num = c - <span class="hljs-string">'0'</span>;                <span class="hljs-comment">// 取出完整的一个数字</span>                <span class="hljs-keyword">while</span> (i + <span class="hljs-number">1</span> &lt; len &amp;&amp; Character.isDigit(str[i + <span class="hljs-number">1</span>])) &#123;                    num = num * <span class="hljs-number">10</span> + (str[i + <span class="hljs-number">1</span>] - <span class="hljs-string">'0'</span>);                    i++;                &#125;                res += sign * num;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span>) &#123;                sign = <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) &#123;                sign = -<span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'('</span>) &#123;                <span class="hljs-comment">// 前一个计算的结果</span>                stack.push(res);                <span class="hljs-comment">// 下一个符号</span>                stack.push(sign);                res = <span class="hljs-number">0</span>;                sign = <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">')'</span>) &#123;                res = res * stack.pop() + stack.pop();            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">        数字：入 numStack</span><span class="hljs-comment">        运算符：进行加减运算直到栈空或遇到 '('</span><span class="hljs-comment">        '(': 入 opStack</span><span class="hljs-comment">        ')': 出栈并计算直到遇到 '('</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    Deque&lt;Integer&gt; numStack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    Deque&lt;Character&gt; opStack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> num = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        <span class="hljs-comment">// 遇到数字，组合数字并压入 numStack</span>        <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;            num = num == -<span class="hljs-number">1</span> ? c - <span class="hljs-string">'0'</span> : num * <span class="hljs-number">10</span> + c - <span class="hljs-string">'0'</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 数字入栈</span>            <span class="hljs-keyword">if</span> (num != -<span class="hljs-number">1</span>) &#123;                numStack.push(num);                num = -<span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">// 运算符，进行加减运算直到栈空或遇到 '('</span>            <span class="hljs-keyword">if</span> (isOperation(c)) &#123;                <span class="hljs-keyword">while</span> (!opStack.isEmpty()) &#123;                    <span class="hljs-keyword">if</span> (opStack.peek() == <span class="hljs-string">'('</span>) &#123;                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">int</span> ans = calc(numStack, opStack);                    numStack.push(ans);                &#125;                <span class="hljs-comment">// 当前运算符入栈</span>                opStack.push(c);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'('</span>) &#123;                <span class="hljs-comment">// '(' 直接入栈</span>                opStack.push(c);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">')'</span>) &#123;                <span class="hljs-comment">// ')': 出栈并计算直到遇到 ')'</span>                <span class="hljs-keyword">while</span> (opStack.peek() != <span class="hljs-string">'('</span>) &#123;                    <span class="hljs-keyword">int</span> ans = calc(numStack, opStack);                    numStack.push(ans);                &#125;                <span class="hljs-comment">// 将 '(' 出栈</span>                opStack.pop();            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (num != -<span class="hljs-number">1</span>) &#123;        numStack.push(num);    &#125;    <span class="hljs-comment">// 若 操作符栈不为空，继续运算</span>    <span class="hljs-keyword">while</span> (!opStack.isEmpty()) &#123;        <span class="hljs-keyword">int</span> ans = calc(numStack, opStack);        numStack.push(ans);    &#125;    <span class="hljs-keyword">return</span> numStack.pop();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 从 numStack 中出栈两个数进行加减运算</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> numStack 数字栈</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> opStack  操作符栈</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(Deque&lt;Integer&gt; numStack, Deque&lt;Character&gt; opStack)</span> </span>&#123;    <span class="hljs-keyword">int</span> num1 = numStack.pop();    <span class="hljs-keyword">int</span> num2 = numStack.pop();    <span class="hljs-keyword">char</span> op = opStack.pop();    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">'+'</span>) &#123;        <span class="hljs-keyword">return</span> num1 + num2;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> num2 - num1;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 判断 c 是否为运算符</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> c</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOperation</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;    <span class="hljs-keyword">return</span> c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span> || c == <span class="hljs-string">'*'</span> || c == <span class="hljs-string">'/'</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 205. 同构字符串</title>
    <link href="/2020/09/11/LeetCode-205-isomorphic-strings/"/>
    <url>/2020/09/11/LeetCode-205-isomorphic-strings/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">205. 同构字符串</a></p><p>需要从两个方向判断！</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">return</span> check(s, t) &amp;&amp; check(t, s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length();    Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">char</span> c = s.charAt(i);        <span class="hljs-keyword">char</span> key = t.charAt(i);        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            <span class="hljs-keyword">char</span> target = map.get(key);            <span class="hljs-keyword">if</span> (c != target) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            map.put(key, c);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-comment">// 双向验证</span>    <span class="hljs-keyword">return</span> check(s, t) &amp;&amp; check(t, s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];    <span class="hljs-keyword">char</span>[] chars1 = s.toCharArray();    <span class="hljs-keyword">char</span>[] chars2 = t.toCharArray();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> target = map[chars1[i]];        <span class="hljs-comment">// 判断对应位置是否匹配</span>        <span class="hljs-keyword">if</span> (target != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (target != chars2[i]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 新增 map</span>        map[chars1[i]] = chars2[i];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 583. 两个字符串的删除操作</title>
    <link href="/2020/09/10/LeetCode-583-delete-operation-for-two-strings/"/>
    <url>/2020/09/10/LeetCode-583-delete-operation-for-two-strings/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. 两个字符串的删除操作</a></p><p>和 <a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a> 类似。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = word1.length();    <span class="hljs-keyword">int</span> cols = word2.length();    <span class="hljs-keyword">char</span>[] chars1 = word1.toCharArray();    <span class="hljs-keyword">char</span>[] chars2 = word2.toCharArray();    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows + <span class="hljs-number">1</span>][cols + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = i;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cols; i++) &#123;        dp[<span class="hljs-number">0</span>][i] = i;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; j++) &#123;            <span class="hljs-keyword">if</span> (chars1[i - <span class="hljs-number">1</span>] == chars2[j - <span class="hljs-number">1</span>]) &#123;                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> &#123;                dp[i][j] = <span class="hljs-number">1</span> + Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[rows][cols];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 44. 通配符匹配</title>
    <link href="/2020/09/09/LeetCode-44-wildcard-matching/"/>
    <url>/2020/09/09/LeetCode-44-wildcard-matching/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. 通配符匹配</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = p.length();    <span class="hljs-keyword">int</span> cols = s.length();    <span class="hljs-keyword">char</span>[] sChars = s.toCharArray();    <span class="hljs-keyword">char</span>[] pChars = p.toCharArray();    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows + <span class="hljs-number">1</span>][cols + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// 若以 '*' 开始，则 p 可以匹配 空串</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;        <span class="hljs-keyword">if</span> (pChars[i - <span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>) &#123;            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; j++) &#123;            <span class="hljs-comment">// 对应字符匹配 || p[j] == '?' 可匹配任意字符</span>            <span class="hljs-keyword">if</span> (sChars[j - <span class="hljs-number">1</span>] == pChars[i - <span class="hljs-number">1</span>] || pChars[i - <span class="hljs-number">1</span>] == <span class="hljs-string">'?'</span>) &#123;                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pChars[i - <span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>) &#123;                <span class="hljs-comment">// '*' 可匹配任意长度</span>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i][j - <span class="hljs-number">1</span>];            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[rows][cols];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 10. 正则表达式匹配</title>
    <link href="/2020/09/09/LeetCode-10-regular-expression-matching/"/>
    <url>/2020/09/09/LeetCode-10-regular-expression-matching/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></p><p><code>dp[i][j]</code> 表示 <code>s[0:i]</code> 是否能匹配到 <code>p[0:j]</code></p><ul><li><code>s[i] == p[j]</code>，对应位置匹配<br /><code>dp[i][j] = dp[i - 1][j - 1]</code></li><li><code>p[j] == '.'</code>，<code>'.'</code> 可以匹配任意字符<br /><code>dp[i][j] = dp[i - 1][j - 1]</code></li><li><code>s[i] != p[j]</code>，若 <code>p[j] != '*'</code>，则肯定无法匹配，只有当 <code>*</code> 时才有可能消除不匹配的字符。<ul><li><code>s[i] != p[j - 1]</code>， <code>*</code> 的前一个字符与 <code>s[i]</code> 无法匹配，则消去 <code>s[i]</code>，此时 <code>#*</code> 代表 <code>#</code> 取 0 个。<br /><code>dp[i][j] = dp[j - 2]</code></li><li><code>s[i] == p[j - 1]</code>， <code>*</code> 的前一个字符与 <code>s[i]</code> 匹配，则 <code>p[j - 2]</code> 可以取 0 个， 1 个或多个<br /><code>dp[i][j] = dp[j - 2] || dp[i][j - 1] || dp[i - 1][j]</code><ul><li>取 0 个：aab - aab b*</li><li>取 1 个：aab - aa b*</li><li>取 n 个：aabbbb - aa b*</li></ul></li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = s.length();    <span class="hljs-keyword">int</span> cols = p.length();    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows + <span class="hljs-number">1</span>][cols + <span class="hljs-number">1</span>];    <span class="hljs-comment">// 空串肯定能匹配</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= cols; i++) &#123;        <span class="hljs-keyword">if</span> (p.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">'*'</span> &amp;&amp; dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">2</span>]) &#123;            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-keyword">true</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; j++) &#123;            <span class="hljs-comment">// s 和 p 当前匹配到的字符</span>            <span class="hljs-keyword">char</span> sc = s.charAt(i - <span class="hljs-number">1</span>);            <span class="hljs-keyword">char</span> pc = p.charAt(j - <span class="hljs-number">1</span>);            <span class="hljs-comment">// i, j 匹配或 j 可取任意值</span>            <span class="hljs-keyword">if</span> (sc == pc || pc == <span class="hljs-string">'.'</span>) &#123;                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pc == <span class="hljs-string">'*'</span>) &#123;                <span class="hljs-comment">// `*` 的前一个字符</span>                <span class="hljs-keyword">char</span> last = p.charAt(j - <span class="hljs-number">2</span>);                <span class="hljs-comment">// last 与 s 的当前位置匹配，则 last 可取 1 位或多位</span>                <span class="hljs-keyword">if</span> (sc == last || last == <span class="hljs-string">'.'</span>) &#123;                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] || dp[i - <span class="hljs-number">1</span>][j];                &#125;                <span class="hljs-comment">// 尝试不取 last</span>                dp[i][j] = dp[i][j] || dp[i][j - <span class="hljs-number">2</span>];            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[rows][cols];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 5. 最长回文子串</title>
    <link href="/2020/09/09/LeetCode-5-longest-palindromic-substring/"/>
    <url>/2020/09/09/LeetCode-5-longest-palindromic-substring/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><ul><li><p>如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；</p></li><li><p>如果一个字符串的头尾两个字符相等，才有必要继续判断下去。</p><ul><li><p>如果里面的子串是回文，整体就是回文串；</p></li><li><p>如果里面的子串不是回文串，整体就不是回文串。</p></li></ul></li></ul><p>状态：<code>dp[i][j]</code> - <code>s[i:j]</code> 是否为回文串<br />状态转移方程：<code>dp[i][j] = s[i] == s[j] and dp[i + 1][j - 1]</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(s)) &#123;            <span class="hljs-keyword">return</span> s;        &#125;        <span class="hljs-keyword">int</span> len = s.length();        <span class="hljs-keyword">char</span>[] str = s.toCharArray();        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len][len];        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; len; j++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= j; i++) &#123;                <span class="hljs-comment">// 首尾相等，看中间</span>                <span class="hljs-keyword">if</span> (str[i] == str[j]) &#123;                    <span class="hljs-comment">// 除去首尾的中间字符 &lt;= 1 个，为回文</span>                    <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123;                        dp[i][j] = <span class="hljs-keyword">true</span>;                    &#125;                     <span class="hljs-comment">// 除去首尾的中间字符 &gt; 1 个，看中间是否为回文</span>                    <span class="hljs-keyword">else</span> &#123;                        dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];                    &#125;                &#125;                <span class="hljs-comment">// 更新最长的回文起始位置</span>                <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen) &#123;                    maxLen = j - i + <span class="hljs-number">1</span>;                    start = i;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(str, start, maxLen);    &#125;</code></pre><h1 id="中心扩散"><a class="markdownIt-Anchor" href="#中心扩散"></a> 中心扩散</h1><p>尝试以每个字符和每个字符间的间隙为中心，向两端扩散。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200909134124.jpeg" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-keyword">int</span> len = str.length;    <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// 奇数扩散，以 s[i] 为中心</span>        <span class="hljs-keyword">int</span>[] res1 = centerSpread(str, i, i);        <span class="hljs-comment">// 偶数扩散，以 s[i], s[i + 1] 为中心</span>        <span class="hljs-keyword">int</span>[] res2 = centerSpread(str, i, i + <span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span>[] res = res1[<span class="hljs-number">1</span>] &gt; res2[<span class="hljs-number">1</span>] ? res1 : res2;        <span class="hljs-comment">// 更新长度</span>        <span class="hljs-keyword">if</span> (res[<span class="hljs-number">1</span>] &gt; maxLen) &#123;            maxLen = res[<span class="hljs-number">1</span>];            begin = res[<span class="hljs-number">0</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> s.substring(begin, begin + maxLen);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] centerSpread(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) &#123;    <span class="hljs-keyword">int</span> len = str.length;    <span class="hljs-comment">// 结束循环时，str[left] != str[right] 或越界</span>    <span class="hljs-comment">// 取 str(left:right)</span>    <span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">0</span> &amp;&amp; right &lt; len) &#123;        <span class="hljs-keyword">if</span> (str[left] != str[right]) &#123;            <span class="hljs-keyword">break</span>;        &#125;        left--;        right++;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left + <span class="hljs-number">1</span>, right - left - <span class="hljs-number">1</span>&#125;;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 680. 验证回文字符串 Ⅱ</title>
    <link href="/2020/09/09/LeetCode-680-valid-palindrome-ii/"/>
    <url>/2020/09/09/LeetCode-680-valid-palindrome-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">680. 验证回文字符串 Ⅱ</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = s.length() - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-comment">// 最多删除一个字符，当有一个字符不等时，判断删除该字符后剩下的部分是否为回文</span>        <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;            <span class="hljs-keyword">return</span> isPalindrome(s, left + <span class="hljs-number">1</span>, right) || isPalindrome(s, left, right - <span class="hljs-number">1</span>);        &#125;        left++;        right--;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        left++;        right--;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 125. 验证回文串</title>
    <link href="/2020/09/09/LeetCode-125-valid-palindrome/"/>
    <url>/2020/09/09/LeetCode-125-valid-palindrome/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">125. 验证回文串</a></p><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] str = s.toCharArray();    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = str.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (i &lt; j) &#123;        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; !Character.isLetterOrDigit(str[i])) &#123;            i++;        &#125;        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; !Character.isLetterOrDigit(str[j])) &#123;            j--;        &#125;        <span class="hljs-keyword">if</span> (Character.toLowerCase(str[i]) != Character.toLowerCase(str[j])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        i++;        j--;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h1 id="reverse"><a class="markdownIt-Anchor" href="#reverse"></a> reverse</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;        <span class="hljs-keyword">char</span> c = s.charAt(i);        <span class="hljs-keyword">if</span> (Character.isLetterOrDigit(c)) &#123;            sb.append(Character.toLowerCase(c));        &#125;    &#125;    String s1 = sb.toString();    String s2 = sb.reverse().toString();    <span class="hljs-keyword">return</span> s1.equals(s2);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 818. 赛车</title>
    <link href="/2020/09/08/LeetCode-818-race-car/"/>
    <url>/2020/09/08/LeetCode-818-race-car/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/race-car/" target="_blank" rel="noopener">818. 赛车</a></p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><p>需要注意：<code>newPos &lt; target * 2</code>，因为对于 <code>target</code> 而言，</p><ul><li>可以在 <code>target</code> 之前进行加速或减速操作；</li><li>或者超过 <code>target</code> 之后进行减速操作；</li></ul><p>这两种方式都可能到达 <code>target</code>，把 <code>newPos</code> 限制在 <code>2 * target</code> 里，是为了让操作的步数不再递增，导致找不到终点。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">racecar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;    Deque&lt;Car&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    queue.add(<span class="hljs-keyword">new</span> Car(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));    visited.add(<span class="hljs-string">"0@1"</span>);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        count++;        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            Car car = queue.poll();            <span class="hljs-keyword">int</span> curPos = car.position;            <span class="hljs-comment">// 达到终点</span>            <span class="hljs-keyword">if</span> (curPos == target) &#123;                <span class="hljs-keyword">return</span> count;            &#125;            <span class="hljs-keyword">int</span> speed = car.speed;            <span class="hljs-comment">// 加速</span>            <span class="hljs-keyword">int</span> newPos = curPos + speed;            <span class="hljs-keyword">int</span> newSpeed = speed &lt;&lt; <span class="hljs-number">1</span>;            String key = newPos + <span class="hljs-string">"@"</span> + newSpeed;            <span class="hljs-keyword">if</span> (!visited.contains(key) &amp;&amp; <span class="hljs-number">0</span> &lt; newPos &amp;&amp; newPos &lt; (target &lt;&lt; <span class="hljs-number">1</span>)) &#123;                queue.add(<span class="hljs-keyword">new</span> Car(newPos, newSpeed));                visited.add(key);            &#125;            <span class="hljs-comment">// 减速</span>            newSpeed = speed &gt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;            key = curPos + <span class="hljs-string">"@"</span> + newSpeed;            <span class="hljs-keyword">if</span> (!visited.contains(key) &amp;&amp; <span class="hljs-number">0</span> &lt; curPos &amp;&amp; curPos &lt; (target &lt;&lt; <span class="hljs-number">1</span>)) &#123;                queue.add(<span class="hljs-keyword">new</span> Car(curPos, newSpeed));                visited.add(key);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;    <span class="hljs-keyword">int</span> position;    <span class="hljs-keyword">int</span> speed;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> speed)</span> </span>&#123;        <span class="hljs-keyword">this</span>.position = position;        <span class="hljs-keyword">this</span>.speed = speed;    &#125;&#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">racecar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-comment">// dp[i]: 到达 i 位置的最小步数</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= target; i++) &#123;        dp[i] = Integer.MAX_VALUE;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>, cnt1 = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 在 i 位置之前进行加速、减速操作</span>        <span class="hljs-comment">// j 每次加速到 2 ^ cnt1 - 1 位置</span>        <span class="hljs-keyword">for</span> (; j &lt; i; j = (<span class="hljs-number">1</span> &lt;&lt; ++cnt1) - <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// k 每次反向加速到 2 ^ cnt2 - 1 位置</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, cnt2 = <span class="hljs-number">0</span>; k &lt; j; k = (<span class="hljs-number">1</span> &lt;&lt; ++cnt2) - <span class="hljs-number">1</span>) &#123;                <span class="hljs-comment">// 正向走了 (j - k) 步 + 加速 + 2 次反向操作</span>                dp[i] = Math.min(dp[i], dp[i - (j - k)] + cnt1 + <span class="hljs-number">1</span> + cnt2 + <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-comment">// 经过 cnt1 次正向加速，此时位置超过 i，然后进行 1 次反向操作</span>        <span class="hljs-comment">// 若 i == j 到达 target，否则还差 j - i 到达 i 位置</span>        dp[i] = Math.min(dp[i], cnt1 + (i == j ? <span class="hljs-number">0</span> : dp[j - i] + <span class="hljs-number">1</span>));    &#125;    <span class="hljs-keyword">return</span> dp[target];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 115. 不同的子序列</title>
    <link href="/2020/09/08/LeetCode-115-distinct-subsequences/"/>
    <url>/2020/09/08/LeetCode-115-distinct-subsequences/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">115. 不同的子序列</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(t)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(s)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> lenS = s.length();    <span class="hljs-keyword">int</span> lenT = t.length();    <span class="hljs-keyword">int</span>[][] cache = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[lenS][lenT];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] row : cache) &#123;        Arrays.fill(row, -<span class="hljs-number">1</span>);    &#125;    dfs(lenS - <span class="hljs-number">1</span>, lenT - <span class="hljs-number">1</span>, cache, s.toCharArray(), t.toCharArray());    <span class="hljs-keyword">return</span> cache[lenS - <span class="hljs-number">1</span>][lenT - <span class="hljs-number">1</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span>[][] cache, <span class="hljs-keyword">char</span>[] s, <span class="hljs-keyword">char</span>[] t)</span> </span>&#123;    <span class="hljs-comment">// t == ""，s 可为任意字符串，只要从 s 取出 "" 即可</span>    <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// s == ""，只有 t == "" 才能匹配</span>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (cache[i][j] != -<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> cache[i][j];    &#125;    <span class="hljs-comment">// 末尾字符相等，s[i] 可取或不取</span>    <span class="hljs-keyword">if</span> (s[i] == t[j]) &#123;        cache[i][j] = dfs(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, cache, s, t) + dfs(i - <span class="hljs-number">1</span>, j, cache, s, t);    &#125;    <span class="hljs-comment">// 末尾字符不等，s[i] 不可取</span>    <span class="hljs-keyword">else</span> &#123;        cache[i][j] = dfs(i - <span class="hljs-number">1</span>, j, cache, s, t);    &#125;    <span class="hljs-keyword">return</span> cache[i][j];&#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">int</span> lenS = s.length();    <span class="hljs-keyword">int</span> lenT = t.length();    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[lenT + <span class="hljs-number">1</span>][lenS + <span class="hljs-number">1</span>];    Arrays.fill(dp[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);    <span class="hljs-keyword">char</span>[] ss = s.toCharArray();    <span class="hljs-keyword">char</span>[] tt = t.toCharArray();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= lenT; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= lenS; j++) &#123;            <span class="hljs-keyword">if</span> (ss[j - <span class="hljs-number">1</span>] == tt[i - <span class="hljs-number">1</span>]) &#123;                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i][j - <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> &#123;                dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[lenT][lenS];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 85. 最大矩形</title>
    <link href="/2020/09/08/LeetCode-85-maximal-rectangle/"/>
    <url>/2020/09/08/LeetCode-85-maximal-rectangle/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a></p><h1 id="暴力"><a class="markdownIt-Anchor" href="#暴力"></a> 暴力</h1><p>保存每个 <code>1</code> 元素的最长距离，向上查找高度。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = matrix.length;    <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 以 widths[row][col] 结尾的最长 `1` 的个数</span>    <span class="hljs-keyword">int</span>[][] widths = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][cols];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-comment">// 当前位置为 `1`</span>            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">'1'</span>) &#123;                widths[i][j] = <span class="hljs-number">1</span>;                <span class="hljs-comment">// 不是第一列，则 = 1 + 左边那个格子的最长数</span>                <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) &#123;                    widths[i][j] += widths[i][j - <span class="hljs-number">1</span>];                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                widths[i][j] = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">int</span> minWidth = widths[i][j];            <span class="hljs-comment">// 向上查找最小矩形</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = i; row &gt;= <span class="hljs-number">0</span>; row--) &#123;                minWidth = Math.min(minWidth, widths[row][j]);                <span class="hljs-keyword">int</span> height = i - row + <span class="hljs-number">1</span>;                res = Math.max(res, minWidth * height);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><p>在 <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a> 的基础上，转化为按行求每行的最大矩形面积。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = matrix.length;    <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 保存每一列的高度</span>    <span class="hljs-keyword">int</span>[] heights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[cols];    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">'1'</span>) &#123;                <span class="hljs-comment">// 当前列为 1，在上一行的基础上 + 1</span>                heights[j]++;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 重新开始</span>                heights[j] = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-comment">// 求每一行的最大值</span>        res = Math.max(res, largestRectangleArea(heights));    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">int</span> rows = matrix.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[] heights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[cols];        <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[cols];        <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[cols];        <span class="hljs-comment">// 左边最低位置 -1</span>        Arrays.fill(left, -<span class="hljs-number">1</span>);        <span class="hljs-comment">// 右边最低位置 len</span>        Arrays.fill(right, cols);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : matrix) &#123;            <span class="hljs-comment">// 计算该行每个元素的矩形高度</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;                <span class="hljs-keyword">if</span> (line[i] == <span class="hljs-string">'1'</span>) &#123;                    heights[i]++;                &#125; <span class="hljs-keyword">else</span> &#123;                    heights[i] = <span class="hljs-number">0</span>;                &#125;            &#125;            <span class="hljs-comment">// 左边最低位置</span>            <span class="hljs-keyword">int</span> leftZero = -<span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;                <span class="hljs-keyword">if</span> (line[i] == <span class="hljs-string">'1'</span>) &#123;                    <span class="hljs-comment">// 若当前为 `1`，可能左边存在 `0`，取最靠近右边的 `0` 才能形成矩形</span>                    left[i] = Math.max(left[i], leftZero);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 当前为 `0`，高度也为 0，左边最低位置在起始点</span>                    left[i] = -<span class="hljs-number">1</span>;                    leftZero = i;                &#125;            &#125;            <span class="hljs-comment">// 右边最低位置</span>            <span class="hljs-keyword">int</span> rightZero = cols;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cols - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;                <span class="hljs-keyword">if</span> (line[i] == <span class="hljs-string">'1'</span>) &#123;                    right[i] = Math.min(right[i], rightZero);                &#125; <span class="hljs-keyword">else</span> &#123;                    right[i] = cols;                    rightZero = i;                &#125;            &#125;            <span class="hljs-comment">// 对该行每个位置求能组成的矩形面积</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;                <span class="hljs-keyword">int</span> cur = (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i];                res = Math.max(cur, res);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 84. 柱状图中最大的矩形</title>
    <link href="/2020/09/08/LeetCode-84-largest-rectangle-in-histogram/"/>
    <url>/2020/09/08/LeetCode-84-largest-rectangle-in-histogram/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></p><h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = heights.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> heights[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-comment">// 添加哨兵，头尾都加一个 0，避免边界判断</span>    <span class="hljs-keyword">int</span>[] newHeights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">2</span>];    System.arraycopy(heights, <span class="hljs-number">0</span>, newHeights, <span class="hljs-number">1</span>, len);    <span class="hljs-comment">// 单调递增栈，当要入栈元素小于栈顶元素时</span>    <span class="hljs-comment">// 栈顶元素为最大值，可计算以栈顶为高度的最大矩形面积</span>    Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(len);    stack.push(<span class="hljs-number">0</span>);    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; newHeights.length; i++) &#123;        <span class="hljs-comment">// 严格递减，则计算面积</span>        <span class="hljs-keyword">while</span> (newHeights[i] &lt; newHeights[stack.peek()]) &#123;            <span class="hljs-comment">// 高度为当前栈顶元素</span>            <span class="hljs-keyword">int</span> height = newHeights[stack.pop()];            <span class="hljs-comment">// 栈顶出栈后，新的栈顶 = 左边小于 height 的元素</span>            <span class="hljs-keyword">int</span> width = i - stack.peek() - <span class="hljs-number">1</span>;            res = Math.max(res, height * width);        &#125;        stack.push(i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = heights.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    left[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;    right[len - <span class="hljs-number">1</span>] = len;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 找左边第一个最低</span>        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; heights[j] &gt;= heights[i]) &#123;            j--;        &#125;        left[i] = j;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// 找右边第一个最低</span>        <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (j &lt; len &amp;&amp; heights[j] &gt;= heights[i]) &#123;            j++;        &#125;        right[i] = j;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> cur = (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i];        res = Math.max(res, cur);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 438. 找到字符串中所有字母异位词</title>
    <link href="/2020/09/07/LeetCode-438-find-all-anagrams-in-a-string/"/>
    <url>/2020/09/07/LeetCode-438-find-all-anagrams-in-a-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></p><h1 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h1><p>右指针不断向右移动，并且判断当前字符字符是否满足目标字符的出现频率，若不满足，则移动左指针直到满足为止。当窗口大小满足要求时，窗口内的所有字符都满足要求，则保存此时的 <code>left</code>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">char</span>[] sChar = s.toCharArray();    <span class="hljs-keyword">char</span>[] pChar = p.toCharArray();    <span class="hljs-comment">// 保存目标字符串的字符出现频率</span>    <span class="hljs-keyword">int</span>[] needs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : pChar) &#123;        needs[c - <span class="hljs-string">'a'</span>]++;    &#125;    <span class="hljs-comment">// 窗口内字符串的出现频率</span>    <span class="hljs-keyword">int</span>[] window = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = p.length();    <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;        <span class="hljs-keyword">int</span> curPos = sChar[right] - <span class="hljs-string">'a'</span>;        window[curPos]++;        right++;        <span class="hljs-comment">// 让窗口内的字符频率和目标频率一致</span>        <span class="hljs-keyword">while</span> (needs[curPos] &lt; window[curPos]) &#123;            window[sChar[left] - <span class="hljs-string">'a'</span>]--;            left++;        &#125;        <span class="hljs-comment">// 长度满足目标长度</span>        <span class="hljs-keyword">if</span> (right - left == len) &#123;            res.add(left);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">char</span>[] sChar = s.toCharArray();    <span class="hljs-keyword">char</span>[] pChar = p.toCharArray();    <span class="hljs-comment">// 窗口中每个有效字符的出现次数</span>    <span class="hljs-keyword">int</span>[] window = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-comment">// 需要的字符出现次数</span>    <span class="hljs-keyword">int</span>[] needs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : pChar) &#123;        needs[c - <span class="hljs-string">'a'</span>]++;    &#125;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> sLen = s.length();    <span class="hljs-keyword">int</span> pLen = p.length();    <span class="hljs-comment">// 窗口中满足要求的有效字符数</span>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (right &lt; sLen) &#123;        <span class="hljs-keyword">int</span> pos = sChar[right] - <span class="hljs-string">'a'</span>;        <span class="hljs-comment">// 不是有效字符</span>        <span class="hljs-keyword">if</span> (needs[pos] == <span class="hljs-number">0</span>) &#123;            right++;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 当前字符满足要求</span>        <span class="hljs-keyword">if</span> (window[pos] &lt; needs[pos]) &#123;            count++;        &#125;        window[pos]++;        right++;        <span class="hljs-comment">// 字符数等于目标大小</span>        <span class="hljs-keyword">while</span> (count == pLen) &#123;            <span class="hljs-comment">// 异位词：窗口长度 == 目标长度 才更新</span>            <span class="hljs-keyword">if</span> (right - left == pLen) &#123;                res.add(left);            &#125;            <span class="hljs-keyword">int</span> leftPos = sChar[left] - <span class="hljs-string">'a'</span>;            <span class="hljs-comment">// left 不在目标字符中</span>            <span class="hljs-keyword">if</span> (needs[leftPos] == <span class="hljs-number">0</span>) &#123;                left++;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// left 在目标字符中</span>            <span class="hljs-keyword">if</span> (window[leftPos] == needs[leftPos]) &#123;                count--;            &#125;            window[leftPos]--;            left++;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 49. 字母异位词分组</title>
    <link href="/2020/09/06/LeetCode-49-group-anagrams/"/>
    <url>/2020/09/06/LeetCode-49-group-anagrams/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;    Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (String s : strs) &#123;        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();        Arrays.sort(chars);        String key = <span class="hljs-keyword">new</span> String(chars);        List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());        list.add(s);        map.put(key, list);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(map.values());&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;    Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (String s : strs) &#123;        <span class="hljs-comment">// 数字哈希，若字母相同，则最终的出现次数相同</span>        <span class="hljs-keyword">char</span>[] keys = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;            keys[c - <span class="hljs-string">'a'</span>]++;        &#125;        String key = <span class="hljs-keyword">new</span> String(keys);        List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());        list.add(s);        map.put(key, list);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(map.values());&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 32. 最长有效括号</title>
    <link href="/2020/09/05/LeetCode-32-longest-valid-parentheses/"/>
    <url>/2020/09/05/LeetCode-32-longest-valid-parentheses/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200905165736.png" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 只有遇到 ) 才能组成有效括号</span>        <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">')'</span>) &#123;            <span class="hljs-comment">// .....() 的情况: i - 2 位置上的最长 dp[i - 2] + 2 (新的括号)</span>            <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">'('</span>) &#123;                <span class="hljs-keyword">if</span> (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span>) &#123;                    dp[i] = <span class="hljs-number">2</span> + dp[i - <span class="hljs-number">2</span>];                &#125; <span class="hljs-keyword">else</span> &#123;                    dp[i] = <span class="hljs-number">2</span>;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// pairPos: 与 ) 配对的 ( 位置</span>                <span class="hljs-comment">// .....)) 的情况: 2 + [pairPos:i] 之间的有效括号 + pairPos 之前的有效括号</span>                <span class="hljs-keyword">int</span> pairPos = i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;                <span class="hljs-comment">// pairPos 位置有效 &amp;&amp; 该位置 = '('</span>                <span class="hljs-keyword">if</span> (pairPos &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(pairPos) == <span class="hljs-string">'('</span>) &#123;                    <span class="hljs-keyword">if</span> (pairPos - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;                        dp[i] = <span class="hljs-number">2</span> + dp[i - <span class="hljs-number">1</span>] + dp[pairPos - <span class="hljs-number">1</span>];                    &#125; <span class="hljs-keyword">else</span> &#123;                        dp[i] = <span class="hljs-number">2</span> + dp[i - <span class="hljs-number">1</span>];                    &#125;                &#125;            &#125;            res = Math.max(res, dp[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><p>栈中存放最后一个 没有被匹配的括号位置，相当于一个分隔符，当进来的右括号没有匹配时，就可根据差值计算有效括号长度。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 栈中存放最后一个 没有被匹配的括号位置</span>    Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    stack.push(-<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 左括号直接入栈</span>        <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">'('</span>) &#123;            stack.push(i);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 遇到右括号，先弹出再判断是否有匹配的左括号</span>            stack.pop();            <span class="hljs-comment">// 若栈空，表示当前右括号没有被匹配</span>            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;                stack.push(i);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 栈不为空，表示当前右括号有匹配元素，即被出栈的那个元素</span>                <span class="hljs-comment">// 有效括号长度 = 当前位置 - 最后一个没有被匹配的括号位置</span>                res = Math.max(res, i - stack.peek());            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 20. 有效的括号</title>
    <link href="/2020/09/05/LeetCode-20-valid-parentheses/"/>
    <url>/2020/09/05/LeetCode-20-valid-parentheses/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;    Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">')'</span>, <span class="hljs-string">'('</span>);    map.put(<span class="hljs-string">'&#125;'</span>, <span class="hljs-string">'&#123;'</span>);    map.put(<span class="hljs-string">']'</span>, <span class="hljs-string">'['</span>);    LinkedList&lt;Character&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> right : s.toCharArray()) &#123;        <span class="hljs-comment">// 当前为右括号</span>        <span class="hljs-keyword">if</span> (map.containsKey(right)) &#123;            <span class="hljs-comment">// 若栈顶与当前的右括号不匹配，则无效</span>            <span class="hljs-keyword">if</span> (stack.isEmpty() || !map.get(right).equals(stack.pop())) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            stack.push(right);        &#125;    &#125;    <span class="hljs-keyword">return</span> stack.isEmpty();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 91. 解码方法</title>
    <link href="/2020/09/05/LeetCode-91-Decode-Ways/"/>
    <url>/2020/09/05/LeetCode-91-Decode-Ways/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a></p><p>考虑 <code>s = 1234</code>，则可以看成两种方案：<code>234</code> 和 <code>34</code>，即去除一位或两位；而 <code>234</code> 和 <code>34</code> 又可以继续去除一位或两位，形成新的方案。</p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200905160755.png" srcset="/img/loading.gif" alt="" /></p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200905161307.png" srcset="/img/loading.gif" alt="" /></p><ul><li>状态：<code>dp[i]</code> - <code>s[0:i]</code> 能组成的方案数</li><li>状态转移方程：<ul><li><code>s[i]</code> 不为 <code>0</code> 时才有效，此时 <code>dp[i] = dp[i - 1]</code></li><li><code>s[i]</code> 和 <code>s[i - 1]</code> 可以组成一个数，此时 <code>dp[i] = dp[i - 2]</code></li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-comment">// dp[1] -&gt; s[0]</span>    dp[<span class="hljs-number">1</span>] = s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'0'</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; len + <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// s[i] 不为 0，表示可以单独组成一个解码方案</span>        <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) != <span class="hljs-string">'0'</span>) &#123;            dp[i] += dp[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-comment">// 10 &lt;= s[i - 1:i] &lt;= 26 可以组成一个解码方案</span>        <span class="hljs-keyword">int</span> num = (s.charAt(i - <span class="hljs-number">2</span>) - <span class="hljs-string">'0'</span>) * <span class="hljs-number">10</span> + (s.charAt(i - <span class="hljs-number">1</span>) - <span class="hljs-string">'0'</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-number">10</span> &lt;= num &amp;&amp; num &lt;= <span class="hljs-number">26</span>) &#123;            dp[i] += dp[i - <span class="hljs-number">2</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[len];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 3. 无重复字符的最长子串</title>
    <link href="/2020/09/04/LeetCode-3-longest-substring-without-repeating-characters/"/>
    <url>/2020/09/04/LeetCode-3-longest-substring-without-repeating-characters/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></p><p>判断重复：使用 <code>map</code> 保存当前字符最后一次出现的位置，若重复，则根据该位置更新区间的起点。</p><p>起点取 <code>max</code> 的原因：始终保证 <code>start</code> 不会左移，否则若 <code>start &lt; map[c]</code>时，直接赋值 <code>start = map[c]</code>，会导致左移，可能无法过滤重复值。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// value 表示字符 c 最后一次出现的位置</span>    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">// [start, end] 区间内的元素都是不重复的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>; end &lt; s.length(); end++) &#123;        <span class="hljs-keyword">char</span> c = s.charAt(end);        <span class="hljs-comment">// 若出现重复，则重新计算 start 位置</span>        <span class="hljs-keyword">if</span> (map.containsKey(c)) &#123;            <span class="hljs-comment">// 取 max 的原因：始终保证 start 不会左移，若左移可能无法过滤重复值</span>            <span class="hljs-comment">// e.g. ...a1...b1....a2...a3....b2... </span>            <span class="hljs-comment">// 当到达 b2，此时 start = a3, b = b1, 若不取 max, start = b1 + 1, 导致 a 重复</span>            start = Math.max(start, map.get(c) + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">// 每次都会更新最大的区间</span>        res = Math.max(res, end - start + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 更新 c 的最新位置，若下次出现重复的 c，则 start 从 map[c] + 1 开始计算</span>        map.put(c, end);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 300. 最长上升子序列</title>
    <link href="/2020/09/04/LeetCode-300-longest-increasing-subsequence/"/>
    <url>/2020/09/04/LeetCode-300-longest-increasing-subsequence/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><ul><li>状态：<code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的「上升子序列」的长度</li><li>状态转移方程<ol><li>在访问 <code>nums[i]</code> 时，需要把 <code>i</code> 之前的数都查看一遍；</li><li>只要 <code>nums[j] &lt; nums[i]</code>，表示可以形成一个上升子序列；</li><li><code>dp[i] = max(dp[0:i]) + 1</code></li></ol></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">int</span> max = -<span class="hljs-number">1</span>;        <span class="hljs-comment">// 遍历之前序列中上升的数，找到最大值</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; j--) &#123;            <span class="hljs-comment">// 严格上升</span>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;                <span class="hljs-comment">// 寻找最大上升值</span>                <span class="hljs-keyword">if</span> (dp[j] &gt; max) &#123;                    max = dp[j];                &#125;            &#125;        &#125;        dp[i] = max == -<span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : max + <span class="hljs-number">1</span>;        res = Math.max(res, dp[i]);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="动态规划-二分"><a class="markdownIt-Anchor" href="#动态规划-二分"></a> 动态规划 + 二分</h1><ul><li>状态：<code>tail[i]</code> 表示长度为 <code>i + 1</code> 的所有上升子序列的结尾的最小值。结尾的元素越小，则越可能构造更长的上升子序列。</li><li>状态转移方程：<ol><li>每来一个新数 <code>num</code>，如果这个数严格大于有序数组 <code>tail</code> 的最后一个元素，就把 <code>num</code> 放在有序数组 <code>tail</code> 的后面；否则进入 2, 3。</li><li>如果有序数组 <code>tail</code> 中存在等于 <code>num</code> 的元素，什么都不做，因为以 <code>num</code> 结尾的最短的「上升子序列」已经存在；</li><li>如果有序数组 <code>tail</code> 中存在大于 <code>num</code> 的元素，找到第 <code>1</code> 个，让它变小，这样我们就找到了一个<strong>结尾更小的相同长度的上升子序列</strong>。</li></ol></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-comment">// tail[i] 表示长度为 i + 1 的 LIS 序列 的最小值</span>    <span class="hljs-keyword">int</span>[] tail = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-comment">// 第一个数 LIS 长度即为 1</span>    tail[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-comment">// end 表示 tail 中最后一个已赋值的元素索引</span>    <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (tail[end] &lt; nums[i]) &#123;            <span class="hljs-comment">// 构造递增的 tail 数组</span>            tail[++end] = nums[i];        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// tail[end] &gt; nums[i]，则进行更新</span>            <span class="hljs-comment">// 在 tail 中找到第一个 &gt; nums[i] 的值进行更新</span>            <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> right = end;            <span class="hljs-keyword">while</span> (left &lt; right) &#123;                <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt;&gt; <span class="hljs-number">1</span>);                <span class="hljs-keyword">if</span> (tail[mid] &lt; nums[i]) &#123;                    left = mid + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    right = mid;                &#125;            &#125;            <span class="hljs-comment">// &gt; nums[i] 的值一定存在，直接更新</span>            tail[left] = nums[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> end + <span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 72. 编辑距离</title>
    <link href="/2020/09/04/LeetCode-72-edit-distance/"/>
    <url>/2020/09/04/LeetCode-72-edit-distance/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></p><ul><li>状态：<code>dp[i][j]</code> - <code>word1[0:i]</code> 和 <code>word2[0:j]</code> 的最小编辑距离。</li><li>状态转移方程：<ul><li>若 <code>i</code>, <code>j</code> 位置相等，则跳过，否则进行删除，插入，替换操作，取最小值。</li><li>删除 <code>word1[i]</code> =&gt; <code>dp[i - 1][j] + 1</code></li><li>在 <code>word1[i + 1]</code> 插入 <code>word2[j]</code> =&gt; <code>dp[i][j - 1] + 1</code></li><li>替换 <code>word1[i]</code> 或 <code>word2[j]</code> =&gt; <code>dp[i - 1][j - 1] + 1</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200910115038.png" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;    <span class="hljs-keyword">int</span> len1 = word1.length();    <span class="hljs-keyword">int</span> len2 = word2.length();    <span class="hljs-comment">// 0 行和 0 列表示有一个单词为空，另一个单词不为空的情况</span>    <span class="hljs-comment">// 所以考虑到空字符串的情况下，多分配一个空间</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len2; i++) &#123;        dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;            <span class="hljs-comment">// 字符相同，同时去除该字符，直接取上一个距离</span>            <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 字符不同，依次尝试去除不同位置，取最小距离 + 1</span>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[len1][len2];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 746. 使用最小花费爬楼梯</title>
    <link href="/2020/09/04/LeetCode-746-min-cost-climbing-stairs/"/>
    <url>/2020/09/04/LeetCode-746-min-cost-climbing-stairs/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">10</td><td style="text-align:center">15</td><td style="text-align:center">20</td><td style="text-align:center"></td></tr></tbody></table><p>爬上第 <code>3</code> 阶楼梯可以从第 <code>1</code> 阶爬两步或者从第 <code>2</code> 阶爬一步。</p><p>题意：阶梯总数 = <code>cost.length</code>，爬上第 <code>i</code> 阶楼梯 &lt;=&gt; 不能算上第 <code>i</code> 阶楼梯的花费 <code>cost[i]</code>，也就是只能算到 <code>i - 1</code> 和 <code>i - 2</code> 阶楼梯。</p><ul><li>状态转移方程: <code>dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]</code></li><li>结果: <code>min(dp[len - 1], dp[len - 2])</code></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = cost.length;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; len; i++) &#123;            dp[i] = Math.min(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i];        &#125;        <span class="hljs-keyword">return</span> Math.min(dp[len - <span class="hljs-number">1</span>], dp[len - <span class="hljs-number">2</span>]);    &#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>从第 <code>i</code> 阶楼梯走一步或两步要花费 <code>cost[i]</code>。<br />走上第 <code>i</code> 阶楼梯可以从 <code>i - 1</code> 阶或 <code>i - 2</code> 阶开始。<br />状态：<code>dp[i]</code> - 走上第 <code>i</code> 阶楼梯的花费。<br />状态转移方程：<code>dp[i] = Math.min(起点 + 花费)</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = cost.length;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= len; i++) &#123;        <span class="hljs-comment">// 从 i - 2 起跳</span>        <span class="hljs-keyword">int</span> a = cost[i - <span class="hljs-number">2</span>] + dp[i - <span class="hljs-number">2</span>];        <span class="hljs-comment">// 从 i - 1 起跳</span>        <span class="hljs-keyword">int</span> b = cost[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>];        dp[i] = Math.min(a, b);    &#125;    <span class="hljs-keyword">return</span> dp[len];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 493. 翻转对</title>
    <link href="/2020/09/03/LeetCode-493-reverse-pairs/"/>
    <url>/2020/09/03/LeetCode-493-reverse-pairs/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-pairs/" target="_blank" rel="noopener">493. 翻转对</a></p><p>解法：</p><ul><li>使用归并排序，把数组分为左右两部分，且都单调递增；</li><li>则每次都固定左边元素 <code>nums[i]</code>，遍历右边元素 <code>nums[j]</code>；</li><li>因为都是有序的，对于 <code>nums[j]</code> 而言，<code>nums[i:mid]</code> 就是翻转对个数，且右边的元素只要遍历一遍。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">return</span> mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;    <span class="hljs-comment">// 左右均有序</span>    count += mergeSort(nums, left, mid);    count += mergeSort(nums, mid + <span class="hljs-number">1</span>, right);    <span class="hljs-comment">// [left, mid] [mid + 1, right] 有序</span>    <span class="hljs-comment">// 对于后半部分的每个元素，找到在前半部分最先满足的元素</span>    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= mid; i++) &#123;        <span class="hljs-keyword">while</span> (j &lt;= right &amp;&amp; nums[i] &gt; <span class="hljs-number">2</span> * (<span class="hljs-keyword">long</span>) nums[j]) &#123;            <span class="hljs-comment">// 对于 nums[j]，nums[i:mid] 都是它的翻转对</span>            count += mid - i + <span class="hljs-number">1</span>;            j++;        &#125;    &#125;    merge(nums, left, mid, right);    <span class="hljs-keyword">return</span> count;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = right - left + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];    <span class="hljs-keyword">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        tmp[k++] = nums[i] &gt; nums[j] ? nums[j++] : nums[i++];    &#125;    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        tmp[k++] = nums[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= right) &#123;        tmp[k++] = nums[j++];    &#125;    System.arraycopy(tmp, <span class="hljs-number">0</span>, nums, left, len);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 56. 合并区间</title>
    <link href="/2020/09/03/LeetCode-56-merge-intervals/"/>
    <url>/2020/09/03/LeetCode-56-merge-intervals/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;    <span class="hljs-keyword">int</span> len = intervals.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> intervals;    &#125;    quickSort(intervals, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    System.out.println(Arrays.deepToString(intervals));    List&lt;<span class="hljs-keyword">int</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> start = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 可以合并：(i + 1).开始 &lt;= i.结束</span>        <span class="hljs-comment">// 开始 = i.开始，结束 = max(i.结束, (i + 1).结束)</span>        <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt;= end) &#123;            <span class="hljs-comment">// 更新 end</span>            end = Math.max(end, intervals[i][<span class="hljs-number">1</span>]);        &#125; <span class="hljs-keyword">else</span> &#123;            list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;start, end&#125;);            <span class="hljs-comment">// 更新 start，用于下一次合并</span>            start = intervals[i][<span class="hljs-number">0</span>];            end = intervals[i][<span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-comment">// 添加最后一个区间</span>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;start, end&#125;);    <span class="hljs-keyword">int</span> count = list.size();    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[count][<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;        res[i] = list.get(i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-keyword">int</span> pivotPos = partition(arr, low, high);        quickSort(arr, low, pivotPos - <span class="hljs-number">1</span>);        quickSort(arr, pivotPos + <span class="hljs-number">1</span>, high);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] pivot = arr[low];    <span class="hljs-keyword">while</span> (low &lt; high) &#123;        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high][<span class="hljs-number">0</span>] &gt;= pivot[<span class="hljs-number">0</span>]) &#123;            high--;        &#125;        arr[low] = arr[high];        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low][<span class="hljs-number">0</span>] &lt;= pivot[<span class="hljs-number">0</span>]) &#123;            low++;        &#125;        arr[high] = arr[low];    &#125;    arr[low] = pivot;    <span class="hljs-keyword">return</span> low;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;    <span class="hljs-keyword">int</span> len = intervals.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> intervals;    &#125;    Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[<span class="hljs-number">0</span>]));    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];    <span class="hljs-keyword">int</span> idx = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] interval : intervals) &#123;        <span class="hljs-comment">// 可以合并：开始 &lt;= 结束</span>        <span class="hljs-keyword">if</span> (idx == -<span class="hljs-number">1</span> || interval[<span class="hljs-number">0</span>] &gt; res[idx][<span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">// 无法合并或 res 为空，添加新区间</span>            res[++idx] = interval;        &#125; <span class="hljs-keyword">else</span> &#123;            res[idx][<span class="hljs-number">1</span>] = Math.max(res[idx][<span class="hljs-number">1</span>], interval[<span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> Arrays.copyOf(res, idx + <span class="hljs-number">1</span>);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 242. 有效的字母异位词</title>
    <link href="/2020/09/03/LeetCode-242-valid-anagram/"/>
    <url>/2020/09/03/LeetCode-242-valid-anagram/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. 有效的字母异位词</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] sc = s.toCharArray();    <span class="hljs-keyword">char</span>[] tc = t.toCharArray();    Arrays.sort(sc);    Arrays.sort(tc);    <span class="hljs-keyword">return</span> Arrays.equals(sc, tc);&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(String s, String t)</span> </span>&#123;    <span class="hljs-keyword">if</span> (s.length() != t.length()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;        arr[s.charAt(i) - <span class="hljs-string">'a'</span>]++;        arr[t.charAt(i) - <span class="hljs-string">'a'</span>]--;    &#125;    <span class="hljs-comment">// 若同一字符数量不相等，则对应位置不为 0</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;        <span class="hljs-keyword">if</span> (value != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1122. 数组的相对排序</title>
    <link href="/2020/09/03/LeetCode-1122-relative-sort-array/"/>
    <url>/2020/09/03/LeetCode-1122-relative-sort-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/relative-sort-array/" target="_blank" rel="noopener">1122. 数组的相对排序</a></p><p>使用计数排序。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] relativeSortArray(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2) &#123;    <span class="hljs-keyword">int</span> len1 = arr1.length;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len1];    <span class="hljs-comment">// 记录 arr1 中每个元素的出现次数</span>    <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1001</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr1) &#123;        bucket[num]++;    &#125;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 输出 arr2 中存在于 arr1 中的元素</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr2) &#123;        <span class="hljs-keyword">while</span> (bucket[num]-- &gt; <span class="hljs-number">0</span>) &#123;            res[k++] = num;        &#125;    &#125;    <span class="hljs-comment">// 若剩余的元素出现次数 &gt; 0，则直接输出</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucket.length; i++) &#123;        <span class="hljs-keyword">while</span> (bucket[i]-- &gt; <span class="hljs-number">0</span>) &#123;            res[k++] = i;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 917. 仅仅反转字母</title>
    <link href="/2020/09/02/LeetCode-917-reverse-only-letters/"/>
    <url>/2020/09/02/LeetCode-917-reverse-only-letters/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-only-letters/" target="_blank" rel="noopener">917. 仅仅反转字母</a></p><h1 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseOnlyLetters</span><span class="hljs-params">(String S)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = S.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-comment">// 找到左边为字母的位置</span>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetter(chars[left])) &#123;            left++;        &#125;        <span class="hljs-comment">// 找到右边为字母的位置</span>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetter(chars[right])) &#123;            right--;        &#125;        <span class="hljs-keyword">char</span> c = chars[left];        chars[left++] = chars[right];        chars[right--] = c;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(chars);&#125;</code></pre><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseOnlyLetters</span><span class="hljs-params">(String S)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = S.toCharArray();    Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-comment">// 将所有字母入栈</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        <span class="hljs-keyword">if</span> (Character.isLetter(c)) &#123;            stack.push(c);        &#125;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        <span class="hljs-comment">// 若是字母从栈中取，否则取字符串的原字符</span>        <span class="hljs-keyword">if</span> (Character.isLetter(c)) &#123;            sb.append(stack.pop());        &#125; <span class="hljs-keyword">else</span> &#123;            sb.append(c);        &#125;    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 557. 反转字符串中的单词 III</title>
    <link href="/2020/09/02/LeetCode-557-reverse-words-in-a-string-iii/"/>
    <url>/2020/09/02/LeetCode-557-reverse-words-in-a-string-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">557. 反转字符串中的单词 III</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">' '</span>) &#123;            reverseWord(chars, start, i - <span class="hljs-number">1</span>);            start = i + <span class="hljs-number">1</span>;        &#125;    &#125;    reverseWord(chars, start, len - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(chars);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseWord</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">while</span> (start &lt; end) &#123;        <span class="hljs-keyword">char</span> c = chars[start];        chars[start++] = chars[end];        chars[end--] = c;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 151. 翻转字符串里的单词</title>
    <link href="/2020/09/02/LeetCode-151-reverse-words-in-a-string/"/>
    <url>/2020/09/02/LeetCode-151-reverse-words-in-a-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151. 翻转字符串里的单词</a></p><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> end = len - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 去除前面空格</span>    <span class="hljs-keyword">while</span> (start &lt; len &amp;&amp; chars[start] == <span class="hljs-string">' '</span>) &#123;        start++;    &#125;    <span class="hljs-comment">// 去除后面空格</span>    <span class="hljs-keyword">while</span> (end &gt;= <span class="hljs-number">0</span> &amp;&amp; chars[end] == <span class="hljs-string">' '</span>) &#123;        end--;    &#125;    <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    System.out.println(chars[end]);    Deque&lt;String&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">int</span> srcPos = start;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;        <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">' '</span>) &#123;            String word = s.substring(srcPos, i);            <span class="hljs-comment">// 若是空单词则跳过</span>            <span class="hljs-keyword">if</span> (!<span class="hljs-string">""</span>.equals(word)) &#123;                stack.push(word);            &#125;            srcPos = i + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 处理最后一个单词</span>        <span class="hljs-keyword">if</span> (i == end) &#123;            stack.push(s.substring(srcPos, Math.max(end, end + <span class="hljs-number">1</span>)));        &#125;    &#125;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;        sb.append(stack.pop());        <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;            sb.append(<span class="hljs-string">" "</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre><h1 id="双端队列"><a class="markdownIt-Anchor" href="#双端队列"></a> 双端队列</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> end = len - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 去除前面空格</span>    <span class="hljs-keyword">while</span> (start &lt; len &amp;&amp; chars[start] == <span class="hljs-string">' '</span>) &#123;        start++;    &#125;    <span class="hljs-comment">// 去除后面空格</span>    <span class="hljs-keyword">while</span> (end &gt;= <span class="hljs-number">0</span> &amp;&amp; chars[end] == <span class="hljs-string">' '</span>) &#123;        end--;    &#125;    <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    StringBuilder curWord = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++) &#123;        <span class="hljs-keyword">char</span> c = chars[i];        <span class="hljs-comment">// 字符为空 &amp;&amp; 单词不为空</span>        <span class="hljs-keyword">if</span> (curWord.length() != <span class="hljs-number">0</span> &amp;&amp; (c == <span class="hljs-string">' '</span>)) &#123;            <span class="hljs-comment">// 添加到队列前部</span>            deque.addFirst(curWord.toString());            <span class="hljs-comment">// 重置当前单词</span>            curWord.setLength(<span class="hljs-number">0</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span>) &#123;            curWord.append(c);        &#125;    &#125;    <span class="hljs-comment">// 因为[start, end] 末尾 != ' '</span>    <span class="hljs-comment">// 所以需要手动添加最后一个单词</span>    deque.addFirst(curWord.toString());    <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">" "</span>, deque);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 541. 反转字符串 II</title>
    <link href="/2020/09/02/LeetCode-541-reverse-string-ii/"/>
    <url>/2020/09/02/LeetCode-541-reverse-string-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">541. 反转字符串 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span> len = chars.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; len) &#123;        <span class="hljs-comment">// 对 (i, i + k) 之间的字符翻转</span>        <span class="hljs-comment">// 需要注意越界的情况</span>        reverseString(chars, i, Math.min(i + k, len) - <span class="hljs-number">1</span>);        i = i + <span class="hljs-number">2</span> * k;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(chars);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">char</span> c = s[left];        s[left] = s[right];        s[right] = c;        left++;        right--;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 344. 反转字符串</title>
    <link href="/2020/09/02/LeetCode-344-reverse-string/"/>
    <url>/2020/09/02/LeetCode-344-reverse-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = s.length;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">char</span> c = s[left];        s[left] = s[right];        s[right] = c;        left++;        right--;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 14. 最长公共前缀</title>
    <link href="/2020/09/01/LeetCode-14-longest-common-prefix/"/>
    <url>/2020/09/01/LeetCode-14-longest-common-prefix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></p><p>只要求前缀而不是子串，所以可以从起点开始查找字符。</p><h1 id="解法一横向比较"><a class="markdownIt-Anchor" href="#解法一横向比较"></a> 解法一：横向比较</h1><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;    <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    <span class="hljs-comment">// 假设前缀为第一个字符串</span>    String res = strs[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; strs.length; i++) &#123;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 将 res 与每个字符串比较</span>        <span class="hljs-keyword">for</span> (; j &lt; res.length() &amp;&amp; j &lt; strs[i].length(); j++) &#123;            <span class="hljs-keyword">if</span> (res.charAt(j) != strs[i].charAt(j)) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// j 表示公共前缀的位置</span>        res = res.substring(<span class="hljs-number">0</span>, j);        <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(res)) &#123;            <span class="hljs-keyword">return</span> res;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="解法二横向比较"><a class="markdownIt-Anchor" href="#解法二横向比较"></a> 解法二：横向比较</h1><p>解法一的另一种写法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;    <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    String prefix = strs[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 两两比较前缀</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; strs.length; i++) &#123;        prefix = getPrefix(prefix, strs[i]);        <span class="hljs-keyword">if</span> (prefix.length() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> prefix;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取 str1 和 str2 的最长公共前缀</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> str1</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> str2</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getPrefix</span><span class="hljs-params">(String str1, String str2)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = Math.min(str1.length(), str2.length());    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (str1.charAt(i) != str2.charAt(i)) &#123;            <span class="hljs-keyword">break</span>;        &#125;        idx++;    &#125;    <span class="hljs-keyword">return</span> str1.substring(<span class="hljs-number">0</span>, idx);&#125;</code></pre><h1 id="解法三纵向比较"><a class="markdownIt-Anchor" href="#解法三纵向比较"></a> 解法三：纵向比较</h1><p>将每个字符串的每个位置上的字符进行比较。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;    <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    <span class="hljs-keyword">int</span> len = strs[<span class="hljs-number">0</span>].length();    <span class="hljs-comment">// i 表示要比较的每个字符位置</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">char</span> cur = strs[<span class="hljs-number">0</span>].charAt(i);        <span class="hljs-comment">// 将第 i 个字符与 strs[] 里的每个串对应位置进行比较</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; strs.length; j++) &#123;            String str = strs[j];            <span class="hljs-comment">// prefix 串长度 == str 长度</span>            <span class="hljs-comment">// 当前位置的字符不匹配</span>            <span class="hljs-keyword">if</span> (i == str.length() || str.charAt(i) != cur) &#123;                <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, i);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 8. 字符串转换整数 (atoi)</title>
    <link href="/2020/09/01/LeetCode-8-string-to-integer-atoi/"/>
    <url>/2020/09/01/LeetCode-8-string-to-integer-atoi/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. 字符串转换整数 (atoi)</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Solution().myAtoi(<span class="hljs-string">"-2147483647"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] chars = str.toCharArray();        <span class="hljs-keyword">int</span> len = chars.length;        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 去除前部的空格</span>        <span class="hljs-keyword">while</span> (start &lt; len &amp;&amp; chars[start] == <span class="hljs-string">' '</span>) &#123;            start++;        &#125;        <span class="hljs-comment">// 到达终点</span>        <span class="hljs-keyword">if</span> (start == len) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">boolean</span> negative = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (chars[start] == <span class="hljs-string">'-'</span>) &#123;            <span class="hljs-comment">// 负数</span>            negative = <span class="hljs-keyword">true</span>;            start++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chars[start] == <span class="hljs-string">'+'</span>) &#123;            <span class="hljs-comment">// 正数</span>            start++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!Character.isDigit(chars[start])) &#123;            <span class="hljs-comment">// 首位非数字</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (start &lt; len &amp;&amp; Character.isDigit(chars[start])) &#123;            <span class="hljs-keyword">int</span> digit = chars[start] - <span class="hljs-string">'0'</span>;            <span class="hljs-comment">// 溢出判断</span>            <span class="hljs-comment">/*if (negative) &#123;</span><span class="hljs-comment">                if (-num &lt; Integer.MIN_VALUE / 10 || (-num == Integer.MIN_VALUE / 10 &amp;&amp; -digit &lt; -8)) &#123;</span><span class="hljs-comment">                    return Integer.MIN_VALUE;</span><span class="hljs-comment">                &#125;</span><span class="hljs-comment">            &#125; else &#123;</span><span class="hljs-comment">                if (num &gt; Integer.MAX_VALUE / 10 || (num == Integer.MAX_VALUE / 10 &amp;&amp; digit &gt; 7)) &#123;</span><span class="hljs-comment">                    return Integer.MAX_VALUE;</span><span class="hljs-comment">                &#125;</span><span class="hljs-comment">            &#125;*/</span>            <span class="hljs-comment">// num * 10 + digit &gt; INT_MAX 可能越界</span>            <span class="hljs-keyword">if</span> (num &gt; (Integer.MAX_VALUE - digit) / <span class="hljs-number">10</span>) &#123;                <span class="hljs-keyword">return</span> negative ? Integer.MIN_VALUE : Integer.MAX_VALUE;            &#125;            <span class="hljs-comment">// 拼装数字</span>            num = num * <span class="hljs-number">10</span> + digit;            <span class="hljs-comment">// 下一位</span>            start++;        &#125;        <span class="hljs-keyword">return</span> negative ? -num : num;    &#125;&#125;</code></pre><h1 id="解法二自动机"><a class="markdownIt-Anchor" href="#解法二自动机"></a> 解法二：自动机</h1><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200901204413.png" srcset="/img/loading.gif" alt="" /></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(String str)</span> </span>&#123;        Automaton automaton = <span class="hljs-keyword">new</span> Automaton();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str.toCharArray()) &#123;            automaton.get(c);        &#125;        <span class="hljs-keyword">return</span> automaton.sign * (<span class="hljs-keyword">int</span>)automaton.ans;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Automaton</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> START = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNED = <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> IN_NUM = <span class="hljs-number">2</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> END = <span class="hljs-number">3</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自动机的状态</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> state = START;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 状态转移表</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Map&lt;Integer, <span class="hljs-keyword">int</span>[]&gt; map;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 符号</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 结果</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Automaton</span><span class="hljs-params">()</span> </span>&#123;        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(START, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;START, SIGNED, IN_NUM, END&#125;);        map.put(SIGNED, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;END, END, IN_NUM, END&#125;);        map.put(IN_NUM, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;END, END, IN_NUM, END&#125;);        map.put(END, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;END, END, END, END&#125;);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCol</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">' '</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;        <span class="hljs-comment">// 新的状态</span>        state = map.get(state)[getCol(c)];        <span class="hljs-comment">// 转移到 数字</span>        <span class="hljs-keyword">if</span> (state == IN_NUM) &#123;            <span class="hljs-keyword">int</span> digit = c - <span class="hljs-string">'0'</span>;            ans = ans * <span class="hljs-number">10</span> + digit;            <span class="hljs-keyword">if</span> (sign == <span class="hljs-number">1</span>) &#123;                <span class="hljs-comment">// 正数</span>                ans = Math.min(ans, Integer.MAX_VALUE);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 负数</span>                ans = Math.min(ans, -(<span class="hljs-keyword">long</span>) Integer.MIN_VALUE);            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == SIGNED) &#123;            <span class="hljs-comment">// 转移到符号</span>            sign = (c == <span class="hljs-string">'+'</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 387. 字符串中的第一个唯一字符</title>
    <link href="/2020/09/01/LeetCode-387-first-unique-character-in-a-string/"/>
    <url>/2020/09/01/LeetCode-387-first-unique-character-in-a-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">387. 字符串中的第一个唯一字符</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>记录每个字母出现的次数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];    <span class="hljs-comment">// 记录每个字母出现的次数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;        counts[c - <span class="hljs-string">'a'</span>]++;    &#125;    <span class="hljs-comment">// 寻找出现次数为 1 的字母位置</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;        <span class="hljs-keyword">if</span> (counts[chars[i] - <span class="hljs-string">'a'</span>] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>判断首次出现的位置和最后出现的位置是否相等。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;        <span class="hljs-keyword">if</span> (s.indexOf(chars[i]) == s.lastIndexOf(chars[i])) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 771. 宝石与石头</title>
    <link href="/2020/08/31/LeetCode-771-jewels-and-stones/"/>
    <url>/2020/08/31/LeetCode-771-jewels-and-stones/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">771. 宝石与石头</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numJewelsInStones</span><span class="hljs-params">(String J, String S)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">char</span>[] js = J.toCharArray();    <span class="hljs-keyword">char</span>[] ss = S.toCharArray();    Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : js) &#123;        set.add(c);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : ss) &#123;        <span class="hljs-keyword">if</span> (set.contains(c)) &#123;            count++;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 58. 最后一个单词的长度</title>
    <link href="/2020/08/31/LeetCode-58-length-of-last-word/"/>
    <url>/2020/08/31/LeetCode-58-length-of-last-word/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">58. 最后一个单词的长度</a></p><p>需要注意最后一个字符为空的情况。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span> end = s.length() - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 找到末尾不为空的字符位置</span>    <span class="hljs-keyword">while</span> (end &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(end) == <span class="hljs-string">' '</span>) &#123;        end--;    &#125;    <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 从后往前找第一个空的位置</span>    <span class="hljs-keyword">int</span> start = end;    <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(start) != <span class="hljs-string">' '</span>) &#123;        start--;    &#125;    <span class="hljs-keyword">return</span> end - start;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 709. 转换成小写字母</title>
    <link href="/2020/08/31/LeetCode-709-to-lower-case/"/>
    <url>/2020/08/31/LeetCode-709-to-lower-case/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/to-lower-case/" target="_blank" rel="noopener">709. 转换成小写字母</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLowerCase</span><span class="hljs-params">(String str)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] chars = str.toCharArray();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;        <span class="hljs-keyword">if</span> (chars[i] &gt;= <span class="hljs-string">'A'</span> &amp;&amp; chars[i] &lt;= <span class="hljs-string">'Z'</span>) &#123;            chars[i] = (<span class="hljs-keyword">char</span>) (chars[i] + <span class="hljs-number">32</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> String.valueOf(chars);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 146. LRU 缓存机制</title>
    <link href="/2020/08/30/LeetCode-146-lru-cache/"/>
    <url>/2020/08/30/LeetCode-146-lru-cache/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 结点类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">int</span> key;    <span class="hljs-keyword">int</span> value;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.value = value;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Cache 对应的链表，用于增删结点 O(1)</span><span class="hljs-comment">     * Node&lt;k1, v1&gt; -&gt; Node&lt;k2, v2&gt; -&gt; ...</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> LinkedList&lt;Node&gt; cache;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * key 到 Node 的映射，用于查询 O(1)</span><span class="hljs-comment">     * key -&gt; Node</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Map&lt;Integer, Node&gt; map;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 最大容量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;        cache = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">this</span>.capacity = capacity;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 若 key 存在，返回，且要把对应结点移到前面</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            <span class="hljs-keyword">int</span> value = map.get(key).value;            <span class="hljs-comment">// 使用 put 方法移动已存在结点到前面</span>            put(key, value);            <span class="hljs-keyword">return</span> value;        &#125;        <span class="hljs-comment">// 结点不存在</span>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 若 key 存在，删除旧结点，添加新结点，并把对应结点移到前面</span><span class="hljs-comment">     * 否则插入新结点</span><span class="hljs-comment">     * 若容量达到上限，删除最久未使用的结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        Node node = <span class="hljs-keyword">new</span> Node(key, value);        <span class="hljs-comment">// 该结点已存在</span>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            <span class="hljs-comment">// 删除旧结点</span>            cache.remove(map.get(key));            map.remove(key);        &#125;        <span class="hljs-comment">// 该结点不存在，则要判断是否有空位置用来新增结点</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// cache 容量达到上限，删除最后一个结点</span>            <span class="hljs-keyword">if</span> (cache.size() == capacity) &#123;                Node last = cache.getLast();                cache.removeLast();                map.remove(last.key);            &#125;        &#125;        <span class="hljs-comment">// 添加新结点</span>        cache.addFirst(node);        map.put(key, node);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 52. N皇后 II</title>
    <link href="/2020/08/29/LeetCode-52-n-queens-ii/"/>
    <url>/2020/08/29/LeetCode-52-n-queens-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">52. N皇后 II</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">totalNQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">this</span>.n = n;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-keyword">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : board) &#123;            Arrays.fill(line, <span class="hljs-string">'.'</span>);        &#125;        backtrack(<span class="hljs-number">0</span>, board);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">if</span> (row == n) &#123;            res++;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;            <span class="hljs-keyword">if</span> (!isValid(row, col, board)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            board[row][col] = <span class="hljs-string">'Q'</span>;            backtrack(row + <span class="hljs-number">1</span>, board);            board[row][col] = <span class="hljs-string">'.'</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : board) &#123;            <span class="hljs-keyword">if</span> (line[col] == <span class="hljs-string">'Q'</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--)&#123;            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'Q'</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'Q'</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 7. 整数反转</title>
    <link href="/2020/08/29/LeetCode-7-reverse-integer/"/>
    <url>/2020/08/29/LeetCode-7-reverse-integer/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. 整数反转</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 个位数</span>        <span class="hljs-keyword">int</span> pop = x % <span class="hljs-number">10</span>;        <span class="hljs-comment">// 去除个位数</span>        x = x / <span class="hljs-number">10</span>;        <span class="hljs-keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="hljs-number">10</span>                <span class="hljs-comment">// 最后一位溢出</span>                || (res == Integer.MAX_VALUE / <span class="hljs-number">10</span> &amp;&amp; pop &gt; <span class="hljs-number">7</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="hljs-number">10</span>                <span class="hljs-comment">// 最后一位溢出</span>                || (res == Integer.MIN_VALUE / <span class="hljs-number">10</span> &amp;&amp; pop &lt; -<span class="hljs-number">8</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// 翻转后的数</span>        res = res * <span class="hljs-number">10</span> + pop;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 338. 比特位计数</title>
    <link href="/2020/08/28/LeetCode-338-counting-bits/"/>
    <url>/2020/08/28/LeetCode-338-counting-bits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>每个数依次计数</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= num; i++) &#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = i;        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;            n = n &amp; (n - <span class="hljs-number">1</span>);            count++;        &#125;        res[i] = count;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>用奇偶数判断妙的很啊！！！</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= num; i++) &#123;        <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 奇数比前面的偶数多一个 1</span>            res[i] = res[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-comment">// 偶数的最低位是 0，所以 i 中 1 的个数和去除低位 0 后的那个数一样多</span>             res[i] = res[i &gt;&gt; <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><p>其实也是奇偶数的思路。<br /><code>i</code> 和 <code>i &gt;&gt; 1</code> 中 <code>1</code> 的个数是最低有效位上的差别。</p><pre><code class="hljs java">i = (<span class="hljs-number">100101</span>)i &gt;&gt; <span class="hljs-number">1</span> = (<span class="hljs-number">10010</span>)</code></pre><p>状态：<code>dp[i]</code> - 数字 <code>i</code> 中 <code>1</code> 的个数。<br />状态转移方程：<code>dp[i] = dp[i &gt;&gt; 1] + 最低有效位</code>。</p><hr /><p><code>i</code> 和 <code>i &amp; (i - 1)</code> 中 <code>1</code> 的个数总是相差 <code>1</code>，因为 <code>i</code> 中的最后一位 <code>1</code> 已经变为 <code>0</code>。<br />状态转移方程：<code>dp[i] = dp[i &amp; (i - 1)] + 1</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;        <span class="hljs-comment">// 使用最低有效位计算</span>        <span class="hljs-comment">// dp[i] = dp[i &gt;&gt; 1] + (i &amp; 1);</span>        <span class="hljs-comment">// 抹除最低位的 1</span>        dp[i] = dp[i &amp; (i - <span class="hljs-number">1</span>)] + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> dp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 190. 颠倒二进制位</title>
    <link href="/2020/08/28/LeetCode-190-reverse-bits/"/>
    <url>/2020/08/28/LeetCode-190-reverse-bits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>逐位移动，<code>n</code> 从<strong>右往左取</strong>，取出的每一位放到 <code>res</code> 中，<code>res</code> 从<strong>左往右放</strong>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">31</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;        <span class="hljs-comment">// 先左移空出最右边一位，再加上 n 的最后一位</span>        res = (res &lt;&lt; <span class="hljs-number">1</span>) + (n &amp; <span class="hljs-number">1</span>);        <span class="hljs-comment">// 删除最后一位</span>        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二：</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// 取最后一位移到左边</span>        res += (n &amp; <span class="hljs-number">1</span>) &lt;&lt; i;        <span class="hljs-comment">// 删除最后一位</span>        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 50. Pow(x, n)</title>
    <link href="/2020/08/28/LeetCode-50-powx-n/"/>
    <url>/2020/08/28/LeetCode-50-powx-n/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></p><h1 id="快速幂-递归"><a class="markdownIt-Anchor" href="#快速幂-递归"></a> 快速幂 + 递归</h1><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>77</mn></msup><mo>←</mo><msup><mi>x</mi><mn>38</mn></msup><mo>⋅</mo><mi>x</mi><mo>←</mo><msup><mi>x</mi><mn>19</mn></msup><mo>←</mo><msup><mi>x</mi><mn>9</mn></msup><mo>⋅</mo><mi>x</mi><mo>←</mo><msup><mi>x</mi><mn>4</mn></msup><mo>⋅</mo><mi>x</mi><mo>←</mo><msup><mi>x</mi><mn>2</mn></msup><mo>←</mo><mi>x</mi><mo>←</mo><msup><mi>x</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">x^{77} \leftarrow x^{38} \cdot x \leftarrow x^{19} \leftarrow x^9 \cdot x \leftarrow x^4 \cdot x \leftarrow x^2 \leftarrow x \leftarrow x^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">9</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></p><p>若 <code>n</code> 为偶数，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><msup><mi>x</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">x^n = x^{\frac{n}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.89708em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.89708em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>若 <code>n</code> 为奇数，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><msup><mi>x</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup><mo>⋅</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x^n = x^{\frac{n}{2}} \cdot x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.89708em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.89708em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></span></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">long</span> N = n;    <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? getPow(x, N) : <span class="hljs-number">1.0</span> / getPow(x, N);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;    &#125;    <span class="hljs-keyword">double</span> y = getPow(x, n / <span class="hljs-number">2</span>);    <span class="hljs-keyword">return</span> (n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> ? y * y * x : y * y;&#125;</code></pre><h1 id="快速幂-迭代"><a class="markdownIt-Anchor" href="#快速幂-迭代"></a> 快速幂 + 迭代</h1><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mi>m</mi></msub><msub><mo>⋯</mo><mn>3</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub></mrow></msup><mo>=</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>×</mo><mn>1</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mn>2</mn></msub><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mn>3</mn></msub><mo>×</mo><msup><mn>2</mn><mn>2</mn></msup></mrow></msup><mo separator="true">⋅</mo><mo>…</mo><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></msup><mo separator="true">⋅</mo></mrow><annotation encoding="application/x-tex">x^n = x^{b_m\dotsb_3b_2b_1} = x^{b_1\times1}·x^{b_2\times2^1}·x^{b_3\times2^2}·\dots·x^{b_m\times2^{m-1}}·</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.899108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.899108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="minner mtight"><span class="minner mtight">⋯</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0369199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.899108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>9</mn></msup><mo>=</mo><msup><mi>x</mi><mn>1001</mn></msup><mo>=</mo><msup><mi>x</mi><mrow><mn>1</mn><mo>×</mo><mn>8</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><mn>0</mn><mo>×</mo><mn>4</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><mn>0</mn><mo>×</mo><mn>2</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>x</mi><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">x^9 = x^{1001} = x^{1\times8}·x^{0\times4}·x^{0\times2}·x^{1\times1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">×</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">×</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">×</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>所以当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = 0 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></msup></mrow><annotation encoding="application/x-tex">x^{b_m\times2^{m-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869199999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> = 1，此时该项不用计算，每一项的规则如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></msup><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>x</mi><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></msup><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">x^{b_m\times2^{m-1}} = \begin{cases}1, &amp; b_m = 0 \\x^{2^{m-1}}, &amp; b_m = 1\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0369199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>最终的计算规则：</p><ul><li>先获取二进制位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><msub><mo>⋯</mo><mn>3</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_m\dotsb_3b_2b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner">⋯</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的值<ul><li><code>n &amp; 1</code>: 获取最后一位</li><li><code>n &gt;&gt; 1</code>: 删除最后一位，获取下一位</li></ul></li><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> == 1，则更新结果：<code>res *= x</code></li><li>计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>1</mn></msup><mo separator="true">,</mo><msup><mi>x</mi><mn>2</mn></msup><mo separator="true">,</mo><msup><mi>x</mi><mn>4</mn></msup><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msup><mi>x</mi><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup></msup></mrow><annotation encoding="application/x-tex">x^1, x^2, x^4, \dots, x^{2^{m-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.18136em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 的值：循环操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x = x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">long</span> N = n;    <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? getPow(x, N) : <span class="hljs-number">1.0</span> / getPow(x, -N);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span> </span>&#123;    <span class="hljs-keyword">double</span> res = <span class="hljs-number">1.0</span>;    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 最后一位为 1，表示此时 x^n 有效</span>        <span class="hljs-comment">// 若为 0，增益为 0，结果不变</span>        <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;            res *= x;        &#125;        <span class="hljs-comment">// 保存当前位的 x^i</span>        x *= x;        <span class="hljs-comment">// 删除最后一位，进行下一位计算</span>        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 231. 2的幂</title>
    <link href="/2020/08/27/LeetCode-231-power-of-two/"/>
    <url>/2020/08/27/LeetCode-231-power-of-two/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">231. 2的幂</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><blockquote><p>二进制下，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 只有一位是 <code>1</code>。</p></blockquote><p>若 <code>x &amp; (x - 1) == 0</code>，表示 <code>x</code> 只有 <code>1</code> 个 <code>1</code>，即为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>。</p><table><thead><tr><th style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></th><th style="text-align:center">n</th><th style="text-align:center">n-1</th><th style="text-align:center">n &amp; (n - 1)</th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">1</td><td style="text-align:center">0000</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">10</td><td style="text-align:center">0001</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">100</td><td style="text-align:center">0011</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">1000</td><td style="text-align:center">0111</td><td style="text-align:center">0</td></tr></tbody></table><p>证明：<br />若 <code>n</code> 为 <code>2</code> 的幂，则 <code>n</code> 的二进制位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><msub><mi>n</mi><mn>2</mn></msub><msub><mi>n</mi><mn>3</mn></msub><msub><mi>n</mi><mn>4</mn></msub><mo>…</mo></mrow><annotation encoding="application/x-tex">n_1 n_2 n_3n_4\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span> 有且只有一位为 <code>1</code>，且为最高位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则 <code>n - 1</code> 的二进制位除了最高位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n_1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 外其余位都为 <code>1</code>。<br />在这种情况下，<code>n &amp; (n - 1) == 0</code>，因此可用来判断 <code>n</code> 是不是 <code>2</code> 的幂。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 除 1 之外的奇数</span>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 2 的幂最后商是 1</span>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 是奇数</span>        <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 191. 位1的个数</title>
    <link href="/2020/08/27/LeetCode-191-number-of-1-bits/"/>
    <url>/2020/08/27/LeetCode-191-number-of-1-bits/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>任何数字 <code>&amp; 1</code> 都会获得这个数字的最低位，因此只要 <code>mask</code> 左移就能获取每个数字的最低位。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 32 位整数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;        <span class="hljs-keyword">if</span> ((n &amp; mask) != <span class="hljs-number">0</span>) &#123;            count++;        &#125;        mask &lt;&lt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;        count += n &amp; <span class="hljs-number">1</span>;        n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p><code>n &amp; n - 1</code> 可以把最低位的 <code>1</code> 变为 <code>0</code>，因此只要循环操作，直到 <code>n == 0</code>，操作的次数就是 <code>1</code> 的个数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;        n = n &amp; (n - <span class="hljs-number">1</span>);        count++;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 773. 滑动谜题</title>
    <link href="/2020/08/27/LeetCode-773-sliding-puzzle/"/>
    <url>/2020/08/27/LeetCode-773-sliding-puzzle/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sliding-puzzle/" target="_blank" rel="noopener">773. 滑动谜题</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>需要注意棋盘的深拷贝。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">slidingPuzzle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">int</span> rows = board.length;        <span class="hljs-keyword">int</span> cols = board[<span class="hljs-number">0</span>].length;        Node start = <span class="hljs-keyword">null</span>;        String startBoardStr = <span class="hljs-string">""</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-number">0</span>) &#123;                    startBoardStr = Arrays.deepToString(board);                    start = <span class="hljs-keyword">new</span> Node(i, j, board.clone(), startBoardStr);                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> (start == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;        String target = Arrays.deepToString(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>&#125;&#125;);        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        Set&lt;String&gt; used = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        queue.add(start);        used.add(startBoardStr);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            count++;            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                Node curNode = queue.poll();                String curBoardStr = curNode.boardStr;                System.out.println(curBoardStr);                <span class="hljs-keyword">if</span> (target.equals(curBoardStr)) &#123;                    <span class="hljs-keyword">return</span> count - <span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                    <span class="hljs-keyword">int</span> newX = curNode.zeroX + dir[<span class="hljs-number">0</span>];                    <span class="hljs-keyword">int</span> newY = curNode.zeroY + dir[<span class="hljs-number">1</span>];                    <span class="hljs-comment">// 越界</span>                    <span class="hljs-keyword">if</span> (!inArea(newX, newY, rows, cols)) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-keyword">int</span>[][] newBoard = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][cols];                    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] line : curNode.board) &#123;                        newBoard[i++] = line.clone();                    &#125;                    <span class="hljs-comment">// 交换数字</span>                    newBoard[curNode.zeroX][curNode.zeroY] = newBoard[newX][newY];                    newBoard[newX][newY] = <span class="hljs-number">0</span>;                    String newBoardStr = Arrays.deepToString(newBoard);                    <span class="hljs-comment">// 已被使用</span>                    <span class="hljs-keyword">if</span> (used.contains(newBoardStr)) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-comment">// 加入队列并标记</span>                    queue.add(<span class="hljs-keyword">new</span> Node(newX, newY, newBoard, newBoardStr));                    used.add(newBoardStr);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">int</span> zeroX;    <span class="hljs-keyword">int</span> zeroY;    <span class="hljs-keyword">int</span>[][] board;    String boardStr;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> zeroX, <span class="hljs-keyword">int</span> zeroY, <span class="hljs-keyword">int</span>[][] board, String boardStr)</span> </span>&#123;        <span class="hljs-keyword">this</span>.zeroX = zeroX;        <span class="hljs-keyword">this</span>.zeroY = zeroY;        <span class="hljs-keyword">this</span>.board = board;        <span class="hljs-keyword">this</span>.boardStr = boardStr;    &#125;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>把二维数组映射为字符串，每次移动一个数字就相当于交换字符，省去了很多边界判断。</p><pre><code class="hljs java">String TARGET = <span class="hljs-string">"123450"</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">slidingPuzzle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;&#125;;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] row : board) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : row) &#123;            sb.append(num);        &#125;    &#125;    String start = sb.toString();    <span class="hljs-keyword">if</span> (TARGET.equals(start)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    Set&lt;String&gt; used = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    queue.add(start);    used.add(start);    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        count++;        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            String cur = queue.poll();            <span class="hljs-keyword">if</span> (TARGET.equals(cur)) &#123;                <span class="hljs-keyword">return</span> count - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">char</span>[] arr = cur.toCharArray();            <span class="hljs-comment">// 一定会找到 0，不用特判</span>            <span class="hljs-keyword">int</span> zeroIdx = cur.indexOf(<span class="hljs-string">'0'</span>);            <span class="hljs-keyword">int</span>[] moves = dirs[zeroIdx];            <span class="hljs-comment">// 尝试交换每个位置</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> next : moves) &#123;                <span class="hljs-comment">// 交换 0</span>                arr[zeroIdx] = arr[next];                arr[next] = <span class="hljs-string">'0'</span>;                <span class="hljs-comment">// 若未出现过，则加入队列</span>                String candidate = String.valueOf(arr);                <span class="hljs-keyword">if</span> (!used.contains(candidate)) &#123;                    queue.add(candidate);                    used.add(candidate);                &#125;                <span class="hljs-comment">// 还原</span>                arr[next] = arr[zeroIdx];                arr[zeroIdx] = <span class="hljs-string">'0'</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1091. 二进制矩阵中的最短路径</title>
    <link href="/2020/08/27/LeetCode-1091-shortest-path-in-binary-matrix/"/>
    <url>/2020/08/27/LeetCode-1091-shortest-path-in-binary-matrix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">1091. 二进制矩阵中的最短路径</a></p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><p>需要注意起点和终点都要 <code>== 0</code>，提交了好多次都在判断边界。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = grid.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 一开始就走不通</span>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 只有一个元素</span>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len][len];        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(<span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            count++;            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                Node curNode = queue.poll();                <span class="hljs-comment">// System.out.println(count + ": " + curNode.x + ", " + curNode.y);</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                    <span class="hljs-keyword">int</span> newX = curNode.x + dir[<span class="hljs-number">0</span>];                    <span class="hljs-keyword">int</span> newY = curNode.y + dir[<span class="hljs-number">1</span>];                    <span class="hljs-comment">// System.out.println(newX + ", " + newY + ", len = " + len);</span>                    <span class="hljs-keyword">if</span> (!inArea(newX, newY, len) || visited[newX][newY] || grid[newX][newY] == <span class="hljs-number">1</span>) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-comment">// grid[i][j] == 0 时才有效</span>                    <span class="hljs-keyword">if</span> (newX == (len - <span class="hljs-number">1</span>) &amp;&amp; newY == (len - <span class="hljs-number">1</span>)) &#123;                        <span class="hljs-keyword">return</span> count + <span class="hljs-number">1</span>;                    &#125;                    queue.add(<span class="hljs-keyword">new</span> Node(newX, newY));                    visited[newX][newY] = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; len &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; len;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">int</span> y;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 37. 解数独</title>
    <link href="/2020/08/26/LeetCode-37-sudoku-solver/"/>
    <url>/2020/08/26/LeetCode-37-sudoku-solver/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = <span class="hljs-number">9</span>;    <span class="hljs-keyword">boolean</span>[][] rows = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">boolean</span>[][] cols = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">boolean</span>[][] boxes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">'.'</span>) &#123;                <span class="hljs-keyword">int</span> num = board[i][j] - <span class="hljs-string">'0'</span>;                <span class="hljs-keyword">int</span> box = i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;                boxes[box][num] = <span class="hljs-keyword">true</span>;                rows[i][num] = <span class="hljs-keyword">true</span>;                cols[j][num] = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;    backtrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n, board, rows, cols, boxes);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">boolean</span>[][] rows, <span class="hljs-keyword">boolean</span>[][] cols, <span class="hljs-keyword">boolean</span>[][] boxes)</span> </span>&#123;    <span class="hljs-comment">// 到达终点</span>    <span class="hljs-keyword">if</span> (i == n) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 到达某行的最后一列</span>    <span class="hljs-keyword">if</span> (j == n) &#123;        <span class="hljs-keyword">return</span> backtrack(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n, board, rows, cols, boxes);    &#125;    <span class="hljs-comment">// 已经是数字，跳过</span>    <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">'.'</span>) &#123;        <span class="hljs-keyword">return</span> backtrack(i, j + <span class="hljs-number">1</span>, n, board, rows, cols, boxes);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>; num &lt;= <span class="hljs-number">9</span>; num++) &#123;        <span class="hljs-keyword">if</span> (notValid(i, j, num, rows, cols, boxes)) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 尝试放数字的同时也要进行标记</span>        placeNum(i, j, num, rows, cols, boxes, board);        <span class="hljs-keyword">if</span> (backtrack(i, j + <span class="hljs-number">1</span>, n, board, rows, cols, boxes)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        removeNum(i, j, num, rows, cols, boxes, board);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">placeNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> num, <span class="hljs-keyword">boolean</span>[][] rows, <span class="hljs-keyword">boolean</span>[][] cols, <span class="hljs-keyword">boolean</span>[][] boxes, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">int</span> box = i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;    boxes[box][num] = <span class="hljs-keyword">true</span>;    board[i][j] = (<span class="hljs-keyword">char</span>) (num + <span class="hljs-string">'0'</span>);    rows[i][num] = <span class="hljs-keyword">true</span>;    cols[j][num] = <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> num, <span class="hljs-keyword">boolean</span>[][] rows, <span class="hljs-keyword">boolean</span>[][] cols, <span class="hljs-keyword">boolean</span>[][] boxes, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">int</span> box = i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;    boxes[box][num] = <span class="hljs-keyword">false</span>;    board[i][j] = <span class="hljs-string">'.'</span>;    rows[i][num] = <span class="hljs-keyword">false</span>;    cols[j][num] = <span class="hljs-keyword">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">notValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> num, <span class="hljs-keyword">boolean</span>[][] rows, <span class="hljs-keyword">boolean</span>[][] cols, <span class="hljs-keyword">boolean</span>[][] boxes)</span> </span>&#123;    <span class="hljs-keyword">int</span> box = i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;    <span class="hljs-keyword">return</span> boxes[box][num] || rows[i][num] || cols[j][num];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 36. 有效的数独</title>
    <link href="/2020/08/26/LeetCode-36-valid-sudoku/"/>
    <url>/2020/08/26/LeetCode-36-valid-sudoku/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p><code>board[i][j]</code> 是字符型，判断九宫格重复时不要忘了转为数字。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span>[][] boxes;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 9 个格子，每个格子 9 个数</span>        <span class="hljs-comment">// 一行代表一个格子，若格子中某个位置为 1，表示该位置对应的数已经出现过</span>        boxes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, board);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-comment">// 所有行遍历完成，则结束</span>        <span class="hljs-keyword">if</span> (row == rows) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 对当前行的每一个位置判断</span>        <span class="hljs-keyword">char</span>[] curLine = board[row];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; curLine.length; col++) &#123;            <span class="hljs-keyword">if</span> (board[row][col] == <span class="hljs-string">'.'</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (!isValid(row, col, board)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 进入下一行</span>        <span class="hljs-keyword">return</span> dfs(row + <span class="hljs-number">1</span>, board);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-comment">// 判断列是否重复</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">if</span> (i != row &amp;&amp; board[i][col] == board[row][col]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 判断行是否重复</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (j != col &amp;&amp; board[row][j] == board[row][col]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 判断九宫格是否重复</span>        <span class="hljs-keyword">int</span> boxNum = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + col / <span class="hljs-number">3</span>;        <span class="hljs-keyword">int</span> num = board[row][col] - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">if</span> (boxes[boxNum][num] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 未出现过则设置为 1，用于下一个数字判断</span>        boxes[boxNum][num] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>把行列，九宫格的数字都映射到数组里，加快判断效率。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-comment">// 每行记录 board 的每行数字是否出现</span>    <span class="hljs-comment">// 下标代表对应元素</span>    <span class="hljs-comment">// 1: 出现 0: 未出现</span>    <span class="hljs-keyword">int</span>[][] rows = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];    <span class="hljs-comment">// 每行记录 board 的每列数字是否出现</span>    <span class="hljs-keyword">int</span>[][] cols = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];    <span class="hljs-comment">// 每行记录 board 每个九宫格是否出现</span>    <span class="hljs-keyword">int</span>[][] boxes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'.'</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">int</span> num = board[i][j] - <span class="hljs-string">'0'</span>;            <span class="hljs-keyword">if</span> (rows[i][num] == <span class="hljs-number">1</span> || cols[j][num] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-keyword">int</span> box = (i / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;            <span class="hljs-keyword">if</span> (boxes[box][num] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 标记对应元素</span>            rows[i][num] = <span class="hljs-number">1</span>;            cols[j][num] = <span class="hljs-number">1</span>;            boxes[box][num] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 130. 被围绕的区域</title>
    <link href="/2020/08/25/LeetCode-130-surrounded-regions/"/>
    <url>/2020/08/25/LeetCode-130-surrounded-regions/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><p>先标记边界以及和边界连通的 <code>O</code>，剩下的就是需要填充的格子，最后还原之前标记的格子。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-comment">// 左</span>            <span class="hljs-keyword">if</span> (board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">'O'</span>) &#123;                dfs(i, <span class="hljs-number">0</span>, board);            &#125;            <span class="hljs-comment">// 右</span>            <span class="hljs-keyword">if</span> (board[i][cols - <span class="hljs-number">1</span>] == <span class="hljs-string">'O'</span>) &#123;                dfs(i, cols - <span class="hljs-number">1</span>, board);            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;            <span class="hljs-comment">// 上</span>            <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>][i] == <span class="hljs-string">'O'</span>) &#123;                dfs(<span class="hljs-number">0</span>, i, board);            &#125;            <span class="hljs-comment">// 下</span>            <span class="hljs-keyword">if</span> (board[rows - <span class="hljs-number">1</span>][i] == <span class="hljs-string">'O'</span>) &#123;                dfs(rows - <span class="hljs-number">1</span>, i, board);            &#125;        &#125;        <span class="hljs-comment">// 填充 O 为 X</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'O'</span>) &#123;                    board[i][j] = <span class="hljs-string">'X'</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 还原 O</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'#'</span>) &#123;                    board[i][j] = <span class="hljs-string">'O'</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        board[x][y] = <span class="hljs-string">'#'</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = x + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = y + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (inArea(newX, newY) &amp;&amp; board[newX][newY] == <span class="hljs-string">'O'</span>) &#123;                dfs(newX, newY, board);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;&#125;</code></pre><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><ul><li>将边界的 <code>O</code> 与 <code>dummy</code> 连接</li><li>将内部的 <code>O</code> 互相连接，剩下的未与 <code>dummy</code> 连接的 <code>O</code> 即为需要填充的部分</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span> dummy;    UnionFind uf;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 所有未被围绕的 O 都与 dummy 连接</span>        dummy = rows * cols;        uf = <span class="hljs-keyword">new</span> UnionFind(dummy + <span class="hljs-number">1</span>);        <span class="hljs-comment">// 连接左右边界</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-comment">// 左</span>            <span class="hljs-keyword">if</span> (board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">'O'</span>) &#123;                uf.union(dummy, getIndex(i, <span class="hljs-number">0</span>));            &#125;            <span class="hljs-comment">// 右</span>            <span class="hljs-keyword">if</span> (board[i][cols - <span class="hljs-number">1</span>] == <span class="hljs-string">'O'</span>) &#123;                uf.union(dummy, getIndex(i, cols - <span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-comment">// 连接上下边界</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;            <span class="hljs-comment">// 上</span>            <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>][i] == <span class="hljs-string">'O'</span>) &#123;                uf.union(dummy, getIndex(<span class="hljs-number">0</span>, i));            &#125;            <span class="hljs-comment">// 下</span>            <span class="hljs-keyword">if</span> (board[rows - <span class="hljs-number">1</span>][i] == <span class="hljs-string">'O'</span>) &#123;                uf.union(dummy, getIndex(rows - <span class="hljs-number">1</span>, i));            &#125;        &#125;        <span class="hljs-comment">// 遍历中间的 O，并将它们互相连接</span>        <span class="hljs-comment">// 则未与 dummy 连接的 O 即为需要填充的</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; cols - <span class="hljs-number">1</span>; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'O'</span>) &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                        <span class="hljs-keyword">int</span> newX = i + dir[<span class="hljs-number">0</span>];                        <span class="hljs-keyword">int</span> newY = j + dir[<span class="hljs-number">1</span>];                        <span class="hljs-keyword">if</span> (board[newX][newY] == <span class="hljs-string">'O'</span>) &#123;                            uf.union(getIndex(i, j), getIndex(newX, newY));                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 未与 dummy 连接的 O 填充为 X</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (!uf.connected(dummy, i * cols + j)) &#123;                    board[i][j] = <span class="hljs-string">'O'</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x * cols + y;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 547. 省份数量</title>
    <link href="/2020/08/25/LeetCode-547-number-of-provinces/"/>
    <url>/2020/08/25/LeetCode-547-number-of-provinces/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-provinces/" target="_blank" rel="noopener">547. 省份数量</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] isConnected)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = isConnected.length;    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 当前节点未被访问，为一个新的连通域</span>        <span class="hljs-keyword">if</span> (!visited[i]) &#123;            count++;            dfs(i, len, isConnected, visited);        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span>[][] isConnected, <span class="hljs-keyword">boolean</span>[] visited)</span> </span>&#123;    visited[i] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// 对 i 的每个连通节点递归标记访问</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;        <span class="hljs-comment">// i, j 连通 &amp;&amp; j 未被访问</span>        <span class="hljs-keyword">if</span> (isConnected[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j]) &#123;            dfs(j, len, isConnected, visited);        &#125;    &#125;&#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] isConnected)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = isConnected.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (visited[i]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        count++;        queue.add(i);        visited[i] = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">// 标记与 i 连接的所有节点</span>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-keyword">int</span> cur = queue.poll();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;                <span class="hljs-keyword">if</span> (isConnected[cur][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j]) &#123;                    queue.add(j);                    visited[j] = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><p>并查集的连通分量数就是朋友圈的数量。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] M)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = M.length;    UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(n);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; M[<span class="hljs-number">0</span>].length; j++) &#123;            <span class="hljs-keyword">if</span> (M[i][j] == <span class="hljs-number">1</span>) &#123;                uf.union(i, j);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> uf.getCount();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 212. 单词搜索 II</title>
    <link href="/2020/08/24/LeetCode-212-word-search-ii/"/>
    <url>/2020/08/24/LeetCode-212-word-search-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">212. 单词搜索 II</a><br />坑：查找前缀时，若找到 <code>word</code>，不能 <code>return</code>，否则递归结束会导致与 <code>word</code> 同前缀的单词丢失，如 <code>aaba</code> 和 <code>aaab</code>，只能找到 <code>aaba</code>。</p><p>还是对前缀树理解不够，找了好久才发现。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">boolean</span>[][] used;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findWords</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String[] words)</span> </span>&#123;        rows = board.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span> || words.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        cols = board[<span class="hljs-number">0</span>].length;        used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];        Trie trie = <span class="hljs-keyword">new</span> Trie();        <span class="hljs-keyword">for</span> (String word : words) &#123;            trie.insert(word);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                backtrack(i, j, board, trie.root);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">char</span>[][] board, TrieNode node)</span> </span>&#123;        node = node.links[board[i][j] - <span class="hljs-string">'a'</span>];        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (node.word != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (!res.contains(node.word)) &#123;                res.add(node.word);                <span class="hljs-comment">// 一定不能 return，否则会丢失前缀</span>                <span class="hljs-comment">// return;</span>            &#125;        &#125;        used[i][j] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = i + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = j + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (inArea(newX, newY) &amp;&amp; !used[newX][newY]) &#123;                backtrack(newX, newY, board, node);            &#125;        &#125;        used[i][j] = <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;    TrieNode[] links;    String word;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> R = <span class="hljs-number">26</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.links = <span class="hljs-keyword">new</span> TrieNode[R];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>] != <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TrieNode <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key, TrieNode node)</span> </span>&#123;        <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>] = node;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;    TrieNode root;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;        root = <span class="hljs-keyword">new</span> TrieNode();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;        TrieNode node = root;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">char</span> key = word.charAt(i);            <span class="hljs-keyword">if</span> (!node.containsKey(key)) &#123;                node.put(key, <span class="hljs-keyword">new</span> TrieNode());            &#125;            node = node.get(key);        &#125;        node.word = word;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 79. 单词搜索</title>
    <link href="/2020/08/24/LeetCode-79-word-search/"/>
    <url>/2020/08/24/LeetCode-79-word-search/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></p><p>还是类似岛屿数量的回溯思想，整体不难，注意细节。<br />一开始方向的坐标写重复了一个，还忘了状态重置，一直无法通过，调了很久才发现。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;    <span class="hljs-keyword">int</span> rows = board.length;    <span class="hljs-keyword">int</span> cols = board[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">char</span>[] str = word.toCharArray();    <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-keyword">if</span> (backtrack(i, j, <span class="hljs-number">0</span>, str, dirs, rows, cols, visited, board)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span>[][] dirs, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">boolean</span>[][] visited, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">if</span> (pos == str.length - <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> board[i][j] == str[pos];    &#125;    <span class="hljs-comment">// 字符相等才进入下一个</span>    <span class="hljs-keyword">if</span> (str[pos] != board[i][j]) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// board[i][j] == str[pos]</span>    <span class="hljs-comment">// 从 (i, j) 的四个方向查找 str 的下一个字符</span>    visited[i][j] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;        <span class="hljs-keyword">int</span> newX = i + dir[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> newY = j + dir[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (!inArea(newX, newY, rows, cols) || visited[newX][newY]) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span> (backtrack(newX, newY, pos + <span class="hljs-number">1</span>, str, dirs, rows, cols, visited, board)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;    visited[i][j] = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 208. 实现 Trie (前缀树)</title>
    <link href="/2020/08/24/LeetCode-208-implement-trie-prefix-tree/"/>
    <url>/2020/08/24/LeetCode-208-implement-trie-prefix-tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></p><p>字典树 结点定义：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 字典树 结点</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每个结点相当于一个数组</span><span class="hljs-comment">     * 若数组的某个位置不为空，则指向下一个结点</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> TrieNode[] links;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 数组的长度</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> R = <span class="hljs-number">26</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 是否到达叶子结点</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnd;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.links = <span class="hljs-keyword">new</span> TrieNode[R];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断 key 位置上是否为空</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 用于计算 key 所在位置</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>] != <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取 key 位置上的下一个结点</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TrieNode <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 设置 key 位置上的下一个结点为 node</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key, TrieNode node)</span> </span>&#123;        <span class="hljs-keyword">this</span>.links[key - <span class="hljs-string">'a'</span>] = node;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断是否到达叶子结点</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isEnd;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 设置叶子结点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.isEnd = <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><p>字典树：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;    <span class="hljs-keyword">private</span> TrieNode root;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initialize your data structure here.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;        root = <span class="hljs-keyword">new</span> TrieNode();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Inserts a word into the trie.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;        TrieNode node = root;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">char</span> key = word.charAt(i);            <span class="hljs-keyword">if</span> (!node.containsKey(key)) &#123;                node.put(key, <span class="hljs-keyword">new</span> TrieNode());            &#125;            node = node.get(key);        &#125;        node.setEnd();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> TrieNode <span class="hljs-title">searchPrefix</span><span class="hljs-params">(String word)</span> </span>&#123;        TrieNode node = root;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">char</span> key = word.charAt(i);            <span class="hljs-keyword">if</span> (!node.containsKey(key)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            node = node.get(key);        &#125;        <span class="hljs-keyword">return</span> node;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns if the word is in the trie.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;        TrieNode node = searchPrefix(word);        <span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span> &amp;&amp; node.isEnd();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns if there is any word in the trie that starts with the given prefix.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 309. 最佳买卖股票时机含冷冻期</title>
    <link href="/2020/08/23/LeetCode-309-best-time-to-buy-and-sell-stock-with-cooldown/"/>
    <url>/2020/08/23/LeetCode-309-best-time-to-buy-and-sell-stock-with-cooldown/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">    0 rest</span><span class="hljs-comment">    1 买入</span><span class="hljs-comment">    2 卖出</span><span class="hljs-comment">    3 卖出后的冷冻期</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">4</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = Integer.MIN_VALUE;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] - prices[i]));        dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);    &#125;    <span class="hljs-keyword">return</span> Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]));&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 714. 买卖股票的最佳时机含手续费</title>
    <link href="/2020/08/22/LeetCode-309-best-time-to-buy-and-sell-stock-with-transaction-fee/"/>
    <url>/2020/08/22/LeetCode-309-best-time-to-buy-and-sell-stock-with-transaction-fee/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></p><p>此题加了手续费，但解法还是和第二题类似。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -(prices[<span class="hljs-number">0</span>] + fee);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i] - fee);    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre><p>可进行状态压缩</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = prices.length;        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> dp0 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> dp1 = -(prices[<span class="hljs-number">0</span>] + fee);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            <span class="hljs-comment">// 保存前一天持有现金时的最大收益</span>            <span class="hljs-keyword">int</span> pre = dp0;            dp0 = Math.max(dp0, dp1 + prices[i]);            dp1 = Math.max(dp1, pre - prices[i] - fee);        &#125;        <span class="hljs-keyword">return</span> dp0;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 188.  买卖股票的最佳时机 IV</title>
    <link href="/2020/08/22/LeetCode-188-best-time-to-buy-and-sell-stock-iv/"/>
    <url>/2020/08/22/LeetCode-188-best-time-to-buy-and-sell-stock-iv/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></p><blockquote><p>一次交易至少需要 2 天，一天买，一天卖。因此如果 <code>k</code> 很大，大到大于等于 <code>len / 2</code>，就相当于股票系列的第 2 题，使用贪心算法去做就可以了。这是一个特判。</p></blockquote><p>可进行状态压缩，省去第一维空间。加上无限交易次数的贪心版本，可加快速度。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 若 交易次数 &gt; 天数 / 2，则无法达成有效的交易，此时等价于无限次交易次数</span>    <span class="hljs-keyword">if</span> (k &gt; len / <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> maxProfit(prices);    &#125;    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];    <span class="hljs-comment">// 初始化第一次状态</span>    <span class="hljs-comment">// 1 次买入</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; k + <span class="hljs-number">1</span>; i++) &#123;        dp[<span class="hljs-number">0</span>][i][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = k; j &gt; <span class="hljs-number">0</span>; j--) &#123;            dp[i][j][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + prices[i]);            dp[i][j][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 123. 买卖股票的最佳时机 III</title>
    <link href="/2020/08/22/LeetCode-123-best-time-to-buy-and-sell-stock-iii/"/>
    <url>/2020/08/22/LeetCode-123-best-time-to-buy-and-sell-stock-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// dp[i][k]:    第 k 次交易</span>    <span class="hljs-comment">// dp[i][k][0]: 买入</span>    <span class="hljs-comment">// dp[i][k][1]: 卖出</span>    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">3</span>][<span class="hljs-number">2</span>];    <span class="hljs-comment">// 第一次买入</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 第二次买入卖出还未发生</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = Integer.MIN_VALUE;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = Integer.MIN_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 今天第一次买入</span>        dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], -prices[i]);        <span class="hljs-comment">// 今天第一次卖出：昨天第一次买入，今天卖出</span>        dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);        <span class="hljs-comment">// 今天第二次卖入：昨天第一次卖出</span>        dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);        <span class="hljs-comment">// 今天第二次卖出：昨天第二次买入</span>        dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + prices[i]);    &#125;    <span class="hljs-keyword">return</span> Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>写法一：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">    dp[i][0] 没有交易 rest</span><span class="hljs-comment">    dp[i][1] 第一次买入</span><span class="hljs-comment">    dp[i][2] 第一次卖出</span><span class="hljs-comment">    dp[i][3] 第二次买入</span><span class="hljs-comment">    dp[i][4] 第二次卖出</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">5</span>];    <span class="hljs-comment">// 第一次买入</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 第二次买入卖出都还没发生</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = Integer.MIN_VALUE;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>] = Integer.MIN_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);        dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);        dp[i][<span class="hljs-number">4</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);    &#125;    <span class="hljs-comment">// 没有交易 第一次卖出 第二次卖出 中可能存在最大值</span>    <span class="hljs-keyword">return</span> Math.max(Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]), dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>]);&#125;</code></pre><p>可进行状态压缩，省去第一维空间。</p><p>写法二：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 0: 第一次买入</span>    <span class="hljs-comment">// 1: 第一次卖出</span>    <span class="hljs-comment">// 2: 第二次买入</span>    <span class="hljs-comment">// 3: 第二次卖出</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">4</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-comment">// dp[0][1] = Integer.MIN_VALUE;</span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = Integer.MIN_VALUE;    <span class="hljs-comment">// dp[0][3] = Integer.MIN_VALUE;</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], -prices[i]);        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);        dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);        dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + prices[i]);    &#125;    <span class="hljs-keyword">return</span> Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 121. 买卖股票的最佳时机</title>
    <link href="/2020/08/22/LeetCode-121-best-time-to-buy-and-sell-stock/"/>
    <url>/2020/08/22/LeetCode-121-best-time-to-buy-and-sell-stock/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></p><h1 id="解法一"><a class="markdownIt-Anchor" href="#解法一"></a> 解法一</h1><p>状态：<br /><code>dp[i][j][s]</code>: 第 <code>i</code> 天最多进行了 <code>j</code> 次交易后，持有股票状态为 <code>s</code> 的最大利润。</p><ul><li><code>i</code>: 第 <code>i</code> 天</li><li><code>j</code>: 到今天进行的最大交易次数</li><li><code>s</code>: 今天是否持有股票</li></ul><p>状态转移方程：</p><ul><li><code>dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])</code><ul><li>昨天就没有持有，然后今天选择 <code>rest</code>，所以我今天还是没有持有；</li><li>昨天持有股票，但是今天我 <code>sell</code> 了，所以我今天没有持有股票了。</li></ul></li><li><code>dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])</code><ul><li>昨天就持有着股票，然后今天选择 <code>rest</code>，所以我今天还持有着股票；</li><li>昨天本没有持有，但今天我选择 <code>buy</code>，所以今天我就持有股票了。</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = prices.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span>;    <span class="hljs-comment">// dp[i][j][1]: 第 i 天，持有股票，至今已经进行了 j 次交易</span>    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][k][<span class="hljs-number">2</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; k; j++) &#123;            dp[i][j][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + prices[i]);            dp[i][j][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][k - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>状态：</p><ul><li><code>dp[i][0]</code> - 持有现金 表示第 <code>i</code> 天<strong>卖出股票后的最大利润</strong></li><li><code>dp[i][1]</code> - 持有股票 表示第 <code>i</code> 天持有股票的最大利润</li></ul><p>状态转移方程：</p><ul><li><code>dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</code><ul><li>昨天持有现金，今天 <code>rest</code>，今天仍持有现金</li><li>昨天持有股票，今天 <code>sell</code>，今天变为持有现金</li></ul></li><li><code>dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);</code><ul><li>昨天持有股票，今天 <code>rest</code>，今天仍持有股票</li><li>昨天持有现金，今天 <code>buy</code>，今天变为持有股票，由于只能进行一次交易，只能买入一次股票，不能加上昨天卖出股票后的最大利润</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = prices.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// dp[i][0] - 持有现金 表示第 i 天卖出股票后的最大利润</span>        <span class="hljs-comment">// dp[i][1] - 持有股票 表示第 i 天买入股票的最大利润</span>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);            <span class="hljs-comment">// 只能进行一次交易，意味着只能卖出一次股票，dp[i][1] 不可以从 dp[i][0] 转移而来</span>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);        &#125;        <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    &#125;</code></pre><h1 id="解法三"><a class="markdownIt-Anchor" href="#解法三"></a> 解法三</h1><p>使用差分数组，求数组的最大子序和就是最大盈利。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = prices.length;        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len - <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            diff[i - <span class="hljs-number">1</span>] = prices[i] - prices[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len - <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>] + diff[i], diff[i]);        &#125;                <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;            max = Math.max(max, dp[i]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 337. 打家劫舍 III</title>
    <link href="/2020/08/21/LeetCode-337-house-robber-iii/"/>
    <url>/2020/08/21/LeetCode-337-house-robber-iii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></p><h1 id="暴力"><a class="markdownIt-Anchor" href="#暴力"></a> 暴力</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 不 rob 孩子</span>    <span class="hljs-keyword">int</span> doNotRobChildren = root.val;    <span class="hljs-comment">// rob 左孙子</span>    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;        doNotRobChildren += rob(root.left.left) + rob(root.left.right);    &#125;    <span class="hljs-comment">// rob 右孙子</span>    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;        doNotRobChildren += rob(root.right.left) + rob(root.right.right);    &#125;    <span class="hljs-comment">// rob 孩子</span>    <span class="hljs-keyword">int</span> robChildren = rob(root.left) + rob(root.right);    <span class="hljs-keyword">return</span> Math.max(doNotRobChildren, robChildren);&#125;</code></pre><h1 id="解法一记忆化递归"><a class="markdownIt-Anchor" href="#解法一记忆化递归"></a> 解法一：记忆化递归</h1><pre><code class="hljs java">Map&lt;TreeNode, Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> (memo.containsKey(root)) &#123;            <span class="hljs-keyword">return</span> memo.get(root);        &#125;        <span class="hljs-comment">// 打劫根结点</span>        <span class="hljs-keyword">int</span> doRob = root.val;        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;            doRob += rob(root.left.left) + rob(root.left.right);        &#125;        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;            doRob += rob(root.right.left) + rob(root.right.right);        &#125;        <span class="hljs-comment">// 不打劫根结点</span>        <span class="hljs-keyword">int</span> notRob = rob(root.left) + rob(root.right);        <span class="hljs-keyword">int</span> res = Math.max(doRob, notRob);        memo.put(root, res);        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><h1 id="解法二"><a class="markdownIt-Anchor" href="#解法二"></a> 解法二</h1><p>状态：</p><ul><li><code>dp[root][0]</code> - 不打劫 <code>root</code> 结点</li><li><code>dp[root][1]</code> - 打劫 <code>root</code> 结点</li></ul><p>转移方程：</p><ul><li><code>dp[root][0]</code>：左右子结点可选择偷或不偷，取他们的最大值</li><li><code>dp[root][1]</code>：左右子结点不偷</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] res = robber(root);    <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] robber(TreeNode root) &#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;    &#125;    <span class="hljs-comment">// 后序遍历，自底向上，先计算左右结点，再计算 root</span>    <span class="hljs-keyword">int</span>[] left = robber(root.left);    <span class="hljs-keyword">int</span>[] right = robber(root.right);    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];    <span class="hljs-comment">// 打劫 root</span>    dp[<span class="hljs-number">1</span>] = root.val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 不打劫 root</span>    dp[<span class="hljs-number">0</span>] = Math.max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + Math.max(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">return</span> dp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 213. 打家劫舍 II</title>
    <link href="/2020/08/21/LeetCode-213-house-robber-ii/"/>
    <url>/2020/08/21/LeetCode-213-house-robber-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></p><p>题目说明：首尾不能同时 rob，那么可以去除第一个元素或去除最后一个元素进行 rob，还是使用 <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a> 的解法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">return</span> Math.max(robRange(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">2</span>), robRange(nums, <span class="hljs-number">1</span>, len - <span class="hljs-number">1</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">robRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">int</span> i_2 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> i_1 = nums[start];    <span class="hljs-keyword">int</span> cur = nums[start];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>; i &lt;= end; i++) &#123;        cur = Math.max(i_1, i_2 + nums[i]);        i_2 = i_1;        i_1 = cur;    &#125;    <span class="hljs-keyword">return</span> cur;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 198. 打家劫舍</title>
    <link href="/2020/08/21/LeetCode-198-house-robber/"/>
    <url>/2020/08/21/LeetCode-198-house-robber/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></p><p>状态：<code>dp[i]</code> 第 <code>i</code> 个数结尾的最大子序列和<br />转移：</p><ul><li>不偷 <code>nums[i]</code>, <code>dp[i] = dp[i - 1]</code></li><li>偷 <code>nums[i - 2]</code>, <code>dp[i] = dp[i - 2] + nums[i - 1]</code></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= len; i++) &#123;        dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">return</span> dp[len];&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 0: 不偷，1: 偷</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);        dp[i][<span class="hljs-number">1</span>] = nums[i] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">return</span> Math.max(dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 152. 乘积最大子数组</title>
    <link href="/2020/08/21/LeetCode-152-maximum-product-subarray/"/>
    <url>/2020/08/21/LeetCode-152-maximum-product-subarray/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></p><p>状态：</p><ul><li><code>dp[i][0]</code>: 以 <code>nums[i]</code> 结尾的子数组最小值</li><li><code>dp[i][1]</code>: 以 <code>nums[i]</code> 结尾的子数组最大值</li></ul><p>状态转移：</p><ul><li><code>nums[i] &gt; 0</code><ul><li><code>最大值 * nums[i]</code> 还是最大值</li><li><code>最小值 * nums[i]</code> 还是最小值</li></ul></li><li><code>nums[i] &gt; 0</code><ul><li><code>最大值 * nums[i]</code> = 最小值</li><li><code>最小值 * nums[i]</code> = 最大值</li></ul></li></ul><p>和 <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a> 类似，只要计算当前数字 <code>nums[i]</code> 对 <code>min</code> 或 <code>max</code> 的增益，若有利于他们的最值，则进行更新，否则从 <code>nums[i]</code> 开始重新计算最值。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">/*</span><span class="hljs-comment">         nums[i] &gt; 0:</span><span class="hljs-comment">            max * nums[i] -&gt; max</span><span class="hljs-comment">                dp[i - 1][1] &gt; 0, max = nums[i] * dp[i - 1][1] else nums[i]</span><span class="hljs-comment">            min * nums[i] -&gt; min</span><span class="hljs-comment">                dp[i - 1][0] &lt; 0, min = nums[i] * dp[i - 1][0] else nums[i]</span><span class="hljs-comment"></span><span class="hljs-comment">         num[i] &lt; 0:</span><span class="hljs-comment">            max * nums[i] -&gt; min</span><span class="hljs-comment">                dp[i - 1][1] &gt; 0, min = nums[i] * dp[i - 1][1] else nums[i]</span><span class="hljs-comment">            min * nums[i] -&gt; max</span><span class="hljs-comment">                dp[i - 1][0] &lt; 0, max = nums[i] * dp[i - 1][0] else nums[i]</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> max = dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;                dp[i][<span class="hljs-number">0</span>] = Math.min(nums[i], nums[i] * dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);                dp[i][<span class="hljs-number">1</span>] = Math.max(nums[i], nums[i] * dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);            &#125; <span class="hljs-keyword">else</span> &#123;                dp[i][<span class="hljs-number">0</span>] = Math.min(nums[i], nums[i] * dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);                dp[i][<span class="hljs-number">1</span>] = Math.max(nums[i], nums[i] * dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);            &#125;            max = Math.max(max, dp[i][<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre><p>空间优化：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">int</span> imax = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> imin = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> max = imax;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 交换 imax 和 imin，省去后面的二次判断</span>        <span class="hljs-comment">// 否则会出现 imax 和 imin 互相依赖的情况</span>        <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> t = imin;            imin = imax;            imax = t;        &#125;        imin = Math.min(nums[i], nums[i] * imin);        imax = Math.max(nums[i], nums[i] * imax);        max = Math.max(max, imax);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 53. 最大子序和</title>
    <link href="/2020/08/20/LeetCode-53-maximum-subarray/"/>
    <url>/2020/08/20/LeetCode-53-maximum-subarray/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p><p>状态转移：如果前一个子序列和 <code>nums[i - 1]</code> 无法为 <code>nums[i]</code> 带来正增益，则 <code>nums[i]</code> 为 <code>dp[i]</code> 的最大值。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 状态：dp[i] 以 nums[i] 结尾的子数组最大和</span><span class="hljs-comment"> * 转移方程：</span><span class="hljs-comment"> * dp[i] = 前一个子序列 + nums[i] if 前一个子序列 + nums[i] &gt; nums[i] else nums[i]</span><span class="hljs-comment"> * dp[i] = nums[i] 表示重新开始计算新的子序列和</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;        dp[i] = Math.max(nums[i], dp[i - <span class="hljs-number">1</span>] + nums[i]);        max = Math.max(dp[i], max);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><p>空间优化：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> dp = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> max = dp;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            dp = Math.max(nums[i], dp + nums[i]);            max = Math.max(dp, max);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 120. 三角形最小路径和</title>
    <link href="/2020/08/20/LeetCode-120-triangle/"/>
    <url>/2020/08/20/LeetCode-120-triangle/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></p><p>最开始用回溯，最后一个测试用例未通过，原因是输出太长了。<br />然后用动态规划：<br />状态转移方程：<br /><code>dp[i][j] = triangle[i][j] + min(dp[i + 1][j], dp[i + 1][j + 1])</code></p><h1 id="自顶向下"><a class="markdownIt-Anchor" href="#自顶向下"></a> 自顶向下</h1><p>判断很多，最后还要排序，虽然也过了，后来题解发现可以采用自底向上可以方便很多。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;    <span class="hljs-keyword">int</span> size = triangle.size();    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size][size];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] line : dp) &#123;        Arrays.fill(line, Integer.MAX_VALUE);    &#125;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) &#123;        List&lt;Integer&gt; curRow = triangle.get(i);        <span class="hljs-comment">// 每行的第一个位置</span>        dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + curRow.get(<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; curRow.size(); j++) &#123;            dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + curRow.get(j);        &#125;    &#125;    <span class="hljs-comment">// 求最后一行的最小值</span>    Arrays.sort(dp[size - <span class="hljs-number">1</span>]);    <span class="hljs-keyword">return</span> dp[size - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre><h1 id="自底向上"><a class="markdownIt-Anchor" href="#自底向上"></a> 自底向上</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = triangle.size();    <span class="hljs-comment">// 多分配一行，不用判断边界</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// 每行元素的个数就是该行 行号</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;            <span class="hljs-comment">// 因为上面的行数总是 &lt; 下面的行数，不用担心越界</span>            dp[i][j] = triangle.get(i).get(j) + Math.min(dp[i + <span class="hljs-number">1</span>][j], dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];&#125;</code></pre><p>空间优化：<br />计算 <code>dp[i][j]dp[i][j]</code> 时，只用到了下一行的 <code>dp[i + 1][j]dp[i+1][j]</code> 和 <code>dp[i + 1][j + 1]dp[i+1][j+1]</code>，因此只用一行就可以了。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = triangle.size();    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;            dp[j] = triangle.get(i).get(j) + Math.min(dp[j], dp[j + <span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1143. 最长公共子序列</title>
    <link href="/2020/08/20/LeetCode-1143-longest-common-subsequence/"/>
    <url>/2020/08/20/LeetCode-1143-longest-common-subsequence/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></p><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200820153633.png" srcset="/img/loading.gif" alt="" /></p><p>base: 两个字符串中有一个为空，则 <code>dp[0][j] = 0</code> 或 <code>dp[i][0] = 0</code><br />状态：<code>dp[i][j]</code> -&gt; <code>str1[:i]</code> 和 <code>str[:j]</code> 的最长序列<br />转移：</p><ul><li>比较位置：<code>str[:i], str[:j]</code> || <code>str1[:i-1]</code>, <code>str2[:j]</code> || <code>str1[:i]</code>, <code>str2[:j-1]</code></li><li>若 <code>i</code>, <code>j</code> 位置相等，直接 + 1</li><li>若不等：取 <code>str1[:i-1]</code>, <code>str2[:j]</code> 和 <code>str1[:i]</code>, <code>str2[:j-1]</code> 中的最大值</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;    <span class="hljs-keyword">int</span> len1 = text1.length();    <span class="hljs-keyword">int</span> len2 = text2.length();    <span class="hljs-keyword">char</span>[] str1 = text1.toCharArray();    <span class="hljs-keyword">char</span>[] str2 = text2.toCharArray();    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len1 + <span class="hljs-number">1</span>][len2 + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;            <span class="hljs-keyword">if</span> (str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>]) &#123;                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[len1][len2];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 322. 零钱兑换</title>
    <link href="/2020/08/19/LeetCode-322-coin-change/"/>
    <url>/2020/08/19/LeetCode-322-coin-change/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] mem = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];    <span class="hljs-keyword">return</span> dp(amount, coins, mem);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span>[] mem)</span> </span>&#123;    <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 若命中缓存，直接返回</span>    <span class="hljs-keyword">if</span> (mem[amount] != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> mem[amount];    &#125;    <span class="hljs-keyword">int</span> count = Integer.MAX_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;        <span class="hljs-comment">// 计算减去 coin 后最小的硬币数量</span>        <span class="hljs-keyword">int</span> prev = amount - coin;        <span class="hljs-keyword">int</span> prevCount = dp(prev, coins, mem);        <span class="hljs-comment">// 若能找到 prev 的最小数目，计算本次 count 的最小值</span>        <span class="hljs-keyword">if</span> (prevCount != -<span class="hljs-number">1</span>) &#123;            count = Math.min(prevCount + <span class="hljs-number">1</span>, count);        &#125;    &#125;    <span class="hljs-comment">// 更新缓存</span>    mem[amount] = count == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : count;    <span class="hljs-keyword">return</span> mem[amount];&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;    <span class="hljs-comment">// 1, 2, 5 =&gt; 11</span>    <span class="hljs-comment">// 10: dp[10] + 1</span>    <span class="hljs-comment">// 9: dp[9] + 1</span>    <span class="hljs-comment">// 6: dp[6] + 1</span>    <span class="hljs-comment">// base: 0, 1, 1</span>    <span class="hljs-comment">// 状态: dp[i] 表示第 i 个值需要的最小硬币数</span>    <span class="hljs-comment">// 选择：每一种硬币</span>    <span class="hljs-comment">// dp[i] = min(dp[i - coin])</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];    Arrays.fill(dp, Integer.MAX_VALUE);    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; amount; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;            <span class="hljs-comment">// 前一个值有效 &amp;&amp; 前一个值能够取得最小硬币数</span>            <span class="hljs-keyword">if</span> (i - coin &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i - coin] != Integer.MAX_VALUE) &#123;                dp[i] = Math.min(dp[i - coin] + <span class="hljs-number">1</span>, dp[i]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : dp[amount];&#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;    ArrayDeque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[amount + <span class="hljs-number">1</span>];    queue.add(amount);    visited[amount] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        count++;        <span class="hljs-keyword">int</span> size = queue.size();        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> cur = queue.poll();            <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> count - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">// 依次变换零钱</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;                <span class="hljs-keyword">int</span> diff = cur - coin;                <span class="hljs-keyword">if</span> (diff &gt;= <span class="hljs-number">0</span> &amp;&amp; !visited[diff]) &#123;                    queue.add(diff);                    visited[diff] = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 63. 不同路径 II</title>
    <link href="/2020/08/18/LeetCode-63-unique-paths-ii/"/>
    <url>/2020/08/18/LeetCode-63-unique-paths-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></p><p>一开始判断第一行或第一列的障碍时没有及时 <code>break</code>，导致若只有一行或一列的情况下出错。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * base: 若左边或上边存在障碍，则不能继续往下走</span><span class="hljs-comment">         * 状态：dp[i][j]</span><span class="hljs-comment">         * 选择：左，上</span><span class="hljs-comment">         * dp[i][[j] = dp[i - 1][j] + dp[i][j - 1]</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span> rows = obstacleGrid.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> cols = obstacleGrid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows][cols];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-comment">// 如果有一个位置有障碍，那么该列剩下的位置都走不过去了</span>            <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cols; i++) &#123;            <span class="hljs-comment">// 如果有一个位置有障碍，那么该行剩下的位置都走不过去了</span>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; cols; j++) &#123;                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">0</span>) &#123;                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[rows - <span class="hljs-number">1</span>][cols - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 62. 不同路径</title>
    <link href="/2020/08/18/LeetCode-62-unique-paths/"/>
    <url>/2020/08/18/LeetCode-62-unique-paths/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></p><p>边界条件：第一行 <code>dp[0][i]</code> 和第一列 <code>dp[i][0]</code> 值为 <code>1</code>：只有一条路径可到达该位置。<br />状态转移方程：每个位置的路径 = 左边路径数 + 上边路径数。</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><code>2</code></td><td style="text-align:center"><code>3</code></td><td style="text-align:center"><code>4</code></td><td style="text-align:center"><code>5</code></td><td style="text-align:center"><code>6</code></td><td style="text-align:center"><code>7</code></td></tr><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center"><code>3</code></td><td style="text-align:center"><code>6</code></td><td style="text-align:center"><code>10</code></td><td style="text-align:center"><code>15</code></td><td style="text-align:center"><code>21</code></td><td style="text-align:center"><code>28</code></td></tr></tbody></table><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * base: 第一行和第一列为 1</span><span class="hljs-comment">     * 状态：dp[i][j] 每个位置路径数 = 左 + 上</span><span class="hljs-comment">     * 选择：左，上</span><span class="hljs-comment">     * dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];&#125;</code></pre><p>优化：</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th></tr></thead><tbody></tbody></table><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center"><code>2</code></th><th style="text-align:center"><code>3</code></th><th style="text-align:center"><code>4</code></th><th style="text-align:center"><code>5</code></th><th style="text-align:center"><code>6</code></th><th style="text-align:center"><code>7</code></th></tr></thead><tbody></tbody></table><p>省去列上的空间：<code>dp[j] = dp[j] + dp[j - 1]</code><br /><code>dp[j]</code> 在更新前相当于上边的值<br /><code>dp[j - 1]</code> 在更新 <code>dp[j]</code> 时，已经更新了 <code>dp[j - 1]</code> ，所以它相当于左边的值。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;     <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];     Arrays.fill(dp, <span class="hljs-number">1</span>);     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;             dp[j] += dp[j - <span class="hljs-number">1</span>];         &#125;     &#125;     <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>]; &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 35. 搜索插入位置</title>
    <link href="/2020/08/17/LeetCode-35-search-insert-position/"/>
    <url>/2020/08/17/LeetCode-35-search-insert-position/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;            left = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> mid;        &#125;     &#125;    <span class="hljs-comment">// 单独处理 left == right 的情况</span>    <span class="hljs-keyword">return</span> nums[left] &gt;= target ? left : left + <span class="hljs-number">1</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (target == nums[mid]) &#123;                <span class="hljs-keyword">return</span> mid;            &#125;            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;                right = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 154. 寻找旋转排序数组中的最小值 II</title>
    <link href="/2020/08/17/LeetCode-154-find-minimum-in-rotated-sorted-array-ii/"/>
    <url>/2020/08/17/LeetCode-154-find-minimum-in-rotated-sorted-array-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[right] &lt; nums[mid]) &#123;                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[right] &gt; nums[mid]) &#123;                right = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 若 右 == 中，因为最小值一定靠近左边，丢弃右边的重复值，缩小右边界</span>                right--;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left];    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 153. 寻找旋转排序数组中的最小值</title>
    <link href="/2020/08/17/LeetCode-153-find-minimum-in-rotated-sorted-array/"/>
    <url>/2020/08/17/LeetCode-153-find-minimum-in-rotated-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></p><p>第一次通过的代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[left] &gt; nums[mid]) &#123;            <span class="hljs-comment">// 左 &gt; 中，min 在 中 后面的部分</span>            min = Math.min(nums[mid], min);            <span class="hljs-comment">// 到左边查找</span>            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 中 &gt;= 左，min 在最左边</span>            min = Math.min(nums[left], min);            <span class="hljs-comment">// 到右边查找</span>            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> Math.min(min, nums[left]);&#125;</code></pre><p>评论区：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * [3,4,5,1,2]</span><span class="hljs-comment">     * [4,5,6,7,0,1,2]</span><span class="hljs-comment">     * [0,1,2,3,4]</span><span class="hljs-comment">     * [2,1]</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[right] &lt; nums[mid]) &#123;            <span class="hljs-comment">// 右 &lt; 中，一定在右边，则到右边查找</span>            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 右 &gt;= 中，一定在左边</span>            right = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> nums[left];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 81. 搜索旋转排序数组 II</title>
    <link href="/2020/08/17/LeetCode-81-search-in-rotated-sorted-array-ii/"/>
    <url>/2020/08/17/LeetCode-81-search-in-rotated-sorted-array-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></p><p>本题加入重复数字，所以在判断哪一部分有序时，若 <code>nums[left] == nums[mid]</code> 可能出现判断不出来的情况，一开始一直卡着，后来发现只要丢弃一个重复数字，则下一次就可成功判断。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (target == nums[mid]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">if</span> (nums[left] &lt; nums[mid]) &#123;                <span class="hljs-comment">// 左半部分有序</span>                <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid]) &#123;                    right = mid;                &#125; <span class="hljs-keyword">else</span> &#123;                    left = mid + <span class="hljs-number">1</span>;                &#125;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] &gt; nums[mid]) &#123;                <span class="hljs-comment">// 右半部分有序</span>                <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;                    left = mid + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    right = mid;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// nums[left] == nums[mid] 时无法判断哪部分有序，则丢弃一个重复数字</span>                <span class="hljs-comment">// [1,3,1,1,1]</span>                <span class="hljs-comment">// [1,3,1,1]</span>                left++;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left] == target;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 74. 搜索二维矩阵</title>
    <link href="/2020/08/17/LeetCode-74-search-a-2d-matrix/"/>
    <url>/2020/08/17/LeetCode-74-search-a-2d-matrix/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a><br />一开始用 <code>i = mid / rows</code> 计算行数，导致位置计算不正确。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> rows = matrix.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = rows * cols - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;            <span class="hljs-comment">// 行数是对每行大小进行整除，</span>            <span class="hljs-comment">// 列数是对每行大小进行取余</span>            <span class="hljs-keyword">int</span> i = mid / cols;            <span class="hljs-keyword">int</span> j = mid % cols;            <span class="hljs-keyword">if</span> (matrix[i][j] == target) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target) &#123;                <span class="hljs-comment">// 不使用 left = mid</span>                <span class="hljs-comment">// 原因在于向上取整时 matrix 可能会越界，所以采用向下取整</span>                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                right = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> matrix[left / cols][left % cols] == target;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 33. 搜索旋转排序数组</title>
    <link href="/2020/08/17/LeetCode-33-search-in-rotated-sorted-array/"/>
    <url>/2020/08/17/LeetCode-33-search-in-rotated-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;                <span class="hljs-keyword">return</span> mid;            &#125;            <span class="hljs-keyword">if</span> (nums[left] &lt; nums[mid]) &#123;                <span class="hljs-comment">// 1. 左半部分 [left, mid] 有序</span>                <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;                    <span class="hljs-comment">// 1.1 target in [left, mid]</span>                    <span class="hljs-comment">// left &lt;= target &lt; mid.....right</span>                    <span class="hljs-comment">// [left, mid - 1]</span>                    right = mid - <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 1.2 target in [mid + 1, right]</span>                    <span class="hljs-comment">// [mid, right]</span>                    left = mid;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 2. 右半部分 [mid, right] 有序</span>                <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;                    <span class="hljs-comment">// 2.1 target in [mid, right]</span>                    <span class="hljs-comment">// left.....mid &lt; target &lt;= right</span>                    <span class="hljs-comment">// [mid, right]</span>                    left = mid;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 2.2 target in [left, mid - 1]</span>                    <span class="hljs-comment">// [left, mid - 1]</span>                    right = mid - <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 367. 有效的完全平方数</title>
    <link href="/2020/08/16/LeetCode-367.%20valid-perfect-square/"/>
    <url>/2020/08/16/LeetCode-367.%20valid-perfect-square/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-perfect-square/" target="_blank" rel="noopener">367. 有效的完全平方数</a></p><p>两种解法都击败 <code>100%</code></p><h1 id="二分法"><a class="markdownIt-Anchor" href="#二分法"></a> 二分法</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">long</span> left = <span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> right = num / <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">long</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">long</span> prod = mid * mid;        <span class="hljs-keyword">if</span> (prod == num) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prod &gt; num) &#123;            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> left * left == num;&#125;</code></pre><h1 id="牛顿迭代法"><a class="markdownIt-Anchor" href="#牛顿迭代法"></a> 牛顿迭代法</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">long</span> x = num / <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (x * x &gt; num) &#123;        x = (x + num / x) / <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> x * x == num;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 69. x 的平方根</title>
    <link href="/2020/08/15/LeetCode-69-sqrtx/"/>
    <url>/2020/08/15/LeetCode-69-sqrtx/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></p><h1 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h1><blockquote><p><code>sqrt(x) &lt;= x / 2</code><br />一个数的平方根 <code>&lt;=</code> 这个数的一半，所以右边界最大 <code>= x / 2</code></p></blockquote><ul><li>先写分支逻辑，再决定中间数是否上取整；</li><li>只要看到 <code>left = mid</code> ，它对应的取中位数的取法一定是 <code>mid = left + (right - left + 1) / 2;</code>。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">long</span> left = <span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> right = x / <span class="hljs-number">2</span>;    <span class="hljs-comment">// 排除元素，使用 &lt;，每次都使用 [left, right] 查找</span>    <span class="hljs-comment">// 查找元素，使用 &lt;=</span>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-comment">// +1 向上取整，避免死循环</span>        <span class="hljs-comment">// 不使用 (left + right) / 2 是为了避免 long 溢出</span>        <span class="hljs-keyword">long</span> mid = left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (mid * mid &gt; x) &#123;            <span class="hljs-comment">// [left, mid - 1]</span>            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// [mid, right]</span>            left = mid;        &#125;    &#125;    <span class="hljs-comment">// 退出循环时 left == right</span>    <span class="hljs-comment">// 还剩一个元素没有查找，</span>    <span class="hljs-comment">// 因为答案一定存在，即一定在搜索区间，剩下的元素就是问题答案</span>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)left;&#125;</code></pre><h1 id="牛顿迭代法"><a class="markdownIt-Anchor" href="#牛顿迭代法"></a> 牛顿迭代法</h1><p>要使用 <code>double</code> 类型，一开始使用 <code>float</code> 精度不够，有三个测试用例无法通过。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mspace linebreak="newline"></mspace><mo>=</mo><mo>&gt;</mo><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>x</mi><mo>=</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mspace linebreak="newline"></mspace><mi>x</mi><mo>=</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><mfrac><mrow><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup><mo>−</mo><mi>a</mi></mrow><mrow><mn>2</mn><msub><mi>x</mi><mi>n</mi></msub></mrow></mfrac><mspace linebreak="newline"></mspace><mi>x</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>+</mo><mfrac><mi>a</mi><msub><mi>x</mi><mi>n</mi></msub></mfrac><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">f(x) = x^2 - a \\=&gt; y = f(x_n) + f&#x27;(x_n)(x - x_n) \\x = x_n - \frac{f(x_n)}{f&#x27;(x_n)}\\x = x_n - \frac{x_n^2 - a}{2x_n}\\x = \frac{1}{2}(x_n + \frac{a}{x_n})\\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6778919999999999em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.327108em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.9435600000000002em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span></span></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">double</span> cur = <span class="hljs-number">1.0</span>;    <span class="hljs-keyword">double</span> pre = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (Math.abs(cur - pre) &gt; <span class="hljs-number">1e-6</span>) &#123;        pre = cur;        cur = (cur + x / cur) / <span class="hljs-number">2</span>;    &#125;    System.out.println(cur);    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)cur;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 45. 跳跃游戏 II</title>
    <link href="/2020/08/14/LeetCode-45-jump-game-ii/"/>
    <url>/2020/08/14/LeetCode-45-jump-game-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></p><p>本题在 <a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a> 基础上加了个最小次数，其实也是计算每个位置能跳到的最远距离，关键在于要保存上一次的最远边界，用来判断跳跃的次数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (pos &lt; nums.length - <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 本次能跳到的最远位置</span>            <span class="hljs-keyword">int</span> max = pos;            <span class="hljs-comment">// 每次都在 [begin, end] 区间里找到能跳到的最远位置</span>            <span class="hljs-comment">// 一个区间表示一次跳跃的所有可能起点，选取能跳到的最远位置</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin; i &lt;= end; i++) &#123;                max = Math.max(max, i + nums[i]);            &#125;            <span class="hljs-comment">// 更新下一次跳的区间</span>            begin = end + <span class="hljs-number">1</span>;            end = max;            <span class="hljs-comment">// 更新最远位置</span>            pos = max;            count++;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre><p>优化：计算从每个位置能跳到的最远距离。每次最远，最终最远，则跳跃次数最少。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">// 一次跳跃可到达的最远位置</span>        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-comment">// 若上一次已到达终点，则结束</span>            <span class="hljs-keyword">if</span> (end == nums.length - <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> count;            &#125;            <span class="hljs-comment">// 计算从第 i 个位置起跳的最远位置</span>            max = Math.max(max, i + nums[i]);            <span class="hljs-comment">// 一次跳跃到达终点，更新跳跃次数和下一次的跳跃边界</span>            <span class="hljs-keyword">if</span> (end == i) &#123;                count++;                end = max;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 55. 跳跃游戏</title>
    <link href="/2020/08/14/LeetCode-55-jump-game/"/>
    <url>/2020/08/14/LeetCode-55-jump-game/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></p><p>(🙃一开始还用的回溯。。。)<br />关键在于：若能跳到第 <code>i</code> 个位置，则在这之前的所有位置都能到达，所以只要计算从第 <code>i</code> 个位置起跳能跳到的最远位置。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> maxPos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-comment">// 若能跳到的最远位置 &lt; 当前位置</span>            <span class="hljs-comment">// 说明连当前位置都跳不到，也就跳不到终点了</span>            <span class="hljs-keyword">if</span> (maxPos &lt; i) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">// 能跳到第 i 个位置的情况下，</span>            <span class="hljs-comment">// 计算从第 i 个位置起跳，能跳到的最远位置</span>            <span class="hljs-comment">// 最远 = max(本次起跳，上次最远位置)</span>            maxPos = Math.max(i + nums[i], maxPos);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 874. 模拟行走机器人</title>
    <link href="/2020/08/13/LeetCode-874-walking-robot-simulation/"/>
    <url>/2020/08/13/LeetCode-874-walking-robot-simulation/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/walking-robot-simulation/" target="_blank" rel="noopener">874. 模拟行走机器人</a></p><p>一开始用的 <code>findObstacle()</code>，每走一步都要遍历 <code>obstacles</code>，效率很慢，官方题解采取<strong>将障碍编码</strong>的方式，这样只要 <code>O(1)</code> 就可以完成判断。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">robotSim</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] commands, <span class="hljs-keyword">int</span>[][] obstacles)</span> </span>&#123;        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[][] dirs = &#123;                <span class="hljs-comment">// 北：0</span>                &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,                <span class="hljs-comment">// 东：1</span>                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,                <span class="hljs-comment">// 南：2</span>                &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,                <span class="hljs-comment">// 西：3</span>                &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        &#125;;        <span class="hljs-keyword">int</span> dir = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 将障碍编码，加快判断效率</span>        Set&lt;Long&gt; obstacleSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] ob : obstacles) &#123;            <span class="hljs-keyword">long</span> ox = ob[<span class="hljs-number">0</span>] + <span class="hljs-number">30000</span>;            <span class="hljs-keyword">long</span> oy = ob[<span class="hljs-number">1</span>] + <span class="hljs-number">30000</span>;            obstacleSet.add((ox &lt;&lt; <span class="hljs-number">16</span>) + oy);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step : commands) &#123;            <span class="hljs-keyword">if</span> (step == -<span class="hljs-number">1</span>) &#123;                <span class="hljs-comment">// 右转</span>                dir = (dir + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (step == -<span class="hljs-number">2</span>) &#123;                <span class="hljs-comment">// 左转</span>                dir = (dir + <span class="hljs-number">3</span>) % <span class="hljs-number">4</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 向前走 step 步，直到遇上障碍物</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; step; i++) &#123;                    <span class="hljs-keyword">long</span> nx = x + dirs[dir][<span class="hljs-number">0</span>] + <span class="hljs-number">30000</span>;                    <span class="hljs-keyword">long</span> ny = y + dirs[dir][<span class="hljs-number">1</span>] + <span class="hljs-number">30000</span>;                    <span class="hljs-keyword">if</span> (!obstacleSet.contains((nx &lt;&lt; <span class="hljs-number">16</span>) + ny)) &#123;                        x = x + dirs[dir][<span class="hljs-number">0</span>];                        y = y + dirs[dir][<span class="hljs-number">1</span>];                        max = Math.max(max, x * x + y * y);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;<span class="hljs-comment">//////////////////////// obsolete ////////////////////////////////</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findObstacle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span>[][] obstacles)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] ob : obstacles) &#123;            <span class="hljs-keyword">if</span> (ob[<span class="hljs-number">0</span>] == x &amp;&amp; ob[<span class="hljs-number">1</span>] == y) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 455. 分发饼干</title>
    <link href="/2020/08/13/LeetCode-455-assign-cookies/"/>
    <url>/2020/08/13/LeetCode-455-assign-cookies/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></p><p>优先用小饼干满足胃口小的孩子</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] g, <span class="hljs-keyword">int</span>[] s)</span> </span>&#123;        Arrays.sort(g);        Arrays.sort(s);        <span class="hljs-keyword">int</span> child = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> cookie = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (child &lt; g.length &amp;&amp; cookie &lt; s.length) &#123;            <span class="hljs-comment">// 满足要求，换下一个小孩</span>            <span class="hljs-keyword">if</span> (s[cookie] &gt;= g[child]) &#123;                count++;                child++;            &#125;            <span class="hljs-comment">// 下一个饼干</span>            cookie++;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 122. 买卖股票的最佳时机 II</title>
    <link href="/2020/08/12/LeetCode-122-best-time-to-buy-and-sell-stock-ii/"/>
    <url>/2020/08/12/LeetCode-122-best-time-to-buy-and-sell-stock-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></p><h1 id="贪心"><a class="markdownIt-Anchor" href="#贪心"></a> 贪心</h1><blockquote><p>贪心的思想在于每一步作出的决策在现在看来总是最好的，它不关心过去或者未来的状态。</p></blockquote><p>只要今天的价格高于明天就计算收益：相当于在今天判断：是否买入昨天，卖出今天。这样每一天都有收益，最终的收益就是最大的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> profit = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;            <span class="hljs-keyword">int</span> cur = prices[i] - prices[i - <span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (cur &gt; <span class="hljs-number">0</span>)&#123;                profit += cur;            &#125;        &#125;        <span class="hljs-keyword">return</span> profit;    &#125;</code></pre><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><p><strong>1. 状态 <code>dp[i][j]</code></strong>:</p><p>第 <code>i</code> 天所能获得的最大利润，<code>j = 0</code>: 第 <code>i</code> 天持有现金，<code>j = 1</code>: 第 <code>i</code> 天持有股票。</p><p><strong>2. 状态转移方程：</strong></p><p>每一天可能持有股票或现金。</p><ul><li>若第 <code>i</code> 天持有股票 (<code>dp[i][0]</code>)：<ul><li>第 <code>i - 1</code> 天持有股票，则第 <code>i</code> 天无操作。</li><li>第 <code>i - 1</code> 天持有现金，则第 <code>i</code> 天买入新股票  (<code>+prices[i]</code>)。</li></ul></li><li>若第 <code>i</code> 天持有现金 (<code>dp[i][1]</code>)：<ul><li>第 <code>i - 1</code> 天持有股票，则第 <code>i</code> 天卖出 (<code>-prices[i]</code>)。</li><li>第 <code>i - 1</code> 天持有现金，则第 <code>i</code> 天无操作。</li></ul></li></ul><p><strong>3. 结束</strong></p><p>输出最后一天持有现金 (<code>dp[len - 1][0]</code>)，持有现金的情况下才会把之前的股票卖出，若最后一天持有股票，金额还会更少 <code>dp[len - 1][0] &gt; dp[len - 1][1]</code>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[prices.length][<span class="hljs-number">2</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;            <span class="hljs-comment">// 第 i 天持有现金</span>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);            <span class="hljs-comment">// 第 i 天持有股票</span>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">return</span> dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    &#125;</code></pre><p><strong>状态压缩</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-comment">// 今天持有现金</span>        <span class="hljs-keyword">int</span> cash = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 今天持有股票</span>        <span class="hljs-keyword">int</span> hold = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 昨天持有现金</span>        <span class="hljs-keyword">int</span> preCash = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 昨天持有股票</span>        <span class="hljs-keyword">int</span> preHold = -prices[<span class="hljs-number">0</span>];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> price : prices) &#123;            cash = Math.max(preCash, preHold + price);            hold = Math.max(preHold, preCash - price);                        preCash = cash;            preHold = hold;        &#125;        <span class="hljs-keyword">return</span> cash;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 860. 柠檬水找零</title>
    <link href="/2020/08/11/LeetCode-860-lemonade-change/"/>
    <url>/2020/08/11/LeetCode-860-lemonade-change/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lemonade-change/" target="_blank" rel="noopener">860. 柠檬水找零</a></p><blockquote><p>不带零钱你买什么柠檬水！！！</p></blockquote><p>虽然有点贪心的思想，我感觉这题在搞笑。。。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] bills)</span> </span>&#123;        <span class="hljs-keyword">if</span> (bills.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> money : bills) &#123;            <span class="hljs-keyword">switch</span> (money) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                    five++;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:                    five--;                    ten++;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>:                    <span class="hljs-keyword">if</span> (ten &gt; <span class="hljs-number">0</span>) &#123;                        five--;                        ten--;                    &#125; <span class="hljs-keyword">else</span> &#123;                        five -= <span class="hljs-number">3</span>;                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span> (five &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 529. 扫雷游戏</title>
    <link href="/2020/08/11/LeetCode-529-minesweeper/"/>
    <url>/2020/08/11/LeetCode-529-minesweeper/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">529. 扫雷游戏</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><blockquote><p>找周围的雷和进入下一层递归都是在 <strong>八个方向</strong> 游走。</p></blockquote><p>典型的 <code>DFS</code>。</p><p>若 <code>click</code> 位置为 <code>M</code>，标记返回，否则进入递归。</p><p>需要注意的是新的位置不能越界，且未被标记过。</p><ol><li>若周围有雷，遍历周围的八个位置，找到雷的数量，标记后返回</li><li>若周围没有雷，标记为 <code>B</code>，遍历周围八个位置，进入递归。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dirs = &#123;            <span class="hljs-comment">// 上：(x - 1, y)</span>            &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,            <span class="hljs-comment">// 下：(x + 1, y)</span>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,            <span class="hljs-comment">// 左：(x, y - 1)</span>            &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 右：(x, y + 1)</span>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 左上：(x - 1, y - 1)</span>            &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 右上，(x - 1, y + 1)</span>            &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 左下：(x + 1, y - 1)</span>            &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 右下：(x + 1, y + 1)</span>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;    &#125;;    <span class="hljs-keyword">boolean</span>[][] used;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[][] updateBoard(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span>[] click) &#123;        <span class="hljs-keyword">if</span> (notInArea(click[<span class="hljs-number">0</span>], click[<span class="hljs-number">1</span>], board)) &#123;            <span class="hljs-keyword">return</span> board;        &#125;        <span class="hljs-keyword">if</span> (board[click[<span class="hljs-number">0</span>]][click[<span class="hljs-number">1</span>]] == <span class="hljs-string">'M'</span>) &#123;            board[click[<span class="hljs-number">0</span>]][click[<span class="hljs-number">1</span>]] = <span class="hljs-string">'X'</span>;            <span class="hljs-keyword">return</span> board;        &#125; <span class="hljs-keyword">else</span> &#123;            used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[board.length][board[<span class="hljs-number">0</span>].length];            dfs(click[<span class="hljs-number">0</span>], click[<span class="hljs-number">1</span>], board);        &#125;        <span class="hljs-keyword">return</span> board;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        used[x][y] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> mineCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = x + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = y + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (notInArea(newX, newY, board)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (board[newX][newY] == <span class="hljs-string">'M'</span>) &#123;                mineCount++;            &#125;        &#125;        <span class="hljs-comment">// 找到地雷返回上一层</span>        <span class="hljs-keyword">if</span> (mineCount &gt; <span class="hljs-number">0</span>) &#123;            board[x][y] = (<span class="hljs-keyword">char</span>) (mineCount + <span class="hljs-string">'0'</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 未找到雷，进行标记，进入下一个位置</span>        board[x][y] = <span class="hljs-string">'B'</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = x + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = y + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (notInArea(newX, newY, board) || used[newX][newY]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            dfs(newX, newY, board);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">notInArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> || x &gt;= board.length                || y &lt; <span class="hljs-number">0</span> || y &gt;= board[<span class="hljs-number">0</span>].length;    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dirs = &#123;        <span class="hljs-comment">// 上：(x - 1, y)</span>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 下：(x + 1, y)</span>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 左：(x, y - 1)</span>        &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 右：(x, y + 1)</span>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 左上：(x - 1, y - 1)</span>        &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 右上，(x - 1, y + 1)</span>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 左下：(x + 1, y - 1)</span>        &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 右下：(x + 1, y + 1)</span>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-keyword">boolean</span>[][] used;<span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[][] updateBoard(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span>[] click) &#123;    <span class="hljs-keyword">if</span> (notInArea(click[<span class="hljs-number">0</span>], click[<span class="hljs-number">1</span>], board)) &#123;        <span class="hljs-keyword">return</span> board;    &#125;    <span class="hljs-keyword">if</span> (board[click[<span class="hljs-number">0</span>]][click[<span class="hljs-number">1</span>]] == <span class="hljs-string">'M'</span>) &#123;        board[click[<span class="hljs-number">0</span>]][click[<span class="hljs-number">1</span>]] = <span class="hljs-string">'X'</span>;        <span class="hljs-keyword">return</span> board;    &#125;    used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[board.length][board[<span class="hljs-number">0</span>].length];    Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(click);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-keyword">int</span>[] cur = queue.poll();        used[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> mineCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;            <span class="hljs-keyword">int</span> newX = cur[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> newY = cur[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (notInArea(newX, newY, board)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (board[newX][newY] == <span class="hljs-string">'M'</span>) &#123;                mineCount++;            &#125;        &#125;        <span class="hljs-keyword">if</span> (mineCount &gt; <span class="hljs-number">0</span>) &#123;            board[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] = (<span class="hljs-keyword">char</span>) (mineCount + <span class="hljs-string">'0'</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            board[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] = <span class="hljs-string">'B'</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                <span class="hljs-keyword">int</span> newX = cur[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];                <span class="hljs-keyword">int</span> newY = cur[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span> (notInArea(newX, newY, board) || used[newX][newY]) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;newX, newY&#125;);                <span class="hljs-comment">// 避免超时</span>                used[newX][newY] = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> board;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">notInArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> || x &gt;= board.length            || y &lt; <span class="hljs-number">0</span> || y &gt;= board[<span class="hljs-number">0</span>].length;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 200. 岛屿数量</title>
    <link href="/2020/08/10/LeetCode-200-number-of-islands/"/>
    <url>/2020/08/10/LeetCode-200-number-of-islands/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></p><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 已被访问的数组</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">boolean</span>[][] visited;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 移动方向</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span>[][] dir = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;            <span class="hljs-comment">// 上: (x - 1, y)</span>            &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,            <span class="hljs-comment">// 右: (x, y + 1)</span>            &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,            <span class="hljs-comment">// 下: (x + 1, y)</span>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,            <span class="hljs-comment">// 左: (x, y - 1)</span>            &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;    &#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;        rows = grid.length;        <span class="hljs-keyword">if</span> (rows &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        cols = grid[<span class="hljs-number">0</span>].length;        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-comment">// 当前位置未访问过 &amp;&amp; 是陆地</span>                <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-string">'1'</span>) &#123;                    <span class="hljs-comment">// 只要未访问过且为 1 肯定存在一个岛屿</span>                    <span class="hljs-comment">// 需要做的就是找到这个岛屿连通的所有位置</span>                    count++;                    dfs(grid, i, j);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        visited[x][y] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dir.length; i++) &#123;            <span class="hljs-keyword">int</span> nextX = x + dir[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> nextY = y + dir[i][<span class="hljs-number">1</span>];            <span class="hljs-comment">// 新位置 未越界 &amp;&amp; 未访问过 &amp;&amp; 是陆地</span>            <span class="hljs-keyword">if</span> (inArea(nextX, nextY) &amp;&amp; !visited[nextX][nextY] &amp;&amp; grid[nextX][nextY] == <span class="hljs-string">'1'</span>) &#123;                dfs(grid, nextX, nextY);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-keyword">int</span> rows;<span class="hljs-keyword">int</span> cols;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 已被访问的数组</span><span class="hljs-comment"> */</span><span class="hljs-keyword">boolean</span>[][] visited;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 移动方向</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span>[][] dir = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;        <span class="hljs-comment">// 上: (x - 1, y)</span>        &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 右: (x, y + 1)</span>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 下: (x + 1, y)</span>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 左: (x, y - 1)</span>        &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">int</span> y;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;    rows = grid.length;    <span class="hljs-keyword">if</span> (rows &lt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    cols = grid[<span class="hljs-number">0</span>].length;    visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;            <span class="hljs-comment">// 当前位置未访问过 &amp;&amp; 是陆地</span>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-string">'1'</span>) &#123;                <span class="hljs-comment">// 只要未访问过且为 1 肯定存在一个岛屿</span>                <span class="hljs-comment">// 需要做的就是找到这个岛屿连通的所有位置</span>                count++;                Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();                visited[i][j] = <span class="hljs-keyword">true</span>;                queue.offer(<span class="hljs-keyword">new</span> Node(i, j));                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;                    Node cur = queue.poll();                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; dir.length; k++) &#123;                        <span class="hljs-keyword">int</span> nextX = cur.x + dir[k][<span class="hljs-number">0</span>];                        <span class="hljs-keyword">int</span> nextY = cur.y + dir[k][<span class="hljs-number">1</span>];                        <span class="hljs-comment">// 新位置 未越界 &amp;&amp; 未访问过 &amp;&amp; 是陆地</span>                        <span class="hljs-keyword">if</span> (inArea(nextX, nextY) &amp;&amp; !visited[nextX][nextY] &amp;&amp; grid[nextX][nextY] == <span class="hljs-string">'1'</span>) &#123;                            queue.offer(<span class="hljs-keyword">new</span> Node(nextX, nextY));                            <span class="hljs-comment">// 及时标记，避免超时</span>                            visited[nextX][nextY] = <span class="hljs-keyword">true</span>;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; cols;&#125;</code></pre><h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1><p>把所有的水连接到水域结点，若是陆地尝试与周围结点链接。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> rows;    <span class="hljs-keyword">int</span> cols;    <span class="hljs-keyword">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;        rows = grid.length;        <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        cols = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (cols == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> len = rows * cols;        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(len + <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;                <span class="hljs-comment">// 如果是 水，连接到 dummy 结点</span>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">'0'</span>) &#123;                    uf.union(len, getIndex(i, j));                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 如果是 陆地，尝试连接到周围的陆地</span>                    <span class="hljs-comment">// 这里 dirs 只要 右和下两个方向就能遍历到周围的结点</span>                    <span class="hljs-comment">// 因为在上一次遍历时已经访问过左和上方的结点</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir : dirs) &#123;                        <span class="hljs-keyword">int</span> newX = i + dir[<span class="hljs-number">0</span>];                        <span class="hljs-keyword">int</span> newY = j + dir[<span class="hljs-number">1</span>];                        <span class="hljs-keyword">if</span> (inArea(newX, newY) &amp;&amp; grid[newX][newY] == <span class="hljs-string">'1'</span>) &#123;                            uf.union(getIndex(i, j), getIndex(newX, newY));                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 减去水域的结点才是所有的陆地结点</span>        <span class="hljs-keyword">return</span> uf.getCount() - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">return</span> i * cols + j;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &lt; rows &amp;&amp; y &lt; cols;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 126. 单词接龙 II</title>
    <link href="/2020/08/09/LeetCode-126-word-ladder-ii/"/>
    <url>/2020/08/09/LeetCode-126-word-ladder-ii/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. 单词接龙 II</a></p><ul><li>找的是最短路径，且可能有多个</li><li>一开始用的 <code>List</code> 存放每层元素，结果 回溯的时候难以访问下一层，最好用 <code>Map</code> 存放</li><li>！！最短路径要及时剪枝</li><li>！！不能用 <code>used</code> 数组标记访问过的元素，而是标记当前层和以上层已经访问过的数组，因为若存在多个最短路径，元素可能重复使用，<code>used</code> 数组标记后会把下层的元素也标记，会导致漏解。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (!wordList.contains(endWord)) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-comment">// boolean[] used = new boolean[wordList.size()];</span>        Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(beginWord);        <span class="hljs-comment">// int start = wordList.indexOf(beginWord);</span>        <span class="hljs-comment">// if (start != -1) &#123;</span>        <span class="hljs-comment">//     used[start] = true;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// key: 当前层每一个单词 value: 每个单词对应的下一层所有单词</span>        Map&lt;String, HashSet&lt;String&gt;&gt; successors = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        Set&lt;String&gt; level = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                String word = queue.poll();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordList.size(); i++) &#123;                    String candidate = wordList.get(i);                    <span class="hljs-comment">// 下一层 candidate 未被使用 &amp;&amp; 可以接龙</span>                    <span class="hljs-keyword">if</span> (!visited.contains(candidate) &amp;&amp; canLadder(word, candidate)) &#123;                        <span class="hljs-comment">// System.out.println(word + " -&gt; " + candidate);</span>                        <span class="hljs-keyword">if</span> (endWord.equals(candidate)) &#123;                            found = <span class="hljs-keyword">true</span>;                        &#125;                        <span class="hljs-keyword">if</span> (!level.contains(candidate))&#123;                            <span class="hljs-comment">// used[i] = true;</span>                            queue.offer(candidate);                            level.add(candidate);                        &#125;                        successors.computeIfAbsent(word, e -&gt; <span class="hljs-keyword">new</span> HashSet&lt;&gt;());                        successors.get(word).add(candidate);                    &#125;                &#125;            &#125;            <span class="hljs-comment">// 若 found 为 true，说明已找到 end 的路径</span>            <span class="hljs-comment">// 可保证为最短路径</span>            <span class="hljs-comment">// ! 第一次提交没 AC 的原因：忘了找最短路径，把所有路径都找出来了</span>            <span class="hljs-keyword">if</span> (found) &#123;                <span class="hljs-keyword">break</span>;            &#125;            System.out.println(level.toString());            visited.addAll(level);            level.clear();        &#125;        System.out.println(successors.toString());        <span class="hljs-comment">// 未找到，返回空集</span>        <span class="hljs-keyword">if</span> (!found) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        path.add(beginWord);        dfs(beginWord, endWord, path, successors, res);        System.out.println(res);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; path, Map&lt;String, HashSet&lt;String&gt;&gt; successors, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;        <span class="hljs-keyword">if</span> (endWord.equals(beginWord)) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// ！及时剪枝，否则 NPE</span>        <span class="hljs-keyword">if</span> (!successors.containsKey(beginWord)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 选择队列：是当前 单词 的下一层，</span>        <span class="hljs-comment">// 所以如果用 List 来保存每一层的话，获取下一层就会比较麻烦</span>        HashSet&lt;String&gt; successor = successors.get(beginWord);        <span class="hljs-keyword">for</span> (String word : successor) &#123;            <span class="hljs-keyword">if</span> (path.contains(word)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            path.add(word);            dfs(word, endWord, path, successors, res);            path.remove(word);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canLadder</span><span class="hljs-params">(String word, String candidate)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">if</span> (word.charAt(i) != candidate.charAt(i)) &#123;                <span class="hljs-keyword">if</span> (++count &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 127. 单词接龙</title>
    <link href="/2020/08/08/LeetCode-127-word-ladder/"/>
    <url>/2020/08/08/LeetCode-127-word-ladder/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. 单词接龙</a></p><p>和 433.最小基因那题很像，不过本题变异的字母是不确定的，不再是 <code>ACGT</code>，若用回溯会超时。</p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;        <span class="hljs-comment">// ! endWord 不在 wordList 中直接返回</span>        <span class="hljs-keyword">if</span> (!wordList.contains(endWord)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[wordList.size()];        LinkedList&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-comment">// 将 beginWord 加入队列，标记访问数组</span>        queue.offer(beginWord);        <span class="hljs-keyword">int</span> start = wordList.indexOf(beginWord);        <span class="hljs-keyword">if</span> (start != -<span class="hljs-number">1</span>) &#123;            used[start] = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            step++;            <span class="hljs-comment">// 此时队列中的所有元素相当于上一个 word 可向下接龙的所有选择</span>            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                String word = queue.poll();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordList.size(); i++) &#123;                    String candidate = wordList.get(i);                    <span class="hljs-comment">// 若已经访问过 || word 无法接龙到 candidate，则跳过 </span>                    <span class="hljs-keyword">if</span> (used[i] || !canLadder(word, candidate)) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-comment">// candidate 到达 end，返回</span>                    <span class="hljs-keyword">if</span> (endWord.equals(candidate)) &#123;                        <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// 标记访问数组，将 candidate 加入队列</span>                        used[i] = <span class="hljs-keyword">true</span>;                        queue.offer(candidate);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// ！！！返回 0，不是 step</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canLadder</span><span class="hljs-params">(String word, String candidate)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; candidate.length(); i++) &#123;            <span class="hljs-keyword">if</span> (word.charAt(i) != candidate.charAt(i)) &#123;                <span class="hljs-keyword">if</span> (++count &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><h1 id="双向-bfs"><a class="markdownIt-Anchor" href="#双向-bfs"></a> 双向 BFS</h1><p>采用左右两个扩散集合，当集合重复即表示扩散结束。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;        <span class="hljs-comment">// 不用 set 竟然超时了！</span>        Set&lt;String&gt; wordSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordList);        <span class="hljs-keyword">if</span> (!wordSet.contains(endWord)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// 标记已访问过的元素</span>        Set&lt;String&gt; used = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-comment">// 左边扩散集合，每次都假设该集合元素最少，则扩散速度更快</span>        Set&lt;String&gt; beginSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        beginSet.add(beginWord);        <span class="hljs-comment">// 右边扩散集合</span>        Set&lt;String&gt; endSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        endSet.add(endWord);        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!beginSet.isEmpty() &amp;&amp; !endSet.isEmpty()) &#123;            step++;            <span class="hljs-comment">// 使 beginSet 的元素最少</span>            <span class="hljs-keyword">if</span> (beginSet.size() &gt; endSet.size()) &#123;                Set&lt;String&gt; tmp = beginSet;                beginSet = endSet;                endSet = tmp;            &#125;            <span class="hljs-comment">// 下一层扩散的集合</span>            Set&lt;String&gt; nextLevel = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();            <span class="hljs-keyword">for</span> (String word : beginSet) &#123;                <span class="hljs-keyword">char</span>[] words = word.toCharArray();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;                    <span class="hljs-keyword">char</span> old = words[i];                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c = <span class="hljs-string">'a'</span>; c &lt;= <span class="hljs-string">'z'</span>; c++) &#123;                        <span class="hljs-keyword">if</span> (old == c) &#123;                            <span class="hljs-keyword">continue</span>;                        &#125;                        words[i] = c;                        String nextWord = String.valueOf(words);                        <span class="hljs-comment">// 新元素必须存在于提供的 list 中</span>                        <span class="hljs-keyword">if</span> (wordSet.contains(nextWord)) &#123;                            <span class="hljs-comment">// 右边集合包含该元素，说明扩散重复，直接返回</span>                            <span class="hljs-keyword">if</span> (endSet.contains(nextWord)) &#123;                                <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span>;                            &#125;                            <span class="hljs-comment">// 加入下一层扩散集合</span>                            <span class="hljs-keyword">if</span> (!used.contains(nextWord)) &#123;                                nextLevel.add(nextWord);                                <span class="hljs-comment">// 标记已访问</span>                                used.add(nextWord);                            &#125;                        &#125;                    &#125;                    words[i] = old;                &#125;            &#125;            <span class="hljs-comment">// 设置下一层的扩散集合</span>            beginSet = nextLevel;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 515. 在每个树行中找最大值</title>
    <link href="/2020/08/07/LeetCode-515-find-largest-value-in-each-tree-row/"/>
    <url>/2020/08/07/LeetCode-515-find-largest-value-in-each-tree-row/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">515. 在每个树行中找最大值</a></p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><p>层次遍历</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(root);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                TreeNode p = queue.poll();                max = Math.max(p.val, max);                <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) &#123;                    queue.offer(p.left);                &#125;                <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) &#123;                    queue.offer(p.right);                &#125;            &#125;            res.add(max);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><p>判断是否到了新的一层：<code>res</code> 中保存的是每一层的最大值，所以 <code>res.size()</code> 等于遍历过的层数，若 <code>res.size() &lt; level</code> 表示到了新层。</p><pre><code class="hljs java">List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;            dfs(root, <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> level)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 遍历到了下一层，添加新元素</span>        <span class="hljs-keyword">if</span> (res.size() &lt; level) &#123;            res.add(root.val);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 计算当前层的最大值</span>            <span class="hljs-keyword">int</span> levelMax = Math.max(root.val, res.get(level - <span class="hljs-number">1</span>));            res.set(level - <span class="hljs-number">1</span>, levelMax);        &#125;        dfs(root.left, level + <span class="hljs-number">1</span>);        dfs(root.right, level + <span class="hljs-number">1</span>);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 22. 括号生成</title>
    <link href="/2020/08/07/LeetCode-22-generate-parentheses/"/>
    <url>/2020/08/07/LeetCode-22-generate-parentheses/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/generate-parentheses/submissions/" target="_blank" rel="noopener">22. 括号生成</a></p><h1 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h1><pre><code class="hljs java">List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        backtrack(n, n, <span class="hljs-string">""</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 路径：生成的括号字符串</span><span class="hljs-comment">     * 选择列表：路径中可放置的左右括号数量</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> left  左括号剩余数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> right 右括号剩余数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path  路径</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, String path)</span> </span>&#123;        <span class="hljs-comment">// 左括号剩余 &gt; 右括号剩余：剪枝</span>        <span class="hljs-comment">// e.g. )</span>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;            res.add(path);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 左边可放置左括号</span>        <span class="hljs-comment">// e.g. ()</span>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;            backtrack(left - <span class="hljs-number">1</span>, right, path + <span class="hljs-string">"("</span>);        &#125;        <span class="hljs-comment">// 左括号剩余 &lt; 右括号剩余：右边可放置右括号</span>        <span class="hljs-comment">// e.g. ((, (</span>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;            backtrack(left, right - <span class="hljs-number">1</span>, path + <span class="hljs-string">")"</span>);        &#125;    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    String path;    <span class="hljs-keyword">int</span> left;    <span class="hljs-keyword">int</span> right;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path  当前结点产生的路径</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> left  左边剩余括号</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> right 右边剩余括号</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String path, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">this</span>.path = path;        <span class="hljs-keyword">this</span>.left = left;        <span class="hljs-keyword">this</span>.right = right;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(<span class="hljs-keyword">new</span> Node(<span class="hljs-string">""</span>, n, n));        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            Node q = queue.poll();            <span class="hljs-comment">// 左右括号均已用完</span>            <span class="hljs-keyword">if</span> (q.left == <span class="hljs-number">0</span> &amp;&amp; q.right == <span class="hljs-number">0</span>) &#123;                res.add(q.path);            &#125;            <span class="hljs-comment">// 左括号剩余</span>            <span class="hljs-keyword">if</span> (q.left &gt; <span class="hljs-number">0</span>) &#123;                queue.offer(<span class="hljs-keyword">new</span> Node(q.path + <span class="hljs-string">"("</span>, q.left - <span class="hljs-number">1</span>, q.right));            &#125;            <span class="hljs-comment">// 右括号剩余</span>            <span class="hljs-keyword">if</span> (q.right &gt; <span class="hljs-number">0</span> &amp;&amp; q.right &gt; q.left) &#123;                queue.offer(<span class="hljs-keyword">new</span> Node(q.path + <span class="hljs-string">")"</span>, q.left, q.right - <span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 433. 最小基因变化</title>
    <link href="/2020/08/06/LeetCode-433-minimum-genetic-mutation/"/>
    <url>/2020/08/06/LeetCode-433-minimum-genetic-mutation/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener">433. 最小基因变化</a></p><h1 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h1><p>第一次解法击败 <code>100%</code> 用户。</p><p>每一次的变异都可在基因库中找到，因此从基因库中构建决策树，与当前基因相差一个碱基且在之前的选择路径中未出现的基因即为下一步变异的基因。</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> minStep = Integer.MAX_VALUE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(String start, String end, String[] bank)</span> </span>&#123;        dfs(start, end, <span class="hljs-number">0</span>, bank);        <span class="hljs-keyword">return</span> minStep == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : minStep;    &#125;    List&lt;String&gt; selectedList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 选择队列：bank 中在决策树中未选择的元素</span><span class="hljs-comment">     * 路径：selectedList</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start 当前变异到的基因</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end   最终的基因</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> count 需要变为最终基因的次数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bank  选择队列</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String start, String end, <span class="hljs-keyword">int</span> count, String[] bank)</span> </span>&#123;        <span class="hljs-comment">// 当前步数 &gt; 最小步数：剪枝</span>        <span class="hljs-keyword">if</span> (count &gt; minStep) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 若 当前基因 可以变为 最终基因</span>        <span class="hljs-comment">// 则计算最小步数，结束递归</span>        <span class="hljs-keyword">if</span> (start.equals(end)) &#123;            minStep = Math.min(minStep, count);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (String candidate : bank) &#123;            <span class="hljs-comment">// 若 candidate 不在决策树中 &amp;&amp; start 可变异为 candidate</span>            <span class="hljs-comment">// 则进入决策</span>            <span class="hljs-keyword">if</span> (notSelected(candidate) &amp;&amp; canMutate(start, candidate)) &#123;                selectedList.add(candidate);                dfs(candidate, end, count + <span class="hljs-number">1</span>, bank);                selectedList.remove(candidate);            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断 start 基因是否可以变为 candidate 基因</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidate</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canMutate</span><span class="hljs-params">(String start, String candidate)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; start.length(); i++) &#123;            <span class="hljs-keyword">if</span> (start.charAt(i) != candidate.charAt(i)) &#123;                <span class="hljs-keyword">if</span> (++count &gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断在之前的路径中是否未选择 candidate</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> candidate</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">notSelected</span><span class="hljs-params">(String candidate)</span> </span>&#123;        <span class="hljs-keyword">return</span> !selectedList.contains(candidate);    &#125;</code></pre><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><p>每次变异一个碱基，队列中保存的即为当前可变异的所有基因，且这些基因都在基因库中未被变异过。<br />相当于构建一棵树，进行树的层次遍历。<br />需要注意的是变异完后的碱基需要恢复原样，否则在下一次获取新基因时可能导致多个碱基都发生了变异。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(String start, String end, String[] bank)</span> </span>&#123;        Set&lt;String&gt; unSelectedSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(bank));        <span class="hljs-keyword">if</span> (!unSelectedSet.contains(end)) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">char</span>[] mutGenes = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'T'</span>&#125;;        LinkedList&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(start);        unSelectedSet.remove(start);        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            step++;            <span class="hljs-comment">// 队列中保存的是一个基因一次变异可以产生的新基因序列</span>            <span class="hljs-comment">// 队列为空则表示这次的序列变异结束，进入下一次遍历</span>            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 基因</span>                <span class="hljs-keyword">char</span>[] genes = queue.poll().toCharArray();                <span class="hljs-comment">// 1. 对每个基因位变异</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; genes.length; i++) &#123;                    <span class="hljs-comment">// 保存旧的碱基</span>                    <span class="hljs-keyword">char</span> oldGene = genes[i];                    <span class="hljs-comment">// 2. 基因的每一位依次进行 ACGT 变异</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> mutGene : mutGenes) &#123;                        genes[i] = mutGene;                        <span class="hljs-comment">// 3. 获取碱基变异后的新基因</span>                        String newGene = String.valueOf(genes);                        <span class="hljs-comment">// 4. 变到 end，直接返回</span>                        <span class="hljs-keyword">if</span> (end.equals(newGene)) &#123;                            <span class="hljs-keyword">return</span> step;                            <span class="hljs-comment">// 5. 在未变异的基因库中找到新基因</span>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unSelectedSet.contains(newGene)) &#123;                            unSelectedSet.remove(newGene);                            queue.offer(newGene);                        &#125;                    &#125;                    <span class="hljs-comment">// 变异的基因位要恢复原来的碱基</span>                    <span class="hljs-comment">// 否则在 3 中获取的新基因会变成 TTTT*，进而影响 4, 5</span>                    genes[i] = oldGene;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre><h1 id="双向-bfs"><a class="markdownIt-Anchor" href="#双向-bfs"></a> 双向 BFS</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(String start, String end, String[] bank)</span> </span>&#123;        <span class="hljs-keyword">if</span> (start.length() == <span class="hljs-number">0</span> || end.length() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        Set&lt;String&gt; list = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(bank));        <span class="hljs-keyword">if</span> (!list.contains(end)) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">char</span>[] muteList = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'T'</span>&#125;;        Set&lt;String&gt; beginSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        beginSet.add(start);        Set&lt;String&gt; endSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        endSet.add(end);        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!beginSet.isEmpty() &amp;&amp; !endSet.isEmpty()) &#123;            count++;            <span class="hljs-comment">// 每次都假设从数目小的集合遍历</span>            <span class="hljs-keyword">if</span> (beginSet.size() &gt; endSet.size()) &#123;                Set&lt;String&gt; tmp = beginSet;                beginSet = endSet;                endSet = tmp;            &#125;            <span class="hljs-comment">// 下一次变异的列表</span>            Set&lt;String&gt; nextLevel = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();            <span class="hljs-keyword">for</span> (String word : beginSet) &#123;                <span class="hljs-keyword">char</span>[] words = word.toCharArray();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;                    <span class="hljs-keyword">char</span> old = words[i];                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : muteList) &#123;                        <span class="hljs-keyword">if</span> (old == c) &#123;                            <span class="hljs-keyword">continue</span>;                        &#125;                        words[i] = c;                        String candidate = String.valueOf(words);                        <span class="hljs-keyword">if</span> (endSet.contains(candidate)) &#123;                            <span class="hljs-keyword">return</span> count;                        &#125;                        <span class="hljs-comment">// 这里一定注意只能变异到 bank 中的单词</span>                        <span class="hljs-comment">// 如果使用 used 判断，会加入不在 bank 中的单词，导致出错</span>                        <span class="hljs-keyword">if</span> (list.contains(candidate)) &#123;                            nextLevel.add(candidate);                            list.remove(candidate);                        &#125;                    &#125;                    words[i] = old;                &#125;            &#125;            beginSet = nextLevel;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 102. 二叉树的层序遍历</title>
    <link href="/2020/08/06/LeetCode-102-binary-tree-level-order-traversal/"/>
    <url>/2020/08/06/LeetCode-102-binary-tree-level-order-traversal/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></p><p>主要在于判断每一层有哪些结点：遍历之前先保存每层结点数，然后按层处理结点。</p><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(root);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-comment">// 保存当前层的结点数</span>            <span class="hljs-keyword">int</span> n = queue.size();            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-comment">// 遍历当前层的结点</span>            <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 对头出队，并将左右结点入队</span>                <span class="hljs-comment">// 当本轮循环结束后，队列里都是同一层的结点</span>                TreeNode p = queue.poll();                level.add(p.val);                <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) &#123;                    queue.add(p.left);                &#125;                <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) &#123;                    queue.add(p.right);                &#125;            &#125;            <span class="hljs-comment">// 将当前层加入结果</span>            res.add(level);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        dfs(root, <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> level)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (res.size() &lt; level) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(root.val)));        &#125; <span class="hljs-keyword">else</span> &#123;            res.get(level - <span class="hljs-number">1</span>).add(root.val);        &#125;        dfs(root.left, level + <span class="hljs-number">1</span>);        dfs(root.right, level + <span class="hljs-number">1</span>);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 51. N皇后</title>
    <link href="/2020/08/05/LeetCode-51-n-queens/"/>
    <url>/2020/08/05/LeetCode-51-n-queens/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></p><p>棋盘每一行相当于决策树的每一层，每行的任意一列都可放置皇后。因此，从 <strong>每一行</strong> 开始，选择该行的 <strong>每一列</strong> 作为选择列表进行递归，该行以上的所有行此时都正确放置了皇后，当行数达到棋盘深度时结束递归，返回本次递归的结果。</p><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] row : board) &#123;            Arrays.fill(row, <span class="hljs-string">'.'</span>);        &#125;        backtrack(board, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> board 棋盘</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> row   行号</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> row)</span> </span>&#123;        <span class="hljs-comment">// 行数达到棋盘最后一行结束</span>        <span class="hljs-comment">// 此时棋盘已正确放置皇后，返回本轮结果</span>        <span class="hljs-keyword">if</span> (row == board.length) &#123;            res.add(genBoard(board));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 路径：row 行上面的那些行都成功放置了 Q</span>        <span class="hljs-keyword">char</span>[] line = board[row];        <span class="hljs-comment">// 选择列表：第 row 行的每一列都是 Q 的可选位置</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; line.length; col++) &#123;            <span class="hljs-comment">// 排除不合法选择</span>            <span class="hljs-comment">// 若当前 (row, col) 位置不满足，则进入该行的下一列</span>            <span class="hljs-keyword">if</span> (!isValid(board, row, col)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 做选择</span>            board[row][col] = <span class="hljs-string">'Q'</span>;            <span class="hljs-comment">// 进入下一行决策</span>            backtrack(board, row + <span class="hljs-number">1</span>);            <span class="hljs-comment">// 撤销选择</span>            board[row][col] = <span class="hljs-string">'.'</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 因为其它位置还处于初始状态</span><span class="hljs-comment">     * 只需要验证每一列，左上和右上位置是否有皇后</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> board 棋盘</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> row   当前行</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> col   当前列</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前位置是否可以放置 皇后</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;        <span class="hljs-comment">// 验证 col 所在列是否有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : board) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-string">'Q'</span> == line[col]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 验证当前位置左上角是否有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>;             i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>;             i--, j--) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-string">'Q'</span> == board[i][j]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 验证当前位置右上角是否有皇后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>;             i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; board.length;             i--, j++) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-string">'Q'</span> == board[i][j]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title">genBoard</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        List&lt;String&gt; bd = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] line : board) &#123;            bd.add(String.valueOf(line));        &#125;        <span class="hljs-keyword">return</span> bd;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 17. 电话号码的字母组合</title>
    <link href="/2020/08/04/LeetCode-17-letter-combinations-of-a-phone-number/"/>
    <url>/2020/08/04/LeetCode-17-letter-combinations-of-a-phone-number/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></p><h1 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h1><p>选择列表：每个 <code>digit</code> 对应的字母列表<br />路径：已选字母组合 + 选择列表的字母<br />终止条件：递归深度达到 <code>digits</code> 的长度</p><pre><code class="hljs java"><span class="hljs-comment">// 2 ~ 9 每个位置所对应的选择列表</span>String[] map = &#123;<span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>, <span class="hljs-string">"ghi"</span>, <span class="hljs-string">"jkl"</span>, <span class="hljs-string">"mno"</span>, <span class="hljs-string">"pqrs"</span>, <span class="hljs-string">"tuv"</span>, <span class="hljs-string">"wxyz"</span>&#125;;List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;    <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    combine(digits, <span class="hljs-string">""</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> digits</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> path   当前已选择的组合路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> len    当前递归到的 digits 位置</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">combine</span><span class="hljs-params">(String digits, String path, <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-comment">// 递归深度为 digits 的长度</span>    <span class="hljs-keyword">if</span> (len == digits.length()) &#123;        res.add(path);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 找到当前 digit 所对应的字母组合</span>    <span class="hljs-keyword">char</span> c = digits.charAt(len);    <span class="hljs-keyword">int</span> pos = c - <span class="hljs-string">'0'</span>;    <span class="hljs-comment">// 所需要的选择列表</span>    String candidateString = map[pos];    <span class="hljs-comment">// 枚举每个字母组合</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; candidateString.length(); i++) &#123;        <span class="hljs-comment">// 路径为：上一轮的路径 + 选择列表中的每个字母</span>        <span class="hljs-comment">// 递归深度/路径长度 + 1</span>        combine(digits, path + candidateString.charAt(i), len + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><p><code>8.16</code> 按照模板的回溯解法：添加 <code>add</code>，<code>remove</code> 操作。<br />一开始 <code>path</code> 使用的是 <code>List</code>，总是无法通过，后来发现若是 <code>digits</code> 由同一个数字组成的情况下，路径中的元素可能是重复的，此时使用 <code>list.remove()</code> 操作会删除错误位置的元素，使用栈的思想可解决这个问题。</p><pre><code class="hljs java">List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();String[] num2Str = &#123;<span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>, <span class="hljs-string">"ghi"</span>, <span class="hljs-string">"jkl"</span>, <span class="hljs-string">"mno"</span>, <span class="hljs-string">"pqrs"</span>, <span class="hljs-string">"tuv"</span>, <span class="hljs-string">"wxyz"</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;    <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">// 使用 StringBuilder</span>    <span class="hljs-comment">// 如果使用 List，当例子为 "999" 等相同数字时，在回溯时 remove 会出错</span>    StringBuilder path = <span class="hljs-keyword">new</span> StringBuilder();    backtrack(<span class="hljs-number">0</span>, path, digits);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len, StringBuilder path, String digits)</span> </span>&#123;    <span class="hljs-keyword">if</span> (len == digits.length()) &#123;        res.add(path.toString());        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> pos = digits.charAt(len) - <span class="hljs-string">'0'</span>;    String str = num2Str[pos];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; str.length(); j++) &#123;        String candidate = String.valueOf(str.charAt(j));        <span class="hljs-comment">// 末尾添加</span>        path.append(candidate);        backtrack(len + <span class="hljs-number">1</span>, path, digits);        <span class="hljs-comment">// 末尾删除</span>        path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h1 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h1><blockquote><p>‘’<br />a, b, c<br />b, c, ad, ae, af<br />…</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">// 2 ~ 9 每个位置所对应的选择列表</span>    String[] map = &#123;<span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>, <span class="hljs-string">"ghi"</span>, <span class="hljs-string">"jkl"</span>, <span class="hljs-string">"mno"</span>, <span class="hljs-string">"pqrs"</span>, <span class="hljs-string">"tuv"</span>, <span class="hljs-string">"wxyz"</span>&#125;;    <span class="hljs-comment">// 添加空元素，初始化时使第一个位置的字母入队</span>    res.add(<span class="hljs-string">""</span>);    <span class="hljs-comment">// 1. 遍历 digits e.g. "23"</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; digits.length(); i++) &#123;        <span class="hljs-keyword">int</span> pos = digits.charAt(i) - <span class="hljs-string">'0'</span>;        <span class="hljs-comment">// 选择列表 e.g. "def"</span>        String candidateStr = map[pos];        <span class="hljs-comment">// 2. 遍历队列，组合字母 res: a, b, c</span>        <span class="hljs-comment">// !! 先缓存当前的队列长度，否则动态 add path 时，队列长度在变化</span>        <span class="hljs-keyword">int</span> size = res.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++) &#123;            <span class="hljs-comment">// 队头出队 e.g. a</span>            String path = res.remove(<span class="hljs-number">0</span>);            <span class="hljs-comment">// 3. 组合队头和选择列表</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; candidateStr.length(); k++) &#123;                <span class="hljs-comment">// b, c, ad, ae, af</span>                res.add(path + candidateStr.charAt(k));            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 169. 多数元素</title>
    <link href="/2020/08/03/LeetCode-169-majority-element/"/>
    <url>/2020/08/03/LeetCode-169-majority-element/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></p><h1 id="解法一hashmap"><a class="markdownIt-Anchor" href="#解法一hashmap"></a> 解法一：<code>HashMap</code></h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = nums.length;    <span class="hljs-keyword">int</span> maj = n / <span class="hljs-number">2</span>;    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(n);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">if</span> (map.get(num) != <span class="hljs-keyword">null</span>) &#123;            map.put(num, map.get(num) + <span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            map.put(num, <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;        <span class="hljs-keyword">if</span> (entry.getValue() &gt; maj) &#123;            <span class="hljs-keyword">return</span> entry.getKey();        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h1 id="解法二排序"><a class="markdownIt-Anchor" href="#解法二排序"></a> 解法二：排序</h1><blockquote><p>给定的数组总是存在多数元素。</p></blockquote><p>排序后中间位置的元素一定是众数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        Arrays.sort(nums);        <span class="hljs-keyword">return</span> nums[nums.length / <span class="hljs-number">2</span>];&#125;</code></pre><ul><li>时间复杂度：<code>O(nlogn)</code></li><li>空间复杂度：<code>O(logn)</code></li></ul><h1 id="解法三随机化"><a class="markdownIt-Anchor" href="#解法三随机化"></a> 解法三：随机化</h1><p>因为超过 <code>n/2</code> 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;       <span class="hljs-keyword">int</span> maj = nums.length / <span class="hljs-number">2</span>;       Random random = <span class="hljs-keyword">new</span> Random();       <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;           <span class="hljs-keyword">int</span> candidate = nums[getRandIdx(random, <span class="hljs-number">0</span>, nums.length)];           <span class="hljs-keyword">if</span> (count(nums, candidate) &gt; maj) &#123;               <span class="hljs-keyword">return</span> candidate;           &#125;       &#125;   &#125;   <span class="hljs-comment">// 1. 获取随机位置</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRandIdx</span><span class="hljs-params">(Random random, <span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> max)</span> </span>&#123;       <span class="hljs-keyword">return</span> random.nextInt(max - min) + min;   &#125;   <span class="hljs-comment">// 2. 计算 candidate 出现次数</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> candidate)</span> </span>&#123;       <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;           <span class="hljs-keyword">if</span> (nums[i] == candidate) &#123;               count++;           &#125;       &#125;       <span class="hljs-keyword">return</span> count;   &#125;</code></pre><ul><li>时间复杂度：理论上最坏情况下的时间复杂度为 <code>O(∞)</code>，平均时间复杂度为 <code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h1 id="方法四分治"><a class="markdownIt-Anchor" href="#方法四分治"></a> 方法四：分治</h1><p>将数组分成左右两部分，直到所有的子问题都是长度为 <code>1</code> 的数组，分别求出左半部分的众数 <code>leftEle</code> 以及右半部分的众数 <code>rightEle</code>，随后在 <code>leftEle</code> 和 <code>rightEle</code> 中选出正确的众数。</p><ul><li>如果回溯后某区间的长度为 <code>1</code>，则子数组中唯一的数显然是众数，直接返回即可。</li><li>如果回溯后某区间的长度大于 <code>1</code>，我们必须将左右子区间的值合并。<ul><li>如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。</li><li>如果它们的众数不同，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">return</span> majEle(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majEle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-comment">// 1. 数组区间中只有一个元素，则直接返回</span>    <span class="hljs-keyword">if</span> (low == high) &#123;        <span class="hljs-keyword">return</span> nums[low];    &#125;    <span class="hljs-comment">// 2. 区间中存在多个元素，计算左右部分的众数</span>    <span class="hljs-keyword">int</span> mid = (high - low) / <span class="hljs-number">2</span> + low;    <span class="hljs-keyword">int</span> leftEle = majEle(nums, low, mid);    <span class="hljs-keyword">int</span> rightEle = majEle(nums, mid + <span class="hljs-number">1</span>, high);    <span class="hljs-comment">//  2.1 左右部分的众数相等</span>    <span class="hljs-keyword">if</span> (leftEle == rightEle) &#123;        <span class="hljs-keyword">return</span> leftEle;    &#125;    <span class="hljs-comment">// 2.2 左右部分众数不等，则计算他们在整个区间的出现次数</span>    <span class="hljs-keyword">int</span> lCount = count(nums, leftEle, low, high);    <span class="hljs-keyword">int</span> rCount = count(nums, rightEle, low, high);    <span class="hljs-keyword">return</span> lCount &gt; rCount ? leftEle : rightEle;&#125;<span class="hljs-comment">// 计算 candidate 出现次数</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> candidate, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt;= high; i++) &#123;        <span class="hljs-keyword">if</span> (nums[i] == candidate) &#123;            count++;        &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre><ul><li>时间复杂度：<code>O(nlogn)</code>。</li><li>空间复杂度：<code>O(logn)</code>。尽管分治算法没有直接分配额外的数组空间，但在递归的过程中使用了额外的栈空间。算法每次将数组从中间分成两部分，所以数组长度变为 <code>1</code> 之前需要进行 <code>O(logn)</code> 次递归，即空间复杂度为 <code>O(logn)</code>。</li></ul><h1 id="方法五boyer-moore-投票算法"><a class="markdownIt-Anchor" href="#方法五boyer-moore-投票算法"></a> 方法五：<code>Boyer-Moore</code> 投票算法</h1><ul><li><p>我们维护一个候选众数 <code>candidate</code> 和它出现的次数 <code>count</code>。初始时 <code>candidate</code> 可以为任意值，<code>count</code> 为 0；</p></li><li><p>我们遍历数组 <code>nums</code> 中的所有元素，对于每个元素 <code>x</code>，在判断 <code>x</code> 之前，如果 <code>count</code> 的值为 0，我们先将 <code>x</code> 的值赋予 <code>candidate</code>，随后我们判断 x：</p><ul><li><p>如果 <code>x</code> 与 <code>candidate</code> 相等，那么计数器 <code>count + 1</code>；</p></li><li><p>如果 <code>x</code> 与 <code>candidate</code> 不等，那么计数器 <code>count - 1</code>。</p></li></ul></li><li><p>在遍历完成后，<code>candidate</code> 即为整个数组的众数。</p></li></ul><p>举个例子，我们的输入数组为 <code>[1, 1, 0, 0, 0, 1, 0]</code>，那么 <code>0</code> 就是多数元素。<br />首先，<code>candidate</code> 被设置为第一个元素 <code>1</code>，<code>count</code> 也变成 <code>1</code>，由于 <code>1</code> 不是多数元素，所以当扫描到数组某个位置时，<code>count</code> 一定会减为 <code>0</code> 。在我们的例子中，当扫描到第四个位置时，<code>count</code> 变成 <code>0</code>.</p><p><code>count</code> 值变化过程：<br /><code>[1, 2, 1, 0 ……]</code></p><p>当 <code>count</code> 变成 <code>0</code> 时，对于每一个出现的 <code>1</code>，我们都用一个 <code>0</code> 与其进行抵消，所以我们消耗掉了与其一样多的<code>0</code>，而 <code>0</code> 是多数元素，这意味着当扫描到第四个位置时，我们已经最大程度的消耗掉了多数元素。然而，对于数组从第五个位置开始的剩余部分，<code>0</code> 依然是其中的多数元素(注意，多数元素出现次数大于 <code>⌊ n/2 ⌋</code>，而我们扫描过的部分中多数元素只占一半，那剩余部分中多数元素还有一半)。如果之前用于抵消的元素中存在非多数元素，那么数组剩余部分包含的多数元素就更多了。</p><blockquote><p>数组中从 <code>candidate</code> 被赋值到 <code>count</code> 减到 <code>0</code> 的那一段可以被去除，余下部分的多数元素依然是原数组的多数元素。我们可以不断重复这个过程，直到扫描到数组尾部，那么 <code>count</code> 必然会大于 <code>0</code>，而且这个 <code>count</code> 对应的 <code>candinate</code> 就是原数组的多数元素。</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> candidate = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;            candidate = num;        &#125;        count += (candidate == num) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> candidate;&#125;</code></pre><ul><li><p>时间复杂度：<code>O(n)</code>。</p></li><li><p>空间复杂度：<code>O(1)</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Overview</title>
    <link href="/2018/12/28/overview/"/>
    <url>/2018/12/28/overview/</url>
    
    <content type="html"><![CDATA[<p>During the past six months, I was focusing on preparing for the entrance exam of postgraduate schools, owing to that, I could barely write posts or sorting out my blog. What’s worse, I figured out that I got my server expired and lost most of my posts that I have written in the almost past three years, in which I have made some records in my study and lives, including programming thoughts and life experiences.</p><p>As you’ll find out, I plan to migrate my blog from cloud server to git pages, it’s kind of a large project. Thanks to the exam which I have mentioned above, actually I did not expect that I could spend a surprisingly large amount of time in concentrating on one thing. It’s helpful in building up a hard-working, persistent personality.</p><p>In short, now that I’ve finished my exam, I plan to get a vacation for a couple of weeks and then back to my blog’s migration.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
