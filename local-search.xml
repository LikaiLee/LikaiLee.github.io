<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>并发-锁原理</title>
    <link href="/2020/07/17/concurrent-lock/"/>
    <url>/2020/07/17/concurrent-lock/</url>
    
    <content type="html"><![CDATA[<h1 id="并发锁"><a href="#并发锁" class="headerlink" title="并发锁"></a>并发锁</h1><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此<strong>乐观锁不会上锁</strong>，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ol><li><code>CAS</code> 机制</li></ol><p><code>CAS</code> 操作包括了 3 个操作数：<br>    (1) 需要读写的内存位置(<code>V</code>)<br>    (2) 进行比较的预期值(<code>A</code>)<br>    (3) 拟写入的新值(<code>B</code>) </p><p><code>CAS</code> 操作逻辑如下：如果内存位置 <code>V</code> 的值等于预期的 <code>A</code> 值，则将该位置更新为新值 <code>B</code>，否则不进行任何操作。许多 <code>CAS</code> 的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。</p><blockquote><p><code>CAS</code> 是由 <code>CPU</code> 支持的原子操作，其原子性是在硬件层面进行保证的。</p></blockquote><ol start="2"><li>版本号机制<br>版本号机制的基本思路是在数据中增加一个字段 <code>version</code>，表示该数据的版本号，每当数据被修改，版本号 <code>+1</code>。</li></ol><ul><li>当某个线程查询数据时，将该数据的版本号一起查出来；</li><li>当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。</li></ul><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</p><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><p>悲观锁的实现方式是<strong>加锁</strong>，加锁既可以是对<strong>代码块加锁</strong>（如 <code>Java</code>的 <code>synchronized</code> 关键字和 <code>Lock</code>），也可以是对<strong>数据加锁</strong>（如 <code>MySQL</code> 中的排它锁）。</p><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>根据线程获取锁的抢占机制，锁可分为公平锁与非公平锁。</p><ul><li>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。</li><li>非公平锁在运行时闯入，也就是先来不一定先得，如 <code>synchronized</code>。</li><li><code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>，默认是非公平锁，但支持公平锁。</li><li>在没有公平性需求的情况下尽量使用非公平锁，因为公平锁会带来性能开销。</li></ul><h2 id="独占锁与共享锁"><a href="#独占锁与共享锁" class="headerlink" title="独占锁与共享锁"></a>独占锁与共享锁</h2><p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁可分为独占锁与共享锁。</p><ul><li>独占锁是一种悲观锁，每次访问资源都加上了互斥锁，在同一时间只允许一个线程读取数据。</li><li>共享锁是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</li></ul><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>当一个线程再次获取它已经获取的琐时，如果不被阻塞，那么该锁是可被重入的。</p><p><code>synchronized</code> 内部锁是可重入锁，在其内部维护一个标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。当一个线程获取了该锁时，计数器的值会变成 <code>1</code>，这时其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞挂起。</p><p>但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值 <code>+1</code>，当释放锁后值 <code>-1</code>。当计数器值为 <code>0</code>，线程标示被重置为 <code>null</code>，这时候被阻塞的线程会被唤醒来竞争该锁。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>当前线程在获取锁时，如果发现锁已被其他线程占有，它不马上阻塞自己，在不放弃 <code>CPU</code> 使用权的情况下，多次尝试获取（默认10次，可以使用 <code>-XX:PreBlockSpinsh</code> 参数设置该值），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定次数后仍没有获取到锁则当前线程才会被阻塞挂起。<br>自旋锁是使用 <code>CPU</code> 时间换取线程阻塞与调度的开销，但是很有可能这些 <code>CPU</code> 时间白白浪费了。</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><blockquote><p><code>AbstractQueuedSynchronizer</code>（简称 <code>AQS</code>）是队列同步器，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>Semaphore</code> 等）。</p><p>因此，要想深入理解 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 等并发锁和同步工具，必须先理解 <code>AQS</code> 的要点和原理。</p></blockquote><h2 id="AQS-的要点"><a href="#AQS-的要点" class="headerlink" title="AQS 的要点"></a><code>AQS</code> 的要点</h2><p>在 <code>java.util.concurrent.locks</code> 包中的相关锁(常用的有 <code>ReentrantLock</code>、 <code>ReadWriteLock</code>)都是基于 <code>AQS</code> 来实现。这些锁都没有直接继承 <code>AQS</code>，而是定义了一个 <code>Sync</code> 类去继承 <code>AQS</code>。为什么要这样呢？因为锁面向的是使用用户，而同步器面向的则是线程控制，那么在锁的实现中聚合同步器而不是直接继承 <code>AQS</code> 就可以很好的隔离二者所关注的事情。</p><p><strong><code>AQS</code> 提供了对独享锁与共享锁的支持。</strong></p><h3 id="独享锁-API"><a href="#独享锁-API" class="headerlink" title="独享锁 API"></a>独享锁 <code>API</code></h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span></code></pre><ul><li><code>acquire</code> - 获取独占锁。</li><li><code>acquireInterruptibly</code> - 获取可中断的独占锁。</li><li><code>tryAcquireNanos</code> - 尝试在指定时间内获取可中断的独占锁。在以下三种情况下回返回：<ul><li>在超时时间内，当前线程成功获取了锁；</li><li>当前线程在超时时间内被中断；</li><li>超时时间结束，仍未获得锁返回 false。</li></ul></li><li><code>release</code> - 释放独占锁。</li></ul><h3 id="共享锁-API"><a href="#共享锁-API" class="headerlink" title="共享锁 API"></a>共享锁 <code>API</code></h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquireSharedNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span></code></pre><ul><li><code>acquireShared</code> - 获取共享锁。</li><li><code>acquireSharedInterruptibly</code> - 获取可中断的共享锁。</li><li><code>tryAcquireSharedNanos</code> - 尝试在指定时间内获取可中断的共享锁。</li><li><code>release</code> - 释放共享锁。</li></ul><h2 id="AQS-的原理"><a href="#AQS-的原理" class="headerlink" title="AQS 的原理"></a><code>AQS</code> 的原理</h2><h3 id="AQS-的数据结构"><a href="#AQS-的数据结构" class="headerlink" title="AQS 的数据结构"></a><code>AQS</code> 的数据结构</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">/** 等待队列的队头，懒加载。只能通过 setHead 方法修改。 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;    <span class="hljs-comment">/** 等待队列的队尾，懒加载。只能通过 enq 方法添加新的等待节点。*/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;    <span class="hljs-comment">/** 同步状态 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;&#125;</code></pre><ul><li><p><code>state</code> - <code>AQS</code> 使用一个整型的 <code>volatile</code> 变量来 维护同步状态。</p><ul><li>这个整数状态的意义由子类来赋予，如 <code>ReentrantLock</code> 中该状态值表示所有者线程已经重复获取该锁的次数，<code>Semaphore</code> 中该状态值表示剩余的许可数量。</li></ul></li><li><p><code>head</code> 和 <code>tail</code> - <code>AQS</code> 维护了一个 <code>Node</code> 类型（<code>AQS</code> 的内部类）的双链表来完成同步状态的管理。这个双链表是一个双向的 <code>FIFO</code> 队列，通过 <code>head</code> 和 <code>tail</code> 指针进行访问。当有线程获取锁失败后，就被添加到队列末尾。</p></li></ul><p><img src="http://dunwu.test.upcdn.net/cs/java/javacore/concurrent/aqs_1.png" srcset="/img/loading.gif" alt="1"></p><p><code>Node</code> 的源码</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-comment">/** 该等待同步的节点处于共享模式 */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();    <span class="hljs-comment">/** 该等待同步的节点处于独占模式 */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">/** 线程等待状态，状态值有: 0、1、-1、-2、-3 */</span>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;    <span class="hljs-comment">/** 前驱节点 */</span>    <span class="hljs-keyword">volatile</span> Node prev;    <span class="hljs-comment">/** 后继节点 */</span>    <span class="hljs-keyword">volatile</span> Node next;    <span class="hljs-comment">/** 等待锁的线程 */</span>    <span class="hljs-keyword">volatile</span> Thread thread;  <span class="hljs-comment">/** 和节点是否共享有关 */</span>    Node nextWaiter;&#125;</code></pre><p>很显然，<code>Node</code> 是一个双链表结构。</p><p><code>waitStatus</code> - <code>Node</code> 使用一个整型的 <code>volatile</code> 变量来 维护 <code>AQS</code> 同步队列中线程节点的状态。<code>waitStatus</code> 有五个状态值：</p><ul><li><p><code>CANCELLED(1)</code> - 此状态表示：该节点的线程可能由于超时或被中断而 <strong>处于被取消(作废)状态</strong>，一旦处于这个状态，表示这个节点应该从等待队列中移除。</p></li><li><p><code>SIGNAL(-1)</code> - 此状态表示：后继节点会被挂起，因此在当前节点释放锁或被取消之后，必须唤醒(<code>unparking</code>)其后继结点。</p></li><li><p><code>CONDITION(-2)</code> - 此状态表示：该节点的线程 处于等待条件状态，不会被当作是同步队列上的节点，直到被唤醒(<code>signal</code>)，设置其值为 0，再重新进入阻塞状态。</p></li><li><p><code>PROPAGATE(-3)</code> - 此状态表示：下一个 <code>acquireShared</code> 应无条件传播。</p></li><li><p><code>0</code> - 非以上状态。</p></li></ul><h3 id="独占锁的获取和释放"><a href="#独占锁的获取和释放" class="headerlink" title="独占锁的获取和释放"></a>独占锁的获取和释放</h3><h4 id="获取独占锁"><a href="#获取独占锁" class="headerlink" title="获取独占锁"></a>获取独占锁</h4><p><code>AQS</code> 中使用 <code>acquire(int arg)</code> 方法获取独占锁，其大致流程如下：</p><ol><li><p>先尝试获取同步状态，如果获取同步状态成功，则结束方法，直接返回。</p></li><li><p>如果获取同步状态不成功，<code>AQS</code> 会不断尝试利用 <code>CAS</code> 操作将当前线程插入等待同步队列的队尾，直到成功为止。</p></li><li><p>接着，不断尝试为等待队列中的线程节点获取独占锁。</p></li></ol><p><img src="http://dunwu.test.upcdn.net/cs/java/javacore/concurrent/aqs_2.png" srcset="/img/loading.gif" alt="2"><br><img src="http://dunwu.test.upcdn.net/cs/java/javacore/concurrent/aqs_3.png" srcset="/img/loading.gif" alt="3"><br>详细流程可以用下图来表示，请结合源码来理解（一图胜千言）：<br><img src="http://dunwu.test.upcdn.net/cs/java/javacore/concurrent/aqs_4.png" srcset="/img/loading.gif" alt="4"></p><h4 id="释放独占锁"><a href="#释放独占锁" class="headerlink" title="释放独占锁"></a>释放独占锁</h4><p><code>AQS</code> 中使用 <code>release(int arg)</code> 方法释放独占锁，其大致流程如下：</p><ol><li><p>先尝试获取解锁线程的同步状态，如果获取同步状态不成功，则结束方法，直接返回。</p></li><li><p>如果获取同步状态成功，<code>AQS</code> 会尝试唤醒当前线程节点的后继节点。</p></li></ol><h4 id="获取可中断的独占锁"><a href="#获取可中断的独占锁" class="headerlink" title="获取可中断的独占锁"></a>获取可中断的独占锁</h4><p><code>AQS</code> 中使用 <code>acquireInterruptibly(int arg)</code> 方法获取可中断的独占锁。</p><p><code>acquireInterruptibly(int arg)</code> 实现方式相较于获取独占锁方法（<code>acquire</code>）非常相似，区别仅在于它会通过 <code>Thread.interrupted</code> 检测当前线程是否被中断，如果是，则立即抛出中断异常（<code>InterruptedException</code>）。</p><h4 id="获取超时等待式的独占锁"><a href="#获取超时等待式的独占锁" class="headerlink" title="获取超时等待式的独占锁"></a>获取超时等待式的独占锁</h4><p><code>AQS</code> 中使用 <code>tryAcquireNanos(int arg)</code> 方法获取超时等待的独占锁。</p><p><code>doAcquireNanos</code> 的实现方式 相较于获取独占锁方法（ <code>acquire</code>）非常相似，区别在于它会根据超时时间和当前时间计算出截止时间。在获取锁的流程中，会不断判断是否超时，如果超时，直接返回 <code>false</code>；如果没超时，则用 <code>LockSupport.parkNanos</code> 来阻塞当前线程。</p><h3 id="共享锁的获取和释放"><a href="#共享锁的获取和释放" class="headerlink" title="共享锁的获取和释放"></a>共享锁的获取和释放</h3><h4 id="获取共享锁"><a href="#获取共享锁" class="headerlink" title="获取共享锁"></a>获取共享锁</h4><p><code>AQS</code> 中使用 <code>acquireShared(int arg)</code> 方法获取共享锁。</p><p><code>acquireShared</code> 方法和 <code>acquire</code> 方法的逻辑很相似，区别仅在于自旋的条件以及节点出队的操作有所不同。</p><p>成功获得共享锁的条件如下：</p><ul><li><p><code>tryAcquireShared(arg)</code> 返回值大于等于 <code>0</code> （这意味着共享锁的 permit 还没有用完）。</p></li><li><p>当前节点的前驱节点是头结点。</p></li></ul><h4 id="释放共享锁"><a href="#释放共享锁" class="headerlink" title="释放共享锁"></a>释放共享锁</h4><p><code>AQS</code> 中使用 <code>releaseShared(int arg)</code> 方法释放共享锁。</p><p><code>releaseShared</code> 首先会尝试释放同步状态，如果成功，则解锁一个或多个后继线程节点。释放共享锁和释放独享锁流程大体相似，区别在于：</p><p>对于独享模式，如果需要 <code>SIGNAL</code>，释放仅相当于调用头节点的 <code>unparkSuccessor</code>。</p><h4 id="获取可中断的共享锁"><a href="#获取可中断的共享锁" class="headerlink" title="获取可中断的共享锁"></a>获取可中断的共享锁</h4><p><code>AQS</code> 中使用 <code>acquireSharedInterruptibly(int arg)</code> 方法获取可中断的共享锁。</p><p><code>acquireSharedInterruptibly</code> 方法与 <code>acquireInterruptibly</code> 几乎一致，不再赘述。</p><h4 id="获取超时等待式的共享锁"><a href="#获取超时等待式的共享锁" class="headerlink" title="获取超时等待式的共享锁"></a>获取超时等待式的共享锁</h4><p><code>AQS</code> 中使用 <code>tryAcquireSharedNanos(int arg)</code> 方法获取超时等待式的共享锁。</p><p><code>tryAcquireSharedNanos</code> 方法与 <code>tryAcquireNanos</code> 几乎一致，不再赘述。</p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Overview</title>
    <link href="/2018/12/28/overview/"/>
    <url>/2018/12/28/overview/</url>
    
    <content type="html"><![CDATA[<p>During the past six months, I was focusing on preparing for the entrance exam of postgraduate schools, owing to that, I could barely write posts or sorting out my blog. What’s worse, I figured out that I got my server expired and lost most of my posts that I have written in the almost past three years, in which I have made some records in my study and lives, including programming thoughts and life experiences.</p><p>As you’ll find out, I plan to migrate my blog from cloud server to git pages, it’s kind of a large project. Thanks to the exam which I have mentioned above, actually I did not expect that I could spend a surprisingly large amount of time in concentrating on one thing. It’s helpful in building up a hard-working, persistent personality.</p><p>In short, now that I’ve finished my exam, I plan to get a vacation for a couple of weeks and then back to my blog’s migration.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
