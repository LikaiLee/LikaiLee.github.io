<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Likai Lee">
  <meta name="keywords" content="">
  <title>并发-线程池 - Likai Lee</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Likai Lee</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                并发-线程池
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-27 10:38">
      2020年7月27日 上午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      70
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。</p>
</blockquote>
<p>如果并发请求数量很多，但每个线程执行的时间很短，就会出现频繁的创建和销毁线程。如此一来，会大大降低系统的效率，可能频繁创建和销毁线程的时间、资源开销要大于实际工作的所需。</p>
<p>正是由于这个问题，所以有必要引入线程池。使用 <strong>线程池的好处</strong> 有以下几点：</p>
<ul>
<li><p><strong>降低资源消耗</strong> - 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p><strong>提高响应速度</strong> - 当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li><p><strong>提高线程的可管理性</strong> - 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p>
</li>
</ul>
<h1 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a><code>Executor</code> 框架</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><code>Executor</code> 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。</p>
<p>还有关键的一点：有助于避免 <code>this</code> 逃逸问题。</p>
<blockquote>
<p><code>this</code> 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p>
</blockquote>
<h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727102933.png" srcset="/img/loading.gif" alt=""></p>
<h3 id="1-任务-Runnable-Callable"><a href="#1-任务-Runnable-Callable" class="headerlink" title="1. 任务(Runnable / Callable)"></a>1. 任务(<code>Runnable</code> / <code>Callable</code>)</h3><p>执行任务需要实现的 <code>Runnable</code> 接口 或 <code>Callable</code> 接口。他们的实现类都可以被 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行。</p>
<h3 id="2-任务的执行-Executor"><a href="#2-任务的执行-Executor" class="headerlink" title="2. 任务的执行(Executor)"></a>2. 任务的执行(<code>Executor</code>)</h3><p>任务执行机制的核心接口 <code>Executor</code> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。<br><code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 这两个关键类实现了 <code>ExecutorService</code> 接口。</p>
<h4 id="2-1-Executor"><a href="#2-1-Executor" class="headerlink" title="2.1 Executor"></a>2.1 <code>Executor</code></h4><p><code>Executor</code> 接口中只定义了一个 <code>execute</code> 方法，用于接收一个 <code>Runnable</code> 对象。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;
&#125;</code></pre>
<h4 id="2-2-ExecutorService"><a href="#2-2-ExecutorService" class="headerlink" title="2.2 ExecutorService"></a>2.2 <code>ExecutorService</code></h4><p><code>ExecutorService</code> 接口继承了 <code>Executor</code> 接口，它还提供了 <code>invokeAll</code>、<code>invokeAny</code>、<code>shutdown</code>、<code>submit</code> 等方法。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Executor</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function">List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span>
<span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException</span>;

    &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;

    &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span></span>;

    Future&lt;?&gt; submit(Runnable task);

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
        <span class="hljs-keyword">throws</span> InterruptedException;

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                                  <span class="hljs-keyword">long</span> timeout, TimeUnit unit)
        <span class="hljs-keyword">throws</span> InterruptedException;

    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span>
<span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;

    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span>
<span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span>
<span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;
&#125;</code></pre>
<p>比于 <code>Executor</code> 接口，<code>ExecutorService</code> 接口主要的扩展是：</p>
<ul>
<li>支持有返回值的线程 - <code>sumbit</code>、<code>invokeAll</code>、<code>invokeAny</code> 方法中都支持传入 <code>Callable</code> 对象。</li>
<li>支持管理线程生命周期 - <code>shutdown</code>、<code>shutdownNow</code>、<code>isShutdown</code> 等方法。</li>
</ul>
<h4 id="2-3-ScheduledExecutorService"><a href="#2-3-ScheduledExecutorService" class="headerlink" title="2.3 ScheduledExecutorService"></a>2.3 <code>ScheduledExecutorService</code></h4><p><code>ScheduledExecutorService</code> 接口扩展了 <code>ExecutorService</code> 接口。</p>
<p>它除了支持前面两个接口的所有能力以外，还支持定时调度线程。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ScheduledExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExecutorService</span> </span>&#123;

    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-keyword">long</span> delay, TimeUnit unit);

    <span class="hljs-keyword">public</span> &lt;V&gt; <span class="hljs-function">ScheduledFuture&lt;V&gt; <span class="hljs-title">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable, <span class="hljs-keyword">long</span> delay, TimeUnit unit)</span></span>;

    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                                  <span class="hljs-keyword">long</span> initialDelay,
                                                  <span class="hljs-keyword">long</span> period,
                                                  TimeUnit unit);

    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,
                                                     <span class="hljs-keyword">long</span> initialDelay,
                                                     <span class="hljs-keyword">long</span> delay,
                                                     TimeUnit unit);
&#125;</code></pre>
<p>其扩展的接口提供以下能力：</p>
<ul>
<li><p><code>schedule</code> 方法可以在指定的延时后执行一个 <code>Runnable</code> 或者 <code>Callable</code> 任务。</p>
</li>
<li><p><code>scheduleAtFixedRate</code> 方法和 <code>scheduleWithFixedDelay</code> 方法可以按照指定时间间隔，定期执行任务。</p>
</li>
</ul>
<h3 id="3-异步计算的结果-Future"><a href="#3-异步计算的结果-Future" class="headerlink" title="3. 异步计算的结果(Future)"></a>3. 异步计算的结果(<code>Future</code>)</h3><blockquote>
<p><code>Future</code> 接口以及 <code>Future</code> 接口的实现类 <code>FutureTask</code> 类都可以代表异步计算的结果。</p>
</blockquote>
<p>当我们把 <code>Runnable</code> 接口或 <code>Callable</code> 接口的实现类提交给 <code>ThreadPoolExecutor</code> 或 <code>ScheduledThreadPoolExecutor</code> 执行，调用 <code>submit()</code> 方法时会返回一个 <code>FutureTask</code> 对象，可通过 <code>FutureTask.get()</code> 捕获抛出的异常。</p>
<h2 id="Executor-框架的使用示意图"><a href="#Executor-框架的使用示意图" class="headerlink" title="Executor 框架的使用示意图"></a><code>Executor</code> 框架的使用示意图</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727105429.png" srcset="/img/loading.gif" alt=""></p>
<ul>
<li><p>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</p>
</li>
<li><p>把创建完成的实现 <code>Runnable</code> / <code>Callable</code> 接口的对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit(Runnable task)</code>或 <code>ExecutorService.submit(Callable &lt;T&gt; task)</code>）。</p>
</li>
<li><p>如果执行 <code>ExecutorService.submit(...)</code>，<code>ExecutorService</code> 将返回一个实现 <code>Future</code> 接口的对象。由于 <code>FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</p>
</li>
<li><p>最后，主线程可以执行 <code>FutureTask.get()</code> 方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel(boolean mayInterruptIfRunning)</code>来取消此任务的执行。</p>
</li>
</ul>
<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a><code>ThreadPoolExecutor</code></h1><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : ThreadPoolTest.java 2020/07/27 Mon 3:29 PM likai</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolTest</span> </span>&#123;
    <span class="hljs-comment">// 核心线程数</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CORE_POOL_SIZE = <span class="hljs-number">5</span>;
    <span class="hljs-comment">// 最大线程数</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_POOL_SIZE = <span class="hljs-number">10</span>;
    <span class="hljs-comment">// 任务队列容量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> QUEUE_CAPACITY = <span class="hljs-number">100</span>;
    <span class="hljs-comment">// 等待时间</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> KEEP_ALIVE_TIME = <span class="hljs-number">1L</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 创建线程池</span>
        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(
                CORE_POOL_SIZE,
                MAX_POOL_SIZE,
                KEEP_ALIVE_TIME,
                TimeUnit.SECONDS,
                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),
                <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            <span class="hljs-comment">// 执行工作线程</span>
            Runnable worker = <span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-string">""</span> + i);
            executor.execute(worker);
            String info = String.format(<span class="hljs-string">"线程池中线程数目：%s，队列中等待执行的任务数目：%s，已执行完的任务数目：%s"</span>,
                    executor.getPoolSize(),
                    executor.getQueue().size(),
                    executor.getCompletedTaskCount());
            System.out.println(info);
        &#125;
        <span class="hljs-comment">// 终止线程池</span>
        executor.shutdown();
        <span class="hljs-keyword">while</span> (!executor.isTerminated()) &#123;

        &#125;
        System.out.println(<span class="hljs-string">"Finish all threads"</span>);
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 工作线程类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;
    <span class="hljs-keyword">private</span> String cmd;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRunnable</span><span class="hljs-params">(String cmd)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.cmd = cmd;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" Start time = "</span> + <span class="hljs-keyword">new</span> Date());
        processCmd();
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" End time = "</span> + <span class="hljs-keyword">new</span> Date());
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCmd</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">2000</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"MyRunnable&#123;"</span> +
                <span class="hljs-string">"cmd='"</span> + cmd + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">'&#125;'</span>;
    &#125;
&#125;</code></pre>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>ThreadPoolExecutor</code> 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, // 线程池的核心线程数量</span></span>
<span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize, // 线程池的最大线程数</span></span>
<span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime, // 当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span>
<span class="hljs-function"><span class="hljs-params">                          TimeUnit unit, // 时间单位</span></span>
<span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列，用来储存等待执行任务的队列</span></span>
<span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory, // 线程工厂，用来创建线程，一般默认即可</span></span>
<span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler // 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span>
<span class="hljs-function"><span class="hljs-params">                           )</span> </span>&#123;
    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||
        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();
    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;
    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;
    <span class="hljs-keyword">this</span>.workQueue = workQueue;
    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);
    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;
    <span class="hljs-keyword">this</span>.handler = handler;
&#125;</code></pre>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727145107.png" srcset="/img/loading.gif" alt=""></p>
<p>参数说明：</p>
<ol>
<li><p><code>corePoolSize</code> - <strong>核心线程数量</strong>。当有新任务通过 <code>execute</code> 方法提交时 ，线程池会执行以下判断：</p>
<ul>
<li>如果运行的线程数少于 <code>corePoolSize</code>，则创建新线程来处理任务，即使线程池中的其他线程是空闲的。</li>
<li>如果线程池中的线程数量大于等于 <code>corePoolSize</code> 且小于 <code>maximumPoolSize</code>，则只有当 <code>workQueue</code> 满时才创建新的线程去处理任务，否则将任务存储在队列里；</li>
<li>如果设置的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 相同，则创建的线程池的大小是固定的。这时如果有新任务提交，若 <code>workQueue</code> 未满，则将请求放入 <code>workQueue</code> 中，等待有空闲的线程去从 <code>workQueue</code> 中取任务并处理；</li>
<li>如果运行的线程数量大于等于 <code>maximumPoolSize</code>，这时如果 <code>workQueue</code> 已经满了，则使用 <code>handler</code> 所指定的策略来处理任务；</li>
<li>所以，任务提交时，判断的顺序为 <code>corePoolSize</code> =&gt; <code>workQueue</code> =&gt; <code>maximumPoolSize</code>。</li>
</ul>
</li>
<li><p><code>maximumPoolSize</code> - <strong>最大线程数量</strong>。</p>
<ul>
<li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</li>
<li>值得注意的是：如果使用了无界的任务队列这个参数就没什么效果。</li>
</ul>
</li>
<li><p><code>keepAliveTime</code> - <strong>线程保持活动的时间</strong>。</p>
<ul>
<li>当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>。</li>
<li>所以，如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li>
</ul>
</li>
<li><p><code>unit</code> - <strong><code>keepAliveTime</code> 的时间单位</strong>。<br>有 7 种取值。可选的单位有天（<code>DAYS</code>），小时（<code>HOURS</code>），分钟（<code>MINUTES</code>），毫秒(<code>MILLISECONDS</code>)，微秒(<code>MICROSECONDS</code>, 千分之一毫秒)和毫微秒(<code>NANOSECONDS</code>, 千分之一微秒)。</p>
</li>
<li><p><code>workQueue</code> - <strong>等待执行的任务队列</strong>。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。</p>
<ul>
<li><p><code>ArrayBlockingQueue</code> - <strong>有界阻塞队列</strong>。</p>
<ul>
<li>此队列是基于<strong>数组</strong>的先进先出队列（<code>FIFO</code>）。</li>
<li>创建时必须指定大小。</li>
</ul>
</li>
<li><p><code>LinkedBlockingQueue</code> - <strong>无界阻塞队列</strong>。</p>
<ul>
<li>此队列是基于<strong>链表</strong>的先进先出队列（<code>FIFO</code>）。</li>
<li>如果创建时没有指定此队列大小，则默认为 <code>Integer.MAX_VALUE</code>。</li>
<li>吞吐量通常要高于 <code>ArrayBlockingQueue</code>。</li>
<li>使用 <code>LinkedBlockingQueue</code> 意味着： <code>maximumPoolSize</code> 将不起作用，线程池能创建的最大线程数为 <code>corePoolSize</code>，因为任务等待队列是无界队列。</li>
<li><code>Executors.newFixedThreadPool</code> 使用了这个队列。</li>
</ul>
</li>
<li><p><code>SynchronousQueue</code> - <strong>不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</strong></p>
<ul>
<li>每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。</li>
<li>吞吐量通常要高于 <code>LinkedBlockingQueue</code>。</li>
<li><code>Executors.newCachedThreadPool</code> 使用了这个队列。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>threadFactory</code> - <strong>线程工厂</strong>。可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</p>
</li>
<li><p><code>handler</code> - <strong>饱和策略</strong>。它是 <code>RejectedExecutionHandler</code> 类型的变量。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。线程池支持以下策略：</p>
<ul>
<li><p><code>AbortPolicy</code> - 抛出  <code>RejectedExecutionException</code> 来拒绝新任务的处理。这也是默认策略。</p>
</li>
<li><p><code>DiscardPolicy</code> - 丢弃任务，但不抛出异常。</p>
</li>
<li><p><code>DiscardOldestPolicy</code> - 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。</p>
</li>
<li><p><code>CallerRunsPolicy</code> - 只用调用者所在的线程来运行任务。</p>
</li>
<li><p>如果以上策略都不能满足需要，也可以通过实现           <code>RejectedExecutionHandler</code> 接口来定制处理策略。如记录日志或持久化不能处理的任务。</p>
</li>
</ul>
</li>
</ol>
<p>工作流程如下图：<br><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727145919.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute 方法"></a><code>execute</code> 方法</h2><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</p>
<p>提交任务可以使用 <code>execute</code> 方法，它是 <code>ThreadPoolExecutor</code> 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p>
<p><code>execute</code> 方法工作流程如下：<br><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727162758.png" srcset="/img/loading.gif" alt=""></p>
<pre><code class="hljs java"><span class="hljs-comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));

 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;
     <span class="hljs-keyword">return</span> c &amp; CAPACITY;
 &#125;
 <span class="hljs-comment">// 任务队列</span>
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;

 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;
     <span class="hljs-comment">// 如果任务为 null，则抛出异常。</span>
     <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)
         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
     <span class="hljs-comment">// ctl 中保存的线程池当前的一些状态信息</span>
     <span class="hljs-keyword">int</span> c = ctl.get();

     <span class="hljs-comment">//  下面会涉及到 3 步 操作</span>
     <span class="hljs-comment">// 1.首先判断当前线程池中之行的任务数量是否小于  corePoolSize</span>
     <span class="hljs-comment">// 如果小于的话，则创建新的核心线程并且执行传入的任务</span>
     <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;
         <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))
             <span class="hljs-comment">// 如果创建新的核心线程成功则直接返回</span>
             <span class="hljs-keyword">return</span>;
         <span class="hljs-comment">// 这里说明创建核心线程失败，需要更新 ctl 的临时变量 c</span>
         c = ctl.get();
     &#125;
     <span class="hljs-comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span>
     <span class="hljs-comment">// 判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务</span>
     <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;
         <span class="hljs-keyword">int</span> recheck = ctl.get();
         <span class="hljs-comment">// 二次检查线程池状态。如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span>
         <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))
             <span class="hljs-comment">// 调用拒绝策略处理任务 - 返回</span>
             reject(command);
             <span class="hljs-comment">// 如果当前线程池为空就新创建一个线程并执行。</span>
         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)
             addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);
     &#125;
     <span class="hljs-comment">// 3. 如果任务不能加入任务队列，则会尝试创建非核心线程传入任务执行</span>
     <span class="hljs-comment">// 创建非核心线程失败，此时需要拒绝执行任务</span>
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))
         <span class="hljs-comment">// 调用拒绝策略处理任务 - 返回</span>
         reject(command);
 &#125;</code></pre>

<p>关于二次检查线程池运行状态：</p>
<blockquote>
<p>如果一个任务成功加入任务队列，我们依然需要二次检查是否需要添加一个工作线程（因为所有存活的工作线程有可能在最后一次检查之后已经终结）或者执行当前方法的时候线程池是否已经终结了。所以我们需要二次检查线程池的状态，必须时把任务从任务队列中移除或者在没有可用的工作线程的前提下新建一个工作线程。</p>
</blockquote>
<h2 id="其他重要方法"><a href="#其他重要方法" class="headerlink" title="其他重要方法"></a>其他重要方法</h2><ul>
<li><code>submit</code> 类似于 <code>execute</code>，但是针对的是有返回值的线程。<code>submit</code> 方法是在 <code>ExecutorService</code> 中声明的方法，在 <code>AbstractExecutorService</code> 就已经有了具体的实现。<code>ThreadPoolExecutor</code> 直接复用 <code>AbstractExecutorService</code> 的 <code>submit</code> 方法。</li>
<li><code>shutdown</code> - 不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</li>
<li><code>shutdownNow</code> - 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</li>
<li><code>isShutdown</code> - 调用了 <code>shutdown</code> 或 <code>shutdownNow</code> 方法后，<code>isShutdown</code> 方法就会返回 <code>true</code>。</li>
<li><code>isTerminaed</code> - 当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 <code>isTerminaed</code> 方法会返回 <code>true</code>。</li>
</ul>
<h1 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a><code>ScheduledThreadPoolExecutor</code></h1><p><code>ScheduledThreadPoolExecutor</code> 主要用来在给定的延迟后运行任务，或者定期执行任务。 这个在实际项目中基本不会被用到，因为有其他方案选择比如 <code>quartz</code>。</p>
<h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p><code>ScheduledThreadPoolExecutor</code> 使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</p>
<h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727200044.png" srcset="/img/loading.gif" alt=""></p>
<p><code>ScheduledThreadPoolExecutor</code> 的执行主要分为两大部分：</p>
<ul>
<li><p>当调用 <code>ScheduledThreadPoolExecutor</code> 的 <code>scheduleAtFixedRate()</code> 方法或者 <code>scheduleWirhFixedDelay()</code> 方法时，会向 <code>ScheduledThreadPoolExecutor</code> 的 <code>DelayQueue</code> 添加一个实现了 <code>RunnableScheduledFuture</code> 接口的 <code>ScheduledFutureTask</code> 。</p>
</li>
<li><p>线程池中的线程从 <code>DelayQueue</code> 中获取 <code>ScheduledFutureTask</code>，然后执行任务。</p>
</li>
</ul>
<p><code>ScheduledThreadPoolExecutor</code> 为了实现周期性的执行任务，对 <code>ThreadPoolExecutor</code> 做了如下修改：</p>
<ul>
<li><p>使用 <code>DelayQueue</code> 作为任务队列；</p>
</li>
<li><p>获取任务的方不同</p>
</li>
<li><p>执行周期任务后，增加了额外的处理</p>
</li>
</ul>
<h2 id="执行周期任务的步骤"><a href="#执行周期任务的步骤" class="headerlink" title="执行周期任务的步骤"></a>执行周期任务的步骤</h2><p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727200325.png" srcset="/img/loading.gif" alt=""></p>
<ul>
<li><p>线程 1 从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask</code>（<code>DelayQueue.take()</code>）。到期任务是指 <code>ScheduledFutureTask</code> 的 <code>time</code> 大于等于当前系统的时间；</p>
</li>
<li><p>线程 1 执行这个 <code>ScheduledFutureTask</code>；</p>
</li>
<li><p>线程 1 修改 <code>ScheduledFutureTask</code> 的 <code>time</code> 变量为下次将要被执行的时间；</p>
</li>
<li><p>线程 1 把这个修改 <code>time</code> 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中 (<code>DelayQueue.add()</code>)。</p>
</li>
</ul>
<h1 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h1><p><code>JDK</code> 的 <code>Executors</code> 类中提供了几种具有代表性的线程池，这些线程池 都是基于 <code>ThreadPoolExecutor</code> 的定制化实现。</p>
<blockquote>
<p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
</blockquote>
<h2 id="创建线程池方式"><a href="#创建线程池方式" class="headerlink" title="创建线程池方式"></a>创建线程池方式</h2><ol>
<li>通过 <code>ThreadPoolExecutor</code> 构造函数实现（推荐）</li>
<li>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现 我们可以创建三种类型的 <code>ThreadPoolExecutor</code><ul>
<li><code>FixedThreadPool</code></li>
<li><code>SingleThreadExecutor</code></li>
<li><code>CachedThreadPool</code></li>
</ul>
</li>
</ol>
<p><code>Executors</code> 返回线程池对象的弊端如下：</p>
<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 <code>OOM</code>。</li>
<li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 <code>OOM</code>。</li>
</ul>
<h2 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a><code>FixedThreadPool</code></h2><p>创建一个<strong>固定大小</strong>的线程池。</p>
<p>每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中。</p>
<p><code>FixedThreadPool</code> 是一个典型且优秀的线程池，它具有线程池<strong>提高程序效率</strong>和<strong>节省创建线程时所耗的开销</strong>的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
<pre><code class="hljs java"> <span class="hljs-comment">/**</span>
<span class="hljs-comment">  * 创建一个可重用固定数量线程的线程池</span>
<span class="hljs-comment">  */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(
        nThreads,
        nThreads,
        <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,
        <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),
        threadFactory);
    &#125;</code></pre>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727191728.png" srcset="/img/loading.gif" alt=""></p>
<p>上图说明：</p>
<ul>
<li><p>如果当前运行的线程数小于 <code>corePoolSize</code>， 如果再来新任务的话，就创建新的线程来执行任务；</p>
</li>
<li><p>当前运行的线程数等于 <code>corePoolSize</code> 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</p>
</li>
<li><p>线程池中的线程执行完 手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</p>
</li>
</ul>
<p><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 <code>Intger.MAX_VALUE</code>）作为线程池的工作队列会对线程池带来如下影响 ：</p>
<ul>
<li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code>corePoolSize</code></li>
<li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况</li>
<li>使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数</li>
<li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code> 或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 <code>OOM</code></li>
</ul>
<h2 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a><code>SingleThreadExecutor</code></h2><p>创建一个<strong>单线程</strong>的线程池。</p>
<p>只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序(<code>FIFO</code>, <code>LIFO</code>, 优先级)执行。 如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它 。</p>
<p>单工作线程最大的特点是：<strong>可保证顺序地执行各个任务</strong>。</p>
<pre><code class="hljs java">  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * 返回只有一个线程的线程池</span>
<span class="hljs-comment">   */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService
            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,
                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,
                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),
                                    threadFactory));
    &#125;</code></pre>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727192058.png" srcset="/img/loading.gif" alt=""></p>
<p>上图说明：</p>
<ul>
<li><p>如果当前运行的线程数少于 <code>corePoolSize</code>，则创建一个新的线程执行任务；</p>
</li>
<li><p>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></p>
</li>
<li><p>线程执行完当前的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</p>
</li>
</ul>
<p>影响： <code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 <code>Intger.MAX_VALUE</code>）。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同，也可能导致 <code>OOM</code>。</p>
<h2 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a><code>CachedThreadPool</code></h2><p>创建一个<strong>可缓存</strong>的线程池。</p>
<ul>
<li><p>如果线程池大小超过处理任务所需要的线程数，就会回收部分空闲的线程；</p>
</li>
<li><p>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p>
</li>
<li><p>此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 <code>JVM</code>）能够创建的最大线程大小。因此，使用 <code>CachedThreadPool</code> 时，一定要注意<strong>控制任务的数量</strong>，否则，由于大量线程同时运行，很有会造成系统瘫痪。</p>
</li>
</ul>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,
                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,
                                      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),
                                      threadFactory);
    &#125;</code></pre>

<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200727192747.png" srcset="/img/loading.gif" alt=""></p>
<p>上图说明：</p>
<ul>
<li><p>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 <code>offer</code> 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code> 方法执行完成，否则执行下面的步骤 2；</p>
</li>
<li><p>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，<code>execute</code> 方法执行完成；</p>
</li>
</ul>
<p>影响：<code>CachedThreadPool</code> 允许创建的线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致 <code>OOM</code>。</p>
<h1 id="线程池大小确定"><a href="#线程池大小确定" class="headerlink" title="线程池大小确定"></a>线程池大小确定</h1><blockquote>
<p>上下文切换：</p>
<p>多线程编程中一般线程的个数都大于 <code>CPU</code> 核心的个数，而一个 <code>CPU</code> 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，<code>CPU</code> 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 <code>CPU</code> 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<p>上下文切换通常是<strong>计算密集型</strong>的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 <code>CPU</code> 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p><code>Linux</code> 相比与其他操作系统（包括其他类 <code>Unix</code> 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
</blockquote>
<p>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 <code>OOM</code>。这样很明显是有问题的！ <code>CPU</code> 根本没有得到充分利用。</p>
<p>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 <code>CPU</code> 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</p>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><p><code>CPU</code> 密集型任务(<code>N + 1</code>)：这种任务消耗的主要是 <code>CPU</code> 资源，可以将线程数设置为 <code>N（CPU 核心数）+ 1</code>，比 <code>CPU</code> 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，<code>CPU</code> 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 <code>CPU</code> 的空闲时间。</p>
</li>
<li><p><code>I/O</code> 密集型任务(<code>2N</code>)：这种任务应用起来，系统会用大部分的时间来处理 <code>I/O</code> 交互，而线程在处理 <code>I/O</code> 的时间段内不会占用 <code>CPU</code> 来处理，这时就可以将 <code>CPU</code> 交出给其它线程使用。因此在 <code>I/O</code> 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 <code>2N</code>。</p>
</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/28/concurrent-utils/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">并发-工具类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/24/concurrent-container/">
                        <span class="hidden-mobile">并发-容器</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <!-- <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> -->
      Crafted with
      <i class="iconfont icon-love" style="color: #f30;"></i>
      by <a href="https://github.com/likailee" target="_blank" rel="noopener">Likai Lee</a>
      | &copy; 2017 - 2020
      <!-- <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a> -->
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?66c61a5fd59052d1b39d89c246846ae5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
