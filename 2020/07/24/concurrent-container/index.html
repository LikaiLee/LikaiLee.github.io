<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Likai Lee">
  <meta name="keywords" content="">
  <title>并发-容器 - Likai Lee</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Likai Lee</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                并发-容器
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-24 15:52">
      2020年7月24日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      44
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 <code>Java</code> 中，同步容器主要包括 <code>2</code> 类：</p>
<ul>
<li><p><code>Vector</code>, <code>Stack</code>, <code>HashTable</code></p>
<ul>
<li><code>Vector</code> - <code>Vector</code> 实现了 <code>List</code> 接口。<code>Vector</code> 实际上就是一个数组，和 <code>ArrayList</code> 类似。但是 <code>Vector</code> 中的方法都是 <code>synchronized</code> 方法，即进行了同步措施。</li>
<li><code>Stack</code> - <code>Stack</code> 继承于 <code>Vector</code> 类，也是一个同步容器，它的方法也用 <code>synchronized</code> 进行了同步。</li>
<li><code>Hashtable</code>- <code>Hashtable</code> 实现了 <code>Map</code> 接口，但是 <code>Hashtable</code> 用 <code>synchronized</code> 进行了同步。</li>
</ul>
</li>
<li><p><code>Collections</code> 类中提供的静态工厂方法创建的类（由 <code>Collections.synchronizedXXX</code> 等方法）。</p>
</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>同步容器的同步原理就是在方法上用 <code>synchronized</code> 修饰。</p>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p><code>synchronized</code> 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 <code>synchronized</code> 的容器性能要差。</p>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>同步容器真的绝对安全吗？</p>
<p>其实也未必。在做复合操作（非原子操作）时，仍然需要加锁来保护。常见复合操作如下：</p>
<ul>
<li><p>迭代：反复访问元素，直到遍历完全部元素；</p>
</li>
<li><p>跳转：根据指定顺序寻找当前元素的下一个（下 <code>n</code> 个）元素；</p>
</li>
<li><p>条件运算：例如若没有则添加等；</p>
</li>
</ul>
<p>❌ 不安全的示例</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> likailee.llk</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@version</span> : ConcurrentContainerTest.java 2020/07/24 Fri 1:56 PM likai</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentContainerTest</span> </span>&#123;
    <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; vector = <span class="hljs-keyword">new</span> Vector&lt;&gt;();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            vector.clear();

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                vector.add(i);
            &#125;
            Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;
                    vector.remove(i);
                &#125;
            &#125;);

            Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;
                    vector.get(i);
                &#125;
            &#125;);

            t1.start();
            t2.start();

            <span class="hljs-keyword">while</span> (Thread.activeCount() &gt; <span class="hljs-number">10</span>) &#123;
                System.out.println(<span class="hljs-string">"同时存在十个以上线程， 退出"</span>);
                <span class="hljs-keyword">return</span>;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>以上程序执行时可能会出现数组越界错误。</p>
<p>这是因为，对于 <code>Vector</code>，虽然能保证每一个时刻只能有一个线程访问它，但是不排除这种可能：<br>当某个线程进行读操作时，其他线程可能已经删除了该线程所要读的那个元素。</p>
<p>因此为了保证线程安全，必须在方法调用端做额外的同步措施，如下面所示：</p>
<pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (vector) &#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;
        vector.remove(i);
    &#125;
&#125;

<span class="hljs-keyword">synchronized</span> (vector) &#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;
        vector.remove(i);
    &#125;
&#125;</code></pre>

<h1 id="并发容器简介"><a href="#并发容器简介" class="headerlink" title="并发容器简介"></a>并发容器简介</h1><blockquote>
<p>同步容器将所有对容器状态的访问都串行化，以保证线程安全性，这种策略会严重降低并发性。</p>
<p>Java 1.5 后提供了多种并发容器，使用并发容器来替代同步容器，可以极大地提高伸缩性并降低风险。</p>
</blockquote>
<p>J.U.C 包中提供了几个非常有用的并发容器作为线程安全的容器：</p>
<table>
<thead>
<tr>
<th align="center">并发容器</th>
<th align="center">对应的普通容器</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ConcurrentHashMap</code></td>
<td align="center"><code>HashMap</code></td>
<td align="center"><code>Java 1.8</code> 之前采用<strong>分段锁机制</strong>细化锁粒度，降低阻塞，从而提高并发性；<code>Java 1.8</code> 之后基于 <code>CAS</code> 实现。</td>
</tr>
<tr>
<td align="center"><code>ConcurrentSkipListMap</code></td>
<td align="center"><code>SortedMap</code></td>
<td align="center">基于跳表实现的</td>
</tr>
<tr>
<td align="center"><code>CopyOnWriteArrayList</code></td>
<td align="center"><code>ArrayList</code></td>
<td align="center">写时复制</td>
</tr>
<tr>
<td align="center"><code>CopyOnWriteArraySet</code></td>
<td align="center"><code>Set</code></td>
<td align="center">基于 <code>CopyOnWriteArrayList</code> 实现。</td>
</tr>
<tr>
<td align="center"><code>ConcurrentSkipListSet</code></td>
<td align="center"><code>SortedSet</code></td>
<td align="center">基于 <code>ConcurrentSkipListMap</code> 实现。</td>
</tr>
<tr>
<td align="center"><code>ConcurrentLinkedQueue</code></td>
<td align="center"><code>Queue</code></td>
<td align="center">线程安全的无界队列。底层采用单链表。支持 <code>FIFO</code>。</td>
</tr>
<tr>
<td align="center"><code>ConcurrentLinkedDeque</code></td>
<td align="center"><code>Deque</code></td>
<td align="center">线程安全的无界双端队列。底层采用双向链表。支持 <code>FIFO</code> 和 <code>FILO</code>。</td>
</tr>
<tr>
<td align="center"><code>ArrayBlockingQueue</code></td>
<td align="center"><code>Queue</code></td>
<td align="center">数组实现的阻塞队列。</td>
</tr>
<tr>
<td align="center"><code>LinkedBlockingQueue</code></td>
<td align="center"><code>Queue</code></td>
<td align="center">链表实现的阻塞队列。</td>
</tr>
<tr>
<td align="center"><code>LinkedBlockingDeque</code></td>
<td align="center"><code>Deque</code></td>
<td align="center">双向链表实现的双端阻塞队列。</td>
</tr>
</tbody></table>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h1><blockquote>
<p><code>ConcurrentHashMap</code> 是线程安全的 <code>HashMap</code> ，用于替代 <code>Hashtable</code>。</p>
</blockquote>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><code>ConcurrentHashMap</code> 实现了 <code>ConcurrentMap</code> 接口，而 <code>ConcurrentMap</code> 接口扩展了 <code>Map</code> 接口。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span>
<span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
&#125;</code></pre>

<p><code>ConcurrentHashMap</code> 的实现包含了 <code>HashMap</code> 所有的基本特性，如：数据结构、读写策略等。</p>
<p><code>ConcurrentHashMap</code> 没有实现对 <code>Map</code> 加锁以提供独占访问。因此无法通过在客户端加锁的方式来创建新的原子操作。但是，一些常见的复合操作，如：“若没有则添加”、“若相等则移除”、“若相等则替换”，都已经实现为原子操作，并且是围绕 <code>ConcurrentMap</code> 的扩展接口而实现。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;

    <span class="hljs-comment">// 仅当 K 没有相应的映射值才插入</span>
    <span class="hljs-function">V <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(K key, V value)</span></span>;

    <span class="hljs-comment">// 仅当 K 被映射到 V 时才移除</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object key, Object value)</span></span>;

    <span class="hljs-comment">// 仅当 K 被映射到 oldValue 时才替换为 newValue</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">replace</span><span class="hljs-params">(K key, V oldValue, V newValue)</span></span>;

    <span class="hljs-comment">// 仅当 K 被映射到某个值时才替换为 newValue</span>
    <span class="hljs-function">V <span class="hljs-title">replace</span><span class="hljs-params">(K key, V value)</span></span>;
&#125;</code></pre>
<p>不同于 <code>Hashtable</code>，<code>ConcurrentHashMap</code> 提供的迭代器不会抛出 <code>ConcurrentModificationException</code>，因此不需要在迭代过程中对容器加锁。</p>
<blockquote>
<p>🔔 注意：一些需要对整个 <code>Map</code> 进行计算的方法，如 <code>size</code> 和 <code>isEmpty</code> ，由于返回的结果在计算时可能已经过期，所以并非实时的精确值。这是一种策略上的权衡，在并发环境下，这类方法由于总在不断变化，所以获取其实时精确值的意义不大。<code>ConcurrentHashMap</code> 弱化这类方法，以换取更重要操作（如：<code>get</code>、<code>put</code>、<code>containesKey</code>、<code>remove</code> 等）的性能。</p>
</blockquote>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>同 <code>HashMap</code></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><code>ConcurrentHashMap</code> 在 <code>Java 1.8</code> 之前和 <code>Java 1.8</code> 之后的实现有很大差异：</p>
<ul>
<li><code>Java 1.8</code> 之前采用<strong>分段锁机制</strong>细化锁粒度，降低阻塞，从而提高并发性。</li>
<li><code>Java 1.8</code> 之后基于 <code>CAS</code> 实现。</li>
</ul>
<h3 id="Java-1-7-的实现"><a href="#Java-1-7-的实现" class="headerlink" title="Java 1.7 的实现"></a>Java 1.7 的实现</h3><p>每一个 <code>segment</code> 都是一个 <code>HashEntry&lt;K,V&gt;[] table</code>， <code>table</code> 中的每一个元素本质上都是一个 <code>HashEntry</code> 的单向队列。比如 <code>table[3]</code> 为首节点，<code>table[3]-&gt;next</code> 为节点 <code>1</code>，之后为节点 <code>2</code>，依次类推。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;</span>
<span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;

    <span class="hljs-comment">// 将整个 hashmap 分成几个小的 map，每个 segment 都是一个锁；与 hashtable 相比，这么设计的目的是对于 put, remove 等操作，可以减少并发冲突，对</span>
    <span class="hljs-comment">// 不属于同一个片段的节点可以并发操作，大大提高了性能</span>
    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;

    <span class="hljs-comment">// 本质上 Segment 类就是一个小的 hashmap，里面 table 数组存储了各个节点的数据，继承了 ReentrantLock, 可以作为互斥锁使用</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;
        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;
        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;
    &#125;

    <span class="hljs-comment">// 基本节点，存储 Key, Value 值</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;
        <span class="hljs-keyword">final</span> K key;
        <span class="hljs-keyword">volatile</span> V value;
        <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;
    &#125;
&#125;</code></pre>

<h3 id="Java-1-8-的实现"><a href="#Java-1-8-的实现" class="headerlink" title="Java 1.8 的实现"></a>Java 1.8 的实现</h3><p><code>JDK 8</code> 中主要做了 2 方面的改进</p>
<ul>
<li><p>取消 <code>segments</code> 字段，直接采用 <code>transient volatile HashEntry&lt;K,V&gt;[] table</code> 保存数据，采用 <code>table</code> 数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</p>
</li>
<li><p>将原先 <strong>数组＋单链表</strong> 的数据结构，变更为 <strong>数组＋单链表＋红黑树</strong> 的结构。对于 <code>hash</code> 表来说，最核心的能力在于将 <code>key hash</code> 之后能均匀的分布在数组中。如果 <code>hash</code> 之后散列的很均匀，那么 <code>table</code> 数组中的每个队列长度主要为 <code>0</code> 或者 <code>1</code>。但实际情况并非总是如此理想，虽然 <code>ConcurrentHashMap</code> 类默认的加载因子为 <code>0.75</code>，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为 <code>O(n)</code>；因此，对于个数超过 <code>8</code>(默认值)的列表，<code>JDK 1.8</code> 中采用了红黑树的结构，那么查询的时间复杂度可以降低到 <code>O(logN)</code>，可以改进性能。</p>
</li>
</ul>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());
    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;
        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;
        <span class="hljs-comment">// 如果 table 为空，初始化；否则，根据 hash 值计算得到数组索引i，如果 tab[i] 为空，直接新建节点 Node 即可。注：tab[i] 实质为链表或者红黑树的首节点。</span>
        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)
            tab = initTable();
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,
                         <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))
                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>
        &#125;
        <span class="hljs-comment">// 如果 tab[i] 不为空并且 hash 值为 MOVED，说明该链表正在进行 transfer 操作，返回扩容完成后的 table。</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        <span class="hljs-keyword">else</span> &#123;
            V oldVal = <span class="hljs-keyword">null</span>;
            <span class="hljs-comment">// 针对首个节点进行加锁操作，而不是 segment，进一步减少线程冲突</span>
            <span class="hljs-keyword">synchronized</span> (f) &#123;
                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;
                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;
                        binCount = <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;
                            K ek;
                            <span class="hljs-comment">// 如果在链表中找到值为 key 的节点 e，直接设置 e.val = value 即可。</span>
                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;
                                oldVal = e.val;
                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)
                                    e.val = value;
                                <span class="hljs-keyword">break</span>;
                            &#125;
                            <span class="hljs-comment">// 如果没有找到值为 key 的节点，直接新建 Node 并加入链表即可。</span>
                            Node&lt;K,V&gt; pred = e;
                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;
                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,
                                                          value, <span class="hljs-keyword">null</span>);
                                <span class="hljs-keyword">break</span>;
                            &#125;
                        &#125;
                    &#125;
                    <span class="hljs-comment">// 如果首节点为 TreeBin 类型，说明为红黑树结构，执行 utTreeVal 操作。</span>
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;
                        Node&lt;K,V&gt; p;
                        binCount = <span class="hljs-number">2</span>;
                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                       value)) != <span class="hljs-keyword">null</span>) &#123;
                            oldVal = p.val;
                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)
                                p.val = value;
                        &#125;
                    &#125;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// 如果节点数 &gt;＝8，那么转换链表结构为红黑树结构。</span>
                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)
                    <span class="hljs-keyword">return</span> oldVal;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">// 计数增加1，有可能触发 transfer 操作(扩容)。</span>
    addCount(<span class="hljs-number">1L</span>, binCount);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre>

<h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><code>CopyOnWriteArrayList</code></h1><p>每个 <code>CopyOnWriteArrayList</code> 对象里有一个 <code>array</code> 数组用来存放具体元素。<code>ReentrantLock</code> 独占锁用来保证同时只有一个线程对 <code>array</code> 进行修改。<br><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200724151232.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li><p>好处：<strong>任何的读操作都不用加锁</strong>，而且保证读取到的是读那一刻 <code>List</code> 完整的快照数据。由于读操作无法感知最新正在变化的数据，所以 <code>CopyOnWriteArrayList</code> 是<strong>弱一致性</strong>的。</p>
</li>
<li><p>写时复制技术因为每次修改都需要完整拷贝一次底层数组，所以有额外的性能开销，但是特别适用于<strong>读多写少</strong>的数据访问场景。</p>
</li>
</ul>
<h2 id="弱一致性问题"><a href="#弱一致性问题" class="headerlink" title="弱一致性问题"></a>弱一致性问题</h2><p>线程1在执行完步骤 <code>A</code> 后，执行步骤 <code>B</code> 前，线程2进行了 <code>remove</code> 操作。<br>虽然线程2已经删除了 <code>index</code> 处的元素，但由于 <code>array</code>指向的数组引用计数为 1 而不是 0，仍会返回 <code>index</code> 处的元素。</p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>先将原容器 copy 一份，然后在新副本上执行写操作，之后再切换引用。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;
    <span class="hljs-comment">// 1.获取独占锁</span>
    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 2.获取 array 数组</span>
        Object[] elements = getArray();
        <span class="hljs-keyword">int</span> len = elements.length;
        <span class="hljs-comment">// 3.复制 array 到新数组</span>
        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);
        <span class="hljs-comment">// 4.添加元素到新数组</span>
        newElements[len] = e;
        <span class="hljs-comment">// 5.用新数组替换原数组</span>
        setArray(newElements);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">// 6.释放锁</span>
        lock.unlock();
    &#125;
&#125;</code></pre>

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>将除要删除元素之外的其他元素拷贝到新副本中，然后切换引用，将原容器引用指向新副本。同属写操作，需要加锁。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
    <span class="hljs-comment">// 获取独占锁</span>
    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        Object[] elements = getArray();
        <span class="hljs-keyword">int</span> len = elements.length;
        E oldValue = get(elements, index);
        <span class="hljs-comment">// 需要移动的元素个数</span>
        <span class="hljs-keyword">int</span> numMoved = len - index - <span class="hljs-number">1</span>;
        <span class="hljs-comment">// 若删除的是最后一个元素</span>
        <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)
           <span class="hljs-comment">// 拷贝前len-1个数据到新副本上，再切换引用</span>
           setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));
        <span class="hljs-keyword">else</span> &#123;
            Object[] newElements = <span class="hljs-keyword">new</span> Object[len - <span class="hljs-number">1</span>];
            <span class="hljs-comment">// 分两块复制到新数组</span>
            System.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);
            System.arraycopy(elements, index + <span class="hljs-number">1</span>, newElements, index,
                             numMoved);
            <span class="hljs-comment">// 设置新数组</span>
            setArray(newElements);
        &#125;
        <span class="hljs-keyword">return</span> oldValue;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">// 释放锁</span>
        lock.unlock();
    &#125;
&#125;</code></pre>

<h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p><code>E get(int index)</code><br>读操作是不用加锁的，性能很高。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
    <span class="hljs-keyword">return</span> get(getArray(), index);
&#125;
<span class="hljs-comment">// A.获取 array 数组</span>
<span class="hljs-keyword">final</span> Object[] getArray() &#123;
    <span class="hljs-keyword">return</span> array;
&#125;
<span class="hljs-comment">// B.通过下标访问指定位置的数组元素</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">get</span><span class="hljs-params">(Object[] a, <span class="hljs-keyword">int</span> index)</span> </span>&#123;
    <span class="hljs-keyword">return</span> (E) a[index];
&#125;</code></pre>

<h2 id="修改指定元素"><a href="#修改指定元素" class="headerlink" title="修改指定元素"></a>修改指定元素</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;
    <span class="hljs-comment">// 获取独占锁</span>
    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 获取 array 数组</span>
        Object[] elements = getArray();
        <span class="hljs-comment">// 找到原位置上的值</span>
        E oldValue = get(elements, index);

        <span class="hljs-keyword">if</span> (oldValue != element) &#123;
            <span class="hljs-keyword">int</span> len = elements.length;
            <span class="hljs-comment">// 复制 array 到新数组</span>
            Object[] newElements = Arrays.copyOf(elements, len);
            <span class="hljs-comment">// 设置 index 位置的元素</span>
            newElements[index] = element;
            <span class="hljs-comment">// 用新数组替换旧数组</span>
            setArray(newElements);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// Not quite a no-op; ensures volatile write semantics</span>
            setArray(elements);
        &#125;
        <span class="hljs-keyword">return</span> oldValue;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">// 释放锁</span>
        lock.unlock();
    &#125;
&#125;</code></pre>

<h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a><code>BlockingQueue</code></h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;&#125;</code></pre>
<p>在 <code>BlockingQueue</code> 中，如果获取队列元素但是队列为空时，会阻塞，等待队列中有元素再返回；如果添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p>
<p><code>BlockingQueue</code> 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：</p>
<p>抛出异常；</p>
<ul>
<li>返回特殊值（<code>null</code> 或 <code>true</code>/<code>false</code>，取决于具体的操作）；</li>
<li>阻塞等待此操作，直到这个操作成功；</li>
<li>阻塞等待此操作，直到成功或者超时指定时间。<br>总结如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Operation</th>
<th align="center">Throws exception</th>
<th align="center">Special value</th>
<th align="center">Blocks</th>
<th align="center">Times out</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Insert</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center">put(e)</td>
<td align="center">offer(e, time, unit)</td>
</tr>
<tr>
<td align="center">Remove</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">poll(time, unit)</td>
</tr>
<tr>
<td align="center">Examine</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">not applicable</td>
<td align="center">not applicable</td>
</tr>
</tbody></table>
<p><code>BlockingQueue</code> 的各个实现类都遵循了这些规则。</p>
<p><code>BlockingQueue</code> 不接受 <code>null</code> 值元素。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AE%B9%E5%99%A8/">容器</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/27/concurrent-threadpool/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">并发-线程池</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/21/concurrent-atomic/">
                        <span class="hidden-mobile">并发-原子类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <!-- <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> -->
      Crafted with
      <i class="iconfont icon-love" style="color: #f30;"></i>
      by <a href="https://github.com/likailee" target="_blank" rel="noopener">Likai Lee</a>
      | &copy; 2017 - 2020
      <!-- <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a> -->
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?66c61a5fd59052d1b39d89c246846ae5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
