<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Likai Lee">
  <meta name="keywords" content="">
  <title>操作系统 内存管理 - Likai Lee</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Likai Lee</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                操作系统 内存管理
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-09-24 17:10">
      2020年9月24日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      77
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年9月27日 晚上
                
              </p>
            
            <article class="markdown-body">
              <p>[TOC]<br />
<code>分层存储器体系(memory hierarchy)</code>：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200924163759.png" srcset="/img/loading.gif" alt="" /></p>
<p>位于顶层的存储器速度最快，但是相对容量最小，成本非常高。层级结构向下，其访问速度会变慢，但是容量会变大，相对造价也就越便宜。（所以个人感觉相对存储容量来说，访问速度是更重要的）</p>
<p>操作系统中管理内存层次结构的部分称为 <code>内存管理器(memory manager)</code>，它的主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。所有现代操作系统都提供内存管理。</p>
<h1 id="无存储器抽象"><a class="markdownIt-Anchor" href="#无存储器抽象"></a> 无存储器抽象</h1>
<p>最简单的存储器抽象是无存储器。早期大型计算机（20 世纪 60 年代之前），小型计算机（20 世纪 70 年代之前）和个人计算机（20 世纪 80 年代之前）都没有存储器抽象。每一个程序都直接访问物理内存。当一个程序执行如下命令：</p>
<pre><code class="hljs angelscript">MOV REGISTER1, <span class="hljs-number">1000</span></code></pre>
<p>计算机会把位置为 1000 的物理内存中的内容移到 <code>REGISTER1</code> 中。因此呈现给程序员的内存模型就是物理内存，内存地址从 0 开始到内存地址的最大值中，每个地址中都会包含一个 <code>8 位</code> 位数的内存单元。</p>
<p>所以这种情况下的计算机<strong>不可能会有两个应用程序同时在内存中</strong>。如果第一个程序向内存地址 2000 的这个位置写入了一个值，那么此值将会替换第二个程序 2000 位置上的值，所以，同时运行两个应用程序是行不通的，两个程序会立刻崩溃。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200924165101.png" srcset="/img/loading.gif" alt="" /></p>
<p>不过即使存储器模型就是物理内存，还是存在一些可变体的。下面展示了三种变体：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200924165747.png" srcset="/img/loading.gif" alt="" /></p>
<p>在上图 <code>a</code> 中，操作系统位于 <code>RAM(Random Access Memory)</code> 的底部，或像是图 <code>b</code> 一样位于 <code>ROM(Read-Only Memory)</code> 顶部；而在图 <code>c</code> 中，<strong>设备驱动程序</strong>位于顶端的 <code>ROM</code> 中，而操作系统位于底部的 <code>RAM</code> 中。</p>
<ul>
<li>图 a 的模型以前用在大型机和小型机上，但现在已经很少使用了；</li>
<li>图 b 中的模型一般用于掌上电脑或者是嵌入式系统中。</li>
<li>第三种模型就应用在早期个人计算机中了。ROM 系统中的一部分成为 <code>BIOS (Basic Input Output System)</code>。模型 a 和 c 的缺点是<strong>用户程序中的错误可能会破坏操作系统</strong>，可能会导致灾难性的后果。</li>
</ul>
<p>按照这种方式组织系统时，通常<strong>同一个时刻只能有一个进程正在运行</strong>。一旦用户键入了一个命令，操作系统就把需要的程序从磁盘复制到内存中并执行；当进程运行结束后，操作系统在用户终端显示提示符并等待新的命令。收到新的命令后，它把新的程序装入内存，覆盖前一个程序。</p>
<p>在没有存储器抽象的系统中实现并行性一种方式是使用多线程来编程。由于同一进程中的多线程内部共享同一内存映像，那么实现并行也就不是问题了。但是这种方式却并没有被广泛采纳，因为人们通常希望能够在同一时间内运行没有关联的程序，而这正是线程抽象所不能提供的。</p>
<h1 id="存储器抽象地址空间"><a class="markdownIt-Anchor" href="#存储器抽象地址空间"></a> 存储器抽象：地址空间</h1>
<p>把物理内存暴露给进程会有几个主要的缺点：</p>
<ul>
<li>
<p>第一个问题是，如果用户程序可以寻址内存的每个字节，它们就可以很容易的<strong>破坏操作系统</strong>，从而使系统停止运行。即使在只有一个用户进程运行的情况下，这个问题也存在。</p>
</li>
<li>
<p>第二点是，<strong>难以运行多个程序</strong>。在个人计算机上，一般会打开很多应用程序，这些进程在不同时刻会有一个进程正在运行，其他应用程序可以通过鼠标来唤醒。在系统中没有物理内存的情况下很难实现。</p>
</li>
</ul>
<h2 id="地址空间概念"><a class="markdownIt-Anchor" href="#地址空间概念"></a> 地址空间概念</h2>
<p><code>地址空间(the address space)</code> 创建了一种抽象内存供程序使用。<strong>地址空间是进程可以用来寻址内存的地址集。每个进程都有它自己的地址空间，独立于其他进程的地址空间，但是某些进程会希望可以共享地址空间。</strong></p>
<h3 id="基址寄存器和变址寄存器"><a class="markdownIt-Anchor" href="#基址寄存器和变址寄存器"></a> 基址寄存器和变址寄存器</h3>
<p>最简单的办法是使用 <code>动态重定位(dynamic relocation)</code> 技术，它就是通过一种简单的方式<strong>将每个进程的地址空间映射到物理内存的不同区域</strong>。<br />
经典办法是给每个 <code>CPU</code> 配置两个特殊硬件寄存器，通常叫做 <code>基址寄存器(basic register)</code> 和 <code>变址寄存器(limit register)</code>。当使用基址寄存器和变址寄存器时，程序会装载到内存中的连续位置并且在装载期间无需重定位。</p>
<ul>
<li>基址寄存器：存储数据内存的起始位置</li>
<li>变址寄存器：存储应用程序的长度。</li>
</ul>
<p>每当进程引用内存以获取指令或读取、写入数据时，<code>CPU</code> 都会自动将基址值添加到进程生成的地址中，然后再将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于变址寄存器中的值。如果程序提供的地址要超过变址寄存器的范围，那么会产生错误并中止访问。</p>
<p>执行 <code>JMP 28</code> 这条指令后，硬件会把它解释为 <code>JMP 16412</code>，所以程序能够跳到 <code>CMP</code> 指令，过程如下：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925132116.png" srcset="/img/loading.gif" alt="" /></p>
<p>使用基址寄存器和变址寄存器是给每个进程提供私有地址空间的一种非常好的方法，因为每个内存地址在送到内存之前，都会先加上基址寄存器的内容。在很多实际系统中，对基址寄存器和变址寄存器都会以一定的方式加以保护，使得只有操作系统可以修改它们。</p>
<p>缺点：在每次访问内存时，都会进行 <code>ADD</code> 和 <code>CMP</code> 运算。<code>CMP</code> 指令可以执行的很快，但是加法就会相对慢一些，除非使用特殊的加法电路，否则加法因进位传播时间而变慢。</p>
<h2 id="交换技术"><a class="markdownIt-Anchor" href="#交换技术"></a> 交换技术</h2>
<p>实际上，所有<strong>进程需要的 <code>RAM</code> 总容量要远远高于内存的容量</strong>。针对<strong>内存不足</strong>的问题，提出了两种处理方式：</p>
<ul>
<li><code>交换(swapping)</code> 技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。</li>
<li><code>虚拟内存(virtual memory)</code>，虚拟内存技术能够允许应用程序部分的运行在内存中。</li>
</ul>
<h3 id="交换过程"><a class="markdownIt-Anchor" href="#交换过程"></a> 交换过程</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925132623.png" srcset="/img/loading.gif" alt="" /></p>
<p>刚开始的时候，只有进程 A 在内存中，然后从创建进程 B 和进程 C 或者从磁盘中把它们换入内存，然后在图 d 中，A 被换出内存到磁盘中，最后 A 重新进来。因为图 g 中的进程 A 现在到了不同的位置，所以在装载过程中需要被重新定位，或者在交换程序时通过软件来执行；或者在程序执行期间通过硬件来重定位。基址寄存器和变址寄存器就适用于这种情况。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925132932.png" srcset="/img/loading.gif" alt="" /></p>
<p>交换在内存创建了多个 <code>空闲区(hole)</code>，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这项技术称为 <code>内存紧缩(memory compaction)</code>。但是这项技术通常不会使用，因为这项技术会消耗很多 <code>CPU</code> 时间。例如，在一个 16GB 内存的机器上每 8ns 复制 8 字节，它紧缩全部的内存大约要花费 16s。</p>
<h3 id="动态内存分配"><a class="markdownIt-Anchor" href="#动态内存分配"></a> 动态内存分配</h3>
<p>如果进程被创建后它的大小是固定的并且不再改变，那么分配策略就比较简单：操作系统会准确的按其需要的大小进行分配。</p>
<p>进程的 <code>data segment</code> 能够自动增长，会有三种处理方式：</p>
<ul>
<li>
<p>如果一个进程与空闲区相邻，那么可把该空闲区分配给进程以供其增大。</p>
</li>
<li>
<p>如果进程相邻的是另一个进程，就会有两种处理方式：要么把需要增长的进程移动到一个内存中空闲区足够大的区域，要么把一个或多个进程交换出去，已变成生成一个大的空闲区。</p>
</li>
<li>
<p>如果一个进程在内存中不能增长，而且磁盘上的交换区也满了，那么这个进程只有挂起一些空闲空间（或者可以结束该进程）。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925133850.png" srcset="/img/loading.gif" alt="" /></p>
<p>上面只针对单个或者一小部分需要增长的进程采用的方式，如果大部分进程都要在运行时增长，为了减少因内存区域不够而引起的进程交换和移动所产生的开销，一种可用的方法是，<strong>在换入或移动进程时为它分配一些额外的内存</strong>。然而，<strong>当进程被换出到磁盘上时，应该只交换实际上使用的内存</strong>，将额外的内存交换也是一种浪费，下面是一种为两个进程分配了增长空间的内存配置。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925134003.png" srcset="/img/loading.gif" alt="" /></p>
<p>如果进程有两个可增长的段，例如，供变量动态分配和释放的作为堆(全局变量)使用的一个 <code>数据段(data segment)</code>，以及存放局部变量与返回地址的一个 <code>堆栈段(stack segment)</code>，就如图 b 所示。在图中可以看到所示进程的<strong>堆栈段在进程所占内存的顶端向下增长</strong>，紧接着在程序段后的<strong>数据段向上增长</strong>。当增长预留的内存区域不够了，处理方式就如上面的流程图(<code>data segment</code> 自动增长的三种处理方式)一样了。</p>
<h2 id="空闲内存管理"><a class="markdownIt-Anchor" href="#空闲内存管理"></a> 空闲内存管理</h2>
<p>在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式</p>
<ul>
<li>位图(<code>bitmap</code>)</li>
<li>空闲列表(<code>free lists</code>)</li>
</ul>
<h3 id="1-使用位图的存储管理"><a class="markdownIt-Anchor" href="#1-使用位图的存储管理"></a> 1. 使用位图的存储管理</h3>
<p>使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925161159.png" srcset="/img/loading.gif" alt="" /></p>
<p>图 <code>a</code> 表示一段有 5 个进程和 3 个空闲区的内存，刻度为内存分配单元，阴影区表示空闲（在位图中用 0 表示）；图 <code>b</code> 表示对应的位图；图 <code>c</code> 表示用链表表示同样的信息。</p>
<p>分配单元的大小是一个重要的设计因素，<strong>分配单位越小，位图越大</strong>。然而，即使只有 <code>4</code> 字节的分配单元，<code>32</code> 位的内存也仅仅只需要位图中的 <code>1</code> 位。<code>32n</code> 位的内存需要 <code>n</code> 位的位图，所以 <code>1</code> 个位图只占用了 <code>1/32</code> 的内存。如果选择更大的内存单元，位图应该要更小。如果进程的大小不是分配单元的整数倍，那么在最后一个分配单元中会有大量的内存被浪费。</p>
<p>位图提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为<strong>位图的大小取决于内存和分配单元的大小</strong>。这种方法有一个问题是，当决定为把具有 <code>k</code> 个分配单元的进程放入内存时，<code>内容管理器(memory manager)</code> 必须搜索位图，在位图中找出能够运行 <code>k</code> 个连续 <code>0</code> 位的串。<strong>在位图中找出制定长度的连续 <code>0</code> 串是一个很耗时的操作，这是位图的缺点。</strong></p>
<h3 id="2-使用链表进行管理"><a class="markdownIt-Anchor" href="#2-使用链表进行管理"></a> 2. 使用链表进行管理</h3>
<p>另一种记录内存使用情况的方法是，维护一个记录<strong>已分配内存段和空闲内存段的链表</strong>，段会包含进程或者是两个进程的空闲区域。可用上面的 <code>图 c</code> 来表示内存的使用情况。链表中的每一项都可以代表一个 <code>空闲区(H)</code> 或者是 <code>进程(P)</code> 的起始标志，长度和下一个链表项的位置。</p>
<p>在这个例子中，<code>段链表(segment list)</code> 是按照地址排序的。这种方式的优点是，当进程终止或被交换时，更新列表很简单。一个终止进程通常有两个邻居（除了内存的顶部和底部外）。相邻的可能是进程也可能是空闲区，它们有四种组合方式。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925163044.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="3-顺序搜索的动态内存分配"><a class="markdownIt-Anchor" href="#3-顺序搜索的动态内存分配"></a> 3. 顺序搜索的动态内存分配</h3>
<p>当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。</p>
<h4 id="31-首次适配first-fit"><a class="markdownIt-Anchor" href="#31-首次适配first-fit"></a> 3.1 <code>首次适配(first fit)</code></h4>
<p><strong>内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止</strong>。除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。</p>
<h4 id="32-下次适配next-fit"><a class="markdownIt-Anchor" href="#32-下次适配next-fit"></a> 3.2 <code>下次适配(next fit)</code></h4>
<p>它和首次匹配的工作方式相同，只有一个不同之处那就是<strong>下次适配在每次找到合适的空闲区时就会记录当时的位置</strong>，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。</p>
<h4 id="33-最佳适配best-fit"><a class="markdownIt-Anchor" href="#33-最佳适配best-fit"></a> 3.3 <code>最佳适配(best fit)</code></h4>
<p>最佳适配会从头到尾寻找整个链表，找出能够容纳进程的<strong>最小空闲区</strong>。最佳适配算法会试图<strong>找出最接近实际需要的空闲区</strong>，以最好的匹配请求和可用空闲区，而不是先一次拆分一个以后可能会用到的大的空闲区。比如现在我们需要一个大小为 2 的块，那么首次匹配算法会把这个块分配在位置 5 的空闲区，而最佳适配算法会把该块分配在位置为 18 的空闲区，如下：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925162851.png" srcset="/img/loading.gif" alt="" /></p>
<p>最佳适配会遍历整个链表，所以最佳适配算法的性能要比首次匹配算法差。但最佳适配算法要比首次匹配和下次匹配算法浪费更多的内存，因为它会产生大量无用的小缓冲区，首次匹配算法生成的空闲区会更大一些。</p>
<h4 id="34-最差适配worst-fit"><a class="markdownIt-Anchor" href="#34-最差适配worst-fit"></a> 3.4 <code>最差适配(worst fit)</code></h4>
<p><strong>总是分配最大的内存区域</strong>，使新分配的空闲区比较大从而可以继续使用。仿真程序表明最差适配算法也不是一个好主意。</p>
<h4 id="35-快速适配quick-fit"><a class="markdownIt-Anchor" href="#35-快速适配quick-fit"></a> 3.5 <code>快速适配(quick fit)</code></h4>
<p><strong>为那些常用大小的空闲区维护单独的链表</strong>。例如，有一个 <code>n</code> 项的表，该表的第一项是指向大小为 <code>4 KB</code> 的空闲区链表表头指针，第二项是指向大小为 <code>8 KB</code> 的空闲区链表表头指针，第三项是指向大小为 <code>12 KB</code> 的空闲区链表表头指针，以此类推。比如 <code>21 KB</code> 这样的空闲区既可以放在 <code>20 KB</code> 的链表中，也可以放在一个专门存放大小比较特别的空闲区链表中。</p>
<p>快速匹配算法寻找一个指定代销的空闲区也是十分快速的，但它和所有将空闲区按大小排序的方案一样，都有一个共同的缺点，<strong>即在一个进程终止或被换出时，寻找它的相邻块并查看是否可以合并的过程都是非常耗时的。</strong> 如果不进行合并，内存将会很快分裂出大量进程无法利用的小空闲区。</p>
<h1 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h1>
<p>在一些中小应用程序可使用交换技术，<strong>如果应用程序过大，交换技术并不是一个很有效的方案。</strong><br />
一个典型的 <code>SATA</code> 磁盘的峰值传输速度高达几百兆/秒，这意味着需要好几秒才能换出或者换入一个 <code>1 GB</code> 的程序。</p>
<p><code>虚拟内存(virtual memory)</code> 的基本思想是，<strong>每个程序都有自己的地址空间，这个地址空间被划分为多个称为 <code>页面(page)</code> 的块。</strong> 每一页都是连续的地址范围。<strong>这些页被映射到物理内存</strong>，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中，当一个程序等待它的一部分读入内存时，可以把 <code>CPU</code> 交给另一个进程使用。</p>
<h2 id="分页"><a class="markdownIt-Anchor" href="#分页"></a> 分页</h2>
<p>大部分使用虚拟内存的系统中都会使用一种 <code>分页(paging)</code> 技术。在任何一台计算机上，程序会引用使用一组内存地址。当程序执行</p>
<pre><code class="hljs assembly">MOV REG, 1000</code></pre>
<p>这条指令时，它会把内存地址为 <code>1000</code> 的内存单元的内容复制到 <code>REG</code> 中（或者相反，这取决于计算机）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</p>
<p>这些程序生成的地址被称为 <code>虚拟地址(virtual addresses)</code> 并形成 <code>虚拟地址空间(virtual address space)</code>.</p>
<ul>
<li>在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作都使用同样地址的物理内存。</li>
<li>在使用虚拟内存时，虚拟地址不会直接发送到内存总线上。相反，会使用 <code>MMU(Memory Management Unit)</code> 内存管理单元<strong>把虚拟地址映射为物理内存地址</strong>，像下图这样：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927155103.png" srcset="/img/loading.gif" alt="" /></li>
</ul>
<p>下面这幅图展示了这种映射是如何工作的：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927155203.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="1-存在映射的页如何映射"><a class="markdownIt-Anchor" href="#1-存在映射的页如何映射"></a> 1. 存在映射的页如何映射</h3>
<p>虚拟地址空间由固定大小的单元组成，这种固定大小的单元称为 <code>页(pages)</code>。而相对的，物理内存中也有固定大小的物理单元，称为 <code>页框(page frames)</code>。页和页框的大小一样。在上面这个例子中，页的大小为 <code>4KB</code> ，但是实际的使用过程中页的大小范围可能是 <code>512</code> 字节 - <code>1G</code> 字节的大小。对应于 <code>64 KB</code> 的虚拟地址空间和 <code>32 KB</code> 的物理内存，可得到 <code>16</code> 个虚拟页面和 <code>8</code> 个页框。 <strong><code>RAM</code> 和磁盘之间的交换总是以整个页为单元进行交换的。</strong></p>
<p>程序试图访问地址时，例如执行下面这条指令：</p>
<pre><code class="hljs assembly">MOV REG, 0</code></pre>
<p>会将虚拟地址 <code>0</code> 送到 <code>MMU</code>。<code>MMU</code> 看到虚拟地址落在<code>页面 0</code> （<code>0 - 4095</code>），根据其映射结果，这一页面对应的<code>页框 2</code> （<code>8192 - 12287</code>），因此 <code>MMU</code> 把地址变换为 <code>8192</code> ，并把地址 <code>8192</code> 送到总线上。内存对 <code>MMU</code> 一无所知，它只看到一个对 <code>8192</code> 地址的读写请求并执行它。<code>MMU</code> 从而有效的把所有虚拟地址 <code>0 - 4095</code> 映射到了 <code>8192 - 12287</code> 的物理地址。同样的，指令</p>
<pre><code class="hljs assembly">MOV REG, 8192</code></pre>
<p>也被有效的转换为</p>
<pre><code class="hljs assembly">MOV REG, 24576</code></pre>
<p>虚拟地址 <code>8192</code>（在<code>虚拟页 2</code> 中）被映射到物理地址 <code>24576</code>（在物理<code>页框 6</code> 中）上。</p>
<p>通过恰当的设置 <code>MMU</code>，可以把 <code>16</code> 个虚拟页面映射到 <code>8</code> 个页框中的任何一个。但是这并没有解决虚拟地址空间比物理内存大的问题。</p>
<p>上图中有 <code>8</code> 个物理页框，于是只有 <code>8</code> 个虚拟页被映射到了物理内存中，在上图中用 <code>X</code> 号表示的其他页面没有被映射。在实际的硬件中，会使用一个 <code>在/不在(Present/absent bit)位</code> 记录页面在内存中的实际存在情况。</p>
<h3 id="2-未映射的页如何映射"><a class="markdownIt-Anchor" href="#2-未映射的页如何映射"></a> 2. 未映射的页如何映射</h3>
<p>当程序访问一个未映射的页面，如执行指令：</p>
<pre><code class="hljs assembly">MOV REG, 32780</code></pre>
<p>将会发生什么情况呢？<code>虚拟页面 8</code> （从 <code>32768</code> 开始）的第 <code>12</code> 个字节所对应的物理地址是什么？<code>MMU</code> 注意到该页面没有被映射（在图中用 <code>X</code> 号表示），于是 <code>CPU</code> 会陷入(<code>trap</code>)到操作系统中。这个陷入称为 <code>缺页中断(page fault)</code> 或者是 <code>缺页错误</code>。操作系统会选择一个很少使用的页并把它的内容写入磁盘（如果它不在磁盘上）。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷入的指令。有点不太好理解，举个例子来看一下。</p>
<p>例如，如果操作系统决定放弃 <code>页框 1</code>，那么它将把 <code>虚拟页面 8</code> 装入物理地址 <code>4096</code>，并对 <code>MMU</code> 映射做两处修改。</p>
<ul>
<li>首先，它要将虚拟页中的 <code>1</code> 表项标记为<code>未映射</code>，使以后任何对虚拟地址 <code>4096 - 8191</code> 的访问都将导致陷入。</li>
<li>随后把虚拟页面 <code>8</code> 的表项的叉号改为 <code>1</code>，因此在引起陷阱的指令重新启动时，它将把虚拟地址 <code>32780</code> 映射为物理地址（<code>4096 + 12</code>）。</li>
</ul>
<p>下面查看一下 <code>MMU</code> 的内部构造以便了解它们是如何工作的，以及了解为什么我们选用的页大小都是 2 的整数次幂。下图我们可以看到一个虚拟地址的例子：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927163045.png" srcset="/img/loading.gif" alt="" /></p>
<blockquote>
<p>虚拟地址 = 虚拟页号 + 页内偏移量<br />
物理地址 = (虚拟地址页号 -&gt; 物理地址页号) + 页内偏移量</p>
</blockquote>
<p>虚拟地址 <code>8196</code> （<code>0010000000000100</code>）用上面的页表映射图所示的 <code>MMU</code> 映射机制进行映射，输入的 <code>16</code> 位虚拟地址被分为 <code>4</code> 位的<strong>页号</strong>和 <code>12</code> 位的<strong>偏移量</strong>。<code>4</code> 位的页号可以表示 <code>16</code> 个页面，<code>12</code> 位的偏移可以为一页内的全部 <code>4096</code> 个字节。</p>
<p>可用页号作为 <code>页表(page table)</code> 的索引，以得出对应于该虚拟页面的<strong>页框号</strong>。如果在/不在位是 <code>0</code> ，则引起一个操作系统陷入。如果该位是 <code>1</code>，则将在页表中查到的页框号复制到输出寄存器的<code>高 3 位</code>中，再加上输入虚拟地址中的<code>低 12 位偏移量</code>。如此就构成了 <code>15</code> 位的物理地址。输出寄存器的内容随即被作为物理地址送到总线。</p>
<h2 id="页表"><a class="markdownIt-Anchor" href="#页表"></a> 页表</h2>
<p>在上面这个简单的例子中，虚拟地址到物理地址的映射可以总结如下：虚拟地址被分为<strong>虚拟页号</strong>（高位部分）和<strong>偏移量</strong>（低位部分）。例如，对于 <code>16</code> 位地址和 <code>4 KB</code> 的页面大小，<strong>高 4 位</strong>可以指定 <code>16</code> 个虚拟页面中的一页，而<strong>低 12 位</strong>接着确定了所选页面中的偏移量（<code>0-4095</code>）。</p>
<p>虚拟页号可作为页表的索引用来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927164705.png" srcset="/img/loading.gif" alt="" /></p>
<p>因此，<strong>页表的目的是把虚拟页映射到页框中</strong>。从数学上说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。</p>
<h3 id="页表项的结构"><a class="markdownIt-Anchor" href="#页表项的结构"></a> 页表项的结构</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927164835.png" srcset="/img/loading.gif" alt="" /></p>
<p>页表项的结构是与机器相关的，但是不同机器上的页表项大致相同。上面是一个页表项的构成，不同计算机的页表项可能不同，但是一般来说都是 <code>32</code> 位的。</p>
<ul>
<li>
<p><code>页框号(Page frame number)</code>: 页表项中最重要的字段，毕竟，页表到页框最重要的一步操作就是要把此值映射过去。</p>
</li>
<li>
<p><code>在/不在(Present/absent bit)位</code>: 如果此位上的值是 1，那么页表项是有效的并且能够被使用。如果此值是 0 的话，则表示该页表项对应的虚拟页面不在内存中，访问该页面会引起一个 <code>缺页中断(page fault)</code>。</p>
</li>
<li>
<p><code>保护位(Protection)</code>: 指出一个页允许什么类型的访问。最简单的表示形式是这个域只有一位，0 表示可读可写，1 表示的是只读。</p>
</li>
<li>
<p><code>修改位(Modified)</code> 和 <code>访问位(Referenced)</code> 会跟踪页面的使用情况。当一个页面被写入时，硬件会自动的设置修改位。修改位在页面重新分配页框时很有用。如果一个页面已经被修改过（即它是 <code>脏</code> 的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是 <code>干净</code> 的），那么重新分配时这个页框会被直接丢弃，因为磁盘上的副本仍然是有效的。这个位有时也叫做 <code>脏位(dirty bit)</code>，因为它反映了页面的状态。</p>
</li>
<li>
<p><code>访问位(Referenced)</code>: 在页面被访问时被设置，不管是读还是写。这个值能够帮助操作系统在发生缺页中断时选择要淘汰的页。不再使用的页要比正在使用的页更适合被淘汰。这个位在后面要讨论的页面置换算法中作用很大。</p>
</li>
<li>
<p><code>高速缓存禁止位</code>: 用于禁止该页面被高速缓存，这个功能对于映射到设备寄存器还是内存中起到了关键作用。通过这一位可以禁用高速缓存。具有独立的 <code>I/O</code> 空间而不是用内存映射 <code>I/O</code> 的机器来说，并不需要这一位。</p>
</li>
</ul>
<p>需要强调一下：<strong>虚拟内存本质上是用来创造一个地址空间的抽象，类似于进程是对 <code>CPU</code> 的抽象。虚拟内存的实现，本质是将虚拟地址空间分解成页，并将每一项映射到物理内存的某个页框。</strong> 因此我们的重点是如何管理这个虚拟内存的抽象。</p>
<h2 id="快表"><a class="markdownIt-Anchor" href="#快表"></a> 快表</h2>
<p>大多数程序总是对少量页面进行多次访问，而不是对大量页面进行少量访问。因此，只有很少的页面能够被再次访问，而其他的页表项很少被访问。</p>
<blockquote>
<p>页表项一般也被称为 <code>Page Table Entry(PTE)</code>。</p>
</blockquote>
<p>基于这种设想，提出了一种方案，即从硬件方面来解决这个问题，为计算机设置一个小型的硬件设备，能够将虚拟地址直接映射到物理地址，而不必再访问内存中的页表。这种设备被称为 <code>转换检测缓冲区(Translation Lookaside Buffer, TLB)</code>，有时又被称为 <code>相联存储器(associate memory)</code>。</p>
<p><code>TLB</code> 通常位于 <code>MMU</code> 中，包含少量的表项，每个表项都记录了页面的相关信息，除了虚拟页号外，其他表项都和页表是一一对应的。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927172214.png" srcset="/img/loading.gif" alt="" /></p>
<p><code>TLB</code> 其实就是一种<strong>内存缓存，用于减少访问内存所需要的时间</strong>，它就是 <code>MMU</code> 的一部分，<code>TLB</code> 会将虚拟地址到物理地址的转换存储起来，通常可以称为 <code>地址翻译缓存(address-translation cache)</code>。<code>TLB</code> 通常位于 <code>CPU</code> 和 <code>CPU</code> 缓存之间，它与 <code>CPU</code> 缓存是不同的缓存级别。下面我们来看一下 <code>TLB</code> 是如何工作的。</p>
<p>当一个 <code>MMU</code> 中的虚拟地址需要进行转换时，硬件首先检查虚拟页号与 <code>TLB</code> 中所有表项进行并行匹配，判断虚拟页是否在 <code>TLB</code> 中。如果找到了有效匹配项，并且要进行的访问操作没有违反保护位的话，则将页框号直接从 <code>TLB</code> 中取出而<strong>不用再直接访问页表</strong>。如果虚拟页在 <code>TLB</code> 中但是违反了保护位的权限的话（比如只允许读但是是一个写指令），则会生成一个 <code>保护错误(protection fault)</code> 返回。</p>
<p>上面探讨的是虚拟地址在 <code>TLB</code> 中的情况，那么如果虚拟地址不再 <code>TLB</code> 中该怎么办？如果 <code>MMU</code> 检测到没有有效的匹配项，就会进行正常的页表查找，然后从 <code>TLB</code> 中逐出一个表项然后把从页表中找到的项放在 <code>TLB</code> 中。当一个表项被从 <code>TLB</code> 中清除出，将修改位复制到内存中页表项，除了访问位之外，其他位保持不变。当页表项从页表装入 <code>TLB</code> 中时，所有的值都来自于内存。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200927172423.png" srcset="/img/loading.gif" alt="" /></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/09/24/LeetCode-209-minimum-size-subarray-sum/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LeetCode 209. 长度最小的子数组</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/09/23/LeetCode-76-minimum-window-substring/">
                        <span class="hidden-mobile">LeetCode 76. 最小覆盖子串</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <!-- <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> -->
      Crafted with
      <i class="iconfont icon-love" style="color: #f30;"></i>
      by <a href="https://github.com/likailee" target="_blank" rel="noopener">Likai Lee</a>
      | &copy; 2017 - 2020
      <!-- <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a> -->
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?66c61a5fd59052d1b39d89c246846ae5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
