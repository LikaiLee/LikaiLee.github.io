<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Likai Lee">
  <meta name="keywords" content="">
  <title>操作系统 内存管理 - Likai Lee</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Likai Lee</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                操作系统 内存管理
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-09-24 17:10">
      2020年9月24日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      43
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年9月25日 下午
                
              </p>
            
            <article class="markdown-body">
              <p>[TOC]<br />
<code>分层存储器体系(memory hierarchy)</code>：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200924163759.png" srcset="/img/loading.gif" alt="" /></p>
<p>位于顶层的存储器速度最快，但是相对容量最小，成本非常高。层级结构向下，其访问速度会变慢，但是容量会变大，相对造价也就越便宜。（所以个人感觉相对存储容量来说，访问速度是更重要的）</p>
<p>操作系统中管理内存层次结构的部分称为 <code>内存管理器(memory manager)</code>，它的主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。所有现代操作系统都提供内存管理。</p>
<h1 id="无存储器抽象"><a class="markdownIt-Anchor" href="#无存储器抽象"></a> 无存储器抽象</h1>
<p>最简单的存储器抽象是无存储器。早期大型计算机（20 世纪 60 年代之前），小型计算机（20 世纪 70 年代之前）和个人计算机（20 世纪 80 年代之前）都没有存储器抽象。每一个程序都直接访问物理内存。当一个程序执行如下命令：</p>
<pre><code class="hljs angelscript">MOV REGISTER1, <span class="hljs-number">1000</span></code></pre>
<p>计算机会把位置为 1000 的物理内存中的内容移到 <code>REGISTER1</code> 中。因此呈现给程序员的内存模型就是物理内存，内存地址从 0 开始到内存地址的最大值中，每个地址中都会包含一个 <code>8 位</code> 位数的内存单元。</p>
<p>所以这种情况下的计算机<strong>不可能会有两个应用程序同时在内存中</strong>。如果第一个程序向内存地址 2000 的这个位置写入了一个值，那么此值将会替换第二个程序 2000 位置上的值，所以，同时运行两个应用程序是行不通的，两个程序会立刻崩溃。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200924165101.png" srcset="/img/loading.gif" alt="" /></p>
<p>不过即使存储器模型就是物理内存，还是存在一些可变体的。下面展示了三种变体：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200924165747.png" srcset="/img/loading.gif" alt="" /></p>
<p>在上图 <code>a</code> 中，操作系统位于 <code>RAM(Random Access Memory)</code> 的底部，或像是图 <code>b</code> 一样位于 <code>ROM(Read-Only Memory)</code> 顶部；而在图 <code>c</code> 中，<strong>设备驱动程序</strong>位于顶端的 <code>ROM</code> 中，而操作系统位于底部的 <code>RAM</code> 中。</p>
<ul>
<li>图 a 的模型以前用在大型机和小型机上，但现在已经很少使用了；</li>
<li>图 b 中的模型一般用于掌上电脑或者是嵌入式系统中。</li>
<li>第三种模型就应用在早期个人计算机中了。ROM 系统中的一部分成为 <code>BIOS (Basic Input Output System)</code>。模型 a 和 c 的缺点是<strong>用户程序中的错误可能会破坏操作系统</strong>，可能会导致灾难性的后果。</li>
</ul>
<p>按照这种方式组织系统时，通常<strong>同一个时刻只能有一个进程正在运行</strong>。一旦用户键入了一个命令，操作系统就把需要的程序从磁盘复制到内存中并执行；当进程运行结束后，操作系统在用户终端显示提示符并等待新的命令。收到新的命令后，它把新的程序装入内存，覆盖前一个程序。</p>
<p>在没有存储器抽象的系统中实现并行性一种方式是使用多线程来编程。由于同一进程中的多线程内部共享同一内存映像，那么实现并行也就不是问题了。但是这种方式却并没有被广泛采纳，因为人们通常希望能够在同一时间内运行没有关联的程序，而这正是线程抽象所不能提供的。</p>
<h1 id="存储器抽象地址空间"><a class="markdownIt-Anchor" href="#存储器抽象地址空间"></a> 存储器抽象：地址空间</h1>
<p>把物理内存暴露给进程会有几个主要的缺点：</p>
<ul>
<li>
<p>第一个问题是，如果用户程序可以寻址内存的每个字节，它们就可以很容易的<strong>破坏操作系统</strong>，从而使系统停止运行。即使在只有一个用户进程运行的情况下，这个问题也存在。</p>
</li>
<li>
<p>第二点是，<strong>难以运行多个程序</strong>。在个人计算机上，一般会打开很多应用程序，这些进程在不同时刻会有一个进程正在运行，其他应用程序可以通过鼠标来唤醒。在系统中没有物理内存的情况下很难实现。</p>
</li>
</ul>
<h2 id="地址空间概念"><a class="markdownIt-Anchor" href="#地址空间概念"></a> 地址空间概念</h2>
<p><code>地址空间(the address space)</code> 创建了一种抽象内存供程序使用。<strong>地址空间是进程可以用来寻址内存的地址集。每个进程都有它自己的地址空间，独立于其他进程的地址空间，但是某些进程会希望可以共享地址空间。</strong></p>
<h3 id="基址寄存器和变址寄存器"><a class="markdownIt-Anchor" href="#基址寄存器和变址寄存器"></a> 基址寄存器和变址寄存器</h3>
<p>最简单的办法是使用 <code>动态重定位(dynamic relocation)</code> 技术，它就是通过一种简单的方式<strong>将每个进程的地址空间映射到物理内存的不同区域</strong>。<br />
经典办法是给每个 <code>CPU</code> 配置两个特殊硬件寄存器，通常叫做 <code>基址寄存器(basic register)</code> 和 <code>变址寄存器(limit register)</code>。当使用基址寄存器和变址寄存器时，程序会装载到内存中的连续位置并且在装载期间无需重定位。</p>
<ul>
<li>基址寄存器：存储数据内存的起始位置</li>
<li>变址寄存器：存储应用程序的长度。</li>
</ul>
<p>每当进程引用内存以获取指令或读取、写入数据时，<code>CPU</code> 都会自动将基址值添加到进程生成的地址中，然后再将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于变址寄存器中的值。如果程序提供的地址要超过变址寄存器的范围，那么会产生错误并中止访问。</p>
<p>执行 <code>JMP 28</code> 这条指令后，硬件会把它解释为 <code>JMP 16412</code>，所以程序能够跳到 <code>CMP</code> 指令，过程如下：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925132116.png" srcset="/img/loading.gif" alt="" /></p>
<p>使用基址寄存器和变址寄存器是给每个进程提供私有地址空间的一种非常好的方法，因为每个内存地址在送到内存之前，都会先加上基址寄存器的内容。在很多实际系统中，对基址寄存器和变址寄存器都会以一定的方式加以保护，使得只有操作系统可以修改它们。</p>
<p>缺点：在每次访问内存时，都会进行 <code>ADD</code> 和 <code>CMP</code> 运算。<code>CMP</code> 指令可以执行的很快，但是加法就会相对慢一些，除非使用特殊的加法电路，否则加法因进位传播时间而变慢。</p>
<h2 id="交换技术"><a class="markdownIt-Anchor" href="#交换技术"></a> 交换技术</h2>
<p>实际上，所有<strong>进程需要的 <code>RAM</code> 总容量要远远高于内存的容量</strong>。针对<strong>内存不足</strong>的问题，提出了两种处理方式：</p>
<ul>
<li><code>交换(swapping)</code> 技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。</li>
<li><code>虚拟内存(virtual memory)</code>，虚拟内存技术能够允许应用程序部分的运行在内存中。</li>
</ul>
<h3 id="交换过程"><a class="markdownIt-Anchor" href="#交换过程"></a> 交换过程</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925132623.png" srcset="/img/loading.gif" alt="" /></p>
<p>刚开始的时候，只有进程 A 在内存中，然后从创建进程 B 和进程 C 或者从磁盘中把它们换入内存，然后在图 d 中，A 被换出内存到磁盘中，最后 A 重新进来。因为图 g 中的进程 A 现在到了不同的位置，所以在装载过程中需要被重新定位，或者在交换程序时通过软件来执行；或者在程序执行期间通过硬件来重定位。基址寄存器和变址寄存器就适用于这种情况。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925132932.png" srcset="/img/loading.gif" alt="" /></p>
<p>交换在内存创建了多个 <code>空闲区(hole)</code>，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这项技术称为 <code>内存紧缩(memory compaction)</code>。但是这项技术通常不会使用，因为这项技术会消耗很多 <code>CPU</code> 时间。例如，在一个 16GB 内存的机器上每 8ns 复制 8 字节，它紧缩全部的内存大约要花费 16s。</p>
<h3 id="动态内存分配"><a class="markdownIt-Anchor" href="#动态内存分配"></a> 动态内存分配</h3>
<p>如果进程被创建后它的大小是固定的并且不再改变，那么分配策略就比较简单：操作系统会准确的按其需要的大小进行分配。</p>
<p>进程的 <code>data segment</code> 能够自动增长，会有三种处理方式：</p>
<ul>
<li>
<p>如果一个进程与空闲区相邻，那么可把该空闲区分配给进程以供其增大。</p>
</li>
<li>
<p>如果进程相邻的是另一个进程，就会有两种处理方式：要么把需要增长的进程移动到一个内存中空闲区足够大的区域，要么把一个或多个进程交换出去，已变成生成一个大的空闲区。</p>
</li>
<li>
<p>如果一个进程在内存中不能增长，而且磁盘上的交换区也满了，那么这个进程只有挂起一些空闲空间（或者可以结束该进程）。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925133850.png" srcset="/img/loading.gif" alt="" /></p>
<p>上面只针对单个或者一小部分需要增长的进程采用的方式，如果大部分进程都要在运行时增长，为了减少因内存区域不够而引起的进程交换和移动所产生的开销，一种可用的方法是，<strong>在换入或移动进程时为它分配一些额外的内存</strong>。然而，<strong>当进程被换出到磁盘上时，应该只交换实际上使用的内存</strong>，将额外的内存交换也是一种浪费，下面是一种为两个进程分配了增长空间的内存配置。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925134003.png" srcset="/img/loading.gif" alt="" /></p>
<p>如果进程有两个可增长的段，例如，供变量动态分配和释放的作为堆(全局变量)使用的一个 <code>数据段(data segment)</code>，以及存放局部变量与返回地址的一个 <code>堆栈段(stack segment)</code>，就如图 b 所示。在图中可以看到所示进程的<strong>堆栈段在进程所占内存的顶端向下增长</strong>，紧接着在程序段后的<strong>数据段向上增长</strong>。当增长预留的内存区域不够了，处理方式就如上面的流程图(<code>data segment</code> 自动增长的三种处理方式)一样了。</p>
<h2 id="空闲内存管理"><a class="markdownIt-Anchor" href="#空闲内存管理"></a> 空闲内存管理</h2>
<p>在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式</p>
<ul>
<li>位图(<code>bitmap</code>)</li>
<li>空闲列表(<code>free lists</code>)</li>
</ul>
<h3 id="1-使用位图的存储管理"><a class="markdownIt-Anchor" href="#1-使用位图的存储管理"></a> 1. 使用位图的存储管理</h3>
<p>使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925161159.png" srcset="/img/loading.gif" alt="" /></p>
<p>图 <code>a</code> 表示一段有 5 个进程和 3 个空闲区的内存，刻度为内存分配单元，阴影区表示空闲（在位图中用 0 表示）；图 <code>b</code> 表示对应的位图；图 <code>c</code> 表示用链表表示同样的信息。</p>
<p>分配单元的大小是一个重要的设计因素，<strong>分配单位越小，位图越大</strong>。然而，即使只有 <code>4</code> 字节的分配单元，<code>32</code> 位的内存也仅仅只需要位图中的 <code>1</code> 位。<code>32n</code> 位的内存需要 <code>n</code> 位的位图，所以 <code>1</code> 个位图只占用了 <code>1/32</code> 的内存。如果选择更大的内存单元，位图应该要更小。如果进程的大小不是分配单元的整数倍，那么在最后一个分配单元中会有大量的内存被浪费。</p>
<p>位图提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为<strong>位图的大小取决于内存和分配单元的大小</strong>。这种方法有一个问题是，当决定为把具有 <code>k</code> 个分配单元的进程放入内存时，<code>内容管理器(memory manager)</code> 必须搜索位图，在位图中找出能够运行 <code>k</code> 个连续 <code>0</code> 位的串。<strong>在位图中找出制定长度的连续 <code>0</code> 串是一个很耗时的操作，这是位图的缺点。</strong></p>
<h3 id="2-使用链表进行管理"><a class="markdownIt-Anchor" href="#2-使用链表进行管理"></a> 2. 使用链表进行管理</h3>
<p>另一种记录内存使用情况的方法是，维护一个记录<strong>已分配内存段和空闲内存段的链表</strong>，段会包含进程或者是两个进程的空闲区域。可用上面的 <code>图 c</code> 来表示内存的使用情况。链表中的每一项都可以代表一个 <code>空闲区(H)</code> 或者是 <code>进程(P)</code> 的起始标志，长度和下一个链表项的位置。</p>
<p>在这个例子中，<code>段链表(segment list)</code> 是按照地址排序的。这种方式的优点是，当进程终止或被交换时，更新列表很简单。一个终止进程通常有两个邻居（除了内存的顶部和底部外）。相邻的可能是进程也可能是空闲区，它们有四种组合方式。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925163044.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="3-顺序搜索的动态内存分配"><a class="markdownIt-Anchor" href="#3-顺序搜索的动态内存分配"></a> 3. 顺序搜索的动态内存分配</h3>
<p>当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。</p>
<h4 id="31-首次适配first-fit"><a class="markdownIt-Anchor" href="#31-首次适配first-fit"></a> 3.1 <code>首次适配(first fit)</code></h4>
<p><strong>内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止</strong>。除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。</p>
<h4 id="32-下次适配next-fit"><a class="markdownIt-Anchor" href="#32-下次适配next-fit"></a> 3.2 <code>下次适配(next fit)</code></h4>
<p>它和首次匹配的工作方式相同，只有一个不同之处那就是<strong>下次适配在每次找到合适的空闲区时就会记录当时的位置</strong>，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。</p>
<h4 id="33-最佳适配best-fit"><a class="markdownIt-Anchor" href="#33-最佳适配best-fit"></a> 3.3 <code>最佳适配(best fit)</code></h4>
<p>最佳适配会从头到尾寻找整个链表，找出能够容纳进程的<strong>最小空闲区</strong>。最佳适配算法会试图<strong>找出最接近实际需要的空闲区</strong>，以最好的匹配请求和可用空闲区，而不是先一次拆分一个以后可能会用到的大的空闲区。比如现在我们需要一个大小为 2 的块，那么首次匹配算法会把这个块分配在位置 5 的空闲区，而最佳适配算法会把该块分配在位置为 18 的空闲区，如下：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200925162851.png" srcset="/img/loading.gif" alt="" /></p>
<p>最佳适配会遍历整个链表，所以最佳适配算法的性能要比首次匹配算法差。但最佳适配算法要比首次匹配和下次匹配算法浪费更多的内存，因为它会产生大量无用的小缓冲区，首次匹配算法生成的空闲区会更大一些。</p>
<h4 id="34-最差适配worst-fit"><a class="markdownIt-Anchor" href="#34-最差适配worst-fit"></a> 3.4 <code>最差适配(worst fit)</code></h4>
<p><strong>总是分配最大的内存区域</strong>，使新分配的空闲区比较大从而可以继续使用。仿真程序表明最差适配算法也不是一个好主意。</p>
<h4 id="35-快速适配quick-fit"><a class="markdownIt-Anchor" href="#35-快速适配quick-fit"></a> 3.5 <code>快速适配(quick fit)</code></h4>
<p><strong>为那些常用大小的空闲区维护单独的链表</strong>。例如，有一个 <code>n</code> 项的表，该表的第一项是指向大小为 <code>4 KB</code> 的空闲区链表表头指针，第二项是指向大小为 <code>8 KB</code> 的空闲区链表表头指针，第三项是指向大小为 <code>12 KB</code> 的空闲区链表表头指针，以此类推。比如 <code>21 KB</code> 这样的空闲区既可以放在 <code>20 KB</code> 的链表中，也可以放在一个专门存放大小比较特别的空闲区链表中。</p>
<p>快速匹配算法寻找一个指定代销的空闲区也是十分快速的，但它和所有将空闲区按大小排序的方案一样，都有一个共同的缺点，<strong>即在一个进程终止或被换出时，寻找它的相邻块并查看是否可以合并的过程都是非常耗时的。</strong> 如果不进行合并，内存将会很快分裂出大量进程无法利用的小空闲区。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/09/24/LeetCode-209-minimum-size-subarray-sum/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LeetCode 209. 长度最小的子数组</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/09/23/LeetCode-76-minimum-window-substring/">
                        <span class="hidden-mobile">LeetCode 76. 最小覆盖子串</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <!-- <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> -->
      Crafted with
      <i class="iconfont icon-love" style="color: #f30;"></i>
      by <a href="https://github.com/likailee" target="_blank" rel="noopener">Likai Lee</a>
      | &copy; 2017 - 2020
      <!-- <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a> -->
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?66c61a5fd59052d1b39d89c246846ae5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
