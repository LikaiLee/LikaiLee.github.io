<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Likai Lee">
  <meta name="keywords" content="">
  <title>操作系统 文件系统 - Likai Lee</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Likai Lee</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                操作系统 文件系统
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-09-28 16:24">
      2020年9月28日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      110
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年9月29日 下午
                
              </p>
            
            <article class="markdown-body">
              <h1 id="文件"><a class="markdownIt-Anchor" href="#文件"></a> 文件</h1>
<h2 id="文件命名"><a class="markdownIt-Anchor" href="#文件命名"></a> 文件命名</h2>
<p>文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用名称访问该文件。</p>
<p>文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。</p>
<p>某些文件区分大小写字母，而大多数则不区分。<code>UNIX</code> 属于第一类；历史悠久的 <code>MS-DOS</code> 属于第二类；因此，<code>UNIX</code> 系统会有三种不同的命名文件：<code>maria</code>、<code>Maria</code>、<code>MARIA</code> 。在 <code>MS-DOS</code>，所有这些命名都属于相同的文件。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928152723.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>
<p>在 <code>UNIX</code> 系统中，文件扩展名只是一种约定，操作系统并不强制采用。</p>
</li>
<li>
<p>与 <code>UNIX</code> 相反，<code>Windows</code> 就会关注扩展名并对扩展名赋予了新的含义。用户(或进程) 可以在操作系统中注册扩展名，并且规定哪个程序能够拥有扩展名。当用户双击某个文件名时，拥有该文件名的程序就启动并运行文件。</p>
</li>
</ul>
<h2 id="文件结构"><a class="markdownIt-Anchor" href="#文件结构"></a> 文件结构</h2>
<p>文件的构造有多种方式。下图列出了常用的三种构造方式：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928153020.png" srcset="/img/loading.gif" alt="" /></p>
<p>上图中的 a 是一种<strong>无结构的字节序列</strong>，操作系统不关心序列的内容是什么，操作系统能看到的就是字节(bytes)。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。</p>
<p>把文件看成字节序列提供了最大的灵活性。用户程序可以向文件中写任何内容，并且可以通过任何方便的形式命名。操作系统不会为为用户写入内容提供帮助，当然也不会干扰阻塞你。对于想做特殊操作的用户来说，后者是十分重要的。所有的 UNIX 版本（包括 Linux 和 OS X）和 Windows 都使用这种文件模型。</p>
<p>图 b 表示在文件结构上的第一步改进。在这个模型中，文件是具有固定长度记录的序列，每个记录都有其内部结构。 把文件作为记录序列的核心思想是：读操作返回一个记录，而写操作重写或者追加一个记录。</p>
<p>第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗记录树构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个key 字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。</p>
<p>在记录树的结构中，可以取出下一个记录，但是最关键的还是根据 key 搜索指定的记录。如上图 c 所示，用户可以读出指定的 pony 记录，而不必关心记录在文件中的确切位置。用户也可以在文件中添加新的记录。但是用户不能决定添加到何处位置，添加到何处位置是由操作系统决定的。</p>
<h2 id="文件类型"><a class="markdownIt-Anchor" href="#文件类型"></a> 文件类型</h2>
<p>很多操作系统支持多种文件类型。例如，<code>UNIX</code>（同样包括 <code>OS X</code>）和 <code>Windows</code> 都具有常规的文件和目录。除此之外，<code>UNIX</code> 还具有 <code>字符特殊文件(character special file)</code> 和 <code>块特殊文件(block special file)</code>。</p>
<ul>
<li><code>常规文件(Regular files)</code> 是包含有用户信息的文件。用户一般使用的文件大都是常规文件，常规文件一般包括 可执行文件、文本文件、图像文件，从常规文件读取数据或将数据写入时，内核会根据文件系统的规则执行操作，是写入可能被延迟，记录日志或者接受其他操作。</li>
<li>字符特殊文件和输入/输出有关，用于串行 <code>I/O</code> 类设备，如终端、打印机、网络等。</li>
<li>块特殊文件用于磁盘类设备。</li>
</ul>
<p>常规文件一般分为 <code>ASCII</code> 码文件或者<code>二进制文件</code>。<code>ASCII</code> 码文件由文本组成。在一些系统中，每行都会用回车符结束（ASCII码是13，控制字符 CR，转义字符\r。），另外一些则会使用换行符（ASCII码是10，控制字符LF，转义字符\n）。一些系统（比如 Windows）两者都会使用。</p>
<p><code>ASCII</code> 文件的优点在于<strong>显示</strong> 和 <strong>打印</strong>，还可以用任何文本编辑器进行编辑。进一步来说，如果许多应用程序使用 <code>ASCII</code> 码作为输入和输出，那么很容易就能够把多个程序连接起来，一个程序的输出可能是另一个程序的输入，就像管道一样。</p>
<p>其他与 <code>ASCII</code> 不同的是二进制文件。打印出来的二进制文件是无法理解的。下面是一个二进制文件的格式，它取自早期的 UNIX 。尽管从技术上来看这个文件只是字节序列，但是操作系统只有在文件格式正确的情况下才会执行。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928155756.png" srcset="/img/loading.gif" alt="" /></p>
<p>这个文件有五个段：文件头、正文、数据、重定位和符号表。文件头以 <code>魔数(magic number)</code> 为开始，表明这个文件是一个可执行文件。然后是文件各个部分的大小，开始执行的标志以及一些标志位。程序本身的正文和数据在文件头后面，他们被加载到内存中或者重定位会根据重定位位进行判断。符号表则用于调试。</p>
<p>二进制文件的另外一种形式是存档文件，它由已编译但没有链接的库过程（模块）组合而成。每个文件都以模块头开始，其中记录了名称、创建日期、所有者、保护码和文件大小。和可执行文件一样，模块头也都是二进制数，将它们复制到打印机将会产生乱码。</p>
<p>当程序从文件中读写数据时，请求会转到 <code>内核处理程序(kernel driver)</code>。如果文件是常规文件，则数据由文件系统驱动程序处理，并且通常存储在磁盘或其他存储介质上的某块区域中，从文件中读取的数据就是之前在该位置写入的数据。</p>
<p>当数据读取或写入到设备文件时，请求会被设备驱动程序处理。每个设备文件都有一个关联的编号，该编号标示要使用的设备驱动程序。设备处理数据的工作是它自己的事。</p>
<ul>
<li><code>块设备</code> 也叫做块特殊文件，它的行为通常与普通文件相似：它们是字节数组，并且在给定位置读取的值是最后写入该位置的值。来自块设备的数据可以缓存在内存中，并从缓存中读取；写入可以被缓冲。块设备通常是可搜索的，块设备的概念是，相应的硬件可以一次读取或者写入整个块，例如磁盘上的一个扇区</li>
<li><code>字符设备</code> 也称为字符特殊文件，它的行为类似于管道、串行端口。将字节写入字符设备可能会导致它在屏幕上显示，在串行端口上输出，转换为声音。</li>
<li><code>目录(Directories)</code> 是管理文件系统结构的系统文件。它是用于在计算机上存储文件的位置。目录位于分层文件系统中，例如 Linux，MS-DOS 和 UNIX。</li>
</ul>
<h2 id="文件访问"><a class="markdownIt-Anchor" href="#文件访问"></a> 文件访问</h2>
<p>早期的操作系统只有一种访问方式：<code>序列访问(sequential access)</code>。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。</p>
<p>在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为<code>随机访问文件(random access file)</code>。许多应用程序都需要这种方式。</p>
<p>随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。</p>
<h1 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h1>
<p>文件系统通常提供 <code>目录(directories)</code> 或者 <code>文件夹(folders)</code> 用于记录文件的位置，在很多系统中目录本身也是文件。</p>
<h2 id="一级目录系统"><a class="markdownIt-Anchor" href="#一级目录系统"></a> 一级目录系统</h2>
<p>目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为 <code>根目录(root directory)</code>，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928161552.png" srcset="/img/loading.gif" alt="" /></p>
<p>该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。</p>
<h2 id="层次目录系统"><a class="markdownIt-Anchor" href="#层次目录系统"></a> 层次目录系统</h2>
<p>对于简单的应用而言，一般都用单层目录方式，但是这种组织形式并不适合于现代计算机，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了 <code>层次目录系统(Hierarchical Directory Systems)</code>，也称为<code>目录树</code>。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928161630.png" srcset="/img/loading.gif" alt="" /></p>
<p>根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户各自创建了子目录。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的。</p>
<h2 id="路径名"><a class="markdownIt-Anchor" href="#路径名"></a> 路径名</h2>
<p>当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个 <code>绝对路径名(absolute path name)</code>，它由根目录到文件的路径组成。在 <code>UNIX</code> 中，路径的组件由 <code>/</code> 分隔。在 <code>Windows</code> 中，分隔符为 <code>\</code>。 在 <code>MULTICS</code> 中，它是 <code>&gt;</code>。 因此，在这三个系统中，相同的路径名将被编写如下</p>
<pre><code class="hljs properties"><span class="hljs-attr">Windows</span> <span class="hljs-string">\usr\ast\mailbox </span>
<span class="hljs-attr">UNIX</span> <span class="hljs-string">/usr/ast/mailbox </span>
<span class="hljs-attr">MULTICS</span> <span class="hljs-string">&gt;usr&gt;ast&gt;mailbox</span></code></pre>
<p>不论使用哪种方式，如果路径名的第一个字符是分隔符，那就是绝对路径。</p>
<p>另外一种指定文件名的方法是 <code>相对路径名(relative path name)</code>。它常常和 <code>工作目录(working directory)</code> （也称作 <code>当前目录(current directory)</code>）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 /usr/ast，那么绝对路径 /usr/ast/mailbox可以直接使用 mailbox 来引用。也就是说，如果工作目录是 /usr/ast，则 UNIX 命令</p>
<pre><code class="hljs awk">cp <span class="hljs-regexp">/usr/</span>ast<span class="hljs-regexp">/mailbox  /u</span>sr<span class="hljs-regexp">/ast/m</span>ailbox.bak</code></pre>
<p>和命令</p>
<pre><code class="hljs avrasm"><span class="hljs-keyword">cp</span> mailbox mailbox.bak</code></pre>
<p>具有相同的含义。相对路径通常情况下更加方便和简洁。而它实现的功能和绝对路径安全相同。<br />
一些程序需要访问某个特定的文件而不必关心当前的工作目录是什么。在这种情况下，应该使用绝对路径名。</p>
<p>支持层次目录结构的大多数操作系统在每个目录中有两个特殊的目录项 <code>.</code> 和 <code>..</code>，分别读作 <code>dot</code> 和 <code>dotdot</code>。<code>dot</code> 指的是当前目录，<code>dotdot</code> 指的是其父目录（在根目录中例外，在根目录中指向自己）。可以参考下面的进程树来查看如何使用。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928162121.png" srcset="/img/loading.gif" alt="" /><br />
一个进程的工作目录是 <code>/usr/ast</code>。</p>
<pre><code class="hljs crystal">cp ../<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">dictionary</span> .</span>

cp /usr/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">dictionary</span> .</span>

cp /usr/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">dictionary</span> <span class="hljs-title">dictionary</span></span>

cp /usr/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">dictionary</span> /<span class="hljs-title">usr</span>/<span class="hljs-title">lib</span>/<span class="hljs-title">dictionary</span></span></code></pre>
<h1 id="文件系统的实现"><a class="markdownIt-Anchor" href="#文件系统的实现"></a> 文件系统的实现</h1>
<h2 id="文件系统布局"><a class="markdownIt-Anchor" href="#文件系统布局"></a> 文件系统布局</h2>
<p>文件系统存储在磁盘中。大部分的磁盘能够划分出一到多个分区，叫做 <code>磁盘分区(disk partitioning)</code> 或者是 <code>磁盘分片(disk slicing)</code>。<strong>每个分区都有独立的文件系统</strong>，每块分区的文件系统可以不同。磁盘的 <code>0</code> 号分区称为 <code>主引导记录(Master Boot Record, MBR)</code>，用来 <code>引导(boot)</code> 计算机。在 <code>MBR</code> 的结尾是 <code>分区表(partition table)</code>。每个分区表给出每个分区由开始到结束的地址。系统管理员使用一个称为分区编辑器的程序来创建，调整大小，删除和操作分区。这种方式的一个缺点是<strong>很难适当调整分区的大小</strong>，导致一个分区具有很多可用空间，而另一个分区几乎完全被分配。</p>
<p><code>MBR</code> 可以用在 <code>DOS</code> 、<code>Microsoft Windows</code> 和 <code>Linux</code> 操作系统中。从 2010 年代中期开始，大多数新计算机都改用 <code>GUID 分区表（GPT）</code>分区方案。</p>
<p>当计算机开始引 <code>boot</code> 时，<code>BIOS</code> 读入并执行 <code>MBR</code>。</p>
<h3 id="引导块"><a class="markdownIt-Anchor" href="#引导块"></a> 引导块</h3>
<p><code>MBR</code> 做的第一件事就是<strong>确定活动分区</strong>，读入它的第一个块，称为 <code>引导块(boot block)</code> 并执行。引导块中的程序将加载分区中的操作系统。为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统。引导块占据文件系统的前 <code>4096</code> 个字节，从磁盘上的字节偏移量 <code>0</code> 开始。引导块可用于启动操作系统。</p>
<blockquote>
<p>在计算机中，引导就是启动计算机的过程，它可以通过硬件（例如按下电源按钮）或者软件命令的方式来启动。开机后，电脑的 <code>CPU</code> 还不能执行指令，因为此时没有软件在主存中，所以一些软件必须先被加载到内存中，然后才能让 <code>CPU</code> 开始执行。也就是计算机开机后，首先会进行软件的装载过程。</p>
<p>重启电脑的过程称为 <code>重新引导(rebooting)</code>，从休眠或睡眠状态返回计算机的过程不涉及启动。</p>
</blockquote>
<p>除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。通常文件系统会包含一些属性，如下：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928163718.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="超级块"><a class="markdownIt-Anchor" href="#超级块"></a> 超级块</h3>
<p><code>超级块(Superblock)</code> 的大小为 <code>4096</code> 字节，从磁盘上的字节偏移 <code>4096</code> 开始。超级块包含文件系统的所有关键参数</p>
<ul>
<li>
<p>文件系统的大小</p>
</li>
<li>
<p>文件系统中的数据块数</p>
</li>
<li>
<p>指示文件系统状态的标志</p>
</li>
<li>
<p>分配组大小</p>
</li>
</ul>
<p>在计算机启动或者文件系统首次使用时，超级块会被读入内存。</p>
<h3 id="空闲空间块"><a class="markdownIt-Anchor" href="#空闲空间块"></a> 空闲空间块</h3>
<p>接着是文件系统中空闲块的信息，例如，可以用位图或者指针列表的形式给出。</p>
<ul>
<li><code>BitMap</code> 位图或者 <code>Bit vector</code> 位向量</li>
</ul>
<p>位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：<code>0</code>和 <code>1</code>，<code>0</code> 表示已分配该块，而 <code>1</code> 表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用 <code>16位</code> 的位图表示为：<code>0000111000000110</code>。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928164045.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>使用链表进行管理</li>
</ul>
<p>在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200928164130.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="碎片"><a class="markdownIt-Anchor" href="#碎片"></a> 碎片</h3>
<p><code>碎片(fragment)</code> 也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。如果你不理解这个概念就给你举个例子。比如你用 Windows 电脑创建了一个文件，你会发现这个文件可以存储在任何地方，比如存在桌面上，存在磁盘中的文件夹中或者其他地方。你可以打开文件，编辑文件，删除文件等等。你可能以为这些都在一个地方发生，但是实际上并不是，你的硬盘驱动器可能会将文件中的一部分存储在一个区域内，另一部分存储在另外一个区域，在你打开文件时，硬盘驱动器会迅速的将文件的所有部分汇总在一起，以便其他计算机系统可以使用它。</p>
<h3 id="inode"><a class="markdownIt-Anchor" href="#inode"></a> inode</h3>
<p><code>inode(index node)</code> 也称作索引节点。它是一个数组的结构，每个文件有一个 <code>inode</code>，<code>inode</code> 非常重要，它说明了文件的方方面面。每个索引节点都存储对象数据的属性和磁盘块位置。</p>
<p><code>inode</code> 节点主要包括了以下信息</p>
<ul>
<li>
<p>模式/权限（保护）</p>
</li>
<li>
<p>所有者 ID</p>
</li>
<li>
<p>组 ID</p>
</li>
<li>
<p>文件大小</p>
</li>
<li>
<p>文件的硬链接数</p>
</li>
<li>
<p>上次访问时间</p>
</li>
<li>
<p>最后修改时间</p>
</li>
<li>
<p><code>inode</code> 上次修改时间</p>
</li>
</ul>
<p>文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 <code>inode</code> 的数量，也不能增加磁盘块的数量。</p>
<p>紧跟在 <code>inode</code> 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。</p>
<h2 id="文件的实现"><a class="markdownIt-Anchor" href="#文件的实现"></a> 文件的实现</h2>
<p>最重要的问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用了不同的方法。下面我们会探讨一下这些方式。分配背后的主要思想是<strong>有效利用文件空间和快速访问文件</strong>，主要有三种分配方案</p>
<ul>
<li>连续分配</li>
<li>链表分配</li>
<li>索引分配</li>
</ul>
<h3 id="1-连续分配"><a class="markdownIt-Anchor" href="#1-连续分配"></a> 1. 连续分配</h3>
<blockquote>
<p><code>CD-ROM</code>, <code>DVD</code>, 蓝光光盘使用了连续分配方式。</p>
</blockquote>
<p>最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929143042.png" srcset="/img/loading.gif" alt="" /></p>
<p>连续的磁盘空间分配有两个优点。</p>
<ul>
<li>
<p>第一，连续文件存储<strong>实现起来比较简单</strong>，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。</p>
</li>
<li>
<p>第二点是<strong>读取性能比较强</strong>，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。</p>
</li>
</ul>
<p>因此，连续的空间分配具有<strong>实现简单、高性能</strong>的特点。</p>
<p>但是随着时间的推移，磁盘会变得很零碎。下图解释了这种现象：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929143412.png" srcset="/img/loading.gif" alt="" /></p>
<p>这里有两个文件 <code>D</code> 和 <code>F</code> 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。</p>
<p>刚开始的时候，这个碎片不是问题，因为每个新文件都会在之前文件的结尾处进行写入。然而，磁盘最终会被填满，<strong>因此要么压缩磁盘、要么重新使用空闲块的空间</strong>。</p>
<ul>
<li>压缩磁盘的开销太大，因此不可行；</li>
<li>重新使用空闲块的空间会维护一个<strong>空闲列表</strong>，这个是可行的。但是这种情况又存在一个问题，为空闲块匹配合适大小的文件，需要知道该文件的最终大小。</li>
</ul>
<h3 id="2-链表分配"><a class="markdownIt-Anchor" href="#2-链表分配"></a> 2. 链表分配</h3>
<p>第二种存储文件的方式是为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929144116.png" srcset="/img/loading.gif" alt="" /></p>
<p>每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。整个的链表分配方案：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929144259.png" srcset="/img/loading.gif" alt="" /></p>
<p>与连续分配方案不同，这一方法<strong>可以充分利用每个磁盘块</strong>。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。</p>
<ul>
<li>
<p>在链表的分配方案中，尽管顺序读取非常方便，但是随机访问却很困难。</p>
</li>
<li>
<p>由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 <code>2</code> 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 <code>2</code> 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以<strong>要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销</strong>。</p>
</li>
</ul>
<h3 id="3-使用内存表进行链表分配"><a class="markdownIt-Anchor" href="#3-使用内存表进行链表分配"></a> 3. 使用内存表进行链表分配</h3>
<p>由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足之处。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929144918.png" srcset="/img/loading.gif" alt="" /></p>
<p>上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 <code>A</code> 依次使用了磁盘块地址 <strong>4</strong>、<strong>7</strong>、 <strong>2</strong>、 <strong>10</strong>、 <strong>12</strong>，文件 B 使用了<strong>6</strong>、<strong>3</strong>、<strong>11</strong> 和 <strong>14</strong>。也就是说，文件 <code>A</code> 从地址 <code>4</code> 处开始，顺着链表走就能找到文件 <code>A</code> 的全部磁盘块。同样，从第 <code>6</code> 块开始，顺着链走到最后，也能够找到文件 <code>B</code> 的全部磁盘块。这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为 <code>文件分配表(File Application Table, FAT)</code>。</p>
<p>使用这种组织方式，整个块都可以存放数据。进而，随机访问也容易很多。虽然仍要顺着链在内存中查找给定的偏移量，但是整个链都存放在内存中，所以不需要任何磁盘引用。与前面的方法相同，不管文件有多大，在目录项中只需记录一个整数（起始块号），按照它就可以找到文件的全部块。</p>
<p>这种方式存在缺点，那就是<strong>必须要把整个链表放在内存中</strong>。对于 1TB 的磁盘和 1KB 的大小的块，那么这张表需要有 10 亿项。每一项对应于这 10 亿个磁盘块中的一块。每项至少 3 个字节，为了提高查找速度，有时需要 4 个字节。根据系统对空间或时间的优化方案，这张表要占用 3GB 或 2.4GB 的内存。FAT 的管理方式不能较好地扩展并应用于大型磁盘中。而这正是最初 MS-DOS 文件比较实用，并仍被各个 Windows 版本所完全支持。</p>
<h3 id="4-inode"><a class="markdownIt-Anchor" href="#4-inode"></a> 4. inode</h3>
<p>最后一个记录各个文件分别包含哪些磁盘块的方法是给每个文件赋予一个称为 <code>inode(索引节点)</code> 的数据结构，每个文件都与一个 <code>inode</code> 进行关联，<code>inode</code> 由整数进行标识。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929150217.png" srcset="/img/loading.gif" alt="" /></p>
<p>给出 <code>inode</code> 的长度，就能够找到文件中的所有块。</p>
<p>相对于在内存中使用表的方式而言，这种机制具有很大的优势。即<strong>只有在文件打开时，其 <code>inode</code> 才会在内存中</strong>。如果每个 <code>inode</code> 需要 <code>n</code> 个字节，最多 <code>k</code> 个文件同时打开，那么 <code>inode</code> 占有总共打开的文件是 <code>kn</code> 字节。仅需预留这么多空间。</p>
<p>这个数组要比我们上面描述的 <code>FAT(文件分配表)</code> 占用的空间小的多。原因是<strong>用于保存所有磁盘块的链接列表的表的大小与磁盘本身成正比</strong>。如果磁盘有 <code>n</code> 个块，那么这个表也需要 <code>n</code> 项。随着磁盘空间的变大，那么该表也随之线性增长。相反，<code>inode</code> 需要在内存中有数组，其大小和可能需要打开的最大文件个数成正比。它与磁盘是 <code>100GB</code>、<code>4000GB</code> 还是 <code>10000GB</code> 无关。</p>
<p><code>inode</code> 的一个问题是如果每个节点都会有固定大小的磁盘地址，那么文件增长到所能允许的最大容量外会发生什么？一个解决方案是<strong>最后一个磁盘地址不指向数据块</strong>，而是指向一个包含额外磁盘块地址的地址，如上图所示。一个更高级的解决方案是：<strong>有两个或者更多包含磁盘地址的块，或者指向其他存放地址的磁盘块的磁盘块。</strong> <code>Windows</code> 的 <code>NTFS</code> 文件系统采用了相似的方法，所不同的仅仅是大的 <code>inode</code> 也可以表示小的文件。</p>
<blockquote>
<p><code>NTFS</code> 的全称是 <code>New Technology File System</code>，是微软公司开发的专用系统文件，<code>NTFS</code> 取代 <code>FAT(文件分配表)</code> 和 <code>HPFS(高性能文件系统)</code>，并在此基础上进一步改进。例如增强对元数据的支持，使用更高级的数据结构以提升性能、可靠性和磁盘空间利用率等。</p>
</blockquote>
<h2 id="目录的实现"><a class="markdownIt-Anchor" href="#目录的实现"></a> 目录的实现</h2>
<p>文件只有打开后才能够被读取。在文件打开后，操作系统会使用用户提供的路径名来定位磁盘中的目录。目录项提供了查找文件磁盘块所需要的信息。根据系统的不同，提供的信息也不同，可能提供的信息是整个文件的磁盘地址，或者是第一个块的数量（两个链表方案）或 inode 的数量。不过不管用哪种情况，目录系统的主要功能就是 <strong>将文件的 <code>ASCII</code> 码的名称映射到定位数据所需的信息上。</strong></p>
<p>与此关系密切的问题是属性应该存放在哪里。每个文件系统包含不同的文件属性，例如文件的所有者和创建时间，需要存储的位置。一种显而易见的方法是直接把文件属性存放在目录中。有一些系统恰好是这么做的，如下：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929151603.png" srcset="/img/loading.gif" alt="" /></p>
<p>在这种简单的设计中，目录有一个固定大小的目录项列表，每个文件对应一项，其中包含一个固定长度的文件名，文件属性的结构体以及用以说明磁盘块位置的一个或多个磁盘地址。</p>
<p>对于采用 <code>inode</code> 的系统，会把 <code>inode</code> 存储在属性中而不是目录项中。在这种情况下，目录项会更短：仅仅只有文件名称和 <code>inode</code> 数量。这种方式如下所示：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929151753.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="可变长度扩展名"><a class="markdownIt-Anchor" href="#可变长度扩展名"></a> 可变长度扩展名</h3>
<p>到目前为止，我们已经假设文件具有较短的、固定长度的名字。在 <code>MS-DOS</code> 中，具有 1 - 8 个字符的基本名称和 1 - 3 个字符的可拓展名称。在 <code>UNIX</code> 版本 7 中，文件有 1 - 14 个字符，包括任何拓展。然而，几乎所有的现代操作系统都支持可变长度的扩展名。这是如何实现的呢？</p>
<p>最简单的方式是给予文件名一个长度限制，比如 255 个字符，然后使用上图中的设计，并为每个文件名保留 255 个字符空间。这种处理很简单，但是浪费了大量的目录空间，因为只有很少的文件会有那么长的文件名称。所以，需要一种其他的结构来处理。</p>
<p>一种可选择的方式是放弃所有目录项大小相同的想法。在这种方法中，每个目录项都包含一个固定部分，这个固定部分通常以目录项的长度开始，后面是固定格式的数据，通常包括所有者、创建时间、保护信息和其他属性。这个固定长度的头的后面是一个任意长度的实际文件名，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929151951.png" srcset="/img/loading.gif" alt="" /></p>
<p>这个例子中，有三个文件，分别是 <code>project-budget</code>、<code>personnel</code> 和 <code>foo</code>。每个文件名以一个特殊字符（通常是 0 ）结束，用矩形中的叉进行表示。为了使每个目录项从字的边界开始，每个文件名被填充成整数个字，如下图所示</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929152139.png" srcset="/img/loading.gif" alt="" /></p>
<p>这个方法的缺点是当文件被移除后，就会留下一块固定长度的空间，而新添加进来的文件大小不一定和空闲空间大小一致。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929152203.png" srcset="/img/loading.gif" alt="" /></p>
<p>这个问题与我们上面探讨的连续磁盘文件的问题是一样的，由于整个目录在内存中，所以只有对目录进行<strong>紧凑拼接</strong>操作才可节省空间。另一个问题是，一个目录项可能会分布在多个页上，在读取文件名时可能发生<strong>缺页中断</strong>。</p>
<p>处理可变长度文件名字的另外一种方法是，<strong>使目录项自身具有固定长度，而将文件名放在目录末尾的堆栈中。</strong> 如上图所示的这种方式。这种方法的优点是当目录项被移除后，下一个文件将能够正常匹配移除文件的空间。当然，必须要对堆进行管理，因为在处理文件名的时候也会发生缺页异常。</p>
<h3 id="加快文件查找"><a class="markdownIt-Anchor" href="#加快文件查找"></a> 加快文件查找</h3>
<p>到目前为止的所有设计中，在需要查找文件名时，所有的方案都是线性的从头到尾对目录进行搜索。对于特别长的目录，线性搜索的效率很低。提高文件检索效率的一种方式是在每个目录上使用 <code>哈希表(hash table)</code>。</p>
<ul>
<li>
<p>添加：无论采用哪种方式，<strong>在添加一个文件时都要对与散列值相对 应的散列表进行检查。</strong> 如果没有使用过，就会将一个指向目录项的指针指向这里。文件目录项紧跟着哈希表后面。如果已经使用过，就会构造一个链表，链表的表头指针存放在表项中，并通过哈希值将所有的表项相连。</p>
</li>
<li>
<p>查找：查找文件的过程和添加类似，首先对文件名进行哈希处理，在哈希表中查找是否有这个哈希值，如果有的话，就检查这条链上所有的哈希项，查看文件名是否存在。如果哈希不在链上，那么文件就不在目录中。</p>
</li>
</ul>
<p>使用哈希表的优势是查找非常迅速，缺点是管理起来非常复杂。只有在系统中会有成千上万个目录项存在时，才会考虑使用散列表作为解决方案。</p>
<p>另外一种在大量目录中加快查找指令目录的方法是使用<code>缓存</code>，缓存查找的结果。在开始查找之前，会首先检查文件名是否在缓存中。如果在缓存中，那么文件就能立刻定位。当然，只有在较少的文件下进行多次查找，缓存才会发挥最大功效。</p>
<h2 id="共享文件"><a class="markdownIt-Anchor" href="#共享文件"></a> 共享文件</h2>
<p>当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图我们在上面提到过，但是有一个更改的地方，就是 <code>C</code> 的一个文件也出现在了 <code>B</code> 的目录下。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929153128.png" srcset="/img/loading.gif" alt="" /></p>
<p>如果按照如上图的这种组织方式而言，那么 <code>B</code> 的目录与该共享文件的联系称为 <code>链接(link)</code>。那么文件系统现在就是一个 <code>有向无环图(Directed Acyclic Graph, 简称 DAG)</code>，而不是一棵树了。</p>
<p>将文件系统组织成为有向无环图会使得维护复杂化，但也是必须要付出的代价。</p>
<p>共享文件很方便，但这也会带来一些问题。<strong>如果目录中包含磁盘地址，则当链接文件时，必须把 <code>C</code> 目录中的磁盘地址复制到 <code>B</code> 目录中。</strong> 如果 <code>B</code> 或者 <code>C</code> 随后又向文件中添加内容，则仅在执行追加的用户的目录中显示新写入的数据块。这种变更将会对其他用户不可见，从而破坏了共享的目的。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929153402.png" srcset="/img/loading.gif" alt="" /></p>
<p>有两种方案可以解决这种问题。</p>
<ul>
<li>
<p>第一种解决方案，<strong>磁盘块不列入目录中</strong>，而是会把磁盘块放在与文件本身相关联的 <code>inode</code> 中。目录将指向这个 <code>inode</code>。这是 <code>UNIX</code> 中使用的方式。</p>
</li>
<li>
<p>在第二种解决方案中，通过让系统建立一个类型为 <code>LINK</code> 的新文件，并把该文件放在 <code>B</code> 的目录下，使得 <code>B</code> 与 <code>C</code> 建立链接。新的文件中只包含了它所链接的文件的路径名。当 <code>B</code> 想要读取文件时，操作系统会检查 <code>B</code> 的目录下存在一个类型为 <code>LINK</code> 的文件，进而找到该链接的文件和路径名，然后再去读文件，这种方式称为 <code>符号链接(symbolic linking)</code>。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929153627.png" srcset="/img/loading.gif" alt="" /></p>
<h2 id="日志结构文件系统"><a class="markdownIt-Anchor" href="#日志结构文件系统"></a> 日志结构文件系统</h2>
<p><code>日志结构文件系统(Log-structured File System, LFS)</code> 旨在解决以下问题：</p>
<ul>
<li>
<p>不断增长的系统内存</p>
</li>
<li>
<p>顺序 <code>I/O</code> 性能胜过随机 <code>I/O</code> 性能</p>
</li>
<li>
<p>现有低效率的文件系统</p>
</li>
<li>
<p>文件系统不支持 <code>RAID（虚拟化）</code></p>
</li>
</ul>
<p>不论是 <code>UNIX</code> 还是 <code>FFS</code>，都有大量的随机读写，因此成为整个系统的性能瓶颈。同时因为 <code>Page cache</code> 的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 <code>cache</code>，因此 <code>LFS</code> 主要要解决的是<strong>减少对硬盘的随机写操作</strong>。</p>
<p>在这种设计中，<code>inode</code> 甚至具有与 <code>UNIX</code> 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，<code>inode</code> 很难定位。为了能够找到 <code>inode</code> ，维护了一个由 <code>inode</code> 索引的 <code>inode map</code>。表项 <code>i</code> 指向磁盘中的第 <code>i</code> 个 <code>inode</code>。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。</p>
<blockquote>
<p>日志结构文件系统主要使用四种数据结构：<code>Inode</code>、<code>Inode Map</code>、<code>Segment</code>、<code>Segment Usage Table</code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929160054.png" srcset="/img/loading.gif" alt="" /></p>
<p>到目前为止，所有写入最初都缓存在内存中，并且追加在日志末尾，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。</p>
<p>真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 <code>inode</code> 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。</p>
<p>为了处理这个问题，LFS 有一个 <code>清理（clean）线程</code>，<strong>它会循环扫描日志并对日志进行压缩</strong>。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 <code>inode</code> 的映射来查看 <code>inode</code> 否在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 <code>inode</code> 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的环形缓冲区，写线程将新的段写在前面，而清理线程则清理后面的段。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929160520.png" srcset="/img/loading.gif" alt="" /></p>
<h2 id="日志文件系统"><a class="markdownIt-Anchor" href="#日志文件系统"></a> 日志文件系统</h2>
<p>虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做日志文件系统，它会保存一个系统下一步将要做什么的日志。微软的 <code>NTFS</code> 文件系统、<code>Linux</code> 的 <code>ext3</code> 就使用了日志。 <code>OS X</code> 将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如 <code>移除文件</code>，这个操作在 <code>UNIX</code> 中需要三个步骤完成：</p>
<ol>
<li>在目录中删除文件</li>
<li>释放 <code>inode</code> 到空闲 <code>inode</code> 池</li>
<li>将所有磁盘块归还给空闲磁盘池。</li>
</ol>
<p>为了让日志能够正确工作，被写入的日志操作必须是 <code>幂等的(idempotent)</code>，它意味着只要有必要，它们就可以重复执行很多次，并不会带来破坏。像操作 <code>更新位表并标记 inode k 或者块 n 是空闲的</code> 可以重复执行任意次。同样地，查找一个目录并且删除所有叫 foobar 的项也是幂等的。相反，把从 inode k 新释放的块加入空闲表的末端不是幂等的，因为它们可能已经被释放并存放在那里了。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929161137.png" srcset="/img/loading.gif" alt="" /></p>
<p>为了增加可靠性，一个文件系统可以引入数据库中 <code>原子事务(atomic transaction)</code> 的概念。使用这个概念，一组动作可以被界定在开始事务和结束事务操作之间。这样，文件系统就会知道它必须完成所有的动作，要么就一个不做。</p>
<h2 id="虚拟文件系统"><a class="markdownIt-Anchor" href="#虚拟文件系统"></a> 虚拟文件系统</h2>
<p>即使在同一台计算机上或者在同一个操作系统下，都会使用很多不同的文件系统。Windows 中的主要文件系统是 NTFS 文件系统，但不是说 Windows 只有 NTFS 操作系统，它还有一些其他的例如旧的 FAT -32 或 FAT -16 驱动器或分区，其中包含仍需要的数据，闪存驱动器，旧的 CD-ROM 或 DVD（每个都有自己的独特文件系统）。<strong>Windows 通过指定不同的盘符来处理这些不同的文件系统</strong>，比如 <code>C:</code>，<code>D:</code> 等。盘符可以显示存在也可以隐式存在，如果你想找指定位置的文件，那么盘符是显示存在；如果当一个进程打开一个文件时，此时盘符是隐式存在，所以 Windows 知道向哪个文件系统传递请求。</p>
<p><code>UNIX</code> 采用了一种不同的方式，即 <strong><code>UNIX</code> 把多种文件系统整合到一个统一的结构中</strong>。一个 <code>Linux</code> 系统可以使用 ext2 作为根文件系统，ext3 分区装载在 /usr 下，另一块采用 Reiser FS 文件系统的硬盘装载到 /home下，以及一个 ISO 9660 的 CD - ROM 临时装载到 /mnt 下。从用户的观点来看，只有一个文件系统层级，但是事实上它们是由多个文件系统组合而成，<strong>对于用户和进程是不可见的</strong>。</p>
<p><code>UNIX</code> 操作系统使用一种 <code>虚拟文件系统(Virtual File System, VFS)</code> 来尝试将多种文件系统构成一个有序的结构。关键的思想是<strong>抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。</strong> 下面是一个 <code>VFS</code> 的系统结构：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200929161745.png" srcset="/img/loading.gif" alt="" /></p>
<p>所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的 <code>POSIX</code> 系统调用，比如 <code>open</code>、<code>read</code>、<code>write</code> 和 <code>seek</code> 等。VFS 对用户进程有一个 <code>上层</code> 接口，这个接口就是著名的 <code>POSIX</code> 接口。</p>
<p><code>VFS</code> 也有一个对于实际文件的 <code>下层</code> 接口，就是上图中标记为 <code>VFS</code> 的接口。这个接口包含许多<strong>功能调用</strong>，这样 <code>VFS</code> 可以使每一个文件系统完成任务。因此，要创建一个可以与 <code>VFS</code> 一起使用的新文件系统，新文件系统的设计者必须确保它提供了 <code>VFS</code> 要求的功能。一个明显的例子是从磁盘读取特定的块，然后将其放入文件系统的缓冲区高速缓存中，然后返回指向该块的指针的函数。 因此，<code>VFS</code> 具有两个不同的接口：<strong>上一个到用户进程，下一个到具体文件系统</strong>。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/09/28/LeetCode-offer-59-hua-dong-chuang-kou-de-zui-da-zhi-lcof/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">剑指 Offer 59 - I. 滑动窗口的最大值</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/09/27/LeetCode-978-longest-turbulent-subarray/">
                        <span class="hidden-mobile">LeetCode 978. 最长湍流子数组</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <!-- <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> -->
      Crafted with
      <i class="iconfont icon-love" style="color: #f30;"></i>
      by <a href="https://github.com/likailee" target="_blank" rel="noopener">Likai Lee</a>
      | &copy; 2017 - 2020
      <!-- <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a> -->
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?66c61a5fd59052d1b39d89c246846ae5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
