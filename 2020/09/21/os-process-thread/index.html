<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Likai Lee">
  <meta name="keywords" content="">
  <title>操作系统 进程与线程 - Likai Lee</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Likai Lee</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                操作系统 进程与线程
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-09-21 15:28">
      2020年9月21日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      62
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年9月21日 下午
                
              </p>
            
            <article class="markdown-body">
              <p>[TOC]</p>
<h1 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h1>
<p><strong>进程是操作系统对正在运行中的程序的一个抽象</strong>，操作系统的其他所有内容都是通过进程展开的。无论是在单核还是多核 <code>CPU</code> 中，一个 <code>CPU</code> 都像是在<strong>并发</strong>地执行多个进程，这是通过处理器在进程间切换来实现的，即<strong>伪并行</strong>。</p>
<blockquote>
<p><code>伪并行</code>是指单核或多核处理器同时执行多个进程，从而使程序更快。 通过以<strong>非常有限的时间间隔在程序之间快速切换 <code>CPU</code></strong>，因此会产生并行感。 缺点是 <code>CPU</code> 时间可能分配给下一个进程，也可能不分配给下一个进程。</p>
</blockquote>
<h2 id="进程模型"><a class="markdownIt-Anchor" href="#进程模型"></a> 进程模型</h2>
<p>在进程模型中，所有计算机上运行的软件，通常也包括操作系统，被组织为若干<strong>顺序进程</strong>(<code>sequential processes</code>)，简称为 <strong>进程</strong>(<code>process</code>) 。一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 <code>CPU</code>，但是实际情况是 <code>CPU</code> 会在各个进程之间进行来回切换。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200918135528.png" srcset="/img/loading.gif" alt="" /><br />
如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200918135549.png" srcset="/img/loading.gif" alt="" /><br />
在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。<br />
当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。<br />
当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p>
<p>从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，但<strong>在任何一个给定的瞬间仅有一个进程真正运行。</strong><br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200918135606.png" srcset="/img/loading.gif" alt="" /></p>
<p>因此，当我们说一个 <code>CPU</code> 只能真正一次运行一个进程的时候，即使有 <code>2</code> 个核（或 <code>CPU</code>），<strong>每一个核也只能一次运行一个线程</strong>。</p>
<p>这里的关键思想是认识到一个进程所需的条件，<strong>进程是某一类特定活动的总和，它有程序、输入输出以及状态。</strong> 单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务。<br />
另外需要注意的是，如果一个进程运行了两遍，则被认为是两个进程，操作系统能够使它们共享代码，因此只有一个副本放在内存中。</p>
<h2 id="进程的创建"><a class="markdownIt-Anchor" href="#进程的创建"></a> 进程的创建</h2>
<p>创建进程的方式:</p>
<ol>
<li>系统初始化（<code>init</code>）</li>
<li>正在运行的程序执行了创建进程的系统调用（比如 fork）</li>
<li>用户请求创建一个新进程</li>
<li>初始化一个批处理工作</li>
</ol>
<p>在 <code>UNIX</code> 和 <code>Windows</code> 中，进程创建之后，<strong>父进程和子进程有各自不同的地址空间</strong>。如果其中某个进程在其地址空间中修改了一个字，这个修改将对另一个进程不可见。</p>
<ul>
<li>
<p>在 <code>UNIX</code> 中，子进程的地址空间是父进程的一个副本，但是这里涉及两个不同的地址空间；<strong>不可写的内存区域是共享的</strong>，<strong>可写的内存是不能被共享的</strong>。<br />
某些 <code>UNIX</code> 实现使子进程共享父进程的所有内存，但是这种情况下通过 <code>写时复制 (copy-on-write)</code> 共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。但是，对于一个新创建的进程来说，确实有可能共享创建者的资源，比如可以共享打开的文件。</p>
</li>
<li>
<p>在 <code>Windows</code> 中，从一开始父进程的地址空间和子进程的地址空间就是不同的。</p>
</li>
</ul>
<h3 id="1-系统初始化"><a class="markdownIt-Anchor" href="#1-系统初始化"></a> 1. 系统初始化</h3>
<p>启动操作系统时，通常会创建若干个进程。</p>
<ul>
<li><code>前台进程 (numerous processes</code>) 同用户进行交互并替他们完成工作的进程。</li>
<li><code>守护进程 (daemons)</code> 运行在后台，并不与特定的用户进行交互。</li>
</ul>
<h3 id="2-系统调用创建"><a class="markdownIt-Anchor" href="#2-系统调用创建"></a> 2. 系统调用创建</h3>
<p>一个正在运行的进程会发出<code>系统调用</code>用来创建一个或多个新进程来帮助其完成工作。</p>
<p>例如，如果有大量的数据需要经过网络调取并进行顺序处理，那么创建一个进程读数据，并把数据放到共享缓冲区中，而让第二个进程取走并正确处理会比较容易些。在多处理器中，让每个进程运行在不同的 CPU 上也可以使工作做的更快。</p>
<h3 id="3-用户请求创建"><a class="markdownIt-Anchor" href="#3-用户请求创建"></a> 3. 用户请求创建</h3>
<p>在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。在 Windows 中启动进程时，它一般没有窗口，但是它可以创建一个或多个窗口。每个窗口都可以运行进程。通过鼠标或者命令就可以切换窗口并与进程进行交互。</p>
<h3 id="4-批处理创建"><a class="markdownIt-Anchor" href="#4-批处理创建"></a> 4. 批处理创建</h3>
<p>批处理创建会在大型机的<code>批处理系统</code>中应用。用户在这种系统中提交批处理作业。当操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业。</p>
<h2 id="进程的终止"><a class="markdownIt-Anchor" href="#进程的终止"></a> 进程的终止</h2>
<p>进程在创建之后，它就开始运行并做完成任务。然而，进程早晚会发生终止，通常是由于以下情况触发的</p>
<ol>
<li>正常退出(自愿的)</li>
<li>错误退出(自愿的)</li>
<li>严重错误(非自愿的)</li>
<li>被其他进程杀死(非自愿的)</li>
</ol>
<h3 id="1-正常退出自愿的"><a class="markdownIt-Anchor" href="#1-正常退出自愿的"></a> 1. 正常退出(自愿的)</h3>
<p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。<br />
这个调用在 <code>UNIX</code> 中是 <code>exit</code> ，在 <code>Windows</code> 中是 <code>ExitProcess</code>。</p>
<h3 id="2-错误退出自愿的"><a class="markdownIt-Anchor" href="#2-错误退出自愿的"></a> 2. 错误退出(自愿的)</h3>
<p>进程发生终止的第二个原因是发现错误。<br />
例如，如果用户执行如下命令</p>
<pre><code class="hljs bash">cc foo.c</code></pre>
<p>要编译 <code>foo.c</code> 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p>
<h3 id="3-严重错误非自愿的"><a class="markdownIt-Anchor" href="#3-严重错误非自愿的"></a> 3. 严重错误(非自愿的)</h3>
<p>严重错误通常是由于程序中的错误所导致的。<br />
例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 <code>UNIX</code> 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p>
<h3 id="4-被其他进程杀死非自愿的"><a class="markdownIt-Anchor" href="#4-被其他进程杀死非自愿的"></a> 4. 被其他进程杀死(非自愿的)</h3>
<p>某个进程执行<strong>系统调用</strong>告诉操作系统杀死某个进程。在 <code>UNIX</code> 中，这个系统调用是 <code>kill</code>。在 <code>Win32</code> 中对应的函数是 <code>TerminateProcess</code>。</p>
<h2 id="进程的层次结构"><a class="markdownIt-Anchor" href="#进程的层次结构"></a> 进程的层次结构</h2>
<p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p>
<h3 id="unix-进程体系"><a class="markdownIt-Anchor" href="#unix-进程体系"></a> <code>UNIX</code> 进程体系</h3>
<p>在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 <code>kill</code> 掉。</p>
<p><code>UNIX</code> 在启动时会运行 <code>init</code> 进程，它会初始化多个子进程，因此，整个操作系统中的所有进程都属于一个以 <code>init</code> 为根的进程树。</p>
<h3 id="windows-进程体系"><a class="markdownIt-Anchor" href="#windows-进程体系"></a> <code>Windows</code> 进程体系</h3>
<p><code>Windows</code> 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为<code>句柄</code>），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 <code>UNIX</code> 中，进程不能剥夺其子进程的 <strong>进程权</strong>。</p>
<h2 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h2>
<p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。例如，一个进程的结果可以作为另一个进程的输入，在 <code>shell</code> 命令中</p>
<pre><code class="hljs shell">cat chapter1 chapter2 chapter3 | grep tree</code></pre>
<p>第一个进程是 <code>cat</code>，将三个文件级联并输出。第二个进程是 <code>grep</code>，它从输入中选择具有包含关键字 <code>tree</code> 的内容，根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的 <code>CPU</code> 时间片），可能会发生下面这种情况，<code>grep</code> 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞 <code>grep</code> 进程，直到输入完毕。</p>
<p>当一个进程开始运行时，它可能会经历下面这几种状态</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921150701.png" srcset="/img/loading.gif" alt="" /></p>
<p>图中会涉及三种状态：</p>
<ol>
<li><strong>运行态</strong>，该时刻进程实际占用 <code>CPU</code>。</li>
<li><strong>就绪态</strong>，可运行，但因为其他进程正在运行而处于就绪状态。</li>
<li><strong>阻塞态</strong>，除非某种外部事件发生，否则进程不能运行。</li>
</ol>
<ul>
<li>逻辑上来说，运行态和就绪态是很相似的。都表示进程可运行，但是<strong>就绪态</strong>没有获得 <code>CPU</code> 时间分片。</li>
<li>阻塞态与前两种状态不同的原因是<strong>这个进程不能运行，<code>CPU</code> 空闲时也不能运行</strong>。</li>
</ul>
<p>三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生 <code>状态 1</code> 的轮转。<br />
<code>转换 2</code> 和<code>转换 3</code> 都是由进程调度程序引起的，进程本身不知道调度程序的存在。<br />
<code>转换 2</code> 的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行 <code>CPU</code> 时间片了。<br />
当所有其他进程都运行过后，这时候该是让第一个进程重新获得 <code>CPU</code> 时间片的时候了，就会发生<code>转换 3</code>。</p>
<blockquote>
<p>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p>
</blockquote>
<p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生<code>转换 4</code>。如果此时没有其他进程在运行，则立刻触发<code>转换 3</code>，该进程便开始运行，否则该进程会处于就绪阶段，等待 <code>CPU</code> 空闲后再轮到它运行。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921152100.png" srcset="/img/loading.gif" alt="" /></p>
<p><strong>操作系统最底层的就是调度程序</strong>，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。事实上，调度程序只是一段非常小的程序。</p>
<h2 id="进程的实现"><a class="markdownIt-Anchor" href="#进程的实现"></a> 进程的实现</h2>
<p>操作系统为了执行进程间的切换，会维护着一张表格，这张表就是 <code>进程表(process table)</code>。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括<strong>程序计数器</strong>、<strong>堆栈指针</strong>、<strong>内存分配状况</strong>、<strong>所打开文件的状态</strong>、<strong>账号和调度信息</strong>，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921152615.webp" srcset="/img/loading.gif" alt="" /></p>
<p>第一列内容与 <strong>进程管理</strong> 有关，第二列内容与 <strong>存储管理</strong> 有关，第三列内容与 <strong>文件管理</strong> 有关。</p>
<h1 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h1>
<h2 id="线程的使用"><a class="markdownIt-Anchor" href="#线程的使用"></a> 线程的使用</h2>
<p>为什么要在进程的基础上再创建一个线程的概念：</p>
<ul>
<li>多线程之间会<strong>共享同一块地址空间和所有可用数据</strong>的能力，这是进程所不具备的。</li>
<li>线程要比进程更<strong>轻量级</strong>，它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 <code>10 - 100</code> 倍。</li>
<li>性能方面：如果多个线程都是 <code>CPU</code> 密集型的，那么并不能获得性能上的增强，但是如果存在着<strong>大量的计算和大量的 <code>I/O</code> 处理</strong>，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度。</li>
</ul>
<h3 id="1-多线程解决方案"><a class="markdownIt-Anchor" href="#1-多线程解决方案"></a> 1. 多线程解决方案</h3>
<p>一个 WEB 服务器，对页面的请求发送给服务器，而所请求的页面发送回客户端。在多数 WEB 站点上，某些页面较其他页面相比有更多的访问。Web 服务器可以把获得大量访问的页面集合保存在内存中，避免到磁盘去调入这些页面，从而改善性能。这种页面的集合称为 <code>高速缓存(cache)</code>，高速缓存也应用在许多场合中，比如说 <code>CPU</code> 缓存。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921153549.png" srcset="/img/loading.gif" alt="" /></p>
<p>上面是一个 web 服务器的组织方式，一个叫做 <code>调度线程(dispatcher thread)</code> 的线程从网络中读入工作请求，在调度线程检查完请求后，它会选择一个空闲的（阻塞的）工作线程来处理请求，通常是将消息的指针写入到每个线程关联的特殊字中。然后调度线程会唤醒正在睡眠中的工作线程，把工作线程的状态从阻塞态变为就绪态。</p>
<p>当<code>工作线程</code>启动后，它会检查请求是否在 web 页面的高速缓存中存在，这个高速缓存是所有线程都可以访问的。如果高速缓存不存在这个 web 页面的话，它会调用一个 read 操作从磁盘中获取页面并且阻塞线程直到磁盘操作完成。当线程阻塞在硬盘操作的期间，为了完成更多的工作，调度线程可能挑选另一个线程运行，也可能把另一个当前就绪的工作线程投入运行。</p>
<p>这种模型允许<strong>将服务器编写为顺序线程</strong>的集合，在分派线程的程序中包含一个死循环，该循环用来获得工作请求并且把请求派给工作线程。每个工作线程的代码包含一个从调度线程接收的请求，并且检查 web 高速缓存中是否存在所需页面，如果有，直接把该页面返回给客户，接着工作线程阻塞，等待一个新请求的到达。如果没有，工作线程就从磁盘调入该页面，将该页面返回给客户机，然后工作线程阻塞，等待一个新请求。</p>
<h3 id="2-单线程解决方案"><a class="markdownIt-Anchor" href="#2-单线程解决方案"></a> 2. 单线程解决方案</h3>
<p>Web 服务器的主循环获取请求并检查请求，并争取在下一个请求之前完成工作。在等待磁盘操作时，服务器空转，并且不处理任何到来的其他请求。结果会导致每秒中只有很少的请求被处理，所以这个例子能够说明多线程提高了程序的并行性并提高了程序的性能。</p>
<h3 id="3-状态机解决方案"><a class="markdownIt-Anchor" href="#3-状态机解决方案"></a> 3. 状态机解决方案</h3>
<p>如果目前只有一个非阻塞版本的 read 系统调用可以使用，那么当请求到达服务器时，这个唯一的 read 调用的线程会进行检查，如果能够从高速缓存中得到响应，那么直接返回，如果不能，则启动一个非阻塞的磁盘操作。</p>
<p>服务器在表中记录当前请求的状态，然后进入并获取下一个事件，紧接着下一个事件可能就是一个新工作的请求或是磁盘对先前操作的回答。如果是新工作的请求，那么就开始处理请求。如果是磁盘的响应，就从表中取出对应的状态信息进行处理。对于非阻塞式磁盘 I/O 而言，这种响应一般都是信号中断响应。</p>
<p>每次服务器从某个请求工作的状态切换到另一个状态时，都必须显示的保存或者重新装入相应的计算状态。这里，每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为 <code>有限状态机(finite-state machine)</code>。</p>
<ul>
<li>多线程使得顺序进程的思想得以保留下来，并且实现了<strong>并行性</strong>，但是顺序进程会<strong>阻塞系统调用</strong>；</li>
<li>单线程服务器保留了阻塞系统的简易性，但是却放弃了性能。</li>
<li>有限状态机的处理方法运用了<strong>非阻塞调用</strong>和中断，通过<strong>并行</strong>实现了高性能，但是给编程增加了困难。</li>
</ul>
<h2 id="经典的线程模型"><a class="markdownIt-Anchor" href="#经典的线程模型"></a> 经典的线程模型</h2>
<p>组成：</p>
<ul>
<li><strong>程序计数器</strong>，记录接着要执行哪一条指令；</li>
<li><strong>寄存器</strong>，保存线程当前正在使用的变量；</li>
<li><strong>堆栈</strong>，记录程序的执行路径。</li>
</ul>
<p>在同一个进程中，允许彼此之间有较大的独立性且互不干扰。在一个进程中并行运行多个线程类似于在一台计算机上运行多个进程。<br />
在多个线程中，各个线程共享同一地址空间和其他资源。<br />
在多个进程中，进程共享物理内存、磁盘、打印机和其他资源。因为线程会包含有一些进程的属性，所以线程被称为轻量的进程(<code>lightweight processes</code>)。</p>
<p>三个进程，每个进程有自己的地址空间和单个控制线程，每个线程都在不同的地址空间中运行。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155110.png" srcset="/img/loading.gif" alt="" /></p>
<p>一个进程三个线程的情况。每个线程都在相同的地址空间中运行。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155327.png" srcset="/img/loading.gif" alt="" /></p>
<p>线程不像是进程那样具备较强的独立性。<strong>同一个进程中的所有线程都会有完全一样的地址空间</strong>，这意味着它们也<strong>共享同样的全局变量</strong>。由于每个线程都可以访问进程地址空间内每个内存地址，因此一个线程可以读取、写入甚至擦除另一个线程的堆栈。线程之间除了共享同一内存空间外，还具有如下不同的内容：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155439.png" srcset="/img/loading.gif" alt="" /></p>
<p>和进程一样，线程可以处于下面这几种状态：<strong>运行</strong>、<strong>阻塞</strong>、<strong>就绪</strong>和<strong>终止</strong>。<br />
正在运行的线程拥有 <code>CPU</code> 时间片并且状态是运行中。<br />
一个被阻塞的线程会等待某个释放它的事件。<br />
例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞直到有输入为止。线程通常会被阻塞，直到它等待某个外部事件的发生或者有其他线程来释放它。线程之间的状态转换和进程之间的状态转换是一样的。</p>
<p>每个线程都会有自己的堆栈，如下图所示<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155658.png" srcset="/img/loading.gif" alt="" /></p>
<h2 id="线程实现"><a class="markdownIt-Anchor" href="#线程实现"></a> 线程实现</h2>
<h3 id="1-在用户空间中实现线程"><a class="markdownIt-Anchor" href="#1-在用户空间中实现线程"></a> 1. 在用户空间中实现线程</h3>
<p>第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921160042.png" srcset="/img/loading.gif" alt="" /><br />
线程在运行时系统之上运行，运行时系统是管理线程过程的集合。</p>
<blockquote>
<p><code>运行时系统(Runtime System)</code> 也叫做运行时环境，<strong>该运行时系统提供了程序在其中运行的环境</strong>。此环境可能会解决许多问题，包括应用程序内存的布局，程序如何访问变量，在过程之间传递参数的机制，与操作系统的接口等等。编译器根据特定的运行时系统进行假设以生成正确的代码。通常，运行时系统将负责设置和管理堆栈，并且会包含诸如垃圾收集，线程或语言内置的其他动态的功能。</p>
</blockquote>
<p>在用户空间管理线程时，每个进程需要有其专用的 <code>线程表(thread table)</code>，<strong>用来跟踪该进程中的线程</strong>。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器和状态。<strong>该线程标由运行时系统统一管理</strong>。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程的所有信息，与内核在进程表中存放的信息完全一样。</p>
<p>优势：</p>
<ul>
<li>
<p>保存线程的状态和调度程序都是<code>本地过程</code>，所以启动他们比进行内核调用效率更高。因而<strong>不需要切换到内核，也就不需要上下文切换，也不需要对内存高速缓存进行刷新，因为线程调度非常便捷，因此效率比较高。</strong></p>
</li>
<li>
<p>允许每个进程有自己定制的调度算法。</p>
</li>
</ul>
<h3 id="2-在内核空间中实现线程"><a class="markdownIt-Anchor" href="#2-在内核空间中实现线程"></a> 2. 在内核空间中实现线程</h3>
<p>使用内核来实现线程的情况，<strong>不再需要运行时环境</strong>，<strong>每个进程中也没有线程表</strong>。相反，在内核中会有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921161156.png" srcset="/img/loading.gif" alt="" /></p>
<p>所有能够阻塞的调用都会通过<strong>系统调用</strong>的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 <code>CPU</code> 时间片（或者没有可运行的线程存在了）为止。</p>
<p>由于在内核中创建或者销毁线程的开销比较大，所以某些系统会采用<strong>可循环利用</strong>的方式来回收线程。<br />
当某个线程被销毁时，就把它标志为不可运行的状态，但是其内部结构没有受到影响。稍后，在必须创建一个新线程时，就会重新启用旧线程，把它标志为可用状态。</p>
<h3 id="3-在用户和内核空间中混合实现线程"><a class="markdownIt-Anchor" href="#3-在用户和内核空间中混合实现线程"></a> 3. 在用户和内核空间中混合实现线程</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921161507.png" srcset="/img/loading.gif" alt="" /></p>
<p>在这种模型中，<strong>编程人员可以自由控制用户线程和内核线程的数量</strong>，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程<strong>多路复用</strong>。</p>
<h1 id="进程间通信"><a class="markdownIt-Anchor" href="#进程间通信"></a> 进程间通信</h1>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/09/20/LeetCode-88-merge-sorted-array/">
                        <span class="hidden-mobile">LeetCode 88. 合并两个有序数组</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <!-- <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> -->
      Crafted with
      <i class="iconfont icon-love" style="color: #f30;"></i>
      by <a href="https://github.com/likailee" target="_blank" rel="noopener">Likai Lee</a>
      | &copy; 2017 - 2020
      <!-- <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a> -->
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?66c61a5fd59052d1b39d89c246846ae5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
