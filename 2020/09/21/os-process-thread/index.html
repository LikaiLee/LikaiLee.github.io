<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Likai Lee">
  <meta name="keywords" content="">
  <title>操作系统 进程与线程 - Likai Lee</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Likai Lee</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                操作系统 进程与线程
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-09-21 15:28">
      2020年9月21日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      18.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      195
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年9月23日 晚上
                
              </p>
            
            <article class="markdown-body">
              <h1 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h1>
<p><strong>进程是操作系统对正在运行中的程序的一个抽象</strong>，操作系统的其他所有内容都是通过进程展开的。无论是在单核还是多核 <code>CPU</code> 中，一个 <code>CPU</code> 都像是在<strong>并发</strong>地执行多个进程，这是通过处理器在进程间切换来实现的，即<strong>伪并行</strong>。</p>
<blockquote>
<p><code>伪并行</code>是指单核或多核处理器同时执行多个进程，从而使程序更快。 通过以<strong>非常有限的时间间隔在程序之间快速切换 <code>CPU</code></strong>，因此会产生并行感。 缺点是 <code>CPU</code> 时间可能分配给下一个进程，也可能不分配给下一个进程。</p>
</blockquote>
<h2 id="进程模型"><a class="markdownIt-Anchor" href="#进程模型"></a> 进程模型</h2>
<p>在进程模型中，所有计算机上运行的软件，通常也包括操作系统，被组织为若干<strong>顺序进程</strong>(<code>sequential processes</code>)，简称为 <strong>进程</strong>(<code>process</code>) 。一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 <code>CPU</code>，但是实际情况是 <code>CPU</code> 会在各个进程之间进行来回切换。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200918135528.png" srcset="/img/loading.gif" alt="" /><br />
如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200918135549.png" srcset="/img/loading.gif" alt="" /><br />
在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。<br />
当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。<br />
当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p>
<p>从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，但<strong>在任何一个给定的瞬间仅有一个进程真正运行。</strong><br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200918135606.png" srcset="/img/loading.gif" alt="" /></p>
<p>因此，当我们说一个 <code>CPU</code> 只能真正一次运行一个进程的时候，即使有 <code>2</code> 个核（或 <code>CPU</code>），<strong>每一个核也只能一次运行一个线程</strong>。</p>
<p>这里的关键思想是认识到一个进程所需的条件，<strong>进程是某一类特定活动的总和，它有程序、输入输出以及状态。</strong> 单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务。<br />
另外需要注意的是，如果一个进程运行了两遍，则被认为是两个进程，操作系统能够使它们共享代码，因此只有一个副本放在内存中。</p>
<h2 id="进程的创建"><a class="markdownIt-Anchor" href="#进程的创建"></a> 进程的创建</h2>
<p>创建进程的方式:</p>
<ol>
<li>系统初始化（<code>init</code>）</li>
<li>正在运行的程序执行了创建进程的系统调用（比如 fork）</li>
<li>用户请求创建一个新进程</li>
<li>初始化一个批处理工作</li>
</ol>
<p>在 <code>UNIX</code> 和 <code>Windows</code> 中，进程创建之后，<strong>父进程和子进程有各自不同的地址空间</strong>。如果其中某个进程在其地址空间中修改了一个字，这个修改将对另一个进程不可见。</p>
<ul>
<li>
<p>在 <code>UNIX</code> 中，子进程的地址空间是父进程的一个副本，但是这里涉及两个不同的地址空间；<strong>不可写的内存区域是共享的</strong>，<strong>可写的内存是不能被共享的</strong>。<br />
某些 <code>UNIX</code> 实现使子进程共享父进程的所有内存，但是这种情况下通过 <code>写时复制 (copy-on-write)</code> 共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。但是，对于一个新创建的进程来说，确实有可能共享创建者的资源，比如可以共享打开的文件。</p>
</li>
<li>
<p>在 <code>Windows</code> 中，从一开始父进程的地址空间和子进程的地址空间就是不同的。</p>
</li>
</ul>
<h3 id="1-系统初始化"><a class="markdownIt-Anchor" href="#1-系统初始化"></a> 1. 系统初始化</h3>
<p>启动操作系统时，通常会创建若干个进程。</p>
<ul>
<li><code>前台进程 (numerous processes</code>) 同用户进行交互并替他们完成工作的进程。</li>
<li><code>守护进程 (daemons)</code> 运行在后台，并不与特定的用户进行交互。</li>
</ul>
<h3 id="2-系统调用创建"><a class="markdownIt-Anchor" href="#2-系统调用创建"></a> 2. 系统调用创建</h3>
<p>一个正在运行的进程会发出<code>系统调用</code>用来创建一个或多个新进程来帮助其完成工作。</p>
<p>例如，如果有大量的数据需要经过网络调取并进行顺序处理，那么创建一个进程读数据，并把数据放到共享缓冲区中，而让第二个进程取走并正确处理会比较容易些。在多处理器中，让每个进程运行在不同的 CPU 上也可以使工作做的更快。</p>
<h3 id="3-用户请求创建"><a class="markdownIt-Anchor" href="#3-用户请求创建"></a> 3. 用户请求创建</h3>
<p>在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。在 Windows 中启动进程时，它一般没有窗口，但是它可以创建一个或多个窗口。每个窗口都可以运行进程。通过鼠标或者命令就可以切换窗口并与进程进行交互。</p>
<h3 id="4-批处理创建"><a class="markdownIt-Anchor" href="#4-批处理创建"></a> 4. 批处理创建</h3>
<p>批处理创建会在大型机的<code>批处理系统</code>中应用。用户在这种系统中提交批处理作业。当操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业。</p>
<h2 id="进程的终止"><a class="markdownIt-Anchor" href="#进程的终止"></a> 进程的终止</h2>
<p>进程在创建之后，它就开始运行并做完成任务。然而，进程早晚会发生终止，通常是由于以下情况触发的</p>
<ol>
<li>正常退出(自愿的)</li>
<li>错误退出(自愿的)</li>
<li>严重错误(非自愿的)</li>
<li>被其他进程杀死(非自愿的)</li>
</ol>
<h3 id="1-正常退出自愿的"><a class="markdownIt-Anchor" href="#1-正常退出自愿的"></a> 1. 正常退出(自愿的)</h3>
<p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。<br />
这个调用在 <code>UNIX</code> 中是 <code>exit</code> ，在 <code>Windows</code> 中是 <code>ExitProcess</code>。</p>
<h3 id="2-错误退出自愿的"><a class="markdownIt-Anchor" href="#2-错误退出自愿的"></a> 2. 错误退出(自愿的)</h3>
<p>进程发生终止的第二个原因是发现错误。<br />
例如，如果用户执行如下命令</p>
<pre><code class="hljs bash">cc foo.c</code></pre>
<p>要编译 <code>foo.c</code> 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p>
<h3 id="3-严重错误非自愿的"><a class="markdownIt-Anchor" href="#3-严重错误非自愿的"></a> 3. 严重错误(非自愿的)</h3>
<p>严重错误通常是由于程序中的错误所导致的。<br />
例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 <code>UNIX</code> 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p>
<h3 id="4-被其他进程杀死非自愿的"><a class="markdownIt-Anchor" href="#4-被其他进程杀死非自愿的"></a> 4. 被其他进程杀死(非自愿的)</h3>
<p>某个进程执行<strong>系统调用</strong>告诉操作系统杀死某个进程。在 <code>UNIX</code> 中，这个系统调用是 <code>kill</code>。在 <code>Win32</code> 中对应的函数是 <code>TerminateProcess</code>。</p>
<h2 id="进程的层次结构"><a class="markdownIt-Anchor" href="#进程的层次结构"></a> 进程的层次结构</h2>
<p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p>
<h3 id="unix-进程体系"><a class="markdownIt-Anchor" href="#unix-进程体系"></a> <code>UNIX</code> 进程体系</h3>
<p>在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 <code>kill</code> 掉。</p>
<p><code>UNIX</code> 在启动时会运行 <code>init</code> 进程，它会初始化多个子进程，因此，整个操作系统中的所有进程都属于一个以 <code>init</code> 为根的进程树。</p>
<h3 id="windows-进程体系"><a class="markdownIt-Anchor" href="#windows-进程体系"></a> <code>Windows</code> 进程体系</h3>
<p><code>Windows</code> 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为<code>句柄</code>），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 <code>UNIX</code> 中，进程不能剥夺其子进程的 <strong>进程权</strong>。</p>
<h2 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h2>
<p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。例如，一个进程的结果可以作为另一个进程的输入，在 <code>shell</code> 命令中</p>
<pre><code class="hljs shell">cat chapter1 chapter2 chapter3 | grep tree</code></pre>
<p>第一个进程是 <code>cat</code>，将三个文件级联并输出。第二个进程是 <code>grep</code>，它从输入中选择具有包含关键字 <code>tree</code> 的内容，根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的 <code>CPU</code> 时间片），可能会发生下面这种情况，<code>grep</code> 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞 <code>grep</code> 进程，直到输入完毕。</p>
<p>当一个进程开始运行时，它可能会经历下面这几种状态</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921150701.png" srcset="/img/loading.gif" alt="" /></p>
<p>图中会涉及三种状态：</p>
<ol>
<li><strong>运行态</strong>，该时刻进程实际占用 <code>CPU</code>。</li>
<li><strong>就绪态</strong>，可运行，但因为其他进程正在运行而处于就绪状态。</li>
<li><strong>阻塞态</strong>，除非某种外部事件发生，否则进程不能运行。</li>
</ol>
<ul>
<li>逻辑上来说，运行态和就绪态是很相似的。都表示进程可运行，但是<strong>就绪态</strong>没有获得 <code>CPU</code> 时间分片。</li>
<li>阻塞态与前两种状态不同的原因是<strong>这个进程不能运行，<code>CPU</code> 空闲时也不能运行</strong>。</li>
</ul>
<p>三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生 <code>状态 1</code> 的轮转。<br />
<code>转换 2</code> 和<code>转换 3</code> 都是由进程调度程序引起的，进程本身不知道调度程序的存在。<br />
<code>转换 2</code> 的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行 <code>CPU</code> 时间片了。<br />
当所有其他进程都运行过后，这时候该是让第一个进程重新获得 <code>CPU</code> 时间片的时候了，就会发生<code>转换 3</code>。</p>
<blockquote>
<p>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p>
</blockquote>
<p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生<code>转换 4</code>。如果此时没有其他进程在运行，则立刻触发<code>转换 3</code>，该进程便开始运行，否则该进程会处于就绪阶段，等待 <code>CPU</code> 空闲后再轮到它运行。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921152100.png" srcset="/img/loading.gif" alt="" /></p>
<p><strong>操作系统最底层的就是调度程序</strong>，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。事实上，调度程序只是一段非常小的程序。</p>
<h2 id="进程的实现"><a class="markdownIt-Anchor" href="#进程的实现"></a> 进程的实现</h2>
<p>操作系统为了执行进程间的切换，会维护着一张表格，这张表就是 <code>进程表(process table)</code>。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括<strong>程序计数器</strong>、<strong>堆栈指针</strong>、<strong>内存分配状况</strong>、<strong>所打开文件的状态</strong>、<strong>账号和调度信息</strong>，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921152615.webp" srcset="/img/loading.gif" alt="" /></p>
<p>第一列内容与 <strong>进程管理</strong> 有关，第二列内容与 <strong>存储管理</strong> 有关，第三列内容与 <strong>文件管理</strong> 有关。</p>
<h1 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h1>
<h2 id="线程的使用"><a class="markdownIt-Anchor" href="#线程的使用"></a> 线程的使用</h2>
<p>为什么要在进程的基础上再创建一个线程的概念：</p>
<ul>
<li>多线程之间会<strong>共享同一块地址空间和所有可用数据</strong>的能力，这是进程所不具备的。</li>
<li>线程要比进程更<strong>轻量级</strong>，它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 <code>10 - 100</code> 倍。</li>
<li>性能方面：如果多个线程都是 <code>CPU</code> 密集型的，那么并不能获得性能上的增强，但是如果存在着<strong>大量的计算和大量的 <code>I/O</code> 处理</strong>，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度。</li>
</ul>
<h3 id="1-多线程解决方案"><a class="markdownIt-Anchor" href="#1-多线程解决方案"></a> 1. 多线程解决方案</h3>
<p>一个 WEB 服务器，对页面的请求发送给服务器，而所请求的页面发送回客户端。在多数 WEB 站点上，某些页面较其他页面相比有更多的访问。Web 服务器可以把获得大量访问的页面集合保存在内存中，避免到磁盘去调入这些页面，从而改善性能。这种页面的集合称为 <code>高速缓存(cache)</code>，高速缓存也应用在许多场合中，比如说 <code>CPU</code> 缓存。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921153549.png" srcset="/img/loading.gif" alt="" /></p>
<p>上面是一个 web 服务器的组织方式，一个叫做 <code>调度线程(dispatcher thread)</code> 的线程从网络中读入工作请求，在调度线程检查完请求后，它会选择一个空闲的（阻塞的）工作线程来处理请求，通常是将消息的指针写入到每个线程关联的特殊字中。然后调度线程会唤醒正在睡眠中的工作线程，把工作线程的状态从阻塞态变为就绪态。</p>
<p>当<code>工作线程</code>启动后，它会检查请求是否在 web 页面的高速缓存中存在，这个高速缓存是所有线程都可以访问的。如果高速缓存不存在这个 web 页面的话，它会调用一个 read 操作从磁盘中获取页面并且阻塞线程直到磁盘操作完成。当线程阻塞在硬盘操作的期间，为了完成更多的工作，调度线程可能挑选另一个线程运行，也可能把另一个当前就绪的工作线程投入运行。</p>
<p>这种模型允许<strong>将服务器编写为顺序线程</strong>的集合，在分派线程的程序中包含一个死循环，该循环用来获得工作请求并且把请求派给工作线程。每个工作线程的代码包含一个从调度线程接收的请求，并且检查 web 高速缓存中是否存在所需页面，如果有，直接把该页面返回给客户，接着工作线程阻塞，等待一个新请求的到达。如果没有，工作线程就从磁盘调入该页面，将该页面返回给客户机，然后工作线程阻塞，等待一个新请求。</p>
<h3 id="2-单线程解决方案"><a class="markdownIt-Anchor" href="#2-单线程解决方案"></a> 2. 单线程解决方案</h3>
<p>Web 服务器的主循环获取请求并检查请求，并争取在下一个请求之前完成工作。在等待磁盘操作时，服务器空转，并且不处理任何到来的其他请求。结果会导致每秒中只有很少的请求被处理，所以这个例子能够说明多线程提高了程序的并行性并提高了程序的性能。</p>
<h3 id="3-状态机解决方案"><a class="markdownIt-Anchor" href="#3-状态机解决方案"></a> 3. 状态机解决方案</h3>
<p>如果目前只有一个非阻塞版本的 read 系统调用可以使用，那么当请求到达服务器时，这个唯一的 read 调用的线程会进行检查，如果能够从高速缓存中得到响应，那么直接返回，如果不能，则启动一个非阻塞的磁盘操作。</p>
<p>服务器在表中记录当前请求的状态，然后进入并获取下一个事件，紧接着下一个事件可能就是一个新工作的请求或是磁盘对先前操作的回答。如果是新工作的请求，那么就开始处理请求。如果是磁盘的响应，就从表中取出对应的状态信息进行处理。对于非阻塞式磁盘 I/O 而言，这种响应一般都是信号中断响应。</p>
<p>每次服务器从某个请求工作的状态切换到另一个状态时，都必须显示的保存或者重新装入相应的计算状态。这里，每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为 <code>有限状态机(finite-state machine)</code>。</p>
<ul>
<li>多线程使得顺序进程的思想得以保留下来，并且实现了<strong>并行性</strong>，但是顺序进程会<strong>阻塞系统调用</strong>；</li>
<li>单线程服务器保留了阻塞系统的简易性，但是却放弃了性能。</li>
<li>有限状态机的处理方法运用了<strong>非阻塞调用</strong>和中断，通过<strong>并行</strong>实现了高性能，但是给编程增加了困难。</li>
</ul>
<h2 id="经典的线程模型"><a class="markdownIt-Anchor" href="#经典的线程模型"></a> 经典的线程模型</h2>
<p>组成：</p>
<ul>
<li><strong>程序计数器</strong>，记录接着要执行哪一条指令；</li>
<li><strong>寄存器</strong>，保存线程当前正在使用的变量；</li>
<li><strong>堆栈</strong>，记录程序的执行路径。</li>
</ul>
<p>在同一个进程中，允许彼此之间有较大的独立性且互不干扰。在一个进程中并行运行多个线程类似于在一台计算机上运行多个进程。<br />
在多个线程中，各个线程共享同一地址空间和其他资源。<br />
在多个进程中，进程共享物理内存、磁盘、打印机和其他资源。因为线程会包含有一些进程的属性，所以线程被称为轻量的进程(<code>lightweight processes</code>)。</p>
<p>三个进程，每个进程有自己的地址空间和单个控制线程，每个线程都在不同的地址空间中运行。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155110.png" srcset="/img/loading.gif" alt="" /></p>
<p>一个进程三个线程的情况。每个线程都在相同的地址空间中运行。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155327.png" srcset="/img/loading.gif" alt="" /></p>
<p>线程不像是进程那样具备较强的独立性。<strong>同一个进程中的所有线程都会有完全一样的地址空间</strong>，这意味着它们也<strong>共享同样的全局变量</strong>。由于每个线程都可以访问进程地址空间内每个内存地址，因此一个线程可以读取、写入甚至擦除另一个线程的堆栈。线程之间除了共享同一内存空间外，还具有如下不同的内容：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155439.png" srcset="/img/loading.gif" alt="" /></p>
<p>和进程一样，线程可以处于下面这几种状态：<strong>运行</strong>、<strong>阻塞</strong>、<strong>就绪</strong>和<strong>终止</strong>。<br />
正在运行的线程拥有 <code>CPU</code> 时间片并且状态是运行中。<br />
一个被阻塞的线程会等待某个释放它的事件。<br />
例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞直到有输入为止。线程通常会被阻塞，直到它等待某个外部事件的发生或者有其他线程来释放它。线程之间的状态转换和进程之间的状态转换是一样的。</p>
<p>每个线程都会有自己的堆栈，如下图所示<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155658.png" srcset="/img/loading.gif" alt="" /></p>
<h2 id="线程实现"><a class="markdownIt-Anchor" href="#线程实现"></a> 线程实现</h2>
<h3 id="1-在用户空间中实现线程"><a class="markdownIt-Anchor" href="#1-在用户空间中实现线程"></a> 1. 在用户空间中实现线程</h3>
<p>第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921160042.png" srcset="/img/loading.gif" alt="" /><br />
线程在运行时系统之上运行，运行时系统是管理线程过程的集合。</p>
<blockquote>
<p><code>运行时系统(Runtime System)</code> 也叫做运行时环境，<strong>该运行时系统提供了程序在其中运行的环境</strong>。此环境可能会解决许多问题，包括应用程序内存的布局，程序如何访问变量，在过程之间传递参数的机制，与操作系统的接口等等。编译器根据特定的运行时系统进行假设以生成正确的代码。通常，运行时系统将负责设置和管理堆栈，并且会包含诸如垃圾收集，线程或语言内置的其他动态的功能。</p>
</blockquote>
<p>在用户空间管理线程时，每个进程需要有其专用的 <code>线程表(thread table)</code>，<strong>用来跟踪该进程中的线程</strong>。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器和状态。<strong>该线程标由运行时系统统一管理</strong>。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程的所有信息，与内核在进程表中存放的信息完全一样。</p>
<p>优势：</p>
<ul>
<li>
<p>保存线程的状态和调度程序都是<code>本地过程</code>，所以启动他们比进行内核调用效率更高。因而<strong>不需要切换到内核，也就不需要上下文切换，也不需要对内存高速缓存进行刷新，因为线程调度非常便捷，因此效率比较高。</strong></p>
</li>
<li>
<p>允许每个进程有自己定制的调度算法。</p>
</li>
</ul>
<h3 id="2-在内核空间中实现线程"><a class="markdownIt-Anchor" href="#2-在内核空间中实现线程"></a> 2. 在内核空间中实现线程</h3>
<p>使用内核来实现线程的情况，<strong>不再需要运行时环境</strong>，<strong>每个进程中也没有线程表</strong>。相反，在内核中会有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921161156.png" srcset="/img/loading.gif" alt="" /></p>
<p>所有能够阻塞的调用都会通过<strong>系统调用</strong>的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 <code>CPU</code> 时间片（或者没有可运行的线程存在了）为止。</p>
<p>由于在内核中创建或者销毁线程的开销比较大，所以某些系统会采用<strong>可循环利用</strong>的方式来回收线程。<br />
当某个线程被销毁时，就把它标志为不可运行的状态，但是其内部结构没有受到影响。稍后，在必须创建一个新线程时，就会重新启用旧线程，把它标志为可用状态。</p>
<h3 id="3-在用户和内核空间中混合实现线程"><a class="markdownIt-Anchor" href="#3-在用户和内核空间中混合实现线程"></a> 3. 在用户和内核空间中混合实现线程</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921161507.png" srcset="/img/loading.gif" alt="" /></p>
<p>在这种模型中，<strong>编程人员可以自由控制用户线程和内核线程的数量</strong>，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程<strong>多路复用</strong>。</p>
<h1 id="进程间通信"><a class="markdownIt-Anchor" href="#进程间通信"></a> 进程间通信</h1>
<h2 id="竞态条件"><a class="markdownIt-Anchor" href="#竞态条件"></a> 竞态条件</h2>
<p>在一些操作系统中，协作的进程可能共享一些彼此都能读写的公共资源。公共资源可能在内存中也可能在一个共享文件。<br />
为了讲清楚进程间是如何通信的，这里我们举一个例子：一个后台打印程序。当一个进程需要打印某个文件时，它会将文件名放在一个特殊的 <code>后台目录(spooler directory)</code> 中。另一个进程 <code>打印后台进程(printer daemon)</code> 会定期的检查是否需要文件被打印，如果有的话，就打印并将该文件名从目录下删除。</p>
<p>假设我们的后台目录有非常多的 <code>槽位(slot)</code>，编号依次为 0，1，2，…，每个槽位存放一个文件名。同时假设有两个共享变量：<code>out</code>，指向下一个需要打印的文件；<code>in</code>，指向目录中下个空闲的槽位。可以把这两个文件保存在一个所有进程都能访问的文件中，该文件的长度为两个字。在某一时刻，0 至 3 号槽位空，4 号至 6 号槽位被占用。在同一时刻，进程 A 和 进程 B 都决定将一个文件排队打印，情况如下：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921163828.webp" srcset="/img/loading.gif" alt="" /></p>
<p>在某一时刻两个进程都认为下一个可用槽位是 7。<br />
进程 B 会将打印文件名写入到 slot 7 中，然后把 in 的指针更改为 8 ，然后进程 B 离开去做其他的事情。<br />
进程 A 也发现 slot 7 的槽位是空的，于是将打印文件名存入 slot 7 中，然后把 in 的值更新为 8，由于 slot 7 这个槽位中已经有进程 B 写入的值，所以进程 A 的打印文件名会把进程 B 的文件覆盖，由于打印机内部是无法发现是哪个进程更新的，它的功能比较局限，所以这时候进程 B 永远无法打印输出，类似这种情况，即<strong>两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时</strong>，这种就被称为 <code>竞态条件(race condition)</code>。</p>
<h2 id="临界区"><a class="markdownIt-Anchor" href="#临界区"></a> 临界区</h2>
<p>不仅共享资源会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：<strong>禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写</strong>。<br />
换句话说，我们需要一种 <code>互斥(mutual exclusion)</code> 条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。</p>
<p>避免竞争问题的条件可以用一种抽象的方式去描述。大部分时间，进程都会忙于内部计算和其他不会导致竞争条件的计算。然而，有时候进程会访问共享内存或文件，或者做一些能够导致竞态条件的操作。我们把<strong>对共享内存进行访问的程序片段</strong>称作 <code>临界区域(critical region)</code> 或 <code>临界区(critical section)</code>。如果我们能够正确的操作，使两个不同进程不可能同时处于临界区，就能避免竞争条件，这也是从操作系统设计角度来进行的。</p>
<p>尽管上面这种设计避免了竞争条件，但是不能确保并发线程同时访问共享数据的正确性和高效性。一个好的解决方案，应该包含下面四种条件</p>
<ol>
<li>任何时候两个进程不能同时处于临界区</li>
<li>不应对 CPU 的速度和数量做任何假设</li>
<li>位于临界区外的进程不得阻塞其他进程</li>
<li>不能使任何进程无限等待进入临界区</li>
</ol>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200922124159.png" srcset="/img/loading.gif" alt="" /></p>
<p>从抽象的角度来看，我们通常希望进程的行为如上图所示，在 t1 时刻，进程 A 进入临界区，在 t2 的时刻，进程 B 尝试进入临界区，因为此时进程 A 正在处于临界区中，所以进程 B 会阻塞直到 t3 时刻进程 A 离开临界区，此时进程 B 能够允许进入临界区。最后，在 t4 时刻，进程 B 离开临界区，系统恢复到没有进程的原始状态。</p>
<h2 id="忙等互斥"><a class="markdownIt-Anchor" href="#忙等互斥"></a> 忙等互斥</h2>
<p>在实现互斥的各种方案中，当一个进程正忙于更新其临界区的共享内存时，没有其他进程会进入其临界区，也不会造成影响。</p>
<h3 id="1-屏蔽中断"><a class="markdownIt-Anchor" href="#1-屏蔽中断"></a> 1. 屏蔽中断</h3>
<p>在<code>单处理器</code>系统上，最简单的解决方案是<strong>让每个进程在进入临界区后立即屏蔽所有中断</strong>，并<strong>在离开临界区之前重新启用它们</strong>。屏蔽中断后，时钟中断也会被屏蔽。<code>CPU</code> 只有发生时钟中断或其他中断时才会进行进程切换。这样，在屏蔽中断后 <code>CPU</code> 不会切换到其他进程。<br />
所以，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不用担心其他进程介入访问共享数据。</p>
<p>缺点：</p>
<ul>
<li>如果经过一段较长时间后进程没有离开，中断一直无法启用，可能会造成整个系统的终止。</li>
<li>如果是<code>多处理器</code>系统，<strong>屏蔽中断仅仅对执行 <code>disable</code> 指令的 <code>CPU</code> 有效</strong>。其他 <code>CPU</code> 仍将继续运行，并可以访问共享内存。</li>
</ul>
<h3 id="2-锁变量"><a class="markdownIt-Anchor" href="#2-锁变量"></a> 2. 锁变量</h3>
<p>考虑有单个共享的（锁）变量，初始为值为 0 。当一个线程想要进入临界区时，它首先会查看锁的值是否为 0 ，如果锁的值是 0 ，进程会把它设置为 1 并让进程进入临界区。如果锁的状态是 1，进程会等待直到锁变量的值变为 0。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200922130139.png" srcset="/img/loading.gif" alt="" /><br />
此时假设一个进程读出锁变量的值并发现它为 0 ，而恰好在它将其设置为 1 之前，另一个进程调度运行，读出锁的变量为0 ，并将锁的变量设置为 1 。然后第一个线程运行，把锁变量的值再次设置为 1，此时，临界区域就会有两个进程在同时运行。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200922130639.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="3-严格轮询法"><a class="markdownIt-Anchor" href="#3-严格轮询法"></a> 3. 严格轮询法</h3>
<p>进程 0：当 <code>turn == 0</code> 进入临界区</p>
<pre><code class="hljs c"><span class="hljs-keyword">while</span>(TRUE)&#123;
  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">turn</span> == <span class="hljs-number">0</span>)&#123;
    <span class="hljs-comment">/* 进入临界区 */</span>
    critical_region();
    <span class="hljs-built_in">turn</span> = <span class="hljs-number">1</span>;
    <span class="hljs-comment">/* 离开临界区 */</span>
    noncritical_region();
  &#125;
&#125;</code></pre>
<p>进程 1：当 <code>turn == 1</code> 进入临界区</p>
<pre><code class="hljs c"><span class="hljs-keyword">while</span>(TRUE)&#123;
  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">turn</span> == <span class="hljs-number">1</span>)&#123;
    <span class="hljs-comment">/* 进入临界区 */</span>
    critical_region();
    <span class="hljs-built_in">turn</span> = <span class="hljs-number">0</span>;
    <span class="hljs-comment">/* 离开临界区 */</span>
    noncritical_region();
  &#125;
&#125;</code></pre>
<p>在上面代码中，变量 <code>turn</code>，初始值为 <code>0</code> ，用于记录轮到那个进程进入临界区，并检查或更新共享内存。开始时，<code>进程 0</code> 检查 <code>turn</code>，发现其值为 <code>0</code>，于是进入临界区。<code>进程 1</code> 也发现其值为 <code>0</code> ，所以在一个等待循环中不停的测试 <code>turn</code>，看其值何时变为 <code>1</code>。</p>
<blockquote>
<p>连续检查一个变量直到某个值出现为止，这种方法称为 <code>忙等待(busywaiting)</code>。用于忙等待的锁，称为 <code>自旋锁(spinlock)</code>。<br />
由于这种方式<strong>浪费 <code>CPU</code> 时间</strong>，所以这种方式通常应该要避免。只有在有理由认为<strong>等待时间是非常短的情况下，才能够使用忙等待</strong>。</p>
</blockquote>
<p>当 <code>进程 0</code> 和 <code>进程 1</code> 都在非临界区时，此时 <code>进程 0</code> 结束了非临界区的操作并返回到循环的开始。但是，这时它不能进入临界区，因为 <code>turn == 1</code>，此时 <code>进程 1</code> 还忙于非临界区的操作，<code>进程 0</code> 只能继续阻塞，直到<code>进程 1</code> 把 <code>turn</code> 的值改为 <code>0</code>。这说明，在<strong>一个进程比另一个进程执行速度慢了很多的情况下，轮流进入临界区并不是一个好的方法。</strong></p>
<p>这种情况违反了前面的叙述 3 ，即 <strong>位于临界区外的进程不得阻塞其他进程</strong>，<code>进程 0</code> 被临界区外的 <code>进程 1</code> 阻塞。由于违反了第三条，所以也不能作为一个好的方案。</p>
<h3 id="4-peterson-解法"><a class="markdownIt-Anchor" href="#4-peterson-解法"></a> 4. Peterson 解法</h3>
<pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE  1</span>
<span class="hljs-comment">/* 进程数量 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N     2													</span>

<span class="hljs-comment">/* 现在轮到谁 */</span>
<span class="hljs-keyword">int</span> <span class="hljs-built_in">turn</span>;					

<span class="hljs-comment">/* 所有值初始化为 0 (FALSE) */</span>
<span class="hljs-keyword">int</span> interested[N];											

<span class="hljs-comment">/* 进程是 0 或 1 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enter_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">process</span>)</span></span>&#123;					
  
  <span class="hljs-comment">/* 另一个进程号 */</span>
  <span class="hljs-keyword">int</span> other;														
  
  <span class="hljs-comment">/* 另一个进程 */</span>
  other = <span class="hljs-number">1</span> - <span class="hljs-built_in">process</span>;				
  
  <span class="hljs-comment">/* 表示愿意进入临界区 */</span>
  interested[<span class="hljs-built_in">process</span>] = TRUE;						
  <span class="hljs-built_in">turn</span> = <span class="hljs-built_in">process</span>;
  
  <span class="hljs-comment">/* 阻塞 */</span>
  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">turn</span> == <span class="hljs-built_in">process</span> 
        &amp;&amp; interested[other] == <span class="hljs-literal">true</span>)&#123;&#125; 
  
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">leave_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">process</span>)</span></span>&#123;
  
  <span class="hljs-comment">/* 表示离开临界区 */</span>
  interested[<span class="hljs-built_in">process</span>] == FALSE;				 
&#125;</code></pre>
<p>在使用共享变量时（即进入其临界区）之前，各个进程使用各自的进程号 <code>0</code> 或 <code>1</code> 作为参数来调用 <code>enter_region</code>，这个函数调用在需要时将使进程等待，直到能够安全的临界区。在完成对共享变量的操作之后，进程将调用 <code>leave_region</code> 表示操作完成，并且允许其他进程进入。</p>
<p>考虑一种两个进程同时调用 <code>enter_region</code> 的情况。它们都将自己的进程存入 <code>turn</code>，但只有最后保存进去的进程号才有效，前一个进程的进程号因为重写而丢失。假如 <code>进程 1</code> 是最后存入的，则 <code>turn = 1</code> 。当两个进程都运行到 <code>while</code> 的时候，<code>进程 0</code> 将不会循环并进入临界区，而 <code>进程 1</code> 将会无限循环且不会进入临界区，直到 <code>进程 0</code> 退出临界区为止。</p>
<h3 id="5-tsl-指令"><a class="markdownIt-Anchor" href="#5-tsl-指令"></a> 5. <code>TSL</code> 指令</h3>
<p>一些计算机，特别是那些设计为多处理器的计算机，都会有下面这条指令</p>
<pre><code class="hljs cos">TSL RX,<span class="hljs-keyword">LOCK</span></code></pre>
<p>称为 <code>测试并加锁(test and set lock)</code>，它将一个内存字 <code>lock</code> 读到寄存器 <code>RX</code> 中，然后在该内存地址上存储一个非零值。其执行过程是一条原语。在这个指令结束之前其他处理器均不允许访问内存。执行 <code>TSL</code> 指令的 <code>CPU</code> 将会锁住内存总线，用来禁止其他 <code>CPU</code> 在这个指令结束之前访问内存。</p>
<p>很重要的一点是锁住内存总线和禁用中断不一样。禁用中断并不能保证一个处理器在读写操作之间另一个处理器对内存的读写。也就是说，在 <code>处理器 1</code> 上屏蔽中断对 <code>处理器 2</code> 没有影响。让 <code>处理器 2</code> 远离内存直到 <code>处理器 1</code> 完成读写的最好的方式就是<strong>锁住总线</strong>。这需要一个特殊的硬件（基本上，一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能使用）。</p>
<h3 id="6-xchg-指令"><a class="markdownIt-Anchor" href="#6-xchg-指令"></a> 6. <code>XCHG</code> 指令</h3>
<p><code>XCHG</code> 指令可以替换 <code>TSL</code> 的指令，它原子性的交换了两个位置的内容，例如，一个寄存器与一个内存字。</p>
<p><code>XCHG</code> 的本质上与 <code>TSL</code> 的解决办法一样。所有的 <code>Intel x86</code> <code>CPU</code> 在底层同步中使用 <code>XCHG</code> 指令。</p>
<h2 id="睡眠与唤醒"><a class="markdownIt-Anchor" href="#睡眠与唤醒"></a> 睡眠与唤醒</h2>
<p><code>Peterson</code> 、<code>TSL</code> 和 <code>XCHG</code> 解法都是正确的，但是它们都有<strong>忙等待</strong>的缺点。这些解法的本质上都是一样的，先检查是否能够进入临界区，若不允许，则该进程将原地等待，直到允许为止。</p>
<p>这种方式不但浪费了 <code>CPU</code> 时间，而且还可能引起意想不到的结果。考虑一台计算机上有两个进程，这两个进程具有不同的优先级，<code>H</code> 是属于优先级比较高的进程，<code>L</code> 是属于优先级比较低的进程。进程调度的规则是<strong>不论何时只要 <code>H 进程</code> 处于就绪态 <code>H</code> 就开始运行</strong>。<br />
在某一时刻，<strong><code>L</code> 处于临界区中</strong>，此时 <code>H</code> 变为就绪态，准备运行（例如，一条 I/O 操作结束）。现在 <code>H</code> 要开始忙等，但由于当 <code>H</code> 就绪时 <code>L</code> 就不会被调度，<code>L</code> 从来不会有机会离开临界区，所以 <code>H</code> 会变成<strong>死循环</strong>，有时将这种情况称为 <code>优先级反转问题(priority inversion problem)</code>。</p>
<p>进程间的通信原语<strong>在不允许它们进入临界区之前会阻塞</strong>而不是浪费 <code>CPU</code> 时间，最简单的是 <code>sleep</code> 和 <code>wakeup</code>。</p>
<ul>
<li><code>Sleep</code> 是一个能够造成调用者阻塞的系统调用，也就是说，这个系统调用会暂停直到其他进程唤醒它。</li>
<li><code>wakeup</code> 调用有一个参数，即要唤醒的进程。</li>
</ul>
<p>还有一种方式是 <code>wakeup</code> 和 <code>sleep</code> 都有一个参数，即 <code>sleep</code> 和 <code>wakeup</code> 需要匹配的内存地址。</p>
<h3 id="生产者-消费者问题"><a class="markdownIt-Anchor" href="#生产者-消费者问题"></a> 生产者-消费者问题</h3>
<p><code>生产者-消费者(producer-consumer)</code> 问题，也称作 <code>有界缓冲区(bounded-buffer)</code> 问题。两个进程共享一个公共的固定大小的缓冲区。其中一个是<code>生产者(producer)</code>，将信息放入缓冲区， 另一个是<code>消费者(consumer)</code>，会从缓冲区中取出。</p>
<p>如果缓冲队列已满，那么当生产者仍想要将数据写入缓冲区的时候，会出现问题。它的解决办法是让生产者睡眠，也就是阻塞生产者。等到消费者从缓冲区中取出一个或多个数据项时再唤醒它。同样的，当消费者试图从缓冲区中取数据，但是发现缓冲区为空时，消费者也会睡眠，阻塞。直到生产者向其中放入一个新的数据。</p>
<pre><code class="hljs c"><span class="hljs-comment">/* 缓冲区 slot 槽的数量 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100						</span>
<span class="hljs-comment">/* 缓冲区数据的数量 */</span>
<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>										
  
<span class="hljs-comment">// 生产者</span>
<span class="hljs-keyword">void</span> producer(<span class="hljs-keyword">void</span>)&#123;
  <span class="hljs-keyword">int</span> item;
  
  <span class="hljs-comment">/* 无限循环 */</span>
  <span class="hljs-keyword">while</span>(TRUE)&#123;				
    <span class="hljs-comment">/* 生成下一项数据 */</span>
    item = produce_item()				
    <span class="hljs-comment">/* 如果缓存区是满的，就会阻塞 */</span>
    <span class="hljs-keyword">if</span>(count == N)&#123;
      sleep();									
    &#125;
    
    <span class="hljs-comment">/* 把当前数据放在缓冲区中 */</span>
    insert_item(item);
    <span class="hljs-comment">/* 增加缓冲区 count 的数量 */</span>
    count = count + <span class="hljs-number">1</span>;					
    <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>)&#123;
      <span class="hljs-comment">/* 缓冲区是否为空？ */</span>
      wakeup(consumer);					
    &#125;
  &#125;
&#125;

<span class="hljs-comment">// 消费者</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;
  
  <span class="hljs-keyword">int</span> item;
  
  <span class="hljs-comment">/* 无限循环 */</span>
  <span class="hljs-keyword">while</span>(TRUE)&#123;
    <span class="hljs-comment">/* 如果缓冲区是空的，就会进行阻塞 */</span>
    <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;							
      sleep();
    &#125;
    <span class="hljs-comment">/* 从缓冲区中取出一个数据 */</span>
    item = remove_item();			
    <span class="hljs-comment">/* 将缓冲区的 count 数量减一 */</span>
    count = count - <span class="hljs-number">1</span>
    <span class="hljs-comment">/* 缓冲区满？ */</span>
    <span class="hljs-keyword">if</span>(count == N - <span class="hljs-number">1</span>)&#123;					
      wakeup(producer);		
    &#125;
    <span class="hljs-comment">/* 打印数据项 */</span>
    consumer_item(item);				
  &#125;
  
&#125;</code></pre>
<p>上面代码中会产生竞争条件。有可能出现下面这种情况：缓冲区为空，此时消费者刚好读取 <code>count</code> 的值发现它为 <code>0</code>。此时<strong>调度程序决定暂停消费者</strong>并启动运行生产者。生产者生产了一条数据并把它放在缓冲区中，然后增加 <code>count</code> 的值，<code>count = 1</code> 。由于 <code>count</code> 初始为 <code>0</code>，消费者必须处于睡眠状态，因此生产者调用 <code>wakeup</code> 来唤醒消费者。但是，消费者此时在逻辑上并没有睡眠，所以 <code>wakeup</code> 信号会<strong>丢失</strong>。当消费者下次启动后，它会查看之前读取的 <code>count</code> 值，发现它的值是 <code>0</code>，然后在此进行睡眠。不久之后生产者会填满整个缓冲区，在这之后会阻塞，这样一来两个进程将永远睡眠下去。</p>
<p>引起上面问题的本质是 <strong>唤醒尚未进行睡眠状态的进程会导致唤醒丢失</strong>。如果它没有丢失，则一切都很正常。一种快速解决上面问题的方式是增加一个 <code>唤醒等待位(wakeup waiting bit)</code>。当一个 <code>wakeup</code> 信号发送给仍在清醒的进程后，该位置为 <code>1</code>。之后，当进程尝试睡眠的时候，如果唤醒等待位为 <code>1</code>，则该位清除，而进程仍然保持清醒。</p>
<p>然而，当进程数量有许多的时候，这时可以通过增加唤醒等待位的数量来唤醒等待位，于是就有了 2、4、6、8 个唤醒等待位，但是并没有从根本上解决问题。</p>
<h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2>
<p>一个信号量的取值可以是 <code>0</code> ，或任意正数。<code>0</code> 表示的是不需要任何唤醒，任意的正数表示的就是资源数目（唤醒次数）。</p>
<p>Dijkstra 提出了信号量有两个操作，现在通常使用 <code>down (P)</code> 和 <code>up (V)</code>（分别可以用 <code>sleep</code> 和 <code>wakeup</code> 来表示）。</p>
<ul>
<li><code>down</code> 操作会检查值是否大于 <code>0</code> 。如果大于 <code>0</code> ，则将其值 <code>- 1</code> ；若该值为 <code>0</code>，则进程将睡眠，而且此时 <code>down</code> 操作将会继续执行。</li>
</ul>
<p><strong>检查数值</strong>、<strong>修改变量值</strong>以及可能发生的<strong>睡眠操作</strong>均为一个单一的、不可分割的 <code>原子操作(atomic action)</code> 完成。这会保证一旦信号量操作开始，没有其他的进程能够访问信号量，直到操作完成或者阻塞。这种原子性对于解决同步问题和避免竞争绝对必不可少。</p>
<ul>
<li><code>up</code> 操作会使信号量的值 <code>+ 1</code>。如果一个或者多个进程在信号量上睡眠，无法完成一个先前的 <code>down</code> 操作，则由系统选择（<strong>随机挑选</strong>）其中的一个并允许该程完成 <code>down</code> 操作。</li>
</ul>
<p>因此，对一个进程在其上睡眠的信号量执行一次 <code>up</code> 操作之后，该信号量的值仍然是 <code>0</code> ，但在其上睡眠的进程却少了一个。信号量的值增 <code>1</code> 和唤醒一个进程同样也是不可分割的。不会有某个进程因执行 <code>up</code> 而阻塞，正如在前面的模型中不会有进程因执行 <code>wakeup</code> 而阻塞是一样的道理。</p>
<h3 id="用信号量解决生产者-消费者问题"><a class="markdownIt-Anchor" href="#用信号量解决生产者-消费者问题"></a> 用信号量解决生产者 - 消费者问题</h3>
<p>用信号量解决丢失的 <code>wakeup</code> 问题，代码如下：</p>
<pre><code class="hljs c"><span class="hljs-comment">/* 定义缓冲区槽的数量 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span>
<span class="hljs-comment">/* 信号量是一种特殊的 int */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;
<span class="hljs-comment">/* 控制临界区的访问 */</span>
semaphore mutex = <span class="hljs-number">1</span>;
<span class="hljs-comment">/* 统计 buffer 空槽的数量 */</span>
semaphore empty = N;
<span class="hljs-comment">/* 统计 buffer 满槽的数量 */</span>
semaphore full = <span class="hljs-number">0</span>;												

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123; 
  
  <span class="hljs-keyword">int</span> item;  
  
  <span class="hljs-keyword">while</span>(TRUE)&#123;			
    <span class="hljs-comment">/* 产生放在缓冲区的一些数据 */</span>
    item = producer_item();		
    <span class="hljs-comment">/* 将空槽数量减 1  */</span>
    <span class="hljs-comment">// 若空槽数量不够，则阻塞</span>
    down(&amp;empty);
    
    <span class="hljs-comment">/* 进入临界区  */</span>
    down(&amp;mutex);	
    <span class="hljs-comment">/* 把数据放入缓冲区中 */</span>
    insert_item(item);
    <span class="hljs-comment">/* 离开临界区 */</span>
    up(&amp;mutex);	
    
    <span class="hljs-comment">/* 将 buffer 满槽数量 + 1 */</span>
    up(&amp;full);														
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;
  
  <span class="hljs-keyword">int</span> item;
  
  <span class="hljs-keyword">while</span>(TRUE)&#123;
    <span class="hljs-comment">/* 缓存区满槽数量 - 1 */</span>
    <span class="hljs-comment">// 若满槽数量不足，无法消费，则阻塞</span>
    down(&amp;full);
    
    <span class="hljs-comment">/* 进入缓冲区 */</span>	
    down(&amp;mutex);
    <span class="hljs-comment">/* 从缓冲区取出数据 */</span>
    item = remove_item();	
    <span class="hljs-comment">/* 离开临界区 */</span>
    up(&amp;mutex);	
    
    <span class="hljs-comment">/* 将空槽数目 + 1 */</span>
    <span class="hljs-comment">// 消费数据和不需要同步，所以先处理空槽数再消费取出的数据</span>
    up(&amp;empty);	
    
    <span class="hljs-comment">/* 消费数据 */</span>
    consume_item(item);											
  &#125;
&#125;</code></pre>
<p>为了确保信号量能正确工作，最重要的是要采用一种不可分割的方式来实现它。通常是将 <code>up</code> 和 <code>down</code> 作为系统调用来实现。而且操作系统只需在执行以下操作时暂时屏蔽全部中断：<strong>检查信号量</strong>、<strong>更新</strong>、<strong>必要时使进程睡眠</strong>。由于这些操作仅需要非常少的指令，因此中断不会造成影响。如果使用多个 <code>CPU</code>，那么信号量应该被<strong>锁</strong>进行保护。使用 <code>TSL</code> 或者 <code>XCHG</code> 指令用来确保同一时刻只有一个 <code>CPU</code> 对信号量进行操作。</p>
<p>使用 <code>TSL</code> 或者 <code>XCHG</code> 来防止几个 <code>CPU</code> 同时访问一个信号量，与生产者或消费者使用<strong>忙等待</strong>来等待其他腾出或填充缓冲区是完全不一样的。前者的操作仅需要几个毫秒，而生产者或消费者可能需要任意长的时间。</p>
<p>上面这个解决方案使用了三种信号量：一个称为 <code>full</code>，用来记录充满的缓冲槽数目；一个称为 <code>empty</code>，记录空的缓冲槽数目；一个称为 <code>mutex</code>，<strong>用来确保生产者和消费者不会同时进入缓冲区</strong>。<code>full</code> 被初始化为 <code>0</code>，<code>empty</code> 初始化为缓冲区中插槽数，<code>mutex</code> 初始化为 <code>1</code>。</p>
<blockquote>
<p>供两个或多个进程使用的信号量，初始化为 <code>1</code>，保证它们中同时只有一个可以进入临界区的信号被称为 <code>二进制信号量(binary semaphores)</code>。如果每个进程都在进入临界区之前执行 <code>down</code> 操作，而在离开临界区之后执行 <code>up</code> 操作，则可以确保相互互斥。</p>
</blockquote>
<p>信号量的另一用途是实现 <code>同步（synchronizeation）</code>。信号量 <code>full</code> 和 <code>empty</code> 用来保证某种事件的顺序发生或不发生。</p>
<h2 id="互斥量"><a class="markdownIt-Anchor" href="#互斥量"></a> 互斥量</h2>
<p>如果不需要信号量的计数能力时，可以使用信号量的一个简单版本，称为 <code>mutex (互斥量)</code>。互斥量的优势就在于在一些共享资源和一段代码中保持互斥。由于互斥的实现既简单又有效，这使得互斥量在实现用户空间线程包时非常有用。</p>
<p>互斥量是一个处于<strong>两种状态</strong>之一的共享变量：<code>解锁(unlocked)</code> 和 <code>加锁(locked)</code>。这样，只需要<strong>一个二进制位</strong>来表示它，不过一般情况下，通常会用一个 <code>整形(integer)</code> 来表示。<code>0</code> 表示解锁，其他所有的值表示加锁，比 <code>1</code> 大的值表示加锁的次数。</p>
<p>当一个线程（或者进程）需要访问临界区时，会调用 <code>mutex_lock</code> 进行加锁。</p>
<ul>
<li>如果互斥锁当前处于<strong>未锁定</strong>状态（表示临界区可用），则调用成功，并且调用线程可以自由进入临界区。</li>
<li>如果 <code>mutex</code> 互斥量<strong>已经锁定</strong>，调用线程会<strong>阻塞直到临界区内的线程执行完毕并且调用了 <code>mutex_unlock</code>。</strong> 如果多个线程在 <code>mutex</code> 互斥量上阻塞，将随机选择一个线程并允许它获得锁。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200922155103.png" srcset="/img/loading.gif" alt="" /></p>
<p>随着并行的增加，有效的 <code>同步(synchronization)</code> 和 <code>锁定(locking)</code> 对于性能来说是非常重要的。</p>
<ul>
<li>如果进程等待时间很短，那么 <code>自旋锁(Spin lock)</code> 是非常有效；但是如果等待时间比较长，那么这会浪费 CPU 周期。</li>
<li>如果进程很多，那么阻塞此进程，并仅当锁被释放的时候让内核解除阻塞是更有效的方式。<br />
不幸的是：它可以在进程竞争频繁的时候运行良好，但是在竞争不是很激烈的情况下内核切换的消耗会非常大，而且更困难的是，预测锁的竞争数量更不容易。</li>
</ul>
<h2 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h2>
<p>管程是程序、变量和数据结构等组成的一个集合，它们组成一个特殊的模块或者包。进程可以在任何需要的时候调用管程中的程序，但是它们不能从管程外部访问数据结构和程序。</p>
<p><strong>在任何时候管程中只能有一个活跃的进程</strong>，这一特性使管程能够很方便的实现互斥操作。通常情况下，当进程调用管程中的程序时，该程序的前几条指令会检查管程中是否有其他活跃的进程。如果有的话，调用进程将被挂起，直到另一个进程离开管程才将其唤醒。如果没有活跃进程在使用管程，那么该调用进程才可以进入。</p>
<p>即使管程提供了一种简单的方式来实现互斥，但在我们看来，这还不够。因为我们还需要一种<strong>使得进程在无法执行时被阻塞</strong>。在生产者-消费者问题中，很容易将针对缓冲区满和缓冲区空的测试放在管程程序中，但是生产者在发现缓冲区满的时候该如何阻塞呢？</p>
<p>解决的办法是引入 <code>条件变量(condition variables)</code> 以及相关的两个操作 <code>wait</code> 和 <code>signal</code>。当一个管程程序发现它不能运行时（例如，生产者发现缓冲区已满），它会在某个条件变量（如 <code>full</code>）上执行 <code>wait</code> 操作。这个操作造成调用进程阻塞，并且还将另一个以前等在管程之外的进程调入管程。另一个进程，比如消费者可以通过执行 <code>signal</code> 来唤醒阻塞的调用进程。</p>
<p>如果在一个条件变量上有若干进程都在等待，则在对该条件执行 <code>signal</code> 操作后，系统调度程序只能选择其中一个进程恢复运行。</p>
<blockquote>
<p>条件变量不是计数器。条件变量也不能像信号量那样积累信号以便以后使用。所以，如果向一个条件变量发送信号，但是该条件变量上没有等待进程，那么信号将会丢失。也就是说，<strong><code>wait</code> 操作必须在 <code>signal</code> 之前执行</strong>。</p>
</blockquote>
<p>通过临界区自动的互斥，<strong>管程比信号量更容易保证并行编程的正确性</strong>。但是管程也有缺点，我们前面说到过管程是一个编程语言的概念，编译器必须要识别管程并用某种方式对其互斥作出保证。C、Pascal 以及大多数其他编程语言都没有管程，所以不能依靠编译器来遵守互斥规则。</p>
<p>与管程和信号量有关的另一个问题是，<strong>这些机制都是设计用来解决访问共享内存的一个或多个 <code>CPU</code> 上的互斥问题的</strong>。</p>
<ul>
<li>通过将信号量放在共享内存中并用 <code>TSL</code> 或 <code>XCHG</code> 指令来保护它们，可以避免竞争。</li>
<li>但是如果是在分布式系统中，可能同时具有多个 <code>CPU</code> 的情况，并且每个 <code>CPU</code> 都有自己的私有内存呢，它们通过网络相连，那么这些原语将会失效。因为信号量太低级了，而管程在少数几种编程语言之外无法使用，所以还需要其他方法。</li>
</ul>
<h2 id="消息传递"><a class="markdownIt-Anchor" href="#消息传递"></a> 消息传递</h2>
<p><code>消息传递(messaage passing)</code> 使用两个原语 <code>send</code> 和 <code>receive</code>，它们像信号量而不像管程，是系统调用而不是语言级别。示例如下</p>
<pre><code class="hljs c">send(destination, &amp;message);

receive(source, &amp;message);</code></pre>
<p><code>send</code> 方法用于向一个给定的目标发送一条消息，<code>receive</code> 从一个给定的源接受一条消息。如果没有消息，接受者可能被阻塞，直到接受一条消息或者带着错误码返回。</p>
<h3 id="设计要点"><a class="markdownIt-Anchor" href="#设计要点"></a> 设计要点</h3>
<p>消息传递系统现在面临着许多信号量和管程所未涉及的问题和设计难点，尤其对那些在网络中不同机器上的通信状况。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923130422.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>
<p><strong>消息丢失</strong> - 为了防止消息丢失，发送方和接收方可以达成一致：一旦接受到消息后，接收方马上回送一条特殊的 <code>确认(acknowledgement)</code> 消息。如果发送方在一段时间间隔内未收到确认，则重发消息。</p>
</li>
<li>
<p><strong>确认消息丢失</strong> - 发送者将重发消息，这样接受者将收到两次相同的消息。对于接收者来说，如何区分新的消息和一条重发的老消息是非常重要的。通常采用<strong>在每条原始消息中嵌入一个连续的序号</strong>来解决此问题。如果接受者收到一条消息，它具有与前面某一条消息一样的序号，就知道这条消息是重复的，可以忽略。</p>
</li>
</ul>
<h3 id="用消息传递解决生产者-消费者问题"><a class="markdownIt-Anchor" href="#用消息传递解决生产者-消费者问题"></a> 用消息传递解决生产者-消费者问题</h3>
<pre><code class="hljs c"><span class="hljs-comment">/* buffer 中槽的数量 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100													</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;
  
  <span class="hljs-keyword">int</span> item;
  <span class="hljs-comment">/* buffer 中槽的数量 */</span>
  message m;													
  
  <span class="hljs-keyword">while</span>(TRUE)&#123;
    <span class="hljs-comment">/* 生成放入缓冲区的数据 */</span>
    item = produce_item();						
    <span class="hljs-comment">/* 等待消费者发送空缓冲区 */</span>
    receive(consumer,&amp;m);							
    <span class="hljs-comment">/* 建立一个待发送的消息 */</span>
    build_message(&amp;m,item);						
    <span class="hljs-comment">/* 发送给消费者 */</span>
    send(consumer,&amp;m);								
  &#125;
  
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;
  
  <span class="hljs-keyword">int</span> item,i;
  message m;
  
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++)&#123;						
    <span class="hljs-comment">/* 发送 N 个缓冲区 */</span>
    send(producer,&amp;m);								
  &#125;
  <span class="hljs-keyword">while</span>(TRUE)&#123;
    <span class="hljs-comment">/* 接受包含数据的消息 */</span>
    receive(producer,&amp;m);							
    <span class="hljs-comment">/* 将数据从消息中提取出来 */</span>
    item = extract_item(&amp;m);					
    <span class="hljs-comment">/* 将空缓冲区发送回生产者 */</span>
    send(producer,&amp;m);								
    <span class="hljs-comment">/* 处理数据 */</span>
    consume_item(item);								
  &#125;
  
&#125;</code></pre>
<p>在该解决方案中共使用 <code>N</code> 条消息，这就类似于一块共享内存缓冲区的 <code>N</code> 个槽。消费者首先将 <code>N</code> 条空消息发送给生产者。当生产者向消费者传递一个数据项时，它取走一条空消息并返回一条填充了内容的消息。通过这种方式，系统中总的消息数量保持不变，所以消息都可以存放在事先确定数量的内存中。</p>
<h2 id="屏障"><a class="markdownIt-Anchor" href="#屏障"></a> 屏障</h2>
<p>屏障是用于<strong>进程组</strong>而不是进程间的生产者-消费者情况的。在某些应用中划分了若干阶段，并且规定，除非<strong>所有的进程都就绪</strong>准备进入下一个阶段，否则任何进程都不能进入下一个阶段，可以通过在每个阶段的结尾安装一个 <code>屏障(barrier)</code> 来实现这种行为。当一个进程到达屏障时，它会被屏障所拦截，直到所有的屏障都到达为止。屏障可用于一组进程同步，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923131256.png" srcset="/img/loading.gif" alt="" /></p>
<h1 id="调度"><a class="markdownIt-Anchor" href="#调度"></a> 调度</h1>
<p>在多道程序系统中，<strong>调度的实质是一种资源分配</strong>，多个进程或者线程同时竞争 <code>CPU</code> 和<code>时间片</code>，通过调度算法来选择需要运行的进程/线程。</p>
<h2 id="调度介绍"><a class="markdownIt-Anchor" href="#调度介绍"></a> 调度介绍</h2>
<p>批处理系统的时代：依次运行磁带上的每一个作业。<br />
对于多道程序设计系统，会复杂一些，因为通常会有多个用户在等待服务。一些大型机仍然将 <code>批处理</code> 和 <code>分时服务</code> 结合使用，需要调度程序决定下一个运行的是一个批处理作业还是终端上的用户。由于在这些机器中 <code>CPU</code> 是稀缺资源，所以好的调度程序可以在提高性能和用户的满意度方面取得很大的成果。</p>
<h3 id="进程行为"><a class="markdownIt-Anchor" href="#进程行为"></a> 进程行为</h3>
<p><strong>几乎所有的进程（磁盘或网络）I/O 请求和计算都是交替运行的。</strong><br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923134601.png" srcset="/img/loading.gif" alt="" /><br />
上面 <code>a</code> 是 <code>CPU 密集型</code> 进程；<code>b</code> 是 <code>I/O 密集型</code> 进程，<code>a</code> 因为在计算的时间上花费时间更长，因此称为 <code>计算密集型(compute-bound)</code> 或者 <code>CPU 密集型(CPU-bound)</code>，<code>b</code> 因为 <code>I/O</code> 发生频率比较快因此称为 <code>I/O 密集型(I/O-bound)</code>。</p>
<ul>
<li>计算密集型进程有较长的 <code>CPU</code> 集中使用和较小频度的 <code>I/O</code> 等待。</li>
<li><code>I/O</code> 密集型进程有较短的 <code>CPU</code> 使用时间和较频繁的 <code>I/O</code> 等待。</li>
</ul>
<p>注意到上面两种进程的区分关键在于 <strong><code>CPU</code> 的时间占用</strong>而不是 <code>I/O</code> 的时间占用。<br />
<code>I/O 密集型</code> 的原因是因为<strong>它们没有在 <code>I/O</code> 之间花费更多的计算、而不是 <code>I/O</code> 请求时间特别长</strong>。无论数据到达后需要花费多少时间，它们都需要花费相同的时间来发出读取磁盘块的硬件请求。</p>
<p>值得注意的是，随着 <code>CPU</code> 的速度越来越快，更多的进程倾向于 <code>I/O 密集型</code>。这种情况出现的原因是 <code>CPU</code> 速度的提升要远远高于硬盘。这种情况导致的结果是，未来对 <code>I/O</code> 密集型进程的调度处理似乎更为重要。这里的基本思想是，如果需要运行 <code>I/O</code> 密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌。</p>
<h3 id="何时调度"><a class="markdownIt-Anchor" href="#何时调度"></a> 何时调度</h3>
<p>第一个和调度有关的问题是<strong>何时进行调度决策</strong>。存在着需要调度处理的各种情形。</p>
<ul>
<li>
<p>首先，在创建一个新进程后，需要决定是运行父进程还是子进程。因为二者的进程都处于就绪态下，这是正常的调度决策，可以任意选择，也就是说，调度程序可以任意的选择子进程或父进程开始运行。</p>
</li>
<li>
<p>第二，在进程退出时需要作出调度决定。因为此进程不再运行（因为它将不再存在），因此必须从就绪进程中选择其他进程运行。如果没有进程处于就绪态，系统提供的空闲进程通常会运行。</p>
</li>
</ul>
<h3 id="调度算法的分类"><a class="markdownIt-Anchor" href="#调度算法的分类"></a> 调度算法的分类</h3>
<p>不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，<strong>在不同的系统中，调度程序的优化也是不同的</strong>。这里有必要划分出三种环境：</p>
<ol>
<li>
<p><code>批处理(Batch)</code>：<br />
批处理系统广泛应用于商业领域，比如用来处理工资单、存货清单、账目收入、账目支出、利息计算、索赔处理和其他周期性作业。在批处理系统中，<strong>一般会选择使用<code>非抢占式算法</code>或者<code>周期性比较长的抢占式算法</code></strong>。这种方法可以<code>减少线程切换</code>因此能够提升性能。</p>
</li>
<li>
<p><code>交互式(Interactive)</code>：<br />
在交互式用户环境中，为了避免一个进程霸占 <code>CPU</code> 拒绝为其他进程服务，所以需要<code>抢占式算法</code>。即使没有进程有意要一直运行下去，但是，由于某个进程出现错误也有可能无限期的排斥其他所有进程。为了避免这种情况，抢占式也是必须的。服务器也属于此类别，因为它们通常为多个（远程）用户提供服务，而这些用户都非常着急，计算机用户总是很忙。</p>
</li>
<li>
<p><code>实时(Real time)</code>：<br />
在实时系统中，抢占有时是不需要的，因为进程知道自己可能运行不了很长时间，通常很快的做完自己的工作并阻塞。</p>
</li>
</ol>
<p>实时系统与交互式系统的差别是，实时系统只运行那些用来推进现有应用的程序，而交互式系统是通用的，它可以运行任意的非协作甚至是有恶意的程序。</p>
<h3 id="调度算法的目标"><a class="markdownIt-Anchor" href="#调度算法的目标"></a> 调度算法的目标</h3>
<p>所有系统:</p>
<ul>
<li>公平：给每个进程公平的 <code>CPU</code> 份额。</li>
<li>策略强制执行：保证规定的策略被执行。</li>
<li>平衡：保持系统的所有部分都忙碌。</li>
</ul>
<p>批处理系统：</p>
<ul>
<li>吞吐量：系统每小时完成的作业数量。</li>
<li>周转时间：一个批处理提交开始直到作业完成时刻为止平均时间。该数据度量了用户要得到输出所需的平均等待时间。周转时间越小越好。</li>
<li><code>CPU</code> 利用率：保持 <code>CPU</code> 时钟忙碌。</li>
</ul>
<p>交互式系统：</p>
<ul>
<li>减少响应时间。</li>
<li>均衡性：满足用户期望。</li>
</ul>
<p>实时系统</p>
<ul>
<li>必须满足最后的截止时间：避免数据丢失。</li>
<li>可预测性：多媒体系统中避免品质降低。</li>
</ul>
<h2 id="一-批处理中的调度"><a class="markdownIt-Anchor" href="#一-批处理中的调度"></a> 一. 批处理中的调度</h2>
<h3 id="1-先来先服务"><a class="markdownIt-Anchor" href="#1-先来先服务"></a> 1. 先来先服务</h3>
<p><code>先来先服务(first-come,first-serverd)</code> <strong>将按照请求顺序为进程分配 <code>CPU</code>。</strong> 最基本的，会有一个就绪进程的等待队列。</p>
<ul>
<li>当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。</li>
<li>当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。</li>
<li>当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923142129.png" srcset="/img/loading.gif" alt="" /></li>
</ul>
<p>缺点：<strong>没有优先级的关系</strong>，试想一下，如果有 100 个 I/O 进程正在排队，第 101 个是一个 CPU 密集型进程，那岂不是需要等 100 个 I/O 进程运行完毕才会等到一个 CPU 密集型进程运行，这在实际情况下根本不可能，所以需要 <code>优先级</code> 或者 <code>抢占式</code> 进程的出现来优先选择重要的进程运行。</p>
<h3 id="2-最短作业优先"><a class="markdownIt-Anchor" href="#2-最短作业优先"></a> 2. 最短作业优先</h3>
<p><code>最短作业优先(Shortest Job First)</code> 以作业的长短来计算优先级，作业越短，其优先级越高。</p>
<blockquote>
<p>需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923142638.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="3-最短剩余时间优先"><a class="markdownIt-Anchor" href="#3-最短剩余时间优先"></a> 3. 最短剩余时间优先</h3>
<p>最短作业优先的<code>抢占式</code>版本被称作为 <code>最短剩余时间优先(Shortest Remaining Time Next)</code> 算法。使用这个算法，调度程序总是选择<strong>剩余运行时间最短</strong>的那个进程运行。当一个新作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式能够使短期作业获得良好的服务。</p>
<h2 id="二-交互式系统中的调度"><a class="markdownIt-Anchor" href="#二-交互式系统中的调度"></a> 二. 交互式系统中的调度</h2>
<h3 id="1-轮询调度"><a class="markdownIt-Anchor" href="#1-轮询调度"></a> 1. 轮询调度</h3>
<p>一种最古老、最简单、最公平并且最广泛使用的算法就是 <code>轮询算法(round-robin)</code>。每个进程都会被分配一个时间段，称为 <code>时间片(quantum)</code>，在这个时间片内允许进程运行。</p>
<p>切换时机：</p>
<ul>
<li>如果时间片结束时进程还在运行的话，则抢占一个 <code>CPU</code> 并将其分配给另一个进程。</li>
<li>如果进程在时间片结束前阻塞或结束，则 <code>CPU</code> 立即进行切换。</li>
</ul>
<p>时间片大小：</p>
<ul>
<li>小时间片有利于短作业，但会频繁执行进程调度和上下文切换。</li>
<li>长时间片，为了使每个进程在一个时间片内完成，RR 算法便退化为 FCFS 算法，无法满足短作业和交互用户的需求。</li>
<li>一个较为可取的时间片大小是略大于一次典型的交互所需要的时间，使大多数交互式进程能在一个时间片内完成，从而可以获得很小的响应时间。</li>
</ul>
<p>轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 <code>a</code>，当一个进程用完时间片后就被移到队列的末尾，就像下图的 <code>b</code>。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923143142.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="2-优先级调度"><a class="markdownIt-Anchor" href="#2-优先级调度"></a> 2. 优先级调度</h3>
<p><code>优先级调度(priority scheduling)</code> 是把处理机分配给就绪队列中优先级最高的进程。</p>
<p>但是也不意味着高优先级的进程能够永远一直运行下去，调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果此操作导致其优先级降低到下一个最高进程的优先级以下，则会发生进程切换。或者，可以为每个进程分配允许运行的最大时间间隔。当时间间隔用完后，下一个高优先级的进程会得到运行的机会。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923144447.png" srcset="/img/loading.gif" alt="" /><br />
算法类型：</p>
<ul>
<li>非抢占式：一旦 CPU 分配给就绪队列中优先级最高的进程后，该进程便一直执行下去直至完成。</li>
<li>抢占式：在优先级最高的进程执行期间，只要出现另一个优先级更高的进程，就将 CPU 分配给新的最高优先级进程。</li>
</ul>
<p>优先级类型：</p>
<ul>
<li>静态优先级：在创建进程时确定优先级，在进程的整个运行期间保持不变。</li>
<li>动态优先级：在创建进程之初，先赋予一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。</li>
</ul>
<h3 id="3-多级队列"><a class="markdownIt-Anchor" href="#3-多级队列"></a> 3. 多级队列</h3>
<p>将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，就绪队列本身也可以设置不同的优先级。</p>
<h3 id="4-最短进程优先"><a class="markdownIt-Anchor" href="#4-最短进程优先"></a> 4. 最短进程优先</h3>
<p>根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。<br />
假设每个终端上每条命令的预估运行时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，现在假设测量到其下一次运行时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，可以用两个值的加权来改进估计时间，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><msub><mi>T</mi><mn>0</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">aT_0 + (1 - a)T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。通过选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">a = \frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 时，可以得到下面这个序列：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msub><mi>T</mi><mn>0</mn></msub><mn>2</mn></mfrac><mo>+</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{T_0}{2} + \frac{T_1}{2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msub><mi>T</mi><mn>0</mn></msub><mn>4</mn></mfrac><mo>+</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mn>4</mn></mfrac><mo>+</mo><mfrac><msub><mi>T</mi><mn>2</mn></msub><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{T_0}{4} + \frac{T_1}{4} + \frac{T_2}{2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msub><mi>T</mi><mn>0</mn></msub><mn>8</mn></mfrac><mo>+</mo><mfrac><msub><mi>T</mi><mn>1</mn></msub><mn>8</mn></mfrac><mo>+</mo><mfrac><msub><mi>T</mi><mn>2</mn></msub><mn>4</mn></mfrac><mo>+</mo><mfrac><msub><mi>T</mi><mn>3</mn></msub><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{T_0}{8} + \frac{T_1}{8} + \frac{T_2}{4} + \frac{T_3}{2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>可以看到，在三轮过后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在新的估计值中所占比重下降至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">1/8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">8</span></span></span></span>。</p>
<p>有时把这种通过当前测量值和先前估计值进行加权平均从而得到下一个估计值的技术称作 <code>老化(aging)</code>。这种方法会使用很多预测值基于当前值的情况。</p>
<h3 id="5-保证调度"><a class="markdownIt-Anchor" href="#5-保证调度"></a> 5. 保证调度</h3>
<p>对用户做出明确的性能保证。一种实际而且容易实现的保证是：在一个有 <code>n</code> 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 <code>1/n</code> 的 <code>CPU</code> 时间。</p>
<h3 id="6-彩票调度"><a class="markdownIt-Anchor" href="#6-彩票调度"></a> 6. 彩票调度</h3>
<p><code>彩票调度(lottery scheduling)算法</code> 为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。</p>
<ul>
<li>
<p><strong>所有的进程是平等的，但是某些进程能够更平等一些。</strong> 一些重要的进程可以给它们额外的彩票，以便增加他们赢得的机会。<br />
如果出售了 100 张彩票，而且有一个进程持有了它们中的 20 张，它就会有 20% 的机会去赢得彩票中奖。在长时间的运行中，它就会获得 20% 的CPU。相反，对于优先级调度程序，很难说明拥有优先级 40 究竟是什么意思，这里的规则很清楚，拥有彩票 f 份额的进程大约得到系统资源的 f 份额。</p>
</li>
<li>
<p><strong>如果希望进程之间协作的话可以交换它们之间的票据。</strong> 例如，客户端进程给服务器进程发送了一条消息后阻塞，客户端进程可能会把自己所有的票据都交给服务器，来增加下一次服务器运行的机会。当服务完成后，它会把彩票还给客户端让其有机会再次运行。事实上，如果没有客户机，服务器也根本不需要彩票。</p>
</li>
</ul>
<h3 id="7-公平分享调度"><a class="markdownIt-Anchor" href="#7-公平分享调度"></a> 7. 公平分享调度</h3>
<p>一些系统在调度前会把<strong>进程的拥有者</strong>考虑在内。在这种模型下，<strong>每个用户都会分配一些 <code>CPU</code> 时间，而调度程序会选择进程并强制执行。</strong> 因此如果两个用户每个都会有 <code>50%</code> 的 <code>CPU</code> 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 <code>CPU</code> 份额。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923151340.png" srcset="/img/loading.gif" alt="" /></p>
<h2 id="三-实时系统中的调度"><a class="markdownIt-Anchor" href="#三-实时系统中的调度"></a> 三. 实时系统中的调度</h2>
<p><code>实时系统(real-time)</code> 是一个时间扮演了重要作用的系统。典型的，一种或多种外部物理设备发给计算机一个服务请求，而计算机<strong>必须在一个确定的时间范围内恰当的做出反应</strong>。</p>
<p>例如，在 CD 播放器中的计算机会获得从驱动器过来的位流，然后必须在非常短的时间内将位流转换为音乐播放出来。如果计算时间过长，那么音乐就会听起来有异常。<br />
再比如说医院特别护理部门的病人监护装置、飞机中的自动驾驶系统、列车中的烟雾警告装置等，在这些例子中，正确但是却缓慢的响应要比没有响应甚至还糟糕。</p>
<p>实时系统可以分为两类，<code>硬实时(hard real time)</code> 和 <code>软实时(soft real time)</code> 系统，前者意味着必须要<strong>满足绝对的截止时间</strong>；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。在这两种情形中，实时都是通过把程序划分为一组进程而实现的，其中每个进程的行为是可预测和提前可知的。这些进程一般寿命较短，并且极快的运行完成。在检测到一个外部信号时，调度程序的任务就是按照满足所有截止时间的要求调度进程。</p>
<p>实时系统中的事件可以按照响应方式进一步分类为 <code>周期性(以规则的时间间隔发生)</code> 事件或 <code>非周期性(发生时间不可预知)</code> 事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个周期事件，事件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 以周期 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 发生，并需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 秒 <code>CPU</code> 时间处理一个事件，那么可以处理负载的条件是</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>P</mi><mi>i</mi></msub></mfrac><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{m} \frac{C_i}{P_i} \leq 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>只有满足这个条件的实时系统称为 <code>可调度</code> 的，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 <code>CPU</code> 时间总和大于 <code>CPU</code> 能提供的时间。</p>
<h2 id="线程调度"><a class="markdownIt-Anchor" href="#线程调度"></a> 线程调度</h2>
<p>当若干进程都有多个线程时，就存在两个层次的并行：进程和线程。在这样的系统中调度处理有本质的差别，这取决于所支持的是用户级线程还是内核级线程（或两者都支持）。</p>
<p>首先考虑 <code>用户级线程</code>，由于内核并不知道有线程存在，所以内核还是和以前一样地操作，选取一个进程，假设为 A，并给予 A 以时间片控制。<strong>进程 A 中的线程调度程序决定哪个线程运行。</strong> 假设为 A1。由于多道线程并不存在时钟中断，所以这个线程可以按其意愿任意运行多长时间。如果该线程用完了进程的全部时间片，内核就会选择另一个进程继续运行。</p>
<p>在进程 A 终于又一次运行时，线程 A1 会接着运行。该线程会继续耗费 A 进程的所有时间，直到它完成工作。不过，线程运行不会影响到其他进程。其他进程会得到调度程序所分配的合适份额，不会考虑进程 A 内部发生的事情。</p>
<p>现在考虑 A 线程每次 CPU 计算的工作比较少的情况，例如：在 50 ms 的时间片中有 5 ms 的计算工作。于是，每个线程运行一会儿，然后把 CPU 交回给线程调度程序。这样在内核切换到进程 B 之前，就会有序列 A1, A2, A3, A1, A2, A3, A1, A2, A3, A1。 如下所示</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923154350.png" srcset="/img/loading.gif" alt="" /></p>
<p>运行时系统使用的调度算法可以是上面介绍算法的任意一种。从实用方面考虑，<strong>轮转调度和优先级调度更为常用</strong>。唯一的局限是，缺乏一个时钟中断运行过长的线程。但由于线程之间的合作关系，这通常也不是问题。</p>
<p>现在考虑使用<code>内核线程</code> 的情况，<strong>内核选择一个特定的线程运行</strong>。<strong>它不用考虑线程属于哪个进程</strong>，不过如果有必要的话，也可以这么做。对被选择的线程赋予一个时间片，而且如果超过了时间片，就会强制挂起该线程。一个线程在 50 ms 的时间片内，5 ms 之后被阻塞，在 30 ms 的时间片中，线程的顺序会是 A1, B1, A2, B2, A3, B3。如下图所示<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200923154416.png" srcset="/img/loading.gif" alt="" /></p>
<p>用户级线程和内核级线程之间的主要差别在于<code>性能</code>。<strong>用户级线程的切换需要少量的机器指令，而内核线程需要完整的上下文切换</strong>，修改内存映像，使高速缓存失效，这会导致了若干数量级的延迟。另一方面，在使用内核级线程时，一旦线程阻塞在 <code>I/O</code> 上就不需要在用户级线程中那样将整个进程挂起。</p>
<p>从进程 A 的一个线程切换到进程 B 的一个线程，其消耗要远高于运行进程 A 的两个线程（涉及修改内存映像，修改高速缓存），内核对这种切换的消耗是了解到，可以通过这些信息作出决定。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/09/21/LeetCode-189-rotate-array/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LeetCode 189. 旋转数组</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/09/20/LeetCode-88-merge-sorted-array/">
                        <span class="hidden-mobile">LeetCode 88. 合并两个有序数组</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <!-- <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> -->
      Crafted with
      <i class="iconfont icon-love" style="color: #f30;"></i>
      by <a href="https://github.com/likailee" target="_blank" rel="noopener">Likai Lee</a>
      | &copy; 2017 - 2020
      <!-- <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a> -->
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css" />
  













  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?66c61a5fd59052d1b39d89c246846ae5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
