<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Likai Lee">
  <meta name="keywords" content="">
  <title>操作系统 进程与线程 - Likai Lee</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Likai Lee</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                操作系统 进程与线程
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-09-21 15:28">
      2020年9月21日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      133
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年9月22日 下午
                
              </p>
            
            <article class="markdown-body">
              <p>[TOC]</p>
<h1 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h1>
<p><strong>进程是操作系统对正在运行中的程序的一个抽象</strong>，操作系统的其他所有内容都是通过进程展开的。无论是在单核还是多核 <code>CPU</code> 中，一个 <code>CPU</code> 都像是在<strong>并发</strong>地执行多个进程，这是通过处理器在进程间切换来实现的，即<strong>伪并行</strong>。</p>
<blockquote>
<p><code>伪并行</code>是指单核或多核处理器同时执行多个进程，从而使程序更快。 通过以<strong>非常有限的时间间隔在程序之间快速切换 <code>CPU</code></strong>，因此会产生并行感。 缺点是 <code>CPU</code> 时间可能分配给下一个进程，也可能不分配给下一个进程。</p>
</blockquote>
<h2 id="进程模型"><a class="markdownIt-Anchor" href="#进程模型"></a> 进程模型</h2>
<p>在进程模型中，所有计算机上运行的软件，通常也包括操作系统，被组织为若干<strong>顺序进程</strong>(<code>sequential processes</code>)，简称为 <strong>进程</strong>(<code>process</code>) 。一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 <code>CPU</code>，但是实际情况是 <code>CPU</code> 会在各个进程之间进行来回切换。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200918135528.png" srcset="/img/loading.gif" alt="" /><br />
如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200918135549.png" srcset="/img/loading.gif" alt="" /><br />
在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。<br />
当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。<br />
当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p>
<p>从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，但<strong>在任何一个给定的瞬间仅有一个进程真正运行。</strong><br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200918135606.png" srcset="/img/loading.gif" alt="" /></p>
<p>因此，当我们说一个 <code>CPU</code> 只能真正一次运行一个进程的时候，即使有 <code>2</code> 个核（或 <code>CPU</code>），<strong>每一个核也只能一次运行一个线程</strong>。</p>
<p>这里的关键思想是认识到一个进程所需的条件，<strong>进程是某一类特定活动的总和，它有程序、输入输出以及状态。</strong> 单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务。<br />
另外需要注意的是，如果一个进程运行了两遍，则被认为是两个进程，操作系统能够使它们共享代码，因此只有一个副本放在内存中。</p>
<h2 id="进程的创建"><a class="markdownIt-Anchor" href="#进程的创建"></a> 进程的创建</h2>
<p>创建进程的方式:</p>
<ol>
<li>系统初始化（<code>init</code>）</li>
<li>正在运行的程序执行了创建进程的系统调用（比如 fork）</li>
<li>用户请求创建一个新进程</li>
<li>初始化一个批处理工作</li>
</ol>
<p>在 <code>UNIX</code> 和 <code>Windows</code> 中，进程创建之后，<strong>父进程和子进程有各自不同的地址空间</strong>。如果其中某个进程在其地址空间中修改了一个字，这个修改将对另一个进程不可见。</p>
<ul>
<li>
<p>在 <code>UNIX</code> 中，子进程的地址空间是父进程的一个副本，但是这里涉及两个不同的地址空间；<strong>不可写的内存区域是共享的</strong>，<strong>可写的内存是不能被共享的</strong>。<br />
某些 <code>UNIX</code> 实现使子进程共享父进程的所有内存，但是这种情况下通过 <code>写时复制 (copy-on-write)</code> 共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。但是，对于一个新创建的进程来说，确实有可能共享创建者的资源，比如可以共享打开的文件。</p>
</li>
<li>
<p>在 <code>Windows</code> 中，从一开始父进程的地址空间和子进程的地址空间就是不同的。</p>
</li>
</ul>
<h3 id="1-系统初始化"><a class="markdownIt-Anchor" href="#1-系统初始化"></a> 1. 系统初始化</h3>
<p>启动操作系统时，通常会创建若干个进程。</p>
<ul>
<li><code>前台进程 (numerous processes</code>) 同用户进行交互并替他们完成工作的进程。</li>
<li><code>守护进程 (daemons)</code> 运行在后台，并不与特定的用户进行交互。</li>
</ul>
<h3 id="2-系统调用创建"><a class="markdownIt-Anchor" href="#2-系统调用创建"></a> 2. 系统调用创建</h3>
<p>一个正在运行的进程会发出<code>系统调用</code>用来创建一个或多个新进程来帮助其完成工作。</p>
<p>例如，如果有大量的数据需要经过网络调取并进行顺序处理，那么创建一个进程读数据，并把数据放到共享缓冲区中，而让第二个进程取走并正确处理会比较容易些。在多处理器中，让每个进程运行在不同的 CPU 上也可以使工作做的更快。</p>
<h3 id="3-用户请求创建"><a class="markdownIt-Anchor" href="#3-用户请求创建"></a> 3. 用户请求创建</h3>
<p>在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。在 Windows 中启动进程时，它一般没有窗口，但是它可以创建一个或多个窗口。每个窗口都可以运行进程。通过鼠标或者命令就可以切换窗口并与进程进行交互。</p>
<h3 id="4-批处理创建"><a class="markdownIt-Anchor" href="#4-批处理创建"></a> 4. 批处理创建</h3>
<p>批处理创建会在大型机的<code>批处理系统</code>中应用。用户在这种系统中提交批处理作业。当操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业。</p>
<h2 id="进程的终止"><a class="markdownIt-Anchor" href="#进程的终止"></a> 进程的终止</h2>
<p>进程在创建之后，它就开始运行并做完成任务。然而，进程早晚会发生终止，通常是由于以下情况触发的</p>
<ol>
<li>正常退出(自愿的)</li>
<li>错误退出(自愿的)</li>
<li>严重错误(非自愿的)</li>
<li>被其他进程杀死(非自愿的)</li>
</ol>
<h3 id="1-正常退出自愿的"><a class="markdownIt-Anchor" href="#1-正常退出自愿的"></a> 1. 正常退出(自愿的)</h3>
<p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。<br />
这个调用在 <code>UNIX</code> 中是 <code>exit</code> ，在 <code>Windows</code> 中是 <code>ExitProcess</code>。</p>
<h3 id="2-错误退出自愿的"><a class="markdownIt-Anchor" href="#2-错误退出自愿的"></a> 2. 错误退出(自愿的)</h3>
<p>进程发生终止的第二个原因是发现错误。<br />
例如，如果用户执行如下命令</p>
<pre><code class="hljs bash">cc foo.c</code></pre>
<p>要编译 <code>foo.c</code> 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p>
<h3 id="3-严重错误非自愿的"><a class="markdownIt-Anchor" href="#3-严重错误非自愿的"></a> 3. 严重错误(非自愿的)</h3>
<p>严重错误通常是由于程序中的错误所导致的。<br />
例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 <code>UNIX</code> 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p>
<h3 id="4-被其他进程杀死非自愿的"><a class="markdownIt-Anchor" href="#4-被其他进程杀死非自愿的"></a> 4. 被其他进程杀死(非自愿的)</h3>
<p>某个进程执行<strong>系统调用</strong>告诉操作系统杀死某个进程。在 <code>UNIX</code> 中，这个系统调用是 <code>kill</code>。在 <code>Win32</code> 中对应的函数是 <code>TerminateProcess</code>。</p>
<h2 id="进程的层次结构"><a class="markdownIt-Anchor" href="#进程的层次结构"></a> 进程的层次结构</h2>
<p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p>
<h3 id="unix-进程体系"><a class="markdownIt-Anchor" href="#unix-进程体系"></a> <code>UNIX</code> 进程体系</h3>
<p>在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 <code>kill</code> 掉。</p>
<p><code>UNIX</code> 在启动时会运行 <code>init</code> 进程，它会初始化多个子进程，因此，整个操作系统中的所有进程都属于一个以 <code>init</code> 为根的进程树。</p>
<h3 id="windows-进程体系"><a class="markdownIt-Anchor" href="#windows-进程体系"></a> <code>Windows</code> 进程体系</h3>
<p><code>Windows</code> 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为<code>句柄</code>），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 <code>UNIX</code> 中，进程不能剥夺其子进程的 <strong>进程权</strong>。</p>
<h2 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h2>
<p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。例如，一个进程的结果可以作为另一个进程的输入，在 <code>shell</code> 命令中</p>
<pre><code class="hljs shell">cat chapter1 chapter2 chapter3 | grep tree</code></pre>
<p>第一个进程是 <code>cat</code>，将三个文件级联并输出。第二个进程是 <code>grep</code>，它从输入中选择具有包含关键字 <code>tree</code> 的内容，根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的 <code>CPU</code> 时间片），可能会发生下面这种情况，<code>grep</code> 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞 <code>grep</code> 进程，直到输入完毕。</p>
<p>当一个进程开始运行时，它可能会经历下面这几种状态</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921150701.png" srcset="/img/loading.gif" alt="" /></p>
<p>图中会涉及三种状态：</p>
<ol>
<li><strong>运行态</strong>，该时刻进程实际占用 <code>CPU</code>。</li>
<li><strong>就绪态</strong>，可运行，但因为其他进程正在运行而处于就绪状态。</li>
<li><strong>阻塞态</strong>，除非某种外部事件发生，否则进程不能运行。</li>
</ol>
<ul>
<li>逻辑上来说，运行态和就绪态是很相似的。都表示进程可运行，但是<strong>就绪态</strong>没有获得 <code>CPU</code> 时间分片。</li>
<li>阻塞态与前两种状态不同的原因是<strong>这个进程不能运行，<code>CPU</code> 空闲时也不能运行</strong>。</li>
</ul>
<p>三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生 <code>状态 1</code> 的轮转。<br />
<code>转换 2</code> 和<code>转换 3</code> 都是由进程调度程序引起的，进程本身不知道调度程序的存在。<br />
<code>转换 2</code> 的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行 <code>CPU</code> 时间片了。<br />
当所有其他进程都运行过后，这时候该是让第一个进程重新获得 <code>CPU</code> 时间片的时候了，就会发生<code>转换 3</code>。</p>
<blockquote>
<p>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p>
</blockquote>
<p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生<code>转换 4</code>。如果此时没有其他进程在运行，则立刻触发<code>转换 3</code>，该进程便开始运行，否则该进程会处于就绪阶段，等待 <code>CPU</code> 空闲后再轮到它运行。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921152100.png" srcset="/img/loading.gif" alt="" /></p>
<p><strong>操作系统最底层的就是调度程序</strong>，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。事实上，调度程序只是一段非常小的程序。</p>
<h2 id="进程的实现"><a class="markdownIt-Anchor" href="#进程的实现"></a> 进程的实现</h2>
<p>操作系统为了执行进程间的切换，会维护着一张表格，这张表就是 <code>进程表(process table)</code>。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括<strong>程序计数器</strong>、<strong>堆栈指针</strong>、<strong>内存分配状况</strong>、<strong>所打开文件的状态</strong>、<strong>账号和调度信息</strong>，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921152615.webp" srcset="/img/loading.gif" alt="" /></p>
<p>第一列内容与 <strong>进程管理</strong> 有关，第二列内容与 <strong>存储管理</strong> 有关，第三列内容与 <strong>文件管理</strong> 有关。</p>
<h1 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h1>
<h2 id="线程的使用"><a class="markdownIt-Anchor" href="#线程的使用"></a> 线程的使用</h2>
<p>为什么要在进程的基础上再创建一个线程的概念：</p>
<ul>
<li>多线程之间会<strong>共享同一块地址空间和所有可用数据</strong>的能力，这是进程所不具备的。</li>
<li>线程要比进程更<strong>轻量级</strong>，它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 <code>10 - 100</code> 倍。</li>
<li>性能方面：如果多个线程都是 <code>CPU</code> 密集型的，那么并不能获得性能上的增强，但是如果存在着<strong>大量的计算和大量的 <code>I/O</code> 处理</strong>，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度。</li>
</ul>
<h3 id="1-多线程解决方案"><a class="markdownIt-Anchor" href="#1-多线程解决方案"></a> 1. 多线程解决方案</h3>
<p>一个 WEB 服务器，对页面的请求发送给服务器，而所请求的页面发送回客户端。在多数 WEB 站点上，某些页面较其他页面相比有更多的访问。Web 服务器可以把获得大量访问的页面集合保存在内存中，避免到磁盘去调入这些页面，从而改善性能。这种页面的集合称为 <code>高速缓存(cache)</code>，高速缓存也应用在许多场合中，比如说 <code>CPU</code> 缓存。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921153549.png" srcset="/img/loading.gif" alt="" /></p>
<p>上面是一个 web 服务器的组织方式，一个叫做 <code>调度线程(dispatcher thread)</code> 的线程从网络中读入工作请求，在调度线程检查完请求后，它会选择一个空闲的（阻塞的）工作线程来处理请求，通常是将消息的指针写入到每个线程关联的特殊字中。然后调度线程会唤醒正在睡眠中的工作线程，把工作线程的状态从阻塞态变为就绪态。</p>
<p>当<code>工作线程</code>启动后，它会检查请求是否在 web 页面的高速缓存中存在，这个高速缓存是所有线程都可以访问的。如果高速缓存不存在这个 web 页面的话，它会调用一个 read 操作从磁盘中获取页面并且阻塞线程直到磁盘操作完成。当线程阻塞在硬盘操作的期间，为了完成更多的工作，调度线程可能挑选另一个线程运行，也可能把另一个当前就绪的工作线程投入运行。</p>
<p>这种模型允许<strong>将服务器编写为顺序线程</strong>的集合，在分派线程的程序中包含一个死循环，该循环用来获得工作请求并且把请求派给工作线程。每个工作线程的代码包含一个从调度线程接收的请求，并且检查 web 高速缓存中是否存在所需页面，如果有，直接把该页面返回给客户，接着工作线程阻塞，等待一个新请求的到达。如果没有，工作线程就从磁盘调入该页面，将该页面返回给客户机，然后工作线程阻塞，等待一个新请求。</p>
<h3 id="2-单线程解决方案"><a class="markdownIt-Anchor" href="#2-单线程解决方案"></a> 2. 单线程解决方案</h3>
<p>Web 服务器的主循环获取请求并检查请求，并争取在下一个请求之前完成工作。在等待磁盘操作时，服务器空转，并且不处理任何到来的其他请求。结果会导致每秒中只有很少的请求被处理，所以这个例子能够说明多线程提高了程序的并行性并提高了程序的性能。</p>
<h3 id="3-状态机解决方案"><a class="markdownIt-Anchor" href="#3-状态机解决方案"></a> 3. 状态机解决方案</h3>
<p>如果目前只有一个非阻塞版本的 read 系统调用可以使用，那么当请求到达服务器时，这个唯一的 read 调用的线程会进行检查，如果能够从高速缓存中得到响应，那么直接返回，如果不能，则启动一个非阻塞的磁盘操作。</p>
<p>服务器在表中记录当前请求的状态，然后进入并获取下一个事件，紧接着下一个事件可能就是一个新工作的请求或是磁盘对先前操作的回答。如果是新工作的请求，那么就开始处理请求。如果是磁盘的响应，就从表中取出对应的状态信息进行处理。对于非阻塞式磁盘 I/O 而言，这种响应一般都是信号中断响应。</p>
<p>每次服务器从某个请求工作的状态切换到另一个状态时，都必须显示的保存或者重新装入相应的计算状态。这里，每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为 <code>有限状态机(finite-state machine)</code>。</p>
<ul>
<li>多线程使得顺序进程的思想得以保留下来，并且实现了<strong>并行性</strong>，但是顺序进程会<strong>阻塞系统调用</strong>；</li>
<li>单线程服务器保留了阻塞系统的简易性，但是却放弃了性能。</li>
<li>有限状态机的处理方法运用了<strong>非阻塞调用</strong>和中断，通过<strong>并行</strong>实现了高性能，但是给编程增加了困难。</li>
</ul>
<h2 id="经典的线程模型"><a class="markdownIt-Anchor" href="#经典的线程模型"></a> 经典的线程模型</h2>
<p>组成：</p>
<ul>
<li><strong>程序计数器</strong>，记录接着要执行哪一条指令；</li>
<li><strong>寄存器</strong>，保存线程当前正在使用的变量；</li>
<li><strong>堆栈</strong>，记录程序的执行路径。</li>
</ul>
<p>在同一个进程中，允许彼此之间有较大的独立性且互不干扰。在一个进程中并行运行多个线程类似于在一台计算机上运行多个进程。<br />
在多个线程中，各个线程共享同一地址空间和其他资源。<br />
在多个进程中，进程共享物理内存、磁盘、打印机和其他资源。因为线程会包含有一些进程的属性，所以线程被称为轻量的进程(<code>lightweight processes</code>)。</p>
<p>三个进程，每个进程有自己的地址空间和单个控制线程，每个线程都在不同的地址空间中运行。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155110.png" srcset="/img/loading.gif" alt="" /></p>
<p>一个进程三个线程的情况。每个线程都在相同的地址空间中运行。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155327.png" srcset="/img/loading.gif" alt="" /></p>
<p>线程不像是进程那样具备较强的独立性。<strong>同一个进程中的所有线程都会有完全一样的地址空间</strong>，这意味着它们也<strong>共享同样的全局变量</strong>。由于每个线程都可以访问进程地址空间内每个内存地址，因此一个线程可以读取、写入甚至擦除另一个线程的堆栈。线程之间除了共享同一内存空间外，还具有如下不同的内容：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155439.png" srcset="/img/loading.gif" alt="" /></p>
<p>和进程一样，线程可以处于下面这几种状态：<strong>运行</strong>、<strong>阻塞</strong>、<strong>就绪</strong>和<strong>终止</strong>。<br />
正在运行的线程拥有 <code>CPU</code> 时间片并且状态是运行中。<br />
一个被阻塞的线程会等待某个释放它的事件。<br />
例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞直到有输入为止。线程通常会被阻塞，直到它等待某个外部事件的发生或者有其他线程来释放它。线程之间的状态转换和进程之间的状态转换是一样的。</p>
<p>每个线程都会有自己的堆栈，如下图所示<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921155658.png" srcset="/img/loading.gif" alt="" /></p>
<h2 id="线程实现"><a class="markdownIt-Anchor" href="#线程实现"></a> 线程实现</h2>
<h3 id="1-在用户空间中实现线程"><a class="markdownIt-Anchor" href="#1-在用户空间中实现线程"></a> 1. 在用户空间中实现线程</h3>
<p>第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921160042.png" srcset="/img/loading.gif" alt="" /><br />
线程在运行时系统之上运行，运行时系统是管理线程过程的集合。</p>
<blockquote>
<p><code>运行时系统(Runtime System)</code> 也叫做运行时环境，<strong>该运行时系统提供了程序在其中运行的环境</strong>。此环境可能会解决许多问题，包括应用程序内存的布局，程序如何访问变量，在过程之间传递参数的机制，与操作系统的接口等等。编译器根据特定的运行时系统进行假设以生成正确的代码。通常，运行时系统将负责设置和管理堆栈，并且会包含诸如垃圾收集，线程或语言内置的其他动态的功能。</p>
</blockquote>
<p>在用户空间管理线程时，每个进程需要有其专用的 <code>线程表(thread table)</code>，<strong>用来跟踪该进程中的线程</strong>。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器和状态。<strong>该线程标由运行时系统统一管理</strong>。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程的所有信息，与内核在进程表中存放的信息完全一样。</p>
<p>优势：</p>
<ul>
<li>
<p>保存线程的状态和调度程序都是<code>本地过程</code>，所以启动他们比进行内核调用效率更高。因而<strong>不需要切换到内核，也就不需要上下文切换，也不需要对内存高速缓存进行刷新，因为线程调度非常便捷，因此效率比较高。</strong></p>
</li>
<li>
<p>允许每个进程有自己定制的调度算法。</p>
</li>
</ul>
<h3 id="2-在内核空间中实现线程"><a class="markdownIt-Anchor" href="#2-在内核空间中实现线程"></a> 2. 在内核空间中实现线程</h3>
<p>使用内核来实现线程的情况，<strong>不再需要运行时环境</strong>，<strong>每个进程中也没有线程表</strong>。相反，在内核中会有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921161156.png" srcset="/img/loading.gif" alt="" /></p>
<p>所有能够阻塞的调用都会通过<strong>系统调用</strong>的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 <code>CPU</code> 时间片（或者没有可运行的线程存在了）为止。</p>
<p>由于在内核中创建或者销毁线程的开销比较大，所以某些系统会采用<strong>可循环利用</strong>的方式来回收线程。<br />
当某个线程被销毁时，就把它标志为不可运行的状态，但是其内部结构没有受到影响。稍后，在必须创建一个新线程时，就会重新启用旧线程，把它标志为可用状态。</p>
<h3 id="3-在用户和内核空间中混合实现线程"><a class="markdownIt-Anchor" href="#3-在用户和内核空间中混合实现线程"></a> 3. 在用户和内核空间中混合实现线程</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921161507.png" srcset="/img/loading.gif" alt="" /></p>
<p>在这种模型中，<strong>编程人员可以自由控制用户线程和内核线程的数量</strong>，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程<strong>多路复用</strong>。</p>
<h1 id="进程间通信"><a class="markdownIt-Anchor" href="#进程间通信"></a> 进程间通信</h1>
<h2 id="竞态条件"><a class="markdownIt-Anchor" href="#竞态条件"></a> 竞态条件</h2>
<p>在一些操作系统中，协作的进程可能共享一些彼此都能读写的公共资源。公共资源可能在内存中也可能在一个共享文件。<br />
为了讲清楚进程间是如何通信的，这里我们举一个例子：一个后台打印程序。当一个进程需要打印某个文件时，它会将文件名放在一个特殊的 <code>后台目录(spooler directory)</code> 中。另一个进程 <code>打印后台进程(printer daemon)</code> 会定期的检查是否需要文件被打印，如果有的话，就打印并将该文件名从目录下删除。</p>
<p>假设我们的后台目录有非常多的 <code>槽位(slot)</code>，编号依次为 0，1，2，…，每个槽位存放一个文件名。同时假设有两个共享变量：<code>out</code>，指向下一个需要打印的文件；<code>in</code>，指向目录中下个空闲的槽位。可以把这两个文件保存在一个所有进程都能访问的文件中，该文件的长度为两个字。在某一时刻，0 至 3 号槽位空，4 号至 6 号槽位被占用。在同一时刻，进程 A 和 进程 B 都决定将一个文件排队打印，情况如下：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200921163828.webp" srcset="/img/loading.gif" alt="" /></p>
<p>在某一时刻两个进程都认为下一个可用槽位是 7。<br />
进程 B 会将打印文件名写入到 slot 7 中，然后把 in 的指针更改为 8 ，然后进程 B 离开去做其他的事情。<br />
进程 A 也发现 slot 7 的槽位是空的，于是将打印文件名存入 slot 7 中，然后把 in 的值更新为 8，由于 slot 7 这个槽位中已经有进程 B 写入的值，所以进程 A 的打印文件名会把进程 B 的文件覆盖，由于打印机内部是无法发现是哪个进程更新的，它的功能比较局限，所以这时候进程 B 永远无法打印输出，类似这种情况，即<strong>两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时</strong>，这种就被称为 <code>竞态条件(race condition)</code>。</p>
<h2 id="临界区"><a class="markdownIt-Anchor" href="#临界区"></a> 临界区</h2>
<p>不仅共享资源会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：<strong>禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写</strong>。<br />
换句话说，我们需要一种 <code>互斥(mutual exclusion)</code> 条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。</p>
<p>避免竞争问题的条件可以用一种抽象的方式去描述。大部分时间，进程都会忙于内部计算和其他不会导致竞争条件的计算。然而，有时候进程会访问共享内存或文件，或者做一些能够导致竞态条件的操作。我们把<strong>对共享内存进行访问的程序片段</strong>称作 <code>临界区域(critical region)</code> 或 <code>临界区(critical section)</code>。如果我们能够正确的操作，使两个不同进程不可能同时处于临界区，就能避免竞争条件，这也是从操作系统设计角度来进行的。</p>
<p>尽管上面这种设计避免了竞争条件，但是不能确保并发线程同时访问共享数据的正确性和高效性。一个好的解决方案，应该包含下面四种条件</p>
<ol>
<li>任何时候两个进程不能同时处于临界区</li>
<li>不应对 CPU 的速度和数量做任何假设</li>
<li>位于临界区外的进程不得阻塞其他进程</li>
<li>不能使任何进程无限等待进入临界区</li>
</ol>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200922124159.png" srcset="/img/loading.gif" alt="" /></p>
<p>从抽象的角度来看，我们通常希望进程的行为如上图所示，在 t1 时刻，进程 A 进入临界区，在 t2 的时刻，进程 B 尝试进入临界区，因为此时进程 A 正在处于临界区中，所以进程 B 会阻塞直到 t3 时刻进程 A 离开临界区，此时进程 B 能够允许进入临界区。最后，在 t4 时刻，进程 B 离开临界区，系统恢复到没有进程的原始状态。</p>
<h2 id="忙等互斥"><a class="markdownIt-Anchor" href="#忙等互斥"></a> 忙等互斥</h2>
<p>在实现互斥的各种方案中，当一个进程正忙于更新其临界区的共享内存时，没有其他进程会进入其临界区，也不会造成影响。</p>
<h3 id="1-屏蔽中断"><a class="markdownIt-Anchor" href="#1-屏蔽中断"></a> 1. 屏蔽中断</h3>
<p>在<code>单处理器</code>系统上，最简单的解决方案是<strong>让每个进程在进入临界区后立即屏蔽所有中断</strong>，并<strong>在离开临界区之前重新启用它们</strong>。屏蔽中断后，时钟中断也会被屏蔽。<code>CPU</code> 只有发生时钟中断或其他中断时才会进行进程切换。这样，在屏蔽中断后 <code>CPU</code> 不会切换到其他进程。<br />
所以，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不用担心其他进程介入访问共享数据。</p>
<p>缺点：</p>
<ul>
<li>如果经过一段较长时间后进程没有离开，中断一直无法启用，可能会造成整个系统的终止。</li>
<li>如果是<code>多处理器</code>系统，<strong>屏蔽中断仅仅对执行 <code>disable</code> 指令的 <code>CPU</code> 有效</strong>。其他 <code>CPU</code> 仍将继续运行，并可以访问共享内存。</li>
</ul>
<h3 id="2-锁变量"><a class="markdownIt-Anchor" href="#2-锁变量"></a> 2. 锁变量</h3>
<p>考虑有单个共享的（锁）变量，初始为值为 0 。当一个线程想要进入临界区时，它首先会查看锁的值是否为 0 ，如果锁的值是 0 ，进程会把它设置为 1 并让进程进入临界区。如果锁的状态是 1，进程会等待直到锁变量的值变为 0。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200922130139.png" srcset="/img/loading.gif" alt="" /><br />
此时假设一个进程读出锁变量的值并发现它为 0 ，而恰好在它将其设置为 1 之前，另一个进程调度运行，读出锁的变量为0 ，并将锁的变量设置为 1 。然后第一个线程运行，把锁变量的值再次设置为 1，此时，临界区域就会有两个进程在同时运行。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200922130639.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="3-严格轮询法"><a class="markdownIt-Anchor" href="#3-严格轮询法"></a> 3. 严格轮询法</h3>
<p>进程 0：当 <code>turn == 0</code> 进入临界区</p>
<pre><code class="hljs c"><span class="hljs-keyword">while</span>(TRUE)&#123;
  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">turn</span> == <span class="hljs-number">0</span>)&#123;
    <span class="hljs-comment">/* 进入临界区 */</span>
    critical_region();
    <span class="hljs-built_in">turn</span> = <span class="hljs-number">1</span>;
    <span class="hljs-comment">/* 离开临界区 */</span>
    noncritical_region();
  &#125;
&#125;</code></pre>
<p>进程 1：当 <code>turn == 1</code> 进入临界区</p>
<pre><code class="hljs c"><span class="hljs-keyword">while</span>(TRUE)&#123;
  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">turn</span> == <span class="hljs-number">1</span>)&#123;
    <span class="hljs-comment">/* 进入临界区 */</span>
    critical_region();
    <span class="hljs-built_in">turn</span> = <span class="hljs-number">0</span>;
    <span class="hljs-comment">/* 离开临界区 */</span>
    noncritical_region();
  &#125;
&#125;</code></pre>
<p>在上面代码中，变量 <code>turn</code>，初始值为 <code>0</code> ，用于记录轮到那个进程进入临界区，并检查或更新共享内存。开始时，<code>进程 0</code> 检查 <code>turn</code>，发现其值为 <code>0</code>，于是进入临界区。<code>进程 1</code> 也发现其值为 <code>0</code> ，所以在一个等待循环中不停的测试 <code>turn</code>，看其值何时变为 <code>1</code>。</p>
<blockquote>
<p>连续检查一个变量直到某个值出现为止，这种方法称为 <code>忙等待(busywaiting)</code>。用于忙等待的锁，称为 <code>自旋锁(spinlock)</code>。<br />
由于这种方式<strong>浪费 <code>CPU</code> 时间</strong>，所以这种方式通常应该要避免。只有在有理由认为<strong>等待时间是非常短的情况下，才能够使用忙等待</strong>。</p>
</blockquote>
<p>当 <code>进程 0</code> 和 <code>进程 1</code> 都在非临界区时，此时 <code>进程 0</code> 结束了非临界区的操作并返回到循环的开始。但是，这时它不能进入临界区，因为 <code>turn == 1</code>，此时 <code>进程 1</code> 还忙于非临界区的操作，<code>进程 0</code> 只能继续阻塞，直到<code>进程 1</code> 把 <code>turn</code> 的值改为 <code>0</code>。这说明，在<strong>一个进程比另一个进程执行速度慢了很多的情况下，轮流进入临界区并不是一个好的方法。</strong></p>
<p>这种情况违反了前面的叙述 3 ，即 <strong>位于临界区外的进程不得阻塞其他进程</strong>，<code>进程 0</code> 被临界区外的 <code>进程 1</code> 阻塞。由于违反了第三条，所以也不能作为一个好的方案。</p>
<h3 id="4-peterson-解法"><a class="markdownIt-Anchor" href="#4-peterson-解法"></a> 4. Peterson 解法</h3>
<pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE  1</span>
<span class="hljs-comment">/* 进程数量 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N     2													</span>

<span class="hljs-comment">/* 现在轮到谁 */</span>
<span class="hljs-keyword">int</span> <span class="hljs-built_in">turn</span>;					

<span class="hljs-comment">/* 所有值初始化为 0 (FALSE) */</span>
<span class="hljs-keyword">int</span> interested[N];											

<span class="hljs-comment">/* 进程是 0 或 1 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enter_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">process</span>)</span></span>&#123;					
  
  <span class="hljs-comment">/* 另一个进程号 */</span>
  <span class="hljs-keyword">int</span> other;														
  
  <span class="hljs-comment">/* 另一个进程 */</span>
  other = <span class="hljs-number">1</span> - <span class="hljs-built_in">process</span>;				
  
  <span class="hljs-comment">/* 表示愿意进入临界区 */</span>
  interested[<span class="hljs-built_in">process</span>] = TRUE;						
  <span class="hljs-built_in">turn</span> = <span class="hljs-built_in">process</span>;
  
  <span class="hljs-comment">/* 阻塞 */</span>
  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">turn</span> == <span class="hljs-built_in">process</span> 
        &amp;&amp; interested[other] == <span class="hljs-literal">true</span>)&#123;&#125; 
  
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">leave_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">process</span>)</span></span>&#123;
  
  <span class="hljs-comment">/* 表示离开临界区 */</span>
  interested[<span class="hljs-built_in">process</span>] == FALSE;				 
&#125;</code></pre>
<p>在使用共享变量时（即进入其临界区）之前，各个进程使用各自的进程号 <code>0</code> 或 <code>1</code> 作为参数来调用 <code>enter_region</code>，这个函数调用在需要时将使进程等待，直到能够安全的临界区。在完成对共享变量的操作之后，进程将调用 <code>leave_region</code> 表示操作完成，并且允许其他进程进入。</p>
<p>考虑一种两个进程同时调用 <code>enter_region</code> 的情况。它们都将自己的进程存入 <code>turn</code>，但只有最后保存进去的进程号才有效，前一个进程的进程号因为重写而丢失。假如 <code>进程 1</code> 是最后存入的，则 <code>turn = 1</code> 。当两个进程都运行到 <code>while</code> 的时候，<code>进程 0</code> 将不会循环并进入临界区，而 <code>进程 1</code> 将会无限循环且不会进入临界区，直到 <code>进程 0</code> 退出临界区为止。</p>
<h3 id="5-tsl-指令"><a class="markdownIt-Anchor" href="#5-tsl-指令"></a> 5. <code>TSL</code> 指令</h3>
<p>一些计算机，特别是那些设计为多处理器的计算机，都会有下面这条指令</p>
<pre><code class="hljs cos">TSL RX,<span class="hljs-keyword">LOCK</span></code></pre>
<p>称为 <code>测试并加锁(test and set lock)</code>，它将一个内存字 <code>lock</code> 读到寄存器 <code>RX</code> 中，然后在该内存地址上存储一个非零值。其执行过程是一条原语。在这个指令结束之前其他处理器均不允许访问内存。执行 <code>TSL</code> 指令的 <code>CPU</code> 将会锁住内存总线，用来禁止其他 <code>CPU</code> 在这个指令结束之前访问内存。</p>
<p>很重要的一点是锁住内存总线和禁用中断不一样。禁用中断并不能保证一个处理器在读写操作之间另一个处理器对内存的读写。也就是说，在 <code>处理器 1</code> 上屏蔽中断对 <code>处理器 2</code> 没有影响。让 <code>处理器 2</code> 远离内存直到 <code>处理器 1</code> 完成读写的最好的方式就是<strong>锁住总线</strong>。这需要一个特殊的硬件（基本上，一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能使用）。</p>
<h3 id="6-xchg-指令"><a class="markdownIt-Anchor" href="#6-xchg-指令"></a> 6. <code>XCHG</code> 指令</h3>
<p><code>XCHG</code> 指令可以替换 <code>TSL</code> 的指令，它原子性的交换了两个位置的内容，例如，一个寄存器与一个内存字。</p>
<p><code>XCHG</code> 的本质上与 <code>TSL</code> 的解决办法一样。所有的 <code>Intel x86</code> <code>CPU</code> 在底层同步中使用 <code>XCHG</code> 指令。</p>
<h2 id="睡眠与唤醒"><a class="markdownIt-Anchor" href="#睡眠与唤醒"></a> 睡眠与唤醒</h2>
<p><code>Peterson</code> 、<code>TSL</code> 和 <code>XCHG</code> 解法都是正确的，但是它们都有<strong>忙等待</strong>的缺点。这些解法的本质上都是一样的，先检查是否能够进入临界区，若不允许，则该进程将原地等待，直到允许为止。</p>
<p>这种方式不但浪费了 <code>CPU</code> 时间，而且还可能引起意想不到的结果。考虑一台计算机上有两个进程，这两个进程具有不同的优先级，<code>H</code> 是属于优先级比较高的进程，<code>L</code> 是属于优先级比较低的进程。进程调度的规则是<strong>不论何时只要 <code>H 进程</code> 处于就绪态 <code>H</code> 就开始运行</strong>。<br />
在某一时刻，<strong><code>L</code> 处于临界区中</strong>，此时 <code>H</code> 变为就绪态，准备运行（例如，一条 I/O 操作结束）。现在 <code>H</code> 要开始忙等，但由于当 <code>H</code> 就绪时 <code>L</code> 就不会被调度，<code>L</code> 从来不会有机会离开临界区，所以 <code>H</code> 会变成<strong>死循环</strong>，有时将这种情况称为 <code>优先级反转问题(priority inversion problem)</code>。</p>
<p>进程间的通信原语<strong>在不允许它们进入临界区之前会阻塞</strong>而不是浪费 <code>CPU</code> 时间，最简单的是 <code>sleep</code> 和 <code>wakeup</code>。</p>
<ul>
<li><code>Sleep</code> 是一个能够造成调用者阻塞的系统调用，也就是说，这个系统调用会暂停直到其他进程唤醒它。</li>
<li><code>wakeup</code> 调用有一个参数，即要唤醒的进程。</li>
</ul>
<p>还有一种方式是 <code>wakeup</code> 和 <code>sleep</code> 都有一个参数，即 <code>sleep</code> 和 <code>wakeup</code> 需要匹配的内存地址。</p>
<h3 id="生产者-消费者问题"><a class="markdownIt-Anchor" href="#生产者-消费者问题"></a> 生产者-消费者问题</h3>
<p><code>生产者-消费者(producer-consumer)</code> 问题，也称作 <code>有界缓冲区(bounded-buffer)</code> 问题。两个进程共享一个公共的固定大小的缓冲区。其中一个是<code>生产者(producer)</code>，将信息放入缓冲区， 另一个是<code>消费者(consumer)</code>，会从缓冲区中取出。</p>
<p>如果缓冲队列已满，那么当生产者仍想要将数据写入缓冲区的时候，会出现问题。它的解决办法是让生产者睡眠，也就是阻塞生产者。等到消费者从缓冲区中取出一个或多个数据项时再唤醒它。同样的，当消费者试图从缓冲区中取数据，但是发现缓冲区为空时，消费者也会睡眠，阻塞。直到生产者向其中放入一个新的数据。</p>
<pre><code class="hljs c"><span class="hljs-comment">/* 缓冲区 slot 槽的数量 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100						</span>
<span class="hljs-comment">/* 缓冲区数据的数量 */</span>
<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>										
  
<span class="hljs-comment">// 生产者</span>
<span class="hljs-keyword">void</span> producer(<span class="hljs-keyword">void</span>)&#123;
  <span class="hljs-keyword">int</span> item;
  
  <span class="hljs-comment">/* 无限循环 */</span>
  <span class="hljs-keyword">while</span>(TRUE)&#123;				
    <span class="hljs-comment">/* 生成下一项数据 */</span>
    item = produce_item()				
    <span class="hljs-comment">/* 如果缓存区是满的，就会阻塞 */</span>
    <span class="hljs-keyword">if</span>(count == N)&#123;
      sleep();									
    &#125;
    
    <span class="hljs-comment">/* 把当前数据放在缓冲区中 */</span>
    insert_item(item);
    <span class="hljs-comment">/* 增加缓冲区 count 的数量 */</span>
    count = count + <span class="hljs-number">1</span>;					
    <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>)&#123;
      <span class="hljs-comment">/* 缓冲区是否为空？ */</span>
      wakeup(consumer);					
    &#125;
  &#125;
&#125;

<span class="hljs-comment">// 消费者</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;
  
  <span class="hljs-keyword">int</span> item;
  
  <span class="hljs-comment">/* 无限循环 */</span>
  <span class="hljs-keyword">while</span>(TRUE)&#123;
    <span class="hljs-comment">/* 如果缓冲区是空的，就会进行阻塞 */</span>
    <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;							
      sleep();
    &#125;
    <span class="hljs-comment">/* 从缓冲区中取出一个数据 */</span>
    item = remove_item();			
    <span class="hljs-comment">/* 将缓冲区的 count 数量减一 */</span>
    count = count - <span class="hljs-number">1</span>
    <span class="hljs-comment">/* 缓冲区满？ */</span>
    <span class="hljs-keyword">if</span>(count == N - <span class="hljs-number">1</span>)&#123;					
      wakeup(producer);		
    &#125;
    <span class="hljs-comment">/* 打印数据项 */</span>
    consumer_item(item);				
  &#125;
  
&#125;</code></pre>
<p>上面代码中会产生竞争条件。有可能出现下面这种情况：缓冲区为空，此时消费者刚好读取 <code>count</code> 的值发现它为 <code>0</code>。此时<strong>调度程序决定暂停消费者</strong>并启动运行生产者。生产者生产了一条数据并把它放在缓冲区中，然后增加 <code>count</code> 的值，<code>count = 1</code> 。由于 <code>count</code> 初始为 <code>0</code>，消费者必须处于睡眠状态，因此生产者调用 <code>wakeup</code> 来唤醒消费者。但是，消费者此时在逻辑上并没有睡眠，所以 <code>wakeup</code> 信号会<strong>丢失</strong>。当消费者下次启动后，它会查看之前读取的 <code>count</code> 值，发现它的值是 <code>0</code>，然后在此进行睡眠。不久之后生产者会填满整个缓冲区，在这之后会阻塞，这样一来两个进程将永远睡眠下去。</p>
<p>引起上面问题的本质是 <strong>唤醒尚未进行睡眠状态的进程会导致唤醒丢失</strong>。如果它没有丢失，则一切都很正常。一种快速解决上面问题的方式是增加一个 <code>唤醒等待位(wakeup waiting bit)</code>。当一个 <code>wakeup</code> 信号发送给仍在清醒的进程后，该位置为 <code>1</code>。之后，当进程尝试睡眠的时候，如果唤醒等待位为 <code>1</code>，则该位清除，而进程仍然保持清醒。</p>
<p>然而，当进程数量有许多的时候，这时可以通过增加唤醒等待位的数量来唤醒等待位，于是就有了 2、4、6、8 个唤醒等待位，但是并没有从根本上解决问题。</p>
<h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2>
<p>一个信号量的取值可以是 <code>0</code> ，或任意正数。<code>0</code> 表示的是不需要任何唤醒，任意的正数表示的就是资源数目（唤醒次数）。</p>
<p>Dijkstra 提出了信号量有两个操作，现在通常使用 <code>down (P)</code> 和 <code>up (V)</code>（分别可以用 <code>sleep</code> 和 <code>wakeup</code> 来表示）。</p>
<ul>
<li><code>down</code> 操作会检查值是否大于 <code>0</code> 。如果大于 <code>0</code> ，则将其值 <code>- 1</code> ；若该值为 <code>0</code>，则进程将睡眠，而且此时 <code>down</code> 操作将会继续执行。</li>
</ul>
<p><strong>检查数值</strong>、<strong>修改变量值</strong>以及可能发生的<strong>睡眠操作</strong>均为一个单一的、不可分割的 <code>原子操作(atomic action)</code> 完成。这会保证一旦信号量操作开始，没有其他的进程能够访问信号量，直到操作完成或者阻塞。这种原子性对于解决同步问题和避免竞争绝对必不可少。</p>
<ul>
<li><code>up</code> 操作会使信号量的值 <code>+ 1</code>。如果一个或者多个进程在信号量上睡眠，无法完成一个先前的 <code>down</code> 操作，则由系统选择（<strong>随机挑选</strong>）其中的一个并允许该程完成 <code>down</code> 操作。</li>
</ul>
<p>因此，对一个进程在其上睡眠的信号量执行一次 <code>up</code> 操作之后，该信号量的值仍然是 <code>0</code> ，但在其上睡眠的进程却少了一个。信号量的值增 <code>1</code> 和唤醒一个进程同样也是不可分割的。不会有某个进程因执行 <code>up</code> 而阻塞，正如在前面的模型中不会有进程因执行 <code>wakeup</code> 而阻塞是一样的道理。</p>
<h3 id="用信号量解决生产者-消费者问题"><a class="markdownIt-Anchor" href="#用信号量解决生产者-消费者问题"></a> 用信号量解决生产者 - 消费者问题</h3>
<p>用信号量解决丢失的 <code>wakeup</code> 问题，代码如下：</p>
<pre><code class="hljs c"><span class="hljs-comment">/* 定义缓冲区槽的数量 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span>
<span class="hljs-comment">/* 信号量是一种特殊的 int */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;
<span class="hljs-comment">/* 控制临界区的访问 */</span>
semaphore mutex = <span class="hljs-number">1</span>;
<span class="hljs-comment">/* 统计 buffer 空槽的数量 */</span>
semaphore empty = N;
<span class="hljs-comment">/* 统计 buffer 满槽的数量 */</span>
semaphore full = <span class="hljs-number">0</span>;												

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123; 
  
  <span class="hljs-keyword">int</span> item;  
  
  <span class="hljs-keyword">while</span>(TRUE)&#123;			
    <span class="hljs-comment">/* 产生放在缓冲区的一些数据 */</span>
    item = producer_item();		
    <span class="hljs-comment">/* 将空槽数量减 1  */</span>
    <span class="hljs-comment">// 若空槽数量不够，则阻塞</span>
    down(&amp;empty);
    
    <span class="hljs-comment">/* 进入临界区  */</span>
    down(&amp;mutex);	
    <span class="hljs-comment">/* 把数据放入缓冲区中 */</span>
    insert_item(item);
    <span class="hljs-comment">/* 离开临界区 */</span>
    up(&amp;mutex);	
    
    <span class="hljs-comment">/* 将 buffer 满槽数量 + 1 */</span>
    up(&amp;full);														
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;
  
  <span class="hljs-keyword">int</span> item;
  
  <span class="hljs-keyword">while</span>(TRUE)&#123;
    <span class="hljs-comment">/* 缓存区满槽数量 - 1 */</span>
    <span class="hljs-comment">// 若满槽数量不足，无法消费，则阻塞</span>
    down(&amp;full);
    
    <span class="hljs-comment">/* 进入缓冲区 */</span>	
    down(&amp;mutex);
    <span class="hljs-comment">/* 从缓冲区取出数据 */</span>
    item = remove_item();	
    <span class="hljs-comment">/* 离开临界区 */</span>
    up(&amp;mutex);	
    
    <span class="hljs-comment">/* 将空槽数目 + 1 */</span>
    <span class="hljs-comment">// 消费数据和不需要同步，所以先处理空槽数再消费取出的数据</span>
    up(&amp;empty);	
    
    <span class="hljs-comment">/* 消费数据 */</span>
    consume_item(item);											
  &#125;
&#125;</code></pre>
<p>为了确保信号量能正确工作，最重要的是要采用一种不可分割的方式来实现它。通常是将 <code>up</code> 和 <code>down</code> 作为系统调用来实现。而且操作系统只需在执行以下操作时暂时屏蔽全部中断：<strong>检查信号量</strong>、<strong>更新</strong>、<strong>必要时使进程睡眠</strong>。由于这些操作仅需要非常少的指令，因此中断不会造成影响。如果使用多个 <code>CPU</code>，那么信号量应该被<strong>锁</strong>进行保护。使用 <code>TSL</code> 或者 <code>XCHG</code> 指令用来确保同一时刻只有一个 <code>CPU</code> 对信号量进行操作。</p>
<p>使用 <code>TSL</code> 或者 <code>XCHG</code> 来防止几个 <code>CPU</code> 同时访问一个信号量，与生产者或消费者使用<strong>忙等待</strong>来等待其他腾出或填充缓冲区是完全不一样的。前者的操作仅需要几个毫秒，而生产者或消费者可能需要任意长的时间。</p>
<p>上面这个解决方案使用了三种信号量：一个称为 <code>full</code>，用来记录充满的缓冲槽数目；一个称为 <code>empty</code>，记录空的缓冲槽数目；一个称为 <code>mutex</code>，<strong>用来确保生产者和消费者不会同时进入缓冲区</strong>。<code>full</code> 被初始化为 <code>0</code>，<code>empty</code> 初始化为缓冲区中插槽数，<code>mutex</code> 初始化为 <code>1</code>。</p>
<blockquote>
<p>供两个或多个进程使用的信号量，初始化为 <code>1</code>，保证它们中同时只有一个可以进入临界区的信号被称为 <code>二进制信号量(binary semaphores)</code>。如果每个进程都在进入临界区之前执行 <code>down</code> 操作，而在离开临界区之后执行 <code>up</code> 操作，则可以确保相互互斥。</p>
</blockquote>
<p>信号量的另一用途是实现 <code>同步（synchronizeation）</code>。信号量 <code>full</code> 和 <code>empty</code> 用来保证某种事件的顺序发生或不发生。</p>
<h2 id="互斥量"><a class="markdownIt-Anchor" href="#互斥量"></a> 互斥量</h2>
<p>如果不需要信号量的计数能力时，可以使用信号量的一个简单版本，称为 <code>mutex (互斥量)</code>。互斥量的优势就在于在一些共享资源和一段代码中保持互斥。由于互斥的实现既简单又有效，这使得互斥量在实现用户空间线程包时非常有用。</p>
<p>互斥量是一个处于<strong>两种状态</strong>之一的共享变量：<code>解锁(unlocked)</code> 和 <code>加锁(locked)</code>。这样，只需要<strong>一个二进制位</strong>来表示它，不过一般情况下，通常会用一个 <code>整形(integer)</code> 来表示。<code>0</code> 表示解锁，其他所有的值表示加锁，比 <code>1</code> 大的值表示加锁的次数。</p>
<p>当一个线程（或者进程）需要访问临界区时，会调用 <code>mutex_lock</code> 进行加锁。</p>
<ul>
<li>如果互斥锁当前处于<strong>未锁定</strong>状态（表示临界区可用），则调用成功，并且调用线程可以自由进入临界区。</li>
<li>如果 <code>mutex</code> 互斥量<strong>已经锁定</strong>，调用线程会<strong>阻塞直到临界区内的线程执行完毕并且调用了 <code>mutex_unlock</code>。</strong> 如果多个线程在 <code>mutex</code> 互斥量上阻塞，将随机选择一个线程并允许它获得锁。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20200922155103.png" srcset="/img/loading.gif" alt="" /></p>
<p>随着并行的增加，有效的 <code>同步(synchronization)</code> 和 <code>锁定(locking)</code> 对于性能来说是非常重要的。</p>
<ul>
<li>如果进程等待时间很短，那么 <code>自旋锁(Spin lock)</code> 是非常有效；但是如果等待时间比较长，那么这会浪费 CPU 周期。</li>
<li>如果进程很多，那么阻塞此进程，并仅当锁被释放的时候让内核解除阻塞是更有效的方式。<br />
不幸的是：它可以在进程竞争频繁的时候运行良好，但是在竞争不是很激烈的情况下内核切换的消耗会非常大，而且更困难的是，预测锁的竞争数量更不容易。</li>
</ul>
<h2 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h2>
<p>管程是程序、变量和数据结构等组成的一个集合，它们组成一个特殊的模块或者包。进程可以在任何需要的时候调用管程中的程序，但是它们不能从管程外部访问数据结构和程序。</p>
<p><strong>在任何时候管程中只能有一个活跃的进程</strong>，这一特性使管程能够很方便的实现互斥操作。通常情况下，当进程调用管程中的程序时，该程序的前几条指令会检查管程中是否有其他活跃的进程。如果有的话，调用进程将被挂起，直到另一个进程离开管程才将其唤醒。如果没有活跃进程在使用管程，那么该调用进程才可以进入。</p>
<p>即使管程提供了一种简单的方式来实现互斥，但在我们看来，这还不够。因为我们还需要一种<strong>使得进程在无法执行被阻塞</strong>。在生产者-消费者问题中，很容易将针对缓冲区满和缓冲区空的测试放在管程程序中，但是生产者在发现缓冲区满的时候该如何阻塞呢？</p>
<p>解决的办法是引入 <code>条件变量(condition variables)</code> 以及相关的两个操作 <code>wait</code> 和 <code>signal</code>。当一个管程程序发现它不能运行时（例如，生产者发现缓冲区已满），它会在某个条件变量（如 <code>full</code>）上执行 <code>wait</code> 操作。这个操作造成调用进程阻塞，并且还将另一个以前等在管程之外的进程调入管程。另一个进程，比如消费者可以通过执行 <code>signal</code> 来唤醒阻塞的调用进程。</p>
<p>如果在一个条件变量上有若干进程都在等待，则在对该条件执行 <code>signal</code> 操作后，系统调度程序只能选择其中一个进程恢复运行。</p>
<blockquote>
<p>条件变量不是计数器。条件变量也不能像信号量那样积累信号以便以后使用。所以，如果向一个条件变量发送信号，但是该条件变量上没有等待进程，那么信号将会丢失。也就是说，<strong><code>wait</code> 操作必须在 <code>signal</code> 之前执行</strong>。</p>
</blockquote>
<p>通过临界区自动的互斥，<strong>管程比信号量更容易保证并行编程的正确性</strong>。但是管程也有缺点，我们前面说到过管程是一个编程语言的概念，编译器必须要识别管程并用某种方式对其互斥作出保证。C、Pascal 以及大多数其他编程语言都没有管程，所以不能依靠编译器来遵守互斥规则。</p>
<p>与管程和信号量有关的另一个问题是，<strong>这些机制都是设计用来解决访问共享内存的一个或多个 <code>CPU</code> 上的互斥问题的</strong>。</p>
<ul>
<li>通过将信号量放在共享内存中并用 <code>TSL</code> 或 <code>XCHG</code> 指令来保护它们，可以避免竞争。</li>
<li>但是如果是在分布式系统中，可能同时具有多个 <code>CPU</code> 的情况，并且每个 <code>CPU</code> 都有自己的私有内存呢，它们通过网络相连，那么这些原语将会失效。因为信号量太低级了，而管程在少数几种编程语言之外无法使用，所以还需要其他方法。</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/09/21/LeetCode-189-rotate-array/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LeetCode 189. 旋转数组</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/09/20/LeetCode-88-merge-sorted-array/">
                        <span class="hidden-mobile">LeetCode 88. 合并两个有序数组</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <!-- <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> -->
      Crafted with
      <i class="iconfont icon-love" style="color: #f30;"></i>
      by <a href="https://github.com/likailee" target="_blank" rel="noopener">Likai Lee</a>
      | &copy; 2017 - 2020
      <!-- <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a> -->
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?66c61a5fd59052d1b39d89c246846ae5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
