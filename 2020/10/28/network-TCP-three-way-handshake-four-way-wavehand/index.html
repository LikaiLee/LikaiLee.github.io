<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Likai Lee">
  <meta name="keywords" content="">
  <title>TCP 三次握手和四次挥手 - Likai Lee</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Likai Lee</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                TCP 三次握手和四次挥手
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-10-28 18:36">
      2020年10月28日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      74
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年10月29日 下午
                
              </p>
            
            <article class="markdown-body">
              <h1 id="tcp-基本认识"><a class="markdownIt-Anchor" href="#tcp-基本认识"></a> TCP 基本认识</h1>
<h2 id="tcp-基础"><a class="markdownIt-Anchor" href="#tcp-基础"></a> TCP 基础</h2>
<h3 id="tcp-头格式"><a class="markdownIt-Anchor" href="#tcp-头格式"></a> TCP 头格式</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028143112.png" srcset="/img/loading.gif" alt="" /></p>
<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 <code>SYN</code> 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题</strong>。</p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决不丢包的问题</strong>。</p>
<p><strong>控制位</strong>：</p>
<ul>
<li><code>ACK</code>：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。</li>
<li><code>RST</code>：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><code>SYN</code>：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><code>FIN</code>：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</li>
</ul>
<h3 id="为什么需要-tcp-协议"><a class="markdownIt-Anchor" href="#为什么需要-tcp-协议"></a> 为什么需要 TCP 协议</h3>
<p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p>
<p><strong>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</strong><br />
因为 <code>TCP</code> 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序</strong>的。</p>
<h3 id="什么是-tcp"><a class="markdownIt-Anchor" href="#什么是-tcp"></a> 什么是 TCP</h3>
<p><code>TCP</code> 是<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议。</p>
<ul>
<li><strong>面向连接</strong>：一定是「<strong>一对一</strong>」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：消息是「<strong>没有边界</strong>」的，所以无论我们消息有多大都可以进行传输。并且消息是「<strong>有序的</strong>」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</li>
</ul>
<h2 id="tcp-连接"><a class="markdownIt-Anchor" href="#tcp-连接"></a> TCP 连接</h2>
<h3 id="什么是-tcp-连接"><a class="markdownIt-Anchor" href="#什么是-tcp-连接"></a> 什么是 TCP 连接</h3>
<blockquote>
<p>用于保证可靠性和流量控制维护的某些<strong>状态信息</strong>，这些信息的组合，包括 <code>Socket</code>、<code>序列号</code>和<code>窗口大小</code>称为连接。</p>
</blockquote>
<ul>
<li><code>Socket</code>：由 IP 地址和端口号组成</li>
<li>序列号：用来解决乱序问题等</li>
<li>窗口大小：用来做流量控制</li>
</ul>
<h3 id="如何唯一确定一个-tcp-连接"><a class="markdownIt-Anchor" href="#如何唯一确定一个-tcp-连接"></a> 如何唯一确定一个 TCP 连接</h3>
<p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p>
<ol>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ol>
<ul>
<li>源地址和目的地址的字段（32位）是在 <code>IP</code> 头部中，作用是通过 <code>IP</code> 协议发送报文给对方主机。</li>
<li>源端口和目的端口的字段（16位）是在 <code>TCP</code> 头部中，作用是告诉 <code>TCP</code> 协议应该把报文发给哪个进程。</li>
</ul>
<h3 id="tcp-的最大连接数"><a class="markdownIt-Anchor" href="#tcp-的最大连接数"></a> TCP 的最大连接数</h3>
<p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。因此，客户端 IP 和 端口是可变的，其理论值计算公式如下：</p>
<pre><code class="hljs routeros">TCP 最大连接数 = 客户端的<span class="hljs-built_in"> IP </span>数 * 客户端的端口数</code></pre>
<p>对 <code>IPv4</code>，客户端的 <code>IP 数</code>最多为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，客户端的 <code>端口数</code> 最多为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>，也就是服务端单机最大 TCP 连接数，约为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。</p>
<ul>
<li>首先主要是<strong>文件描述符限制</strong>，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；</li>
<li>另一个是<strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的。</li>
</ul>
<h2 id="tcp-和-udp"><a class="markdownIt-Anchor" href="#tcp-和-udp"></a> TCP 和 UDP</h2>
<h3 id="udp-和-tcp-的区别-应用场景"><a class="markdownIt-Anchor" href="#udp-和-tcp-的区别-应用场景"></a> UDP 和 TCP 的区别、应用场景</h3>
<p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。<br />
UDP 协议头部只有 <code>8</code> 个字节，UDP 的头部格式如下：<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028144852.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li><strong>目标和源端口</strong>：主要是告诉 UDP 协议应该把报文发给哪个进程。</li>
<li><strong>包长度</strong>：该字段保存了 UDP 首部的长度跟数据的长度之和。</li>
<li><strong>校验和</strong>：校验和是为了提供可靠的 UDP 首部和数据而设计。</li>
</ul>
<p>TCP 和 UDP 区别：</p>
<ol>
<li>连接</li>
</ol>
<p>TCP 是面向连接的传输层协议，传输数据前先要建立连接。<br />
UDP 是不需要连接，即刻传输数据。<br />
2. 服务对象</p>
<p>TCP 是一对一的两点服务，即<strong>一条连接只有两个端点</strong>。<br />
UDP 支持一对一、一对多、多对多的交互通信<br />
3. 可靠性</p>
<p>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。<br />
UDP 是尽最大努力交付，不保证可靠交付数据。<br />
4. 拥塞控制、流量控制</p>
<p>TCP 有<strong>拥塞控制</strong>和<strong>流量控制</strong>机制，保证数据传输的安全性。<br />
UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。<br />
5. 首部开销</p>
<p>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。<br />
UDP 首部只有 8 个字节，并且是固定不变的，开销较小。<br />
6. 传输方式</p>
<p>TCP 是<strong>流式传输，没有边界，但保证顺序和可靠</strong>。<br />
UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。<br />
7. 分片不同</p>
<p>TCP 的数据大小如果大于 <code>MSS</code> 大小，则会在 <code>传输层</code> 进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。<br />
UDP 的数据大小如果大于 <code>MTU</code> 大小，则会在 <code>IP 层</code> 进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输效率非常差，所以<strong>通常 <code>UDP</code> 的报文应该小于 <code>MTU</code></strong>。</p>
<p>TCP 和 UDP 应用场景：<br />
由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li><code>FTP</code> 文件传输</li>
<li><code>HTTP</code> / <code>HTTPS</code></li>
</ul>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ul>
<h3 id="为什么-udp-头部没有首部长度字段"><a class="markdownIt-Anchor" href="#为什么-udp-头部没有首部长度字段"></a> 为什么 UDP 头部没有「首部长度」字段</h3>
<p>原因是 <code>TCP</code> 有<strong>可变长</strong>的「<code>选项</code>」字段，而 <code>UDP</code> <strong>头部长度则是不会变化</strong>的，无需多一个字段去记录 <code>UDP</code> 的首部长度。</p>
<h3 id="为什么-udp-头部有包长度字段"><a class="markdownIt-Anchor" href="#为什么-udp-头部有包长度字段"></a> 为什么 UDP 头部有「包长度」字段</h3>
<blockquote>
<p>TCP 数据长度 = <code>IP</code> 总长度 - <code>IP</code> 首部长度 - <code>TCP</code> 首部长度</p>
</blockquote>
<p>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p>
<p><strong>为了网络设备硬件设计和处理方便，首部长度需要是 <code>4字节</code> 的整数倍。</strong><br />
如果去掉 UDP 「包长度」字段，那 UDP 首部长度就不是 4 字节的整数倍了，所以这可能是为了补全 UDP 首部长度是 4 字节的整数倍，才补充了「包长度」字段。</p>
<h1 id="tcp-连接建立"><a class="markdownIt-Anchor" href="#tcp-连接建立"></a> TCP 连接建立</h1>
<h2 id="tcp-三次握手过程和状态变迁"><a class="markdownIt-Anchor" href="#tcp-三次握手过程和状态变迁"></a> TCP 三次握手过程和状态变迁</h2>
<p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而建立连接是通过三次握手来进行的。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028155915.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li>
<li>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 1 ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，<strong>这次报文可以携带客户到服务器的数据</strong>，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
</ul>
<blockquote>
<p>可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的。</p>
</blockquote>
<p>一旦完成三次握手，双方都处于 <code>ESTABLISHED</code> 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。</p>
<h2 id="为什么是三次握手"><a class="markdownIt-Anchor" href="#为什么是三次握手"></a> 为什么是三次握手</h2>
<p>三次握手才能保证双方具有接收和发送的能力，可以初始化 <code>Socket</code>、<code>序列号</code>和<code>窗口大小</code>并建立 TCP 连接。</p>
<p>原因：</p>
<ol>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ol>
<h3 id="避免历史连接"><a class="markdownIt-Anchor" href="#避免历史连接"></a> 避免历史连接</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028161453.png" srcset="/img/loading.gif" alt="" /></p>
<p><strong>客户端连续发送多次 SYN 建立连接的报文</strong>，在网络拥堵情况下：</p>
<ul>
<li>一个「<strong>旧 SYN 报文</strong>」比「<strong>最新的 SYN</strong>」 报文早到达了服务端；</li>
<li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li>
<li>客户端收到后可以根据自身的上下文，判断这是一个<strong>历史连接</strong>（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</li>
</ul>
<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p>
<p>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接；<br />
如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接；<br />
所以，TCP 使用三次握手建立连接的最主要原因是<strong>防止历史连接初始化了连接</strong>。</p>
<h3 id="同步双方初始序列号"><a class="markdownIt-Anchor" href="#同步双方初始序列号"></a> 同步双方初始序列号</h3>
<p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，<strong>表示客户端的 SYN 报文已被服务端成功接收</strong>，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能<strong>确保双方的初始序列号能被可靠的同步</strong>。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028162521.png" srcset="/img/loading.gif" alt="" /></p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但<strong>由于第二步和第三步可以优化成一步，所以就成了「三次握手」。</strong></p>
<p><strong>两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</strong></p>
<h3 id="避免资源浪费"><a class="markdownIt-Anchor" href="#避免资源浪费"></a> 避免资源浪费</h3>
<p>如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？</p>
<p>如果客户端的 <code>SYN</code> 阻塞了，重复发送多次 <code>SYN</code> 报文，那么<strong>服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028162315.jpeg" srcset="/img/loading.gif" alt="" /></p>
<p>即两次握手会造成消息滞留情况下，<strong>服务器重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</strong></p>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<p>TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<h2 id="为什么客户端和服务端的初始序列号-isn-是不相同的"><a class="markdownIt-Anchor" href="#为什么客户端和服务端的初始序列号-isn-是不相同的"></a> 为什么客户端和服务端的初始序列号 ISN 是不相同的</h2>
<p>如果一个已经失效的连接被重用了，但是该旧连接的历史报文还残留在网络中，如果序列号相同，那么就无法分辨出该报文是不是历史报文，如果历史报文被新的连接接收了，则会产生数据错乱。</p>
<p>所以，每次建立连接前重新初始化一个序列号主要是为了<strong>通信双方能够根据序号将不属于本连接的报文段丢弃。</strong></p>
<p>另一方面是为了<strong>安全性</strong>，防止黑客伪造的相同序列号的 TCP 报文被对方接收。</p>
<h2 id="既然-ip-层会分片为什么-tcp-层还需要-mss"><a class="markdownIt-Anchor" href="#既然-ip-层会分片为什么-tcp-层还需要-mss"></a> 既然 IP 层会分片，为什么 TCP 层还需要 MSS</h2>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201023155957.png" srcset="/img/loading.gif" alt="" /></p>
<blockquote>
<p><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。<br />
<code>MSS</code>：除去 <code>IP</code> 和 <code>TCP</code> 头部之后，一个网络包所能容纳的 <code>TCP</code> 数据的最大长度。</p>
</blockquote>
<p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？</p>
<p>当 IP 层有一个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 <strong>IP 层就要进行分片</strong>，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 <strong>IP 层来进行重新组装</strong>后，再交给上一层 TCP 传输层。</p>
<p>这看起来井然有序，但这存在隐患的，那么<strong>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。</strong><br />
因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。<br />
因为是在接收方的 IP 层进行分片重组，当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。<br />
因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</p>
<p>所以，<strong>为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。<br />
经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。</p>
<h2 id="什么是-syn-攻击如何避免-syn-攻击"><a class="markdownIt-Anchor" href="#什么是-syn-攻击如何避免-syn-攻击"></a> 什么是 SYN 攻击？如何避免 SYN 攻击？</h2>
<h3 id="syn-攻击"><a class="markdownIt-Anchor" href="#syn-攻击"></a> SYN 攻击</h3>
<p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入 <code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的 SYN 接收队列（未连接队列）</strong>，使得服务器不能为正常用户服务。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028164702.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="避免-syn-攻击方式一"><a class="markdownIt-Anchor" href="#避免-syn-攻击方式一"></a> 避免 SYN 攻击方式一</h3>
<p>其中一种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。</p>
<p>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。可以控制该队列的最大值，或限制 <code>SYN_RCVD</code> 状态连接的最大个数，当超出处理能力时，对新的 <code>SYN</code> 直接回报 <code>RST</code>，丢弃连接。</p>
<h3 id="避免-syn-攻击方式二"><a class="markdownIt-Anchor" href="#避免-syn-攻击方式二"></a> 避免 SYN 攻击方式二</h3>
<p>Linux 内核的 <code>SYN</code> （未完成连接建立）队列与 <code>Accpet</code> （已完成连接建立）队列的正常流程：</p>
<ol>
<li>当服务端接收到客户端的 <code>SYN</code> 报文时，会将其加入到内核的「<code>SYN 队列</code>」；</li>
<li>接着发送 <code>SYN + ACK</code> 给客户端，等待客户端回应 <code>ACK</code> 报文；</li>
<li>服务端接收到 <code>ACK</code> 报文后，从「<code>SYN 队列</code>」移除放入到「<code>Accept 队列</code>」；</li>
<li>应用通过调用 <code>accpet()</code> socket 接口，从「<code>Accept 队列</code>」取出连接。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028164936.png" srcset="/img/loading.gif" alt="" /></p>
<p>应用程序过慢：</p>
<p>如果应用程序过慢时，就会导致「Accept 队列」被占满。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028165619.jpeg" srcset="/img/loading.gif" alt="" /></p>
<p>受到 SYN 攻击：</p>
<p>如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满。<br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028165601.jpeg" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，<strong>不进入「SYN 队列」</strong>；</li>
<li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「<code>序列号</code>」返回客户端，</li>
<li>服务端接收到客户端的应答报文时，服务器会检查这个 <code>ACK</code> 包的合法性。如果合法，直接放入到「<code>Accept 队列</code>」。</li>
<li>最后应用通过调用 <code>accpet()</code> socket 接口，从「<code>Accept 队列</code>」取出的连接。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201028165544.jpeg" srcset="/img/loading.gif" alt="" /></p>
<h1 id="tcp-连接断开"><a class="markdownIt-Anchor" href="#tcp-连接断开"></a> TCP 连接断开</h1>
<h2 id="tcp-四次挥手过程和状态变迁"><a class="markdownIt-Anchor" href="#tcp-四次挥手过程和状态变迁"></a> TCP 四次挥手过程和状态变迁</h2>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029124017.jpg" srcset="/img/loading.gif" alt="" /><br />
<img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029130218.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSED</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 后，自动进入 <code>CLOSED</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<blockquote>
<p>可以看到，每个方向都需要一个 <code>FIN</code> 和一个 <code>ACK</code>，因此通常被称为四次挥手。<br />
需要注意的是：<strong>主动关闭连接的，才有 <code>TIME_WAIT</code> 状态。</strong></p>
</blockquote>
<h2 id="为什么挥手需要四次"><a class="markdownIt-Anchor" href="#为什么挥手需要四次"></a> 为什么挥手需要四次</h2>
<ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示<strong>客户端不再发送数据了但是还能接收数据。</strong></li>
<li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而<strong>服务端可能还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，<strong>服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会<code>分开发送</code></strong>，从而比三次握手导致多了一次。</p>
<h2 id="为什么-time_wait-等待的时间是-2-msl"><a class="markdownIt-Anchor" href="#为什么-time_wait-等待的时间是-2-msl"></a> 为什么 TIME_WAIT 等待的时间是 2 MSL</h2>
<blockquote>
<p><code>MSL</code> 是 <code>Maximum Segment Lifetime</code>，报文最大生存时间，它是<strong>任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。<strong>因为 <code>TCP</code> 报文基于是 <code>IP</code> 协议的，而 <code>IP</code> 头中有一个 <code>TTL</code> 字段，是 <code>IP</code> 数据报可以经过的</strong>最大路由数</strong>，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 <code>ICMP</code> 报文通知源主机。</p>
<p><code>MSL</code> 与 <code>TTL</code> 的区别： <code>MSL</code> 的单位是时间，而 <code>TTL</code> 是经过路由跳数。所以 <code>MSL</code> 应该要大于等于 <code>TTL</code> 消耗为 <code>0</code> 的时间，以确保报文已被自然消亡。</p>
</blockquote>
<p>2 MSL 是为了<strong>确保发送方最后发送的 <code>ACK</code> 已经被对端接收</strong>。<br />
如果被动关闭方没有收到断开连接的最后的 <code>ACK</code> 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 <code>FIN</code> 后，会重发 <code>ACK</code> 给被动关闭方， 一来一去正好 <code>2</code> 个 <code>MSL</code>。</p>
<blockquote>
<p>当客户端 <code>TIME-WAIT</code> 时间超过了 <code>2MSL</code>，则客户端就直接进入关闭状态。若此时第四次挥手的 <code>ACK</code> 和重发的 <code>FIN</code> 都丢失，此时会看服务端超时重发 <code>FIN</code> 报文的次数如果超过 <code>tcp_orphan_retries</code> 大小后，服务端也会关闭 <code>TCP</code> 连接。</p>
</blockquote>
<p>2 MSL 的时间是<strong>从客户端接收到 <code>FIN</code> 后发送 <code>ACK</code> 开始计时的</strong>。如果在 <code>TIME-WAIT</code> 时间内，因为客户端的 <code>ACK</code> 没有传输到服务端，客户端又接收到了服务端重发的 <code>FIN</code> 报文，那么 2 MSL 时间将<strong>重新计时</strong>。</p>
<h2 id="为什么需要-time_wait-状态"><a class="markdownIt-Anchor" href="#为什么需要-time_wait-状态"></a> 为什么需要 TIME_WAIT 状态</h2>
<p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p>
<p>需要 <code>TIME-WAIT</code> 状态，主要是两个原因：</p>
<ul>
<li>防止具有相同「四元组」的「旧」数据包被收到，使旧的数据包消亡在网络中；</li>
<li>保证「被动关闭连接」的一方能被正确的关闭，即<strong>保证最后的 <code>ACK</code> 能让被动关闭方接收，从而帮助其正常关闭；</strong></li>
</ul>
<h3 id="原因一防止旧连接的数据包"><a class="markdownIt-Anchor" href="#原因一防止旧连接的数据包"></a> 原因一：防止旧连接的数据包</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029124033.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>如上图黄色框框服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li>
<li>这时有相同端口的 TCP 连接被复用后，被延迟的 <code>SEQ = 301</code> 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生<strong>数据错乱</strong>等严重的问题。</li>
</ul>
<p>所以，TCP 就设计出了这么一个机制，经过 2MSL 这个时间，足以<strong>让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<h3 id="原因二保证连接正确关闭"><a class="markdownIt-Anchor" href="#原因二保证连接正确关闭"></a> 原因二：保证连接正确关闭</h3>
<blockquote>
<p><code>TIME-WAIT</code> 作用是等待足够的时间以确保最后的 <code>ACK</code> 能让被动关闭方接收，从而帮助其正常关闭。<br />
假设 <code>TIME-WAIT</code> 没有等待时间或时间过短，断开连接会造成什么问题呢？</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201029124052.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>如上图红色框框客户端四次挥手的最后一个 <code>ACK</code> 报文如果在网络中被丢失了，此时如果客户端 <code>TIME-WAIT</code> 过短或没有，则就直接进入了 <code>CLOSED</code> 状态了，那么<strong>服务端则会一直处在 <code>LASE-ACK</code> 状态。</strong></li>
<li>当客户端发起建立连接的 <code>SYN</code> 请求报文后，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止。</li>
</ul>
<p>如果 <code>TIME-WAIT</code> 等待足够长的情况就会遇到两种情况：</p>
<ul>
<li>服务端正常收到四次挥手的最后一个 <code>ACK</code> 报文，则服务端正常关闭连接。</li>
<li>服务端没有收到四次挥手的最后一个 <code>ACK</code> 报文时，则会重发 <code>FIN</code> 关闭连接报文并等待新的 <code>ACK</code> 报文。</li>
</ul>
<p>所以客户端在 <code>TIME-WAIT</code> 状态等待 <code>2MSL</code> 时间后，就可以<strong>保证双方的连接都可以正常的关闭</strong>。</p>
<h2 id="time_wait-过多有什么危害"><a class="markdownIt-Anchor" href="#time_wait-过多有什么危害"></a> TIME_WAIT 过多有什么危害</h2>
<p>如果服务器有处于 <code>TIME-WAIT</code> 状态的 <code>TCP</code>，则说明是由<strong>服务器方主动发起的断开请求</strong>。</p>
<p>过多的 <code>TIME-WAIT</code> 状态主要的危害有两种：</p>
<ol>
<li><strong>内存</strong>资源占用；</li>
<li><strong>端口</strong>资源的占用，一个 TCP 连接至少消耗一个本地端口；</li>
</ol>
<p>如果发起连接一方的 <code>TIME_WAIT</code> 状态过多，占满了所有端口资源，则会导致无法创建新连接。</p>
<ul>
<li>
<p>客户端受端口资源限制：<br />
客户端 <code>TIME_WAIT</code> 过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致<strong>无法创建新的连接。</strong></p>
</li>
<li>
<p>服务端受系统资源限制：<br />
由于一个四元组表示 TCP 连接，理论上服务端可以建立很多连接，服务端确实只监听一个端口 但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听。但是线程池处理不了那么多一直不断的连接了。所以当服务端出现大量 <code>TIME_WAIT</code> 时，系统资源被占满时，会<strong>导致处理不过来新的连接。</strong></p>
</li>
</ul>
<h2 id="tcp-保活机制"><a class="markdownIt-Anchor" href="#tcp-保活机制"></a> TCP 保活机制</h2>
<blockquote>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 <code>TCP</code> 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
</blockquote>
<pre><code class="hljs stylus">保活时间：net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.tcp_keepalive_time</span> = <span class="hljs-number">7200</span>
保活探测的间隔：net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.tcp_keepalive_intvl</span> = <span class="hljs-number">75</span>
保活探测的次数：net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.tcp_keepalive_probes</span> = <span class="hljs-number">9</span></code></pre>
<ul>
<li><code>tcp_keepalive_time=7200</code>：表示保活时间是 <code>7200</code> 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li>
<li><code>tcp_keepalive_intvl=75</code>：表示每次检测间隔 <code>75</code> 秒；</li>
<li><code>tcp_keepalive_probes=9</code>：表示检测 <code>9</code> 次无响应，认为对方是不可达的，从而中断本次的连接。</li>
</ul>
<p>也就是说在 Linux 系统中，最少需要经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi>v</mi><mi>l</mi><mo>∗</mo><mi>p</mi><mi>r</mi><mi>o</mi><mi>b</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">time + (intvl * probes)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span> 即 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p>
<p>如果开启了 TCP 保活，需要考虑以下几种情况：</p>
<ol>
<li>对端程序是<strong>正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP <strong>保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li></li>
<li>对端程序<strong>崩溃并重启</strong>。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP <strong>连接已经被重置</strong>。</li>
<li></li>
<li>对端程序<strong>崩溃</strong>，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 <strong>TCP 连接已经死亡</strong>。</li>
</ol>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/10/28/LeetCode-1207-unique-number-of-occurrences/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LeetCode 1207. 独一无二的出现次数</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/10/27/LeetCode-145-binary-tree-postorder-traversal/">
                        <span class="hidden-mobile">LeetCode 145. 二叉树的后序遍历</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <!-- <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> -->
      Crafted with
      <i class="iconfont icon-love" style="color: #f30;"></i>
      by <a href="https://github.com/likailee" target="_blank" rel="noopener">Likai Lee</a>
      | &copy; 2017 - 2020
      <!-- <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a> -->
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css" />
  













  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?66c61a5fd59052d1b39d89c246846ae5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
