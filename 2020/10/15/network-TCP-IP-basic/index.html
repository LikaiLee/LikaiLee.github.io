<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Likai Lee">
  <meta name="keywords" content="">
  <title>TCP/IP 基础 - Likai Lee</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Likai Lee</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                TCP/IP 基础
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-10-15 14:57">
      2020年10月15日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      72
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年10月21日 下午
                
              </p>
            
            <article class="markdown-body">
              <p>[TOC]</p>
<h1 id="网络基础知识"><a class="markdownIt-Anchor" href="#网络基础知识"></a> 网络基础知识</h1>
<h2 id="osi-参考模型"><a class="markdownIt-Anchor" href="#osi-参考模型"></a> OSI 参考模型</h2>
<ol>
<li>应用层：针对特定应用的协议，如电子邮件，远程登录，文件传输。</li>
<li>表示层：接收不同表现形式的信息，如文字，图像，声音。</li>
<li>会话层：通信管理，管理传输层以下的分层。</li>
<li>传输层：负责<strong>端到端的可靠性传输</strong>。</li>
<li>网络层：<strong>地址管理与路由选择</strong>。</li>
<li>数据链路层：互连设备之间传送数据帧。</li>
<li>物理层：比特流与电信号之间的转换。</li>
</ol>
<h2 id="传输方式"><a class="markdownIt-Anchor" href="#传输方式"></a> 传输方式</h2>
<h3 id="1-面向连接型与面向无连接型"><a class="markdownIt-Anchor" href="#1-面向连接型与面向无连接型"></a> 1. 面向连接型与面向无连接型</h3>
<ul>
<li>在面向有连接的方式下，必须在通信传输前后，专门进行建立和断开连接的处理。</li>
<li>在面向无连接的方式下，发送端可于任何时候自由发送数据。不需要确认对端是否存在，即使接收端不存在或无法接受数据，发送端也能将数据发送出去。</li>
</ul>
<h3 id="2-电路交换与分组交换"><a class="markdownIt-Anchor" href="#2-电路交换与分组交换"></a> 2. 电路交换与分组交换</h3>
<ul>
<li>电路交换中，两台计算机独占线路进行传输，其他计算机只能等线路空闲后才能使用这条电路进行通信。</li>
<li>分组交换中，把数据分成多个数据包，按照一定的顺序排列之后进行发送。每个分组的首部写入发送端和接收端的地址，所以即使同一条线路同时为多个用户提供服务，也可以明确每个分组数据的目的地。</li>
</ul>
<h3 id="3-根据接收端数量分类"><a class="markdownIt-Anchor" href="#3-根据接收端数量分类"></a> 3. 根据接收端数量分类</h3>
<ol>
<li>单播：一对一通信。</li>
<li>广播：将消息从一台主机发送给与之相连的<strong>所有其他主机</strong>。</li>
<li>多播：将消息从一台主机发送给<strong>某一组主机</strong>。</li>
<li>任播：在特定的多台主机中选出一台作为接收端进行通信。</li>
</ol>
<h2 id="各层网络设备"><a class="markdownIt-Anchor" href="#各层网络设备"></a> 各层网络设备</h2>
<ul>
<li>中继器（<code>Repeater</code>）：从物理层上延长网络。</li>
<li>网桥（<code>Bridge</code>）/ 2 层交换机：从数据链路层上延长网络。</li>
<li>路由器（<code>Router</code>）/ 3 层交换机：从网络层转发分组数据的设备。</li>
<li>4 ~ 7 层交换机：处理传输层以上各层网络传输的设备。</li>
<li>网关（<code>Gageway</code>）：转换协议的设备。</li>
</ul>
<h2 id="路由器和交换机的区别"><a class="markdownIt-Anchor" href="#路由器和交换机的区别"></a> 路由器和交换机的区别</h2>
<ul>
<li>交换机主要工作在<strong>数据链路层</strong>；<br />
路由器工作在<strong>网络层</strong>。</li>
<li>交换机转发所依据的对象时：<code>MAC</code> 地址。（物理地址）；<br />
路由转发所依据的对象是：<code>IP</code> 地址。（网络地址）。</li>
<li>交换机主要用于组建局域网；<br />
路由器将局域网连接起来，或者接入互联网。</li>
<li>路由器实现了<strong>不同网络</strong>之间的数据<strong>转发</strong>；<br />
交换机实现了<strong>特定网络</strong>内的数据<strong>交换</strong>。</li>
</ul>
<h1 id="tcpip-基础知识"><a class="markdownIt-Anchor" href="#tcpip-基础知识"></a> TCP/IP 基础知识</h1>
<h2 id="tcpip-具体含义"><a class="markdownIt-Anchor" href="#tcpip-具体含义"></a> TCP/IP 具体含义</h2>
<p>TCP/IP 是协议群的统称，有时也称为网际协议族。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201015144631.png" srcset="/img/loading.gif" alt="" /></p>
<h2 id="tcpip-与-osi-参考模型"><a class="markdownIt-Anchor" href="#tcpip-与-osi-参考模型"></a> TCP/IP 与 OSI 参考模型</h2>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201015144926.png" srcset="/img/loading.gif" alt="" /></p>
<h2 id="数据包处理"><a class="markdownIt-Anchor" href="#数据包处理"></a> 数据包处理</h2>
<p>每一个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息。每个包首部中至少会包含两个信息：一个是发送端和接收端地址，另一个是上一层的协议类型。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201015145629.png" srcset="/img/loading.gif" alt="" /></p>
<h1 id="数据链路"><a class="markdownIt-Anchor" href="#数据链路"></a> 数据链路</h1>
<h2 id="mac-地址与-ip-地址"><a class="markdownIt-Anchor" href="#mac-地址与-ip-地址"></a> MAC 地址与 IP 地址</h2>
<ul>
<li><code>MAC</code> 地址（数据链路层）用于识别数据链路中互连的节点。</li>
<li><code>IP</code> 地址（网络层）用于在连接到网络中的所有主机中识别出进行通信的目标地址。</li>
</ul>
<p>MAC 地址格式：</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201015151427.png" srcset="/img/loading.gif" alt="" /></p>
<p><strong>MAC 地址不一定是唯一的。</strong><br />
即使 MAC 地址 相同，只要不是同属一个数据链路就没问题。如虚拟机分配的虚拟网卡，很难保证 MAC 地址的唯一性。</p>
<h2 id="共享介质型网络"><a class="markdownIt-Anchor" href="#共享介质型网络"></a> 共享介质型网络</h2>
<p>共享介质型网络指由多个设备共享一个通信介质的一种网络。</p>
<ul>
<li>设备之间使用<strong>同一个信道进行发送和接收。</strong></li>
<li>基本上采用<strong>半双工通信</strong>方式。</li>
<li>需要对介质进行<strong>访问控制</strong>。</li>
</ul>
<blockquote>
<p>半双工：共享介质，只发送或只接受的通信方式。<br />
全双工：专用介质，可以同时发送数据和接收数据。</p>
</blockquote>
<p>介质访问控制方式：</p>
<ol>
<li>争用方式（<code>Contention</code>）：指的是争夺获取数据传输的方式。这种方法通常令网络中的各个站采用<strong>先到先得</strong>的方式占用信道发送数据。</li>
<li>令牌传递方式：只有获得令牌的站才能发送数据。特点是<strong>不会有冲突，每个站都有通过平等循环获得令牌的方式。</strong></li>
</ol>
<h2 id="非共享介质型网络"><a class="markdownIt-Anchor" href="#非共享介质型网络"></a> 非共享介质型网络</h2>
<p>非共享介质型网络是指不共享介质，是对介质采取<strong>专用</strong>的一种传输控制方式。每个站直连交换机，<strong>由交换机负责转发数据帧</strong>，采用<strong>全双工通信</strong>方式。</p>
<h1 id="ip-协议"><a class="markdownIt-Anchor" href="#ip-协议"></a> IP 协议</h1>
<h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h2>
<h3 id="网络层与数据链路层的关系"><a class="markdownIt-Anchor" href="#网络层与数据链路层的关系"></a> 网络层与数据链路层的关系</h3>
<ul>
<li>
<p>数据链路层提供两个设备之间的通信功能，在<strong>互连同一种数据链路的节点之间</strong>进行包传递。</p>
</li>
<li>
<p>网络层负责在<strong>没有直连的两个网络之间</strong>进行通信传输。网络层可以<strong>跨越不同的数据链路</strong>，在不同的数据链路上也能实现两端节点之间的数据包传输。</p>
</li>
</ul>
<h3 id="路由控制"><a class="markdownIt-Anchor" href="#路由控制"></a> 路由控制</h3>
<p>路由控制（<code>Routing</code>）是指将分组数据发送到最终目标地址的功能。</p>
<p>IP 路由也叫多跳路由，跳（<code>Hop</code>） 是指网络中的一个区间，在每一个区间内决定着 IP 包在下一跳被转发的路径。<br />
<strong>多跳路由</strong> 是指路由器或主机在转发 IP 数据包时<strong>只指定下一个路由器或主机</strong>，而不是将到最终目标地址为止的所有通路全部指定出来。因为每一个区间（跳）在转发 IP 数据包时会分别指定下一跳的操作。</p>
<p>为了将数据包发给目标主机，所有主机都维护着一张路由控制表（<code>Routing Table</code>）。该表记录 IP 数据在下一步应该发给哪个路由器。IP 包将根据路由表在各个数据链路上传输。</p>
<h3 id="mtu"><a class="markdownIt-Anchor" href="#mtu"></a> MTU</h3>
<p>数据链路的地址可以被抽象为 IP 地址，对 IP 的上一层来说，不论底层数据链路使用以太网还是无线 LAN 亦或是 PPP，都将被一视同仁。</p>
<p>不同的数据链路的最大区别：它们各自的最大传输单位（<code>MTU</code>）不同。而我们需要传输比 MTU 更多字节的数据，就需要对 IP 数据包进行 <strong>分片处理（<code>IP Fragmentation</code>）</strong>，将较大的 IP 包分成多个较小的 IP 包。分片的包到了对端目标地址后会再被组合起来传给上一层。</p>
<h3 id="ip-属于面向无连接型"><a class="markdownIt-Anchor" href="#ip-属于面向无连接型"></a> IP 属于面向无连接型</h3>
<p>IP 在发包之前，不需要建立与对端目标地址之间的连接。上层如果遇到需要发给 IP 的数据，该数据会立即被压缩成 IP 包发送出去。</p>
<p>原因：</p>
<ol>
<li>简化：面向连接处理相对复杂，需要管理每个连接。</li>
<li>提速：每次通信之前都要先建立连接，会降低处理速度。</li>
</ol>
<blockquote>
<p>由于 IP 只负责将数据发给目标主机，为了保证通信的可靠性，上层的 TCP 采用面向连接型，负责保证对端主机确实收到数据。</p>
</blockquote>
<h2 id="ip-地址"><a class="markdownIt-Anchor" href="#ip-地址"></a> IP 地址</h2>
<h3 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h3>
<p>IP 地址（IPv4）由 <code>32</code> 位正整数表示，每 <code>8</code> 位一组，分成 4 组，每组以 <code>.</code> 隔开，再将每组数转换为十进制。</p>
<p>IP 地址由 <code>网络地址（网络号）</code> 和 <code>主机地址（主机号）</code> 组成，网络号在数据链路的每个段配置不同的值。网络号必须保证相互连接的每个段的地址不重复。而<strong>相同段内相连的主机必须有相同的网络地址。主机号则不允许在同一个网段内重复出现。</strong></p>
<h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3>
<p>根据 IP 地址中从第 <code>1</code> 位到第 <code>4</code> 位划分为 <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code> 类。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201016134533" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>A 类地址：第 1 字节为网络地址，其它 3 个字节为主机地址。它的第 1 个字节的<code>第一位</code>固定为 <code>0</code>。
<ul>
<li>网络号范围：<code>0.0.0.0 ~ 127.0.0.0</code></li>
<li>私有地址：<code>10.0.0.0 ~ 10.255.255.255</code></li>
<li>保留地址：<code>127.x.x.x</code>，用于循环测试</li>
</ul>
</li>
<li>B 类地址：第 1 字节和第 2 字节为网络地址，后 2 个字节为主机地址。它的第 1 个字节的<code>前两位</code>固定为 <code>10</code>。
<ul>
<li>网络号范围：<code>128.0.0.0 ~ 191.255.0.0</code></li>
<li>私有地址：<code>172.16.0.0 ~ 172.31.255.255</code></li>
<li>保留地址：<code>169.254.x.x</code>，如果是自动获取 IP 地址，而你在网络上又没有找到可用的 DHCP 服务器。就会得到其中一个 IP。</li>
<li>广播地址：<code>191.255.255.255</code>，不能分配。</li>
</ul>
</li>
<li>C 类地址：第 1 字节、第 2 字节和第 3 个字节为网络地址，第 4 个字节为主机地址。另外第 1 个字节的<code>前三位</code>固定为 <code>110</code>。
<ul>
<li>网络号范围：<code>192.0.0.0 ~ 223.255.255.0</code></li>
<li>私有地址：<code>192.168.0.0 ~ 192.168.255.255</code></li>
</ul>
</li>
<li>D 类地址：没有主机地址，常用于多播，它的第 1 个字节的<code>前四位</code>固定为 <code>1110</code>。
<ul>
<li>地址范围：<code>224.0.0.0 ~ 239.255.255.255</code></li>
</ul>
</li>
<li>E 类地址：不分网络地址和主机地址，它的第 1 个字节的<code>前四位</code>固定为 <code>1111</code>。
<ul>
<li>地址范围：<code>240.0.0.0 ~ 255.255.255.254</code></li>
</ul>
</li>
</ul>
<h3 id="子网掩码"><a class="markdownIt-Anchor" href="#子网掩码"></a> 子网掩码</h3>
<blockquote>
<p>子网掩码的重要作用：就是将某个IP地址划分成网络地址和主机地址两部分。</p>
</blockquote>
<p>子网掩码实际上就是将原来 A/B/C 等分类中的<strong>主机地址部分用作子网地址</strong>，可以将原网络分为多个物理网络的一种机制。</p>
<p>表示方式：IP 地址网络号全部为 <code>1</code>，主机号全部为 <code>0</code>。<br />
由此，一个 IP 地址不再受限自己的类别，而是可以使用子网掩码自由地定位自己的网络号部分。</p>
<p>如：<code>172.20.100.52/26</code> 表示前 <code>26</code> 位是网络号。<br />
IP 地址：172. 20.  100. 52<br />
子网掩码：255. 255. 255. 192</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019122155" srcset="/img/loading.gif" alt="" /></p>
<h2 id="路由控制-2"><a class="markdownIt-Anchor" href="#路由控制-2"></a> 路由控制</h2>
<p>IP 地址的网络部分用于进行路由控制。路由表中记录着<strong>网络地址</strong>与下一步应该发送至<strong>路由器的地址</strong>。如果路由表中存在多条相同网络地址的记录，就选择一个相同位数最多（<code>最长匹配</code>）的网络地址。</p>
<ul>
<li>默认路由：<code>0.0.0.0/0</code> 路由表中任何一个地址都能与之匹配。</li>
<li>主机路由：<code>IP 地址/32</code> 整个 IP 地址的所有位都将参与路由。</li>
<li>环回地址：<code>127.0.0.1、localhost</code> 同一台计算机上的程序之间进行网络通信。</li>
</ul>
<h2 id="相关协议"><a class="markdownIt-Anchor" href="#相关协议"></a> 相关协议</h2>
<h3 id="dns"><a class="markdownIt-Anchor" href="#dns"></a> DNS</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019132145.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="arp-rarp"><a class="markdownIt-Anchor" href="#arp-rarp"></a> ARP、RARP</h3>
<p>ARP 将 IP 地址定位到对应的 MAC 地址。只适用于 IPv4。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019133552.png" srcset="/img/loading.gif" alt="" /></p>
<p>主机 A 为了获取主机 B 的 MAC 地址，要通过<strong>广播</strong>发送一个 ARP 请求包，这个包中包含了 主机 B 的 IP 地址。由于广播的包可以被同一个链路上所有的主机或路由器接收，<strong>如果请求包中的 IP 地址与自己的 IP 地址一致，那么这个节点就将自己的 MAC 地址放入 ARP 响应包返回给 主机 A。</strong></p>
<p>RARP 是从 MAC 地址定位 IP 地址的一种协议。例如将打印机等嵌入式设备接入到网络时就会用到。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019134340.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="icmp"><a class="markdownIt-Anchor" href="#icmp"></a> ICMP</h3>
<p>ICMP 的主要功能包括：确认 IP 包是否成功送达目标地址，通知在发送过程中 IP 包被废弃原因，改善网络设置，进行网络诊断。</p>
<p>ICMP 的消息大致可以分成两类：一类是通知出错原因的错误消息，另一类是用于诊断的查询信息。</p>
<h3 id="dhcp"><a class="markdownIt-Anchor" href="#dhcp"></a> DHCP</h3>
<p>DHCP 可实现自动设置 IP 地址，统一管理 IP 地址分配，让即插即用变得可能。在 IPv4，IPv6 中均可使用。</p>
<h3 id="nat"><a class="markdownIt-Anchor" href="#nat"></a> NAT</h3>
<p>NAT 用于在本地网络中使用私有地址，在连接互联网时使用全局 IP 地址。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019152539.png" srcset="/img/loading.gif" alt="" /></p>
<p>NAPT 将端口号一起转换。</p>
<blockquote>
<p>在使用 TCP 或 UDP 的通信当中，只有目标地址、源地址、目标端口、源端口以及协议种类都一致时才被认为是同一个连接。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019153122.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="ip-隧道"><a class="markdownIt-Anchor" href="#ip-隧道"></a> IP 隧道</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201019153834.png" srcset="/img/loading.gif" alt="" /></p>
<p>IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。</p>
<h1 id="tcp-与-udp"><a class="markdownIt-Anchor" href="#tcp-与-udp"></a> TCP 与 UDP</h1>
<h2 id="传输层作用"><a class="markdownIt-Anchor" href="#传输层作用"></a> 传输层作用</h2>
<p>TCP 是<strong>面向连接的、可靠</strong>的流协议，为实现可靠传输，实行顺序控制或重发控制机制，还具备流量控制、拥塞空着、提高网络利用率等功能。</p>
<p>UDP 是<strong>面向无连接、不具有可靠性</strong>的数据报协议，主要用于那些对高速传输和实时性有较高要求的通信或广播通信。它不会进行重发处理。</p>
<h2 id="端口号"><a class="markdownIt-Anchor" href="#端口号"></a> 端口号</h2>
<p>端口号用来识别同一台计算机中进行通信的不同应用程序，它也被称为程序地址。传输层协议正是利用这些端口号识别本机中正在通信的应用程序，并准确地将数据传输。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020140053.png" srcset="/img/loading.gif" alt="" /></p>
<p>常见端口号：</p>
<table>
<thead>
<tr>
<th style="text-align:center">端口号</th>
<th style="text-align:center">服务名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">ftp-data</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">ftp</td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:center">ssh</td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:center">telnet</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center">smtp</td>
</tr>
<tr>
<td style="text-align:center">80</td>
<td style="text-align:center">http</td>
</tr>
<tr>
<td style="text-align:center">443</td>
<td style="text-align:center">https</td>
</tr>
</tbody>
</table>
<h2 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h2>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3>
<p>由于 UDP 面向无连接，它可以随时发送数据，加上 UDP 本身的处理既简单又高效，常用于以下几个方面：</p>
<ul>
<li>包总量较少的通信（DNS、SNMP 等）</li>
<li>视频、音频等多媒体通信</li>
<li>限定于 LAN 等特定网络中的应用通信</li>
<li>广播通信（广播、多播）</li>
</ul>
<h3 id="首部"><a class="markdownIt-Anchor" href="#首部"></a> 首部</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020140728.png" srcset="/img/loading.gif" alt="" /></p>
<p>UDP 首部由源端口号，目标端口号，包长度和校验和组成。</p>
<ul>
<li>源端口号（<code>Source Port</code>）：发送端端口号，字段长 <code>16</code> 位，该字段是可选项，没有源端口号时设置为 <code>0</code>，可用于不需要返回的通信中。</li>
<li>目标端口号（<code>Destination Port</code>）：接收端端口号，字段长 <code>16</code> 位。</li>
<li>包长度（<code>Length</code>）：UDP 首部的长度和数据的长度之和。单位：字节。</li>
<li>校验和（<code>Checksum</code>）：校验和是为了提供可靠的 UDP 首部和数据而设计。</li>
</ul>
<h2 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> TCP</h2>
<p>TCP 通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>
<h3 id="确认应答"><a class="markdownIt-Anchor" href="#确认应答"></a> 确认应答</h3>
<p>TCP 通过确认应答（<code>ACK</code>）实现可靠的数据传输。<br />
当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端，反之，数据丢失的可能性很大。</p>
<p>确认丢失：当主机 A 在设定的超时重传时间内没有收到确认，但无法知道是自己发送的分组出错、丢失，或是主机 B 发送的确认丢失了。这时 A 会重传数据，假设 B 收到了重复数据，则它会丢弃这个重复数据，向 A 发送确认。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020142913.png" srcset="/img/loading.gif" alt="" /></p>
<p>确认迟到：传输过程中没有出现差错，但 B 对分组的确认迟到了，此时 A 会重传分组，B 收下重复分组后就丢弃，并向 A 发送确认。A 对于迟到的确认收下后就丢弃。</p>
<h3 id="超时重传"><a class="markdownIt-Anchor" href="#超时重传"></a> 超时重传</h3>
<p>超时重传时间是指在重发数据之前，等待确认应答到来的那个特定时间间隔。</p>
<p>超时时间随着数据包途径的网络环境的不同而有所变化，在同一个时段中，根据不同时段网络拥堵程度，时间长短也会发生变化。</p>
<p>在 UNIX 以及 Windows 中，超时都以 <code>0.5s</code> 为单位进行控制。数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以 <code>2</code> 倍、<code>4</code> 倍的指数函数延长。</p>
<p>数据不会被无限、反复地重发。达到一定重发次数后，如果仍没有任何确认应答返回，就会判断对方主机发生了异常，强制关闭连接，并且通知应用通信异常强行终止。</p>
<h3 id="mss"><a class="markdownIt-Anchor" href="#mss"></a> MSS</h3>
<p>TCP 以段为单位发送数据，以最大消息长度（<code>MSS：Maximum Segment Size</code>）的大小将数据进行分割发送。</p>
<p><strong><code>MSS</code> 是在三次握手时，在两端主机之间被计算得出。</strong> 两端主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己能够适应的 MSS 大小，然后会使用两者之间的较小值。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020144627.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h3>
<p>TCP 以 1 个段为单位，每发一个段进行一次确认应答的处理，但是如果包的往返时间越长，网络的吞吐量会越差，通信性能就越低。</p>
<p>所以 TCP 引入了滑动窗口，<strong>确认应答是以窗口大小进行确认的</strong>。发送端主机在发送了一个段之后不必要一直等待确认应答，而是继续发送。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020145712.png" srcset="/img/loading.gif" alt="" /></p>
<p>窗口内的数据即使没有收到确认也可以发送出去，在收到确认应答之前，必须在缓冲区中保留这部分数据。</p>
<p>在滑动窗口以外的部分包括已经确认收到应答的数据和尚未发送的数据，收到确认的数据此时可以从缓冲区清除。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020145753.png" srcset="/img/loading.gif" alt="" /></p>
<h4 id="确认丢失"><a class="markdownIt-Anchor" href="#确认丢失"></a> 确认丢失</h4>
<p>在没有使用滑动窗口时，没有收到确认应答的数据都会被重发。<br />
而使用了滑动窗口时，窗口在一定程度上较大时，某些确认应答即便丢失也无需重发，可以通过<strong>下一个</strong>确认应答进行确认。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020150635.png" srcset="/img/loading.gif" alt="" /></p>
<h4 id="报文丢失"><a class="markdownIt-Anchor" href="#报文丢失"></a> 报文丢失</h4>
<p><code>高速重发控制</code>：在报文丢失的情况下，同一个序号的确认应答会被重复不断地返回。而发送端主机如果连续 <code>3</code> 次收到同一个确认应答，就会将其所对应的数据重发。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020150452.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="流量控制"><a class="markdownIt-Anchor" href="#流量控制"></a> 流量控制</h3>
<p>流量控制：TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。<br />
滑动窗口大小：接收端主机向发送端主机通知自己可以接收数据的大小（首部字段中的<code>窗口大小</code>），于是发送端会发送不超过这个限度的数据。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020151743.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制"></a> 拥塞控制</h3>
<p>在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。<br />
为了防止该问题的出现，在通信一开始时会通过<code>慢开始</code>算法对发送数据量进行控制。</p>
<p>在慢开始时，将<code>拥塞窗口</code>大小设置为 <code>1 MSS</code>，之后每收到一次确认应答，拥塞窗口的值就加 <code>1</code>。即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口。</p>
<blockquote>
<p>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化，<strong>发送方让自己的发送窗口等于拥塞窗口。</strong> 考虑到接收方的接收能力，那么发送窗口还可能小于拥塞窗口。</p>
</blockquote>
<p><strong>每经过一个传输轮次，拥塞窗口就加倍</strong>，以 1，2，4指数增长。为了防止拥塞窗口增长过大，还需要设置<code>慢开始阈值</code>：</p>
<ul>
<li>当 <code>cwnd &lt; ssthresh</code> 时，使用<strong>慢开始</strong>算法；</li>
<li>当 <code>cwnd &gt; ssthresh</code> 时，使用<strong>拥塞避免</strong>算法；</li>
<li>当 <code>cwnd = ssthresh</code> 时，可使用<strong>拥塞避免</strong>算法，也可使用<strong>慢开始</strong>算法。</li>
</ul>
<p><code>拥塞避免</code>的思路是让拥塞窗口缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口<code>加 1</code>，而不是加倍。这样，<strong>拥塞窗口按线性规律缓慢增长</strong>，比慢开始算法的增长速率慢得多。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020154633.png" srcset="/img/loading.gif" alt="" /></p>
<p>实际上，使用最广泛的是 <code>AIMD（加法增大乘法减小）</code>算法。</p>
<ul>
<li>加法增大：执行拥塞避免算法，使拥塞窗口缓慢增大。</li>
<li>乘法减小：不论是在慢开始还是在拥塞避免阶段，只要出现超时，就<strong>把窗口阈值 ssthresh 设置为当前的拥塞窗口的一半，与此同时，执行慢开始算法。</strong></li>
</ul>
<h3 id="tcp-首部"><a class="markdownIt-Anchor" href="#tcp-首部"></a> TCP 首部</h3>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201020155556.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>源端口号（<code>Source Port</code>）：字段长 <code>16</code> 位。</li>
<li>目标端口号（<code>Destination Port</code>）：字段长 <code>16</code> 位。</li>
<li>序列号（<code>Sequence Number</code>）：字段长 <code>32</code> 位，指的是发送数据的位置，每发送一次数据，就累加一次该数据字节数的大小。</li>
<li>确认应答号（<code>Acknowledgement Number</code>）：字段长 <code>32</code> 位，指的是下一个应该收到的数据的序列号。实际上，它是指已收到 <code>确认应答号 - 1</code> 为止的数据。发送端收到这个确认应答号后可以认为在这个序号以前的数据都已经被正常接收。</li>
<li>数据偏移（<code>Data Offset</code>）：字段长 <code>4</code> 位。表示所传输的数据部分应该从 TCP 包的哪个位开始计算。可以看作是 <strong>TCP 首部的长度</strong>。</li>
<li>保留（<code>Reserved</code>）：字段长 <code>4</code> 位。一般设置为 <code>0</code>，主要是为了以后扩展时使用。</li>
<li>控制位（<code>Control Flag</code>）：字段长 <code>8</code> 位。从左至右分别为 <code>CWR</code>、<code>ECE</code>、<code>URG</code>、<code>ACK</code>、<code>PSH</code>、<code>RST</code>、<code>SYN</code>、<code>FIN</code>。</li>
<li>窗口大小（<code>Window Size</code>）：字段长 <code>16</code> 位。用于通知从确认应答号所指位置开始能接收的数据大小。TCP 不允许发送超过此处所示大小的数据。如果窗口为 <code>0</code>，表示可以发送窗口探测，以了解最新的窗口大小。</li>
<li>校验和（<code>Checksum</code>）：字段长 <code>16</code> 位。TCP 的校验和和 UDP 相似，区别在于 TCP 的校验和无法关闭。</li>
<li>紧急指针（<code>Urgent Pointer</code>）：字段长 <code>16</code> 位。一般在暂时中断通信时使用。从数据部分的首位到紧急指针所指示的位置为止为紧急数据。</li>
<li>选项（<code>Options</code>）：用于提高 TCP 的传输性能。</li>
</ul>
<h1 id="路由协议"><a class="markdownIt-Anchor" href="#路由协议"></a> 路由协议</h1>
<h2 id="静态路由与动态路由"><a class="markdownIt-Anchor" href="#静态路由与动态路由"></a> 静态路由与动态路由</h2>
<ul>
<li>静态路由是指事先设置好路由器和主机中并将路由信息固定的一种方法。
<ul>
<li>静态路由通常由使用者手工操作完成。</li>
<li>一旦某个路由器发生故障，基本上无法自动绕过发生故障的节点。</li>
</ul>
</li>
<li>动态路由是指让路由协议在运行过程中自动地设置路由控制信息的一种方法。
<ul>
<li>动态路由设定过程的复杂程度与具体要设置路由协议的类型有直接关系。</li>
<li>动态路由会给相邻路由器发送自己已知的网络连接信息，直至网络传递完成，路由控制表也制作完成。</li>
<li>一旦发生故障，只要有一个可绕的路径，数据包就会自动选择这个路径。</li>
</ul>
</li>
</ul>
<h2 id="路由算法"><a class="markdownIt-Anchor" href="#路由算法"></a> 路由算法</h2>
<h3 id="距离矢量算法"><a class="markdownIt-Anchor" href="#距离矢量算法"></a> 距离矢量算法</h3>
<p>距离矢量算法（<code>Distance-Vector</code>）算法是根据<strong>距离</strong>和<strong>方向</strong>决定目标网络或目标主机位置的一种方法。</p>
<p>路由器之间可以互换目标网络的方向及其距离的相关信息，并以这些信息为基础制作路由控制表。因此，<strong>每一个路由器的位置不同，它们的路由表也是不同的。</strong></p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201021142516.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="链路状态算法"><a class="markdownIt-Anchor" href="#链路状态算法"></a> 链路状态算法</h3>
<p>链路状态算法是路由器在了解<strong>网络整体状态</strong>的基础上生成路由控制表的一种方法。</p>
<p>在该方法中，<strong>每个路由器必须保持同样的信息</strong>才能进行正确的路由选择，这意味着可以使路由信息达到一个稳定的状态。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201021142452.png" srcset="/img/loading.gif" alt="" /></p>
<h3 id="主要路由协议"><a class="markdownIt-Anchor" href="#主要路由协议"></a> 主要路由协议</h3>
<table>
<thead>
<tr>
<th style="text-align:center">路由协议</th>
<th style="text-align:center">下一层协议</th>
<th style="text-align:center">方式</th>
<th style="text-align:center">适用范围</th>
<th style="text-align:center">循环检测</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RIP</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center">距离矢量</td>
<td style="text-align:center">自治系统内</td>
<td style="text-align:center">不可以</td>
</tr>
<tr>
<td style="text-align:center">OSPF</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center">链路状态</td>
<td style="text-align:center">自治系统内</td>
<td style="text-align:center">可以</td>
</tr>
<tr>
<td style="text-align:center">EGP</td>
<td style="text-align:center">IP</td>
<td style="text-align:center">距离矢量</td>
<td style="text-align:center">对外连接</td>
<td style="text-align:center">不可以</td>
</tr>
<tr>
<td style="text-align:center">BGP</td>
<td style="text-align:center">IP</td>
<td style="text-align:center">路径矢量</td>
<td style="text-align:center">对外连接</td>
<td style="text-align:center">可以</td>
</tr>
</tbody>
</table>
<h2 id="rip"><a class="markdownIt-Anchor" href="#rip"></a> RIP</h2>
<p>特点：</p>
<ul>
<li>仅和<strong>相邻路由器</strong>交换信息。</li>
<li>交换的信息是当前本路由器所知道的全部信息，即自己的<strong>路由表</strong>。</li>
<li>按固定的时间间隔（<code>30s</code>）交换路由信息。</li>
</ul>
<p>路由表中的主要信息就是：到某个网络的距离（最短距离），以及经过的下一跳地址。路由表更新的原则就是<strong>找出到每个目的网络的最短距离</strong>。</p>
<p>RIP 存在的问题：由于采用距离矢量算法，当网络出现故障时，要经过较长时间才能将此信息传送到所有路由器。</p>
<h2 id="ospf"><a class="markdownIt-Anchor" href="#ospf"></a> OSPF</h2>
<p>OPPF 为链路状态型协议，所以能检测网络中的<strong>环路</strong>。</p>
<p>特点：</p>
<ul>
<li>向本自治系统中<strong>所有路由器</strong>发送信息，使用洪泛法（<code>flooding</code>）。</li>
<li>发送的信息是与本路由器相邻的所有路由器的<strong>链路状态</strong>。链路状态就是说明本路由器和哪些路由器相邻，以及该链路的<code>代价</code>，<strong>OSPF 总是选择一个总代价最小的一条路径</strong>，而 RIP 选择路由器个数最少的路径。</li>
<li>只有当<strong>链路状态变</strong>化时，路由器才发送信息。</li>
</ul>
<p>当网络的个数越多，每次交换的路由信息就越大，当链路状态变化较小时，这在一定程度上浪费了网络带宽。为了使 <strong>OSPF 能够用于规模很大的网络</strong>，OSPF 将一个自治系统再划分为若干个更小的<strong>区域</strong>，所有的其他区域都和<code>主干区域（Backbone Area）</code>相连接，每一个区域内部交换路由信息的通信量大大减小。</p>
<h2 id="bgp"><a class="markdownIt-Anchor" href="#bgp"></a> BGP</h2>
<p><code>BGP(Border Gateway Protocol)</code> 是连接不同自治系统的一种协议，它属于外部网关协议（<code>EGP</code>）。</p>
<p>在 <code>RIP</code> 和 <code>OSPF</code> 中利用 <code>IP</code> 地址的网络地址部分进行路由控制，然而 <code>BGP</code> 需要放眼整个互联网进行路由控制。<code>BGP</code> 的最终路由控制表由<strong>网络地址</strong>和<strong>下一站的路由器组</strong>来表示，它会根据所要经过的 <code>AS</code> 个数进行路由控制。</p>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201021153257.png" srcset="/img/loading.gif" alt="" /></p>
<p>每个 <code>AS</code> 都有一个 <code>16 bit</code> 的 <code>AS 编号</code>，<code>BGP</code> 就是根据 <code>AS 编号</code>进行路由控制。<br />
代表整个 AS 与其它 AS 交换路由控制信息的路由器叫做 BGP 发言人，一个 BGP 发言人与其它 AS 的 BGP 发言人要交换路由信息，就要先建立 TCP 连接。</p>
<p>BGP 中数据包送达目标网络时，会生成一个中途经过所有 AS 的编号列表（AS 路径信息访问列表<code>AS Path List</code>）。在做路由选择时，BGP 选择 AS 数最少的路径。</p>
<blockquote>
<p>路径向量（Path Vector）协议：可以检测环路，在 AS 路径信息访问列表中包含转发方向、距离和途径所有 AS 的编号。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LikaiLee/likailee.github.io/img/20201021154457.png" srcset="/img/loading.gif" alt="" /></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/10/15/LeetCode-71-simplify-path/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LeetCode 71. 简化路径</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/10/14/LeetCode-410-split-array-largest-sum/">
                        <span class="hidden-mobile">LeetCode 410. 分割数组的最大值</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <!-- <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> -->
      Crafted with
      <i class="iconfont icon-love" style="color: #f30;"></i>
      by <a href="https://github.com/likailee" target="_blank" rel="noopener">Likai Lee</a>
      | &copy; 2017 - 2020
      <!-- <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a> -->
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?66c61a5fd59052d1b39d89c246846ae5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
